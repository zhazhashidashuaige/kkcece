<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
<!-- ▼▼▼ 用这整块代码替换掉你旧的meta和icon链接 ▼▼▼ -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">


<!-- 1. (核心) 为苹果设备设置主屏幕图标 -->
<link rel="apple-touch-icon" href="https://i.postimg.cc/Kj8JnRcp/267611-CC01-F8-A3-B4910-A2-C2-FFDE479-DC.jpg">
<link rel="apple-touch-icon" sizes="152x152" href="https://i.postimg.cc/Kj8JnRcp/267611-CC01-F8-A3-B4910-A2-C2-FFDE479-DC.jpg">
<link rel="apple-touch-icon" sizes="180x180" href="https://i.postimg.cc/Kj8JnRcp/267611-CC01-F8-A3-B4910-A2-C2-FFDE479-DC.jpg">
<link rel="apple-touch-icon" sizes="167x167" href="https://i.postimg.cc/Kj8JnRcp/267611-CC01-F8-A3-B4910-A2-C2-FFDE479-DC.jpg">

<!-- 2. (核心) 链接到manifest文件 -->
<link rel="manifest" href="manifest.json">

<!-- 3. (核心) 告诉苹果设备，这是一个Web应用，可以全屏显示 -->
<meta name="apple-mobile-web-app-capable" content="yes">

<!-- 4. (核心) 设置苹果设备全屏模式下的状态栏样式 -->
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<!-- 5. (可选) 设置应用在主屏幕上显示的标题 -->
<meta name="apple-mobile-web-app-title" content="EPhone（兔k机版）">

<!-- 6. (兼容) 为部分安卓浏览器提供支持 -->
<meta name="mobile-web-app-capable" content="yes">

<!-- 7. (备用) 标准浏览器页签图标 -->
<link rel="icon" type="image/png" href="https://i.postimg.cc/Kj8JnRcp/267611-CC01-F8-A3-B4910-A2-C2-FFDE479-DC.jpg">
<!-- ▲▲▲ 替换结束 ▲▲▲ -->


    <title>EPhone（兔k机版）</title>

    <script src="https://unpkg.com/dexie/dist/dexie.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify/dist/purify.min.js"></script>
    <script src="https://phoebeboo.github.io/mewoooo/pp.js" defer></script>
    <script src="main-app.js" defer></script>
    <script src="game-hall.js" defer></script>

    <style>
        :root { --screen-width: 350px; --screen-height: 650px; --secondary-bg: #ffffff; --border-color: #e0e0e0; --text-primary: #1f1f1f; --text-secondary: #8a8a8a; --accent-color: #007bff;    --status-bar-text-color: var(--accent-color); }
/* ▼▼▼ 用这块终极代码，替换掉你现有的 html 和 body 样式 ▼▼▼ */
html {
    -webkit-text-size-adjust: 100%;
    height: 100%; /* 确保html元素也能撑满 */
}

body {
    margin: 0;
    font-family: 'bulangni', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    font-weight: normal;
    background-color: #f0f2f5;
    height: 100%; /* 让body也撑满父元素(html) */
    overflow: hidden; /* 防止body本身出现滚动条 */
}
/* ▲▲▲ 替换结束 ▲▲▲ */

/* 2. 让 #phone-screen 成为新的“根”容器，撑满整个浏览器窗口 */
/* ▼▼▼ 请用这块【最终修正版】的代码，替换掉你现有的 #phone-screen 样式 ▼▼▼ */
#phone-screen {
    width: 100%;
    height: 100vh;
    position: relative;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    background-color: #ffffff; /* ★ 修改这里为白色 */
}
/* ▲▲▲ 替换结束 ▲▲▲ */

/* 3. 【核心】隐藏掉模拟器的状态栏 */
#status-bar {
    display: none;
}

/* 4. 【核心】让所有页面的头部自动适应iPhone的“刘海”安全区 */
.header, .qzone-header {
    /* 使用 env(safe-area-inset-top) 自动获取顶部安全距离 */
    padding-top: calc(15px + env(safe-area-inset-top));
}

/* 5. 【核心】让聊天输入框和底部导航栏自动适应iPhone底部的“小黑条”安全区 */
#chat-input-area {
    padding-bottom: calc(8px + env(safe-area-inset-bottom));
}

#chat-list-bottom-nav {
     padding-bottom: env(safe-area-inset-bottom);
}

/* ▲▲▲ 替换结束 ▲▲▲ */

      /* 修改后的代码块 */
/* ▼▼▼ 用这整块【可爱圆润版】代码，替换掉所有旧的 status-bar 和 battery 样式 ▼▼▼ */

#status-bar { 
    position: absolute; 
    top: 0; 
    left: 0; 
    width: 100%; 
    padding: 12px 20px; 
    display: none; 
    justify-content: space-between; 
    align-items: center; 
    color: var(--accent-color); /* ★ 修改：状态栏文字/图标颜色，现在会跟随主题色！ */
    z-index: 10; 
    font-size: 14px; 
    box-sizing: border-box; 
    pointer-events: none; 
    /* ★ 新增：使用你的自定义字体，并加上柔和的光晕，让它更可爱 */
    font-family: 'bulangni', sans-serif; 
    text-shadow: 0 0 8px rgba(255, 255, 255, 0.5); 
}

#status-bar-time { 
    font-weight: 600; 
}

.battery-container { 
    display: flex; 
    align-items: center; 
    gap: 5px; 
}

.battery-icon { 
    width: 25px; 
    height: 12px; 
    border: 1.5px solid currentColor; /* ★ 边框加粗一点点 */
    border-radius: 5px; /* ★ 修改：增加圆角，让它更圆润可爱 */
    position: relative; 
    padding: 1px; 
}

.battery-icon::after { 
    content: ''; 
    position: absolute; 
    right: -4px; /* 微调位置 */
    top: 2.5px; 
    width: 2px; 
    height: 5px; 
    background-color: currentColor; 
    border-radius: 0 2px 2px 0; /* ★ 头部小块也变圆润 */
}

.battery-level { 
    height: 100%; 
    background-color: currentColor; /* ★ 默认填充色也跟随主题色 */
    border-radius: 3px; /* ★ 内部填充条也变圆润 */
    transition: width 0.5s ease; 
}

/* ★ 核心修改：让充电时也显示主题色！ */
.battery-container.charging .battery-level { 
    animation: charge-breath 2s infinite; 
}
@keyframes charge-breath { 
    0%, 100% { opacity: 1; } 
    50% { opacity: 0.7; } 
}
/* ▲▲▲ 替换结束 ▲▲▲ */
/* ▼▼▼ 【终极修正版】请用这块代码完整替换掉所有旧的 .screen 样式 ▼▼▼ */
.screen {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;  /* ★ 新增 */
    bottom: 0; /* ★ 新增 */
    width: 100%; /* 保留 */
    /* height: 100%; */ /* ★ 注释或删除掉这一行 */

    display: flex;
    flex-direction: column;
    overflow: hidden;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s, visibility 0.3s;
}
/* ▲▲▲ 替换结束 ▲▲▲ */
/* ▲▲▲ 替换结束 ▲▲▲ */
/* ▲▲▲ 替换结束 ▲▲▲ */

        .screen.active { opacity: 1; visibility: visible; z-index: 1; }
       .header {
    position: relative;
    z-index: 15;
    flex-shrink: 0;
    padding: 15px 15px;
    padding-top: 45px;
    background-color: rgba(247, 247, 247, 0.8);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-bottom: 1px solid var(--border-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 18px;
    font-weight: 600;
    
    /* ▼▼▼ 新增下面这两行 ▼▼▼ */
    height: 110px;               /* ★ 新增：强制设置一个统一的高度 */
    box-sizing: border-box;     /* ★ 新增：确保高度计算包含内边距 */
    /* ▲▲▲ 新增结束 ▲▲▲ */
}

        .header .header-actions { display: flex; align-items: center; gap: 5px; }
        /* ▼▼▼ 【触摸区域优化版】替换旧的 .header .back-btn, .header .action-btn 样式 ▼▼▼ */
.header .back-btn, .header .action-btn {
    font-size: 24px; /* 保持图标大小不变 */
    cursor: pointer;
    color: var(--accent-color);
    display: flex;
    align-items: center;
    justify-content: center;

    /* --- 核心修改从这里开始 --- */
    width: 40px;              /* 1. 将按钮宽度从30px增加到40px */
    height: 40px;             /* 2. 将按钮高度从30px增加到40px */
    border-radius: 50%;       /* 3. (可选但推荐) 让按钮变成圆形，更美观 */
    transition: background-color 0.2s; /* 4. 为悬停效果添加平滑动画 */
}

/* 【新增】为按钮添加悬停/点击时的背景色，给用户明确的反馈 */
.header .back-btn:hover, .header .action-btn:hover {
    background-color: rgba(0, 0, 0, 0.05); /* 鼠标放上去时给一个淡淡的背景 */
}
#phone-screen.dark-mode .header .back-btn:hover,
#phone-screen.dark-mode .header .action-btn:hover {
    background-color: rgba(255, 255, 255, 0.1); /* 夜间模式下的悬停颜色 */
}
/* ▲▲▲ 替换结束 ▲▲▲ */


.header .action-btn {
    font-size: 16px; /* 专门为“上传”、“+”等文字按钮缩小字号 */
    font-weight: 600; /* 可以加粗一点让它更清晰 */
}

        .header .action-btn img { height: 26px; }
        .header .save-btn { font-size: 16px; color: var(--accent-color); font-weight: 600; cursor: pointer; }
/* ▼▼▼ 【终极合并修正版】请用这块代码完整替换掉旧的 #home-screen, #clock-container, .app-grid 样式 ▼▼▼ */
        
/* 1. (核心) 为锁屏和主屏幕应用相同的全屏布局 (此部分保持不变) */
#lock-screen, 
#home-screen {
    display: flex;
    flex-direction: column;
    width: 100%;
    height: 100%;
    background-size: cover;
    background-position: center;
    
    /* 用padding把内容挤进来，同时让背景铺满安全区 */
    padding-top: env(safe-area-inset-top);
    padding-bottom: env(safe-area-inset-bottom);
    padding-left: 20px;
    padding-right: 20px;
    
    box-sizing: border-box;
}

/* 2. (核心) 单独处理锁屏的文字，让它自动贴底 (这是本次的唯一修改) */
#lock-screen-content {
    margin-top: auto; /* 关键：自动将此元素推到容器底部 */
    margin-bottom: 40px; /* ★ 核心修正：使用 margin-bottom 向上推开，而不是padding */
    text-align: center;
    color: white;
    text-shadow: 0 2px 6px rgba(0,0,0,0.5);
    font-size: 16px;
    font-weight: 500;
}

/* 3. 保持主屏幕的时钟和App图标布局不变 */
#clock-container {
    text-align: center;
    color: white;
    text-shadow: 0 3px 8px rgba(0,0,0,0.4);
    margin-bottom: 20px;
    flex-shrink: 0;
    margin-top: 60px; 
}
.app-grid {
    margin-top: auto;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    width: 100%;
    padding: 20px;
    margin-bottom: 30px; 
}



/* ▲▲▲ 替换结束 ▲▲▲ */



        .app-row { display: flex; justify-content: center; gap: 25px; width: 100%; }
        .app-icon { display: flex; flex-direction: column; align-items: center; cursor: pointer; color: white; text-shadow: 0 1px 3px rgba(0,0,0,0.5); font-size: 14px; font-weight: 500; text-align: center; }
        .app-icon .icon-bg { width: 65px; height: 65px; border-radius: 18px; background-color: var(--secondary-bg); display: flex; justify-content: center; align-items: center; font-size: 32px; margin-bottom: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.15); transition: transform 0.2s ease; overflow: hidden; }
        .app-icon:active .icon-bg { transform: scale(0.9); }
        .app-icon .icon-bg img { width: 100%; height: 100%; object-fit: cover; }
        .app-icon .label { color: white; }
        .form-container, .list-container { padding: 20px; overflow-y: auto; flex-grow: 1; display:flex; flex-direction: column; }
        .form-group { margin-bottom: 20px; }
        .form-group label { display: block; margin-bottom: 8px; font-weight: 500; color: var(--text-secondary); }
        .form-group input, .form-group select, .form-group textarea { width: 100%; padding: 12px; border: 1px solid var(--border-color); border-radius: 8px; font-size: 16px; box-sizing: border-box; }
        .form-group textarea { min-height: 80px; resize: vertical; }
        #world-book-content-input { height: calc(100% - 120px); }
        .form-button { width: 100%; padding: 15px; background-color: var(--accent-color); color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; margin-top: 10px; }
        .form-button-secondary { background-color: #f0f0f0; color: var(--text-primary); border: 1px solid var(--border-color); }
        #wallpaper-screen .form-container { align-items: center; }
        #wallpaper-preview { width: 180px; height: 320px; border: 2px dashed var(--border-color); background-color: var(--secondary-bg); margin-bottom: 20px; background-size: cover; background-position: center; border-radius: 10px; display: flex; justify-content: center; align-items: center; color: var(--text-secondary); }
        #wallpaper-upload-input { display: none; }
/* 修改后的 #world-book-list 样式 */
/* 【终极修复版】世界书主界面列表样式 */
#world-book-list {
    flex-grow: 1;          /* 让列表占据所有剩余的垂直空间 */
    overflow-y: auto;      /* 内容超出时，自动显示垂直滚动条 */
    min-height: 0;         /* 解决Flex布局下的滚动兼容性问题 */
    background-color: var(--secondary-bg); /* 保留你喜欢的背景色 */
    /* 我们不再需要 padding-top 和 margin-top 这两个技巧了 */
}


/* 修改后的 #chat-list 样式，适配了iOS底部安全区 */
#chat-list {
    flex-grow: 1;
    background-color: var(--secondary-bg);
    padding-top: 110px; 
    /* 核心修复：将底部内边距从 8px 增加到 60px，为导航栏留出足够空间 */
    padding-bottom: calc(60px + env(safe-area-inset-bottom)); 
    box-sizing: border-box;
}


        .list-item { display: flex; flex-direction: column; padding: 12px 20px; cursor: pointer; border-bottom: 1px solid var(--border-color); }
        .list-item:hover { background-color: #f5f5f5; }
        .list-item .item-title { font-weight: 500; font-size: 16px; margin-bottom: 5px; }
        .list-item .item-content { font-size: 14px; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .chat-list-item { display: flex; align-items: center; padding: 10px 15px; cursor: pointer; border-bottom: 1px solid var(--border-color); position: relative; }
        .chat-list-item:hover { background-color: #f5f5f5; }
        .chat-list-item .avatar { width: 45px; height: 45px; border-radius: 50%; margin-right: 12px; object-fit: cover; background-color: #ccc; }
        .chat-list-item .info { flex-grow: 1; overflow: hidden; }
        .chat-list-item .name-line { display: flex; align-items: center; gap: 6px; margin-bottom: 2px; }
        .chat-list-item .name { font-weight: 500; color: var(--text-primary); }
        .chat-list-item .group-tag { font-size: 10px; color: var(--accent-color); background-color: #e7f3ff; padding: 2px 6px; border-radius: 4px; font-weight: bold; flex-shrink: 0; }
        .chat-list-item .last-msg { font-size: 13px; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 180px; }
        /* 修改后的代码 */
/* ▼▼▼ 用这块【终极修复版】代码，替换你旧的 #chat-interface-screen 和 #chat-messages 样式 ▼▼▼ */

/* 1. 聊天屏幕总容器：让它成为一个撑满屏幕的Flex列布局 */
#chat-interface-screen { 
    background-size: cover; 
    background-position: center; 
    display: flex; /* <-- 核心：必须是flex布局 */
    flex-direction: column; /* <-- 核心：子元素垂直排列 */
    height: 100%; /* <-- 核心：撑满父容器 */
    overflow: hidden; /* <-- 核心：防止任何意外溢出 */
}

/* 2. 聊天消息区域：让它自动填充剩余空间，而不是固定高度 */
#chat-messages {
    flex-grow: 1;           /* ★★★ 最最关键的一行！让它自动伸缩，填满剩余空间 ★★★ */
    min-height: 0;          /* 一个神奇的保险丝，解决Flex布局下的滚动兼容问题 */
    overflow-y: auto;       /* 内容超出时，允许自身垂直滚动 */
    overflow-x: hidden;
    padding: 10px 15px;     /* 保留舒适的左右内边距 */
    box-sizing: border-box;

    /* 
     * 保留你的头部适配方案：
     * 为顶部半透明的header留出空间，同时让背景图能透上去。
     * 110px是header的高度, -80px是向上拉的距离，你可以根据你的header样式微调。
    */
    padding-top: 110px;
    margin-top: -80px;

    /* 保持内部消息气泡的flex布局 */
    display: flex;
    flex-direction: column;
    gap: 20px;
}

/* ▲▲▲ 替换结束 ▲▲▲ */
        #load-more-btn { text-align: center; padding: 10px; color: var(--accent-color); font-size: 14px; cursor: pointer; background-color: transparent; border: none; width: 100%; }
        #load-more-btn:hover { text-decoration: underline; }

/* ▼▼▼ 用这整块【最终修复版】代码，完整替换所有旧的 .sender-name 样式 ▼▼▼ */

/* 1. 这是发送者信息行 (名字+标签) 的总容器 */
/* ▼▼▼ 【独家定制】昵称/头衔上移修复 ▼▼▼ */
/* 
  用这整块代码，完整替换掉你旧的 .group-sender-line 样式。
  它将把名字和标签整体向上移动一点，避免遮挡气泡。
*/

.group-sender-line {
    display: flex;
    align-items: center; 
    gap: 8px; 
    font-size: 11px;
    color: #666;
    position: absolute; 
    
    /* ★★★ 修改这里：从 -16px 改为 -18px，让它向上移动2像素 ★★★ */
    /* 你可以根据自己的喜好，继续减小这个值（比如-20px）让它更高 */
    top: -18px;      

    left: 50px;       
    white-space: nowrap; 

    /* 【新增】为了保证层级，确保它在气泡之上 */
    z-index: 1; 
}

/* ▲▲▲ 替换结束 ▲▲▲ */

/* 2. 我们不再需要针对 .sender-name 的特殊定位了，因为现在都由 .group-sender-line 控制 */
/* 所以，可以把旧的 .message-wrapper.ai .sender-name 规则删掉，或者用这个空的规则覆盖掉它 */
.message-wrapper.ai .sender-name {
    /* 这个规则现在是空的，因为它已经被新的 .group-sender-line 替代了 */
}


/* 3. 【全新】这是聊天界面内，跟在名字后面的身份和头衔标签的专属样式 */
.group-sender-tags {
    display: inline-flex; /* 确保它自己也是一个 flex 容器，让内部的标签能水平排列 */
    align-items: center;
    gap: 5px; /* 标签之间的间距 */
}

.group-role-tag, .group-title-tag {
    font-size: 10px;
    padding: 1px 5px;
    border-radius: 8px; /* 圆润的胶囊形状 */
    font-weight: 500;
    line-height: 1.4;
}

/* 群主和管理员的颜色 */
.group-role-tag.owner {
    background-color: #FFF2C2;
    color: #D98C00;
    border: 1px solid #FFE89D;
}
.group-role-tag.admin {
    background-color: #D4EDDA;
    color: #155724;
    border: 1px solid #C3E6CB;
}

/* ▼▼▼ 【独家终极修复版】请用这整块代码，完整替换掉所有旧的 .group-title-tag 样式 ▼▼▼ */

/* ▼▼▼ 【最终修复版】请将这整块代码粘贴到 <style> 标签的最末尾 ▼▼▼ */

/* 1. 先为【所有】头衔设置你想要的紫色作为默认值 */
.group-title-tag {
    background-color: #E9E7FD !important; /* 淡紫色背景 */
    color: #5E548E !important;           /* 深紫色文字 */
    border: 1px solid #D9D5F8 !important; /* 稍深的紫色边框 */
}

/* 2. 然后，单独为【管理员】的头衔设置绿色 */
.group-role-tag.admin ~ .group-title-tag {
    background-color: #D4EDDA !important; /* 复制管理员标签的绿色 */
    color: #155724 !important;
    border: 1px solid #C3E6CB !important;
}

/* 3. 同理，为【群主】的头衔设置黄色 */
.group-role-tag.owner ~ .group-title-tag {
    background-color: #FFF2C2 !important; /* 复制群主标签的黄色 */
    color: #D98C00 !important;
    border: 1px solid #FFE89D !important;
}


/* === 夜间模式适配 (原理相同) === */

/* 夜间模式下的默认紫色 */
#phone-screen.dark-mode .group-title-tag {
    background-color: #3B3355 !important;
    color: #C3B9E7 !important;
    border-color: #514777 !important;
}

/* 夜间模式下的管理员绿色 */
#phone-screen.dark-mode .group-role-tag.admin ~ .group-title-tag {
    background-color: #104A3C !important;
    color: #76DDC4 !important;
    border-color: #176854 !important;
}

/* 夜间模式下的群主黄色 */
#phone-screen.dark-mode .group-role-tag.owner ~ .group-title-tag {
    background-color: #594200 !important;
    color: #FFD466 !important;
    border-color: #795B00 !important;
}

/* ▲▲▲ 修复结束 ▲▲▲ */

/* ▲▲▲ 替换结束 ▲▲▲ */


/* ▲▲▲ 替换结束 ▲▲▲ */


/* === 【全新】消息布局与时间戳样式 === */

/* 1. 消息单元的总容器 (重构) */
.message-wrapper {
    display: flex;          /* 使用Flex布局 */
    gap: 8px;               /* 气泡和时间戳之间的间距 */
    align-items: flex-end;  /* 核心：让气泡和时间戳底部对齐 */
    position: relative;
    max-width: 90%;         /* 可以稍微放宽一点，因为时间戳现在在外面了 */
}

/* 2. AI消息单元靠左 */
.message-wrapper.ai {
    align-self: flex-start;
    flex-direction: row; /* 头像、气泡、时间戳，从左到右排列 */
}

/* 3. 用户消息单元靠右 */
.message-wrapper.user {
    align-self: flex-end;
    flex-direction: row-reverse; /* 时间戳、气泡、头像，从右到左排列 */
}

/* 4. 气泡和头像的直接容器 (保持不变) */
.message-bubble {
    display: flex;
    align-items: flex-start;
    gap: 12px;
    max-width: 100%;
}

.timestamp {
    /* 移除旧的 position: absolute */
    font-size: 11px;
    color: #999;
    text-shadow: 0 0 3px rgba(255,255,255,0.6);
    white-space: nowrap; /* 防止时间换行 */
    margin-bottom: 5px;  /* 让它和气泡底部有轻微的对齐偏移，更美观 */
    flex-shrink: 0;      /* 防止被压缩 */
}

        .message-bubble.selected::after { content: '✔'; position: absolute; left: -10px; top: 50%; transform: translateY(-50%); background-color: var(--accent-color); color: white; width: 20px; height: 20px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 12px; }
        .message-bubble.user.selected::after { left: auto; right: -10px; }

        .message-bubble.user { flex-direction: row-reverse; }
        #typing-indicator { align-self: flex-start; display: none; margin: 0 10px 10px; color: var(--text-secondary); }
        /* 修改聊天输入框区域的 padding */
#chat-input-area { 
    flex-shrink: 0; 
    /* ▼▼▼ 核心修改1：增加了上、左、右的内边距，让整个区域更“宽敞” ▼▼▼ */
    padding: 10px 12px; 
    background-color: rgba(247, 247, 247, 0.8); 
    backdrop-filter: blur(10px); 
    -webkit-backdrop-filter: blur(10px); 
    border-top: 1px solid var(--border-color); 
    display: flex; 
    flex-direction: column; 
    gap: 5px; 
}

/* 修改iPhone底部安全区的适配 */
#chat-input-area {
    /* ▼▼▼ 核心修改2：将这里的 8px 也同步为 10px，保持一致 ▼▼▼ */
    padding-bottom: calc(10px + env(safe-area-inset-bottom));
}

        #chat-input-main-row { display: flex; align-items: flex-end; gap: 8px; width: 100%; }
        #chat-input { flex-grow: 1; border: none; padding: 10px 15px; border-radius: 20px; background-color: var(--secondary-bg); font-size: 16px; max-height: 100px; resize: none; }
        .action-button { border: none; color: white; border-radius: 20px; cursor: pointer; font-weight: 600; font-size: 14px; flex-shrink: 0; }
        #send-btn { background-color: var(--accent-color); height: 40px; padding: 0 15px;}
        .modal {
    /* ▼▼▼ 核心修改：将定位方式从 absolute 改为 fixed ▼▼▼ */
    position: fixed; 
    /* ▲▲▲ 修改结束 ▲▲▲ */
    top: 0; 
    left: 0; 
    width: 100%; 
    height: 100%; 
    background-color: rgba(0,0,0,0.4); 
    display: none; 
    justify-content: center; 
    align-items: center; 
    z-index: 100; 
}

        .modal.visible { display: flex; }
        .modal-content { width: 90%; max-height: 90%; background-color: white; border-radius: 15px; display: flex; flex-direction: column; }
        .modal-header { padding: 15px; font-weight: 600; border-bottom: 1px solid var(--border-color); text-align: center; display: flex; justify-content: space-between; align-items: center; }
        .modal-body { padding: 15px; overflow-y: auto; }
        .modal-footer { padding: 15px; border-top: 1px solid var(--border-color); display: flex; justify-content: space-around; }
        .modal-footer button { width: 45%; padding: 12px; border-radius: 8px; border: 1px solid var(--accent-color); cursor: pointer; font-size: 16px; }
        .modal-footer .save { background-color: var(--accent-color); color: white; }
        .modal-footer .cancel { background-color: white; color: var(--accent-color); }
        .avatar-upload { display: flex; align-items: center; gap: 15px; }
        .avatar-upload img { width: 60px; height: 60px; border-radius: 50%; object-fit: cover; background-color: #eee; }
        .avatar-upload button { padding: 8px 12px; border: 1px solid #ccc; background-color: #f0f0f0; border-radius: 5px; cursor: pointer; }
        #open-persona-library-btn { font-size: 14px; padding: 6px 10px; margin-left: 0; }
        .avatar-upload input[type="file"] { display: none; }
        .theme-selector label { display: inline-flex; align-items: center; margin-right: 15px; margin-bottom: 5px; cursor: pointer; }
        #reset-theme-btn { background: none; border: 1px solid #ccc; color: #555; font-size: 12px; padding: 2px 8px; border-radius: 5px; cursor: pointer; margin-left: 10px; }
        #group-members-settings { display: flex; overflow-x: auto; padding-bottom: 10px; gap: 15px; }
        .member-editor { text-align: center; cursor: pointer; }
        .member-editor img { width: 50px; height: 50px; border-radius: 50%; object-fit: cover; background-color: #eee; margin-bottom: 5px; }
        .member-editor .member-name { font-size: 12px; }
        #notification-bar { position: absolute; top: 40px; left: 50%; width: 90%; z-index: 500; background-color: rgba(250, 250, 250, 0.9); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border-radius: 16px; padding: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); display: flex; align-items: center; gap: 12px; cursor: pointer;     transform: translateX(-50%) translateY(-150%); 
    transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    visibility: hidden;
}
#notification-bar.visible {
    /* 关键：在Y轴回到原位的同时，保持X轴的居中变换 */
    transform: translateX(-50%) translateY(0);
    visibility: visible;
}
        #notification-avatar { width: 30px; height: 30px; border-radius: 50%; object-fit: cover; }
        #notification-content .name { font-weight: 600; font-size: 15px; color: #000; }
        #notification-content .message { font-size: 14px; color: #555; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 200px; }
        .sticker-image { max-width: 100px; max-height: 100px; display: block; object-fit: contain; }
        .message-bubble.is-sticker .content, .message-bubble.is-voice-message .content { padding: 0; background-color: transparent; box-shadow: none; border: none; backdrop-filter: none; -webkit-backdrop-filter: none; }
        #chat-input-actions-top { display: flex; gap: 8px; padding: 0 5px; }
        .chat-action-icon-btn { font-size: 24px; padding: 0; width: 38px; height: 38px; line-height: 38px; text-align: center; border-radius: 50%; background-color: rgba(255, 255, 255, 0.5); color: var(--text-primary); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border: 1px solid rgba(0,0,0,0.05); cursor: pointer; display:flex; justify-content:center; align-items:center; }
        #sticker-panel { position: absolute; bottom: 0; left: 0; width: 100%; height: 50%; background-color: rgba(242, 242, 247, 0.85); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-top: 1px solid var(--border-color); border-radius: 20px 20px 0 0; z-index: 200; display: flex; flex-direction: column; transform: translateY(100%); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); visibility: hidden; }
        #sticker-panel.visible { transform: translateY(0); visibility: visible; }
        #sticker-panel-header { padding: 10px 20px; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; border-bottom: 1px solid var(--border-color); }
        #sticker-panel-header .title { font-weight: 600; }
        #sticker-panel-header .panel-btn { font-size: 16px; padding: 5px 10px; cursor: pointer; color: var(--accent-color); }
        #sticker-grid, #exclusive-sticker-grid, #common-sticker-grid { flex-grow: 1; overflow-y: auto; padding: 15px; display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 15px; }
        .sticker-item { position: relative; aspect-ratio: 1 / 1; background-color: white; border-radius: 10px; background-size: contain; background-repeat: no-repeat; background-position: center; cursor: pointer; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .sticker-item .delete-btn { display: none; position: absolute; top: -5px; right: -5px; width: 20px; height: 20px; background-color: #ff3b30; color: white; border-radius: 50%; text-align: center; line-height: 20px; font-size: 14px; cursor: pointer; border: 2px solid white; }
        #input-actions-wrapper { position: static; display: flex; align-items: flex-end; gap: 8px; flex-shrink: 0; }
        #wait-reply-btn { position: static; bottom: auto; right: auto; width: auto; height: 40px; padding: 0 10px; border-radius: 20px; display: flex; align-items: center; justify-content: center; background-color: rgba(255, 255, 255, 0.6); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border: 1px solid rgba(0,0,0,0.08); box-shadow: 0 2px 5px rgba(0,0,0,0.1); transition: opacity 0.2s, transform 0.1s; cursor: pointer;}
        #wait-reply-btn:hover { opacity: 0.8; }
        #wait-reply-btn:active { transform: scale(0.9); }
        #wait-reply-btn img { height: 22px; display: block; margin: auto; }
        .chat-image { max-width: 100%; border-radius: 10px; display: block; }
        .message-bubble.has-image .content { padding: 5px; }
        #custom-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); display: none; align-items: center; justify-content: center; z-index: 1000; opacity: 0; transition: opacity 0.2s ease-in-out; }
        #custom-modal-overlay.visible { display: flex; opacity: 1; }
        #custom-modal { background-color: #fff; width: 280px; border-radius: 14px; box-shadow: 0 4px 20px rgba(0,0,0,0.2); display: flex; flex-direction: column; transform: scale(0.95); transition: transform 0.2s ease-in-out; }
        #custom-modal-overlay.visible #custom-modal { transform: scale(1); }
        .custom-modal-header { padding: 16px; font-size: 17px; font-weight: 600; text-align: center; }
        .custom-modal-body { padding: 0 16px 16px; text-align: center; font-size: 14px; color: #333; line-height: 1.5; }
        .custom-modal-body p { margin: 0; margin-bottom: 12px; }
        .custom-modal-body input { width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ccc; font-size: 14px; box-sizing: border-box; }
        .custom-modal-footer { border-top: 1px solid #dbdbdb; display: flex; }
        .custom-modal-footer button { flex: 1; background: none; border: none; padding: 12px; font-size: 17px; cursor: pointer; color: var(--accent-color); }
        .custom-modal-footer button:first-child { border-right: 1px solid #dbdbdb; }
        .custom-modal-footer .confirm-btn { font-weight: 600; }
        .custom-modal-footer .confirm-btn.btn-danger { color: #ff3b30; }
        #preset-actions-modal .custom-modal-footer { flex-direction: column; }
        #preset-actions-modal .custom-modal-footer button { width: 100%; border: none; border-bottom: 1px solid #dbdbdb; padding: 14px; font-size: 18px; }
        #preset-actions-modal .custom-modal-footer button:last-child { border-bottom: none; }
        .custom-multiselect { position: relative; user-select: none; }
        .select-box { display: flex; align-items: center; width: 100%; padding: 12px; border: 1px solid var(--border-color); border-radius: 8px; font-size: 16px; box-sizing: border-box; background-color: #fff; cursor: pointer; }
        .select-box .selected-options-text { flex-grow: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text-primary); }
        .select-box .arrow-down { margin-left: auto; font-size: 10px; color: var(--text-secondary); transition: transform 0.2s; }
        .select-box.expanded .arrow-down { transform: rotate(180deg); }

.checkboxes-container {
    display: none;
    position: absolute;
    top: 100%; 
    margin-top: 5px;
    left: 0;
    right: 0;
    max-height: 400px; /* ★★★ 修改点在这里 ★★★ 我把高度从 150px 增加到了 350px */
    overflow-y: auto;
    overflow-x: hidden;
    background-color: #fff;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    z-index: 101;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}
        .checkboxes-container.visible { display: block; }
        .checkboxes-container label { display: block; padding: 10px 12px; cursor: pointer; font-weight: normal; color: var(--text-primary); }

.checkboxes-container label {
    display: block;
    padding: 12px 15px; /* <-- 修改：增加了上下和左右的内边距，让每一行更高更宽 */
    cursor: pointer;
    font-weight: normal;
    color: var(--text-primary);
    font-size: 15px; /* <-- 新增：将字体大小从默认值放大到15px */
}

        .checkboxes-container input { margin-right: 10px; vertical-align: middle; }
        .bg-upload-container { display: flex; align-items: center; gap: 10px; margin-top: 8px; flex-wrap: wrap; }
        .bg-preview-img { max-width: 120px; max-height: 80px; border-radius: 8px; border: 1px solid var(--border-color); object-fit: cover; display: none; }
        #remove-bg-btn { padding: 8px 12px; border: 1px solid #ff3b30; color: #ff3b30; background-color: #fff; border-radius: 5px; cursor: pointer; font-size: 14px; display: none; }
        .message-bubble.is-ai-image .content { padding: 5px; background: transparent; box-shadow: none; border: none; backdrop-filter: none; -webkit-backdrop-filter: none; }
        .ai-generated-image { max-width: 180px; border-radius: 12px; display: block; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; }
        .ai-generated-image:hover { transform: scale(1.05); box-shadow: 0 4px 15px rgba(0,0,0,0.2); }
        .voice-message-body { display: flex; align-items: center; cursor: pointer; padding: 8px 12px; min-width: 80px; max-width: 200px; }
        .message-bubble.user .voice-message-body { color: #1a3d00; flex-direction: row-reverse; }
        .message-bubble.ai .voice-message-body { color: var(--text-primary); }
        .voice-waveform { display: flex; align-items: center; height: 20px; gap: 2px; flex-grow: 1; margin: 0 10px; }
        .voice-waveform div { width: 3px; background-color: currentColor; border-radius: 2px; animation: wave-quiet 1.5s ease-in-out infinite; }
        @keyframes wave-quiet { 0%, 100% { height: 2px; } 50% { height: 10px; } }
        .voice-waveform div:nth-child(2) { animation-delay: 0.2s; } .voice-waveform div:nth-child(3) { animation-delay: 0.4s; } .voice-waveform div:nth-child(4) { animation-delay: 0.6s; } .voice-waveform div:nth-child(5) { animation-delay: 0.8s; }
.voice-duration {
    /* --- 核心修正 --- */
    font-size: var(--chat-font-size, 13px);
    /* --- 修正结束 --- */
    font-weight: 500;
    color: var(--text-secondary);
}
        .message-bubble.user .voice-duration { color: #3e6224; }

/* ▼▼▼ 用这块代码替换掉你原来的 .message-bubble .content 样式 ▼▼▼ */
/* 通用内容区样式，为时间戳和字体大小做准备 */
.message-bubble .content {
    position: relative;
    font-size: var(--chat-font-size, 16px);
    padding: 8px 12px;
    line-height: 1.5;
    word-break: break-word; /* 核心修正: 强制长单词或URL换行，防止撑破气泡 */
}
/* ▲▲▲ 替换结束 ▲▲▲ */

        /* === 气泡主题样式 === */
        .message-bubble.user .content { background-color: rgba(255, 255, 255, 0.75); color: #585858; border-radius: 8px 2px 8px 8px; }
        .message-bubble.ai .content { background-color: rgba(255, 255, 255, 0.7); color: #585858; border-radius: 2px 8px 8px 8px; }
      
.message-bubble::after {
    content: "";
    position: absolute;
    width: 20px;  
    height: 20px; 
    background-size: contain;
    background-repeat: no-repeat;
    opacity: 1; 
    z-index: 1;
}
      
        #chat-messages[data-theme="pink_blue"] .message-bubble.user .content { background-color: #fff0f6; color: #432531; }
        #chat-messages[data-theme="pink_blue"] .message-bubble.ai .content { background-color: #eff7ff; color: #263a4e; }
        #chat-messages[data-theme="blue_white"] .message-bubble.user .content { background-color: #eff7ff; color: #263a4e; }
        #chat-messages[data-theme="blue_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #383d41; }
        #chat-messages[data-theme="purple_yellow"] .message-bubble.user .content { background-color: #faf7ff; color: #827693; }
        #chat-messages[data-theme="purple_yellow"] .message-bubble.ai .content { background-color: #fffde4; color: #5C4033; }
        #chat-messages[data-theme="black_white"] .message-bubble.user .content { background-color: #343a40; color: #f8f9fa; }
        #chat-messages[data-theme="black_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #343a40; }
        #chat-messages[data-theme="yellow_white"] .message-bubble.user .content { background-color: #FFEB3B; color: #5D4037; }
        #chat-messages[data-theme="yellow_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #383d41; }
        #chat-messages[data-theme="red_black"] .message-bubble.user .content { background-color: #C62828; color: #FFFFFF; }
        #chat-messages[data-theme="red_black"] .message-bubble.ai .content { background-color: #212121; color: #FFFFFF; }
        #chat-messages[data-theme="blue_yellow"] .message-bubble.user .content { background-color: #A0D2EB; color: #153243; }
        #chat-messages[data-theme="blue_yellow"] .message-bubble.ai .content { background-color: #FEF9E7; color: #5D4037; }
        #chat-messages[data-theme="pink_yellow"] .message-bubble.user .content { background-color: #fff0f6; color: #432531; }
        #chat-messages[data-theme="pink_yellow"] .message-bubble.ai .content { background-color: #FEF9E7; color: #5D4037; }
        #chat-messages[data-theme="pink_purple"] .message-bubble.user .content { background-color: #fff0f6; color: #a78396; }
        #chat-messages[data-theme="pink_purple"] .message-bubble.ai .content { background-color: #faf7ff; color: #827693; }
        #chat-messages[data-theme="gray_white"] .message-bubble.user .content { background-color: #e9ecef; color: #495057; }
        #chat-messages[data-theme="gray_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #383d41; }
        #chat-messages[data-theme="blue_green"] .message-bubble.user .content { background-color: #d1ecf1; color: #0c5460; }
        #chat-messages[data-theme="blue_green"] .message-bubble.ai .content { background-color: #d4edda; color: #155724; }
        #chat-messages[data-theme="pink_white"] .message-bubble.user .content { background-color: #fff0f6; color: #a78396; }
        #chat-messages[data-theme="pink_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #383d41; }
        #chat-messages[data-theme="pink_black"] .message-bubble.user .content { background-color: #F8BBD0; color: #5B2C6F; }
        #chat-messages[data-theme="pink_black"] .message-bubble.ai .content { background-color: #343a40; color: #f8f9fa; }
        #chat-messages[data-theme="pink_green"] .message-bubble.user .content { background-color: #F8BBD0; color: #5B2C6F; }
        #chat-messages[data-theme="pink_green"] .message-bubble.ai .content { background-color: #C8E6C9; color: #1B5E20; }
        #chat-messages[data-theme="green_black"] .message-bubble.user .content { background-color: #d4edda; color: #155724; }
        #chat-messages[data-theme="green_black"] .message-bubble.ai .content { background-color: #343a40; color: #f8f9fa; }

        #transfer-btn { font-weight: bold; }
        #transfer-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 1001; }
        #transfer-modal.visible { display: flex; }
        .transfer-content { background-color: #fff0f5; border-radius: 20px; width: 290px; padding: 20px; box-shadow: 0 5px 25px rgba(255, 105, 180, 0.3); text-align: center; background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100" opacity="0.05"><path d="M50,4 C35,4 28,15 28,24 C28,33 35,32 35,40 C35,48 28,49 28,57 C28,65 35,66 35,74 C35,82 28,83 28,91 C28,99 35,100 50,100 C65,100 72,99 72,91 C72,83 65,82 65,74 C65,66 72,65 72,57 C72,49 65,48 65,40 C65,32 72,33 72,24 C72,15 65,4 50,4 Z" fill="%23FF69B4"/></svg>'); background-repeat: no-repeat; background-position: top right; background-size: 80px; }
        .transfer-header { font-size: 20px; font-weight: bold; color: #a35c7b; margin-bottom: 20px; }
        .transfer-input-group { margin-bottom: 15px; text-align: left; }
        .transfer-input-group label { display: block; font-size: 14px; color: #ff85b3; margin-bottom: 5px; font-weight: 500; }
        .transfer-input-group input { width: 100%; padding: 12px; border-radius: 10px; border: 2px solid #ffcce0; background-color: #fff; font-size: 16px; box-sizing: border-box; }
        .transfer-input-group input:focus { border-color: #ff85b3; outline: none; }
        .transfer-actions { display: flex; justify-content: space-between; gap: 10px; }
        .transfer-actions button { flex: 1; padding: 12px; border: none; border-radius: 10px; font-size: 16px; font-weight: bold; cursor: pointer; transition: transform 0.2s; }
        .transfer-actions button:active { transform: scale(0.95); }
        #transfer-cancel-btn { background-color: #ffdde9; color: #a35c7b; }
        #transfer-confirm-btn { background-color: #ff85b3; color: white; }
        .message-bubble.is-transfer .content { padding: 0; background: transparent; box-shadow: none; border: none; backdrop-filter: none; -webkit-backdrop-filter: none; cursor: pointer; }
        .transfer-card { width: 200px; border-radius: 12px; padding: 12px; color: white; position: relative; overflow: hidden; }
        .transfer-card::before { content: '🐾'; position: absolute; right: 10px; top: 5px; font-size: 30px; opacity: 0.2; transform: rotate(15deg); }
        .message-bubble.user .transfer-card { background: radial-gradient(circle at top left, #ffc5d5, #ff85b3); }
        .message-bubble.ai .transfer-card { background: radial-gradient(circle at top left, #a1c4fd, #c2e9fb); }
        .transfer-title { font-size: 16px; font-weight: 600; display: flex; align-items: center; gap: 6px; margin-bottom: 8px; }
        .transfer-amount { font-size: 28px; font-weight: bold; margin-bottom: 4px; }
        .transfer-note { font-size: 13px; opacity: 0.9; border-top: 1px solid rgba(255,255,255,0.3); padding-top: 8px; margin-top: 8px; word-break: break-all; }
        
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        #listen-together-btn img.rotating { animation: spin 2s linear infinite; }
        #listen-together-btn img.paused { animation-play-state: paused; }
        #music-player-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 50; display: none; justify-content: center; align-items: center; background-color: rgba(0,0,0,0.3); }
        #music-player-overlay.visible { display: flex; }
        .music-player-window { width: 90%; background-color: rgba(255, 255, 255, 0.6); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border-radius: 20px; box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37); border: 1px solid rgba(255, 255, 255, 0.18); padding: 25px; display: flex; flex-direction: column; align-items: center; color: #1f1f1f; position: relative; }
        #music-playlist-btn { position: absolute; top: 15px; right: 15px; font-size: 24px; cursor: pointer; color: #333; }
        #music-time-counter { font-size: 12px; color: #555; margin-bottom: 20px; }
        #music-player-song-title { font-size: 20px; font-weight: 600; margin-bottom: 5px; text-align: center; }
        #music-player-artist { font-size: 14px; color: #666; margin-bottom: 25px; }
        .music-controls { display: flex; align-items: center; justify-content: center; gap: 20px; width: 100%; margin-bottom: 30px; }
        .music-controls button { background: none; border: none; font-size: 16px; font-weight: bold; cursor: pointer; color: #333; width: 44px; height: 44px; display: flex; justify-content: center; align-items: center; transition: transform 0.2s; }
        .music-controls button:active { transform: scale(0.9); }
        .music-controls .play-pause-btn { font-size: 24px; width: 60px; height: 60px; border-radius: 50%; background-color: rgba(0,0,0,0.05); }
        .music-bottom-actions { display: flex; justify-content: space-between; width: 100%; }
        .music-bottom-actions button { flex: 1; padding: 12px 0; border: none; border-radius: 10px; font-size: 15px; font-weight: 500; cursor: pointer; }
        #music-exit-btn { background-color: rgba(255, 100, 100, 0.7); color: white; margin-right: 5px; }
        #music-return-btn { background-color: rgba(0, 123, 255, 0.7); color: white; margin-left: 5px; }
        
        #music-playlist-panel { position: absolute; bottom: 0; left: 0; width: 100%; height: 70%; background-color: rgba(242, 242, 247, 0.9); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-top: 1px solid var(--border-color); border-radius: 20px 20px 0 0; z-index: 210; display: flex; flex-direction: column; transform: translateY(100%); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); visibility: hidden; }
        #music-playlist-panel.visible { transform: translateY(0); visibility: visible; }
        .playlist-header { padding: 15px 20px; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; border-bottom: 1px solid var(--border-color); font-weight: 600; }
        .playlist-header .panel-btn { font-size: 16px; cursor: pointer; color: var(--accent-color); }
        .playlist-body { flex-grow: 1; overflow-y: auto; padding: 10px 0; }
        .playlist-item { padding: 10px 20px; display: flex; justify-content: space-between; align-items: center; cursor: pointer; border-bottom: 1px solid #eee; }
        .playlist-item.playing { background-color: rgba(0, 123, 255, 0.1); }
        .playlist-item-info .title { font-weight: 500; font-size: 15px; }
        .playlist-item-info .artist { font-size: 12px; color: #666; }
        .playlist-item .delete-track-btn { color: #ff3b30; font-size: 20px; padding: 5px; }

        /* Persona Library Styles */
        #persona-library-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; padding: 10px; }
        .persona-preset-item { aspect-ratio: 1 / 1; border-radius: 12px; background-size: cover; background-position: center; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; border: 1px solid rgba(0,0,0,0.1); }
        .persona-preset-item:hover { transform: scale(1.08); box-shadow: 0 4px 10px rgba(0,0,0,0.2); }
        .modal-header .action-button { font-size: 16px; color: var(--accent-color); font-weight: 600; cursor: pointer; background: none; border: none; padding: 5px; }
        
        /* Battery Alert Modal Styles */
        #battery-alert-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.4); display: none; justify-content: center; align-items: center; z-index: 2000; opacity: 0; transition: opacity 0.3s ease; }
        #battery-alert-modal.visible { display: flex; opacity: 1; }
        .battery-alert-content { background-color: rgba(255, 255, 255, 0.9); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); width: 280px; border-radius: 15px; box-shadow: 0 5px 20px rgba(0,0,0,0.2); text-align: center; padding: 20px; cursor: pointer; transform: scale(0.9); transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); }
        #battery-alert-modal.visible .battery-alert-content { transform: scale(1); }
        #battery-alert-image { max-width: 100px; max-height: 100px; margin-bottom: 15px; }
        #battery-alert-text { font-size: 16px; font-weight: 500; color: #333; margin: 0; line-height: 1.4; }

/* 这是你要添加的新样式 */
#font-preview {
    transition: font-family 0.3s ease;}

/* === 聊天列表界面新增样式 (这是新添加的) === */
#chat-list-screen {
}

.chat-list-view {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.2s, visibility 0.2s;
    z-index: 1; 
}
.chat-list-view.active {
    opacity: 1;
    visibility: visible;
    z-index: 2; 
}

#messages-view {
    overflow-y: auto; 
}

/* 底部导航栏样式 */
#chat-list-bottom-nav {
    position: absolute; /* 让它固定在底部 */
    bottom: 0;
    left: 0;
    width: 100%;
    z-index: 15; /* 确保它在视图之上 */
    display: flex;
    border-top: 1px solid var(--border-color);
    background-color: rgba(247, 247, 247, 0.9);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
}

.nav-item {
    flex: 1;
    text-align: center;
    padding: 13px 0;
    font-size: 14px;
    color: var(--text-secondary);
    cursor: pointer;
    transition: color 0.2s;
}

.nav-item.active {
    color: var(--accent-color);
    font-weight: 600;
}

/* === 动态界面 (QZone) 样式 (这是新添加的) === */
#qzone-screen {
    background-color: #f0f2f5;
}

.qzone-header {
    /* position: absolute;  <-- 把这个改成 relative */
    position: relative;
    z-index: 10; /* z-index 保持，或者可以更高 */
    flex-shrink: 0; /* 防止被压缩 */
    padding: 15px 20px;
    padding-top: 45px;
    background-color: rgba(247, 247, 247, 0.7); 
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-bottom: 1px solid var(--border-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 18px;
    font-weight: 600;
    text-align: center;
}

.qzone-header .back-btn {
    font-size: 24px;
    cursor: pointer;
    color: var(--accent-color);
}

.qzone-header span:nth-child(2) { /* "好友动态"文字 */
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
}

.qzone-content {
    flex-grow: 1;
    overflow-y: auto;
    /* padding-top: 80px;  <-- 删除这个，因为header不再是absolute了 */
}

.qzone-profile-header {
    position: relative;
    margin-bottom: 20px;
}

.qzone-banner-container {
    width: 100%;
    height: 180px; /* 背景板高度 */
    position: relative;
}

#qzone-banner-img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.qzone-user-info {
    position: absolute;
    bottom: -30px; /* 让头像和昵称区域向下偏移，一半在背景板内，一半在外 */
    left: 20px;
    display: flex;
    align-items: flex-end; /* 让昵称和头像底部对齐 */
    gap: 10px;
}

.qzone-avatar-container {
    position: relative;
}

#qzone-avatar-img {
    width: 70px;
    height: 70px;
    border-radius: 50%;
    border: 3px solid white;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    object-fit: cover;
}

#qzone-nickname {
    font-size: 18px;
    font-weight: 600;
    color: #fff;
    text-shadow: 0 1px 3px rgba(0,0,0,0.5);
    padding-bottom: 5px; /* 微调位置 */
}

/* 编辑按钮的通用样式 */
.qzone-edit-btn {
    position: absolute;
    background-color: rgba(0,0,0,0.4);
    color: white;
    border: none;
    border-radius: 10px;
    padding: 4px 8px;
    font-size: 12px;
    cursor: pointer;
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
}

#change-qzone-banner-btn {
    bottom: 10px;
    right: 10px;
}

#change-qzone-avatar-btn {
    bottom: 5px;
    right: 5px;
}

#change-qzone-nickname-btn {
    font-size: 14px;
    padding: 2px 6px;
    margin-left: 5px; /* 与昵称的间距 */
    color: var(--text-primary);
    background-color: rgba(255,255,255,0.7);
    border-radius: 5px;
    position: relative; /* 脱离flex布局的对齐 */
    bottom: 5px; /* 微调垂直位置 */
}

/* === 让编辑功能更“隐形” === */
#qzone-banner-container,
#qzone-avatar-container,
#qzone-nickname {
    cursor: pointer; /* 鼠标悬停时显示为可点击手势 */
    transition: opacity 0.2s;
}
#qzone-banner-container:hover,
#qzone-avatar-container:hover,
#qzone-nickname:hover {
    opacity: 0.85; /* 悬停时稍微变暗，给用户反馈 */
}
/* 隐藏掉旧的、独立的编辑按钮 */
.qzone-edit-btn {
    display: none;
}

/* === 控制 Header 和 Bottom Nav 的显隐 === */
/* 默认隐藏动态界面的 Header */
#qzone-screen .qzone-header {
    display: none;
}
/* 当动态视图激活时，显示它的Header */
#qzone-screen.active .qzone-header {
    display: flex;
}

/* 当进入动态视图时，隐藏主Header和底部导航栏 */
#chat-list-screen.in-qzone-view > .header,
#chat-list-screen.in-qzone-view > #chat-list-bottom-nav {
    display: none;
}

.chat-group-container:first-child {
    margin-top: 10px; 
}

/* ▲▲▲ 新样式替换结束 ▲▲▲ */

/* ▼▼▼ 把所有这些新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === 动态功能栏样式 === */
.qzone-actions-bar {
    display: flex;
    justify-content: space-around;
    padding: 10px 0;
    margin: 40px 15px 15px 15px; /* 上边距更大，为浮动的头像留出空间 */
    background-color: var(--secondary-bg);
    border-radius: 12px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
}

.action-item {
    flex: 1;
    text-align: center;
    font-size: 15px;
    font-weight: 500;
    color: var(--text-primary);
    cursor: pointer;
    padding: 8px 0;
    position: relative;
}

/* 用伪元素创建分隔线 */
.action-item:not(:last-child)::after {
    content: '';
    position: absolute;
    right: 0;
    top: 50%;
    transform: translateY(-50%);
    width: 1px;
    height: 20px;
    background-color: var(--border-color);
}

/* === 动态帖子列表样式 === */
#qzone-posts-list {
    padding: 0 15px 20px 15px; /* 左右和底部留出边距 */
    display: flex;
    flex-direction: column;
    gap: 20px; /* 帖子之间的间距 */
}

.qzone-post-item {
    background-color: var(--secondary-bg);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.06);
}

.post-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 12px;
}

.post-header .post-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    object-fit: cover;
}

.post-info {
    display: flex;
    flex-direction: column;
}

.post-info .post-nickname {
    font-weight: 600;
    font-size: 15px;
    color: var(--text-primary);
}

.post-info .post-timestamp {
    font-size: 12px;
    color: var(--text-secondary);
}

.post-content {
    font-size: 14px;
    line-height: 1.6;
    color: #333;
    white-space: pre-wrap; /* 让换行符生效 */
    word-break: break-word; /* 防止长单词溢出 */
}

/* ▲▲▲ 新样式结束 ▲▲▲ */

/* ▼▼▼ 新样式粘贴到末尾 ▼▼▼ */

/* === 发布动态模态框样式 === */
#post-public-text {
    min-height: 80px; /* 确保文本域有足够的高度 */
    resize: vertical;
}

.post-image-preview-container {
    position: relative;
    width: 100%;
    aspect-ratio: 16 / 9; /* 保持16:9的预览比例 */
    background-color: #f0f2f5;
    border: 2px dashed var(--border-color);
    border-radius: 8px;
    margin-bottom: 15px;
    display: none; /* 默认隐藏 */
    justify-content: center;
    align-items: center;
}
.post-image-preview-container.visible {
    display: flex; /* 上传后显示 */
}

#post-image-preview {
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
    border-radius: 6px;
}

#post-remove-image-btn {
    position: absolute;
    top: -10px;
    right: -10px;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    background-color: #ff3b30;
    color: white;
    border: 2px solid white;
    font-size: 16px;
    line-height: 20px;
    text-align: center;
    cursor: pointer;
    box-shadow: 0 1px 4px rgba(0,0,0,0.3);
}

.post-image-upload-options {
    display: flex;
    gap: 10px;
}

.post-image-upload-options button {
    flex: 1;
    margin-top: 0;
}

/* ▲▲▲ 新样式结束 ▲▲▲ */

/* ▼▼▼ 新样式 ▼▼▼ */

/* === 发布动态模态框 - 模式切换样式 === */
.post-mode-switcher {
    display: flex;
    margin-bottom: 20px;
    background-color: #e9ecef;
    border-radius: 8px;
    padding: 4px;
}

.mode-btn {
    flex: 1;
    padding: 8px;
    border: none;
    background-color: transparent;
    border-radius: 6px;
    font-size: 14px;
    font-weight: 500;
    color: var(--text-secondary);
    cursor: pointer;
    transition: all 0.2s ease-in-out;
}

.mode-btn.active {
    background-color: var(--secondary-bg);
    color: var(--text-primary);
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}

.post-mode-content {
    display: none; /* 默认都隐藏 */
}

.post-mode-content.active {
    display: block; /* 激活的才显示 */
}

/* ▲▲▲ 新样式结束 ▲▲▲ */

/* === 相册页面背景色 === */
#album-screen {
    background-color: #f0f2f5; /* 使用一个柔和的浅灰色，比纯白更护眼 */
}

/* === 相册页面网格布局 === */
#album-grid-page {
    padding: 15px;
    display: grid;
    grid-template-columns: repeat(2, 1fr); /* 每行显示2个相册 */
    gap: 15px;
}

/* === 相册项目样式 (美化) === */
.album-item {
    display: flex;
    flex-direction: column;
    cursor: pointer;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    border-radius: 8px; /* 给整个项目也加个圆角 */
}

.album-item:hover {
    transform: translateY(-5px);
    box-shadow: 0 8px 15px rgba(0,0,0,0.1);
}

.album-cover {
    aspect-ratio: 1 / 1; /* 保持封面为正方形 */
    background-size: cover;
    background-position: center;
    border-radius: 8px;
    margin-bottom: 8px;
    background-color: #f0f2f5; /* 封面加载前的占位颜色 */
}

.album-info {
    text-align: center;
}

.album-name {
    font-weight: 500;
    margin: 0 0 4px 0;
    color: var(--text-primary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis; /* 防止长名字换行 */
}

.album-count {
    font-size: 12px;
    color: var(--text-secondary);
    margin: 0;
}

/* ▲▲▲ 新的 CSS 粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这些新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === 相册照片详情页 === */
#album-photos-screen {
    background-color: #f0f2f5;
}

#photos-grid-page {
    padding: 15px;
    display: grid;
    /* 每行显示3张照片，并保持间距 */
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
}

.photo-item {
    position: relative; /* 为了定位删除按钮 */
    aspect-ratio: 1 / 1; /* 保持照片为正方形 */
    border-radius: 6px;
    overflow: hidden; /* 防止图片溢出圆角 */
    background-color: #e9ecef; /* 图片加载前的占位符颜色 */
}

.photo-item .photo-thumb {
    width: 100%;
    height: 100%;
    object-fit: cover; /* 保证图片填满容器且不变形 */
    cursor: pointer;
}

/* 删除按钮的样式 */
.photo-item .photo-delete-btn {
    position: absolute;
    top: 5px;
    right: 5px;
    width: 22px;
    height: 22px;
    background-color: rgba(0, 0, 0, 0.6);
    color: white;
    border: none;
    border-radius: 50%;
    font-size: 16px;
    line-height: 22px;
    text-align: center;
    cursor: pointer;
    opacity: 0; /* 默认隐藏 */
    transition: opacity 0.2s ease;
}

/* 鼠标悬停在照片上时显示删除按钮 */
.photo-item:hover .photo-delete-btn {
    opacity: 1;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* === 图片查看器模态框样式 === */
#photo-viewer-modal {
    background-color: rgba(0, 0, 0, 0.85);
    z-index: 1002;
    -webkit-backdrop-filter: blur(5px);
    backdrop-filter: blur(5px);
}

.photo-viewer-content {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100%;
    height: 100%;
}

#photo-viewer-image {
    max-width: 90vw;  /* 图片最大宽度为视口的90% */
    max-height: 85vh; /* 图片最大高度为视口的85% */
    object-fit: contain;
    border-radius: 8px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
    /* 为图片的切换添加一点平滑的淡入淡出效果 */
    transition: opacity 0.2s ease-in-out;
}

/* 关闭按钮 */
#photo-viewer-close-btn {
    position: absolute;
    top: 20px;
    right: 20px;
    background: none;
    border: none;
    color: white;
    font-size: 40px;
    font-weight: 200;
    cursor: pointer;
    line-height: 1;
    text-shadow: 0 0 5px black;
}

/* 左右导航箭头 */
#photo-viewer-modal .nav-arrow {
    position: absolute; /* 现在我们用绝对定位来控制箭头 */
    top: 50%;
    transform: translateY(-50%);
    background: none;
    border: none;
    color: rgba(255, 255, 255, 0.7);
    font-size: 50px; /* 在手机屏幕上，可以稍微小一点 */
    font-weight: 100;
    cursor: pointer;
    padding: 10px; /* 调整内边距 */
    user-select: none;
    transition: color 0.2s;
    z-index: 1003; /* 确保箭头在最上层 */
}

#photo-viewer-prev-btn {
    left: 5px; /* 定位左箭头 */
}

#photo-viewer-next-btn {
    right: 5px; /* 定位右箭头 */
}

#photo-viewer-modal .nav-arrow:hover {
    color: white;
}

/* 当箭头被禁用时（比如第一张或最后一张） */
#photo-viewer-modal .nav-arrow:disabled {
    color: rgba(255, 255, 255, 0.2);
    cursor: default;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这些新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* ▼▼▼ 请用这块新CSS替换掉上一版的交互区CSS ▼▼▼ */

/* === 帖子内容区 - 相对定位容器 === */
/* === 帖子内容区 === */
.post-main-content {
    /* 它现在只是一个普通的内容容器，不再需要特殊样式了 */
}

/* === 帖子互动图标区 (新样式) === */
.post-feedback-icons {
    display: flex;
    justify-content: flex-end; /* 让图标靠右对齐 */
    align-items: center;
    gap: 12px;
    padding: 8px 0; /* 核心修改：给图标区域上下各8px的留白 */
}

.action-icon {
    cursor: pointer;
    color: var(--text-secondary); /* 默认灰色 */
    transition: all 0.2s ease-in-out;
}

.action-icon svg {
    width: 22px;
    height: 22px;
    fill: none;
    stroke: currentColor;
    stroke-width: 2;
    stroke-linecap: round;
    stroke-linejoin: round;
}

/* 图标激活(点赞/收藏后)的样式 */
.action-icon.active {
    color: #ff5252; /* 激活后变红色 */
    transform: scale(1.1); /* 轻微放大 */
}

.action-icon.active.favorite {
    color: #ffc107; /* 收藏用黄色 */
}

.action-icon.active svg {
    fill: currentColor; /* 激活后填充颜色 */
}

/* 点击时的动画效果 */
.animate-like {
    animation: like-bounce 0.4s ease-in-out;
}

@keyframes like-bounce {
    0%   { transform: scale(1); }
    25%  { transform: scale(0.8); }
    50%  { transform: scale(1.2); }
    75%  { transform: scale(1.05); }
    100% { transform: scale(1.1); }
}


/* === 帖子底部评论区样式 (现在是独立部分) === */
.post-footer {
    margin-top: 15px;
    padding-top: 10px;
    border-top: 1px solid #f0f0f0; /* 用一条浅色线分隔 */
    display: flex;
    align-items: center;
    gap: 8px; /* 调整整体间距 */
}

/* 评论区容器 */
.comment-section {
    flex-grow: 1; /* 占据大部分空间 */
    display: flex;
    align-items: center;
    gap: 8px;
}

.comment-section .comment-avatar {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    object-fit: cover;
    flex-shrink: 0;
}

.comment-section .comment-input {
    width: 100%;
    padding: 8px 12px;
    border: none;
    background-color: #f0f2f5;
    border-radius: 14px;
    font-size: 13px;
    outline: none;
}

/* 新增的发送按钮样式 */
.comment-send-btn {
    flex-shrink: 0; /* 防止被压缩 */
    padding: 8px 15px;
    border: none;
    background-color: var(--accent-color);
    color: white;
    border-radius: 14px;
    font-size: 13px;
    font-weight: 500;
    cursor: pointer;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === 未读消息小红点通用样式 === */
.unread-indicator {
    position: absolute;
    top: -8px;      
    right: -15px;    
    min-width: 18px;
    height: 18px;
    padding: 0 5px;
    background-color: #ff3b30;
    color: white;
    font-size: 11px;
    font-weight: bold;
    line-height: 18px;
    text-align: center;
    border-radius: 9px;
    box-shadow: 0 1px 2px rgba(0,0,0,0.2);
    display: none;
    z-index: 1;
}

/* 聊天界面返回按钮上的小红点 (只显示点，不显示数字) */
.back-btn-indicator {
    top: 0;
    right: -8px; /* 放到返回箭头右上角 */
    width: 10px;
    height: 10px;
    min-width: 10px;
    padding: 0;
    border-radius: 50%;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === 评论列表容器 === */
.post-comments-container {
    padding: 10px 0; /* 上下留白 */
    display: flex;
    flex-direction: column;
    gap: 8px; /* 评论之间的间距 */
    font-size: 13px; /* 统一评论区字体大小 */
}

/* 每一条评论 */
.comment-item {
    line-height: 1.5;
}

/* 评论者的名字，加粗并使用主题色 */
.comment-item .commenter-name {
    font-weight: 600;
    color: var(--accent-color);
    cursor: pointer;
    margin-right: 5px; /* 和评论内容之间留点空隙 */
}

/* 评论内容 */
.comment-item .comment-text {
    color: var(--text-primary);
    word-break: break-word;
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === 帖子点赞区域样式 === */
.post-likes-section {
    display: flex;
    align-items: center;
    gap: 6px; /* 图标和文字的间距 */
    padding: 8px 10px; /* 内边距 */
    font-size: 13px;
    color: var(--accent-color); /* 使用主题蓝色 */
    background-color: #f0f5fa; /* 给一个淡淡的背景色 */
    border-top: 1px solid #e9eef3;
    border-bottom: 1px solid #e9eef3;
    margin-top: 5px; /* 和上方的图标保持一点距离 */
}

.post-likes-section .like-icon {
    width: 16px;
    height: 16px;
    fill: currentColor; /* 让SVG图标继承父元素的颜色 */
    flex-shrink: 0; /* 防止图标被压缩 */
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === @提及 弹出菜单样式 === */
.at-mention-popup {
    position: absolute; /* 相对于父元素定位 */
    bottom: 100%; /* 显示在输入框的上方 */
    left: 40px; /* 和输入框左侧对齐 (考虑了头像宽度) */
    width: calc(100% - 40px); /* 宽度和输入框差不多 */
    max-height: 120px;
    overflow-y: auto;
    background-color: var(--secondary-bg);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    box-shadow: 0 -4px 12px rgba(0,0,0,0.1);
    z-index: 10;
    display: none; /* 默认隐藏 */
}

.at-mention-item {
    padding: 8px 12px;
    font-size: 14px;
    cursor: pointer;
    color: var(--text-primary);
    border-bottom: 1px solid #f0f0f0;
}

.at-mention-item:last-child {
    border-bottom: none;
}

.at-mention-item:hover {
    background-color: #f5f5f5;
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* ▼▼▼ 请用下面这段【新样式】替换掉你现有的 #favorites-list 样式 ▼▼▼ */

/* 让收藏视图成为一个flex容器, 从上到下排列 */
#favorites-view {
    display: flex;
    flex-direction: column;
}

/* 确保收藏页的header高度固定，不被压缩 */
#favorites-view > .header {
    flex-shrink: 0;
}

/* === 收藏列表样式 (修正后) === */
#favorites-list {
    flex-grow: 1; 
    overflow-y: auto; 
    overflow-x: hidden; /* <-- 新增这行，禁止水平滚动 */
    padding: 15px; 
    display: flex;
    flex-direction: column;
    gap: 15px; 
}

/* ▲▲▲ 替换结束 ▲▲▲ */

.favorite-item-card {
    background-color: var(--secondary-bg);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.06);
    position: relative; /* 为了定位删除按钮 */
}

/* 卡片头部，包含头像、名字和来源 */
.fav-card-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 12px;
}

.fav-card-header .avatar {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    object-fit: cover;
}

.fav-card-header .info {
    flex-grow: 1;
}

.fav-card-header .name {
    font-weight: 600;
    font-size: 15px;
}

.fav-card-header .source {
    font-size: 12px;
    color: var(--text-secondary);
}

/* 卡片内容 */
.fav-card-content {
    font-size: 14px;
    line-height: 1.6;
    color: #333;
    white-space: pre-wrap;
    word-break: break-word;
}

.fav-card-content .chat-image {
    margin-top: 8px; /* 图片和文字的间距 */
}

/* 删除按钮 */
.fav-delete-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    width: 28px;
    height: 28px;
    background: #f0f2f5;
    border: none;
    border-radius: 50%;
    cursor: pointer;
    font-size: 18px;
    color: var(--text-secondary);
    line-height: 28px;
    text-align: center;
}

.fav-delete-btn:hover {
    background-color: #e9ecef;
    color: #ff3b30;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === 搜索栏样式 === */
.search-bar-container {
    padding: 10px 15px;
    background-color: #f9f9f9; /* 和列表背景色保持一致 */
    position: relative; /* 为了定位清除按钮 */
    flex-shrink: 0;
}

#favorites-search-input {
    width: 100%;
    padding: 10px 30px 10px 15px; /* 右侧留出清除按钮的位置 */
    font-size: 14px;
    border: 1px solid var(--border-color);
    border-radius: 18px; /* 圆角矩形，更现代化 */
    background-color: var(--secondary-bg);
    box-sizing: border-box;
    outline: none;
}
#favorites-search-input:focus {
    border-color: var(--accent-color);
}

.search-clear-btn {
    position: absolute;
    right: 25px;
    top: 50%;
    transform: translateY(-50%);
    background: #ccc;
    color: white;
    border: none;
    border-radius: 50%;
    width: 20px;
    height: 20px;
    line-height: 20px;
    text-align: center;
    font-size: 16px;
    cursor: pointer;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* === 聊天界面多选操作栏优化 === */
#chat-interface-screen .header .selection-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
}

#chat-interface-screen .selection-controls .action-btn {
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    padding: 5px;
}

/* === 收藏页面多选模式样式 === */
#favorites-view.selection-mode .favorite-item-card {
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

/* 选择框的样式 */
.favorite-item-card::before {
    content: '';
    position: absolute;
    left: -25px; /* 把它放在卡片左边外面 */
    top: 50%;
    transform: translateY(-50%);
    width: 20px;
    height: 20px;
    border: 2px solid #ccc;
    border-radius: 50%;
    background-color: white;
    transition: all 0.2s ease;
    opacity: 0; /* 默认隐藏 */
}

/* 进入选择模式时，卡片向右移动，露出选择框 */
#favorites-view.selection-mode .favorite-item-card {
    transform: translateX(35px);
}
#favorites-view.selection-mode .favorite-item-card::before {
    opacity: 1;
}

/* 选中后的样式 */
#favorites-view.selection-mode .favorite-item-card.selected::before {
    background-color: var(--accent-color);
    border-color: var(--accent-color);
    content: '✔';
    color: white;
    font-size: 14px;
    text-align: center;
    line-height: 20px;
}

/* 底部操作栏 (终极修正版) */
#favorites-action-bar {
    position: absolute; /* ★ 改为 absolute，相对于 #phone-screen 定位 */
    bottom: 0;
    left: 0;
    right: 0;           /* ★ 新增 right: 0，和 left: 0 一起撑满宽度 */
    width: auto;        /* ★ 改为 auto，让 left/right 决定宽度 */
    padding: 10px 15px;
    padding-bottom: calc(10px + env(safe-area-inset-bottom)); /* 适配iPhone底部安全区 */
    background-color: rgba(247, 247, 247, 0.9);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-top: 1px solid var(--border-color);
    box-sizing: border-box;
    z-index: 5;
    display: none;
    /* max-width 已经不需要了，因为父元素已经限制了宽度 */
}

#favorites-action-bar .action-bar-btn {
    width: 100%;
    padding: 12px;
    border-radius: 8px;
    border: none;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    background-color: #ff3b30;
    color: white;
}

/* === 【修正】聊天界面头部控件切换逻辑 === */

/* 默认状态：隐藏多选控件 */
#chat-interface-screen .header .selection-controls {
    display: none;
}

/* 默认状态：显示默认控件，并让它撑满整个头部 */
#chat-interface-screen .header .default-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
}

/* 当进入多选模式时：隐藏默认控件 */
#chat-interface-screen.selection-mode .header .default-controls {
    display: none;
}

/* 当进入多选模式时：显示多选控件，并让它撑满整个头部 */
#chat-interface-screen.selection-mode .header .selection-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
}

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === 修正：放大所有主要的“+”号按钮 === */
#add-chat-btn,
#add-world-book-btn,
#create-album-btn-page {
    font-size: 28px;   /* 显著增大字体大小，使其视觉上与旁边的图标匹配 */
    font-weight: 300;  /* 使用更细的字重，让加号看起来更清爽，不显粗笨 */
    position: relative;/* 允许进行位置微调 */
    top: -1px;         /* 字体放大后，通常需要稍微向上移动一点，使其视觉上更居中 */
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这些新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* 预览区容器样式 */
#settings-preview-area {
    width: 100%;
    height: 180px; /* 给一个固定的高度 */
    background-color: #f0f2f5;
    border-radius: 8px;
    padding: 15px;
    box-sizing: border-box;
    overflow: hidden; /* 防止内容溢出 */
    display: flex;
    flex-direction: column;
    gap: 10px; /* 预览气泡之间的间距 */
    border: 1px solid var(--border-color);
    position: relative; /* 为了定位背景 */
}

/* 预览区的背景，可以和真实聊天界面同步 */
#settings-preview-area::before {
    content: '';
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background-size: cover;
    background-position: center;
    z-index: 1;
    opacity: 0.8;
}

/* 让预览气泡在背景之上 */
#settings-preview-area .message-wrapper {
    position: relative;
    z-index: 2;
}

/* 预览区内使用的头像要小一点 */
#settings-preview-area .message-bubble .avatar {
    width: 30px;
    height: 30px;
}

#settings-preview-area .message-bubble .timestamp {
    display: none; /* 预览区不需要显示时间戳 */
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */
.existing-group-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px;
    background-color: #f9f9f9;
    border-radius: 8px;
    border: 1px solid var(--border-color);
}

.existing-group-item .group-name {
    font-weight: 500;
}

.existing-group-item .delete-group-btn {
    color: #ff3b30;
    font-size: 20px;
    cursor: pointer;
    padding: 5px;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */
.chat-group-container {
    border-bottom: 1px solid var(--border-color);
}
.chat-group-container:first-child {
    border-top: 1px solid var(--border-color);
}

.chat-group-header {
    display: flex;
    align-items: center;
    padding: 12px 15px;
    cursor: pointer;
    background-color: var(--secondary-bg); /* <-- 修改这里，使用变量 */
}


.chat-group-header .arrow {
    font-size: 14px;
    margin-right: 8px;
    transition: transform 0.2s ease;
}

.chat-group-header.collapsed .arrow {
    transform: rotate(-90deg);
}

.chat-group-header .group-name {
    font-weight: 600;
    font-size: 15px;
}

.chat-group-content {
    max-height: 1000px; /* 一个足够大的值 */
    overflow: hidden;
    transition: max-height 0.3s ease-in-out;
}

.chat-group-content.collapsed {
    max-height: 0;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */

/* 格式助手按钮的容器 */
.format-helpers {
    display: flex;
    gap: 10px;
    margin-bottom: 15px; /* 与下方的文本框拉开距离 */
    flex-wrap: wrap; /* 如果按钮太多可以换行 */
}

/* 单个格式助手按钮的样式 */
.format-btn {
    background-color: #e9ecef;
    color: var(--text-primary);
    border: none;
    padding: 6px 12px;
    border-radius: 16px; /* 胶囊形状，更友好 */
    font-size: 13px;
    font-weight: 500;
    cursor: pointer;
    transition: background-color 0.2s;
}

.format-btn:hover {
    background-color: #dcdfe3;
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */

/* “…”按钮的样式 */
.post-actions-btn {
    margin-left: auto; /* 关键：让它自动靠到最右边 */
    padding: 5px 10px;
    font-size: 20px;
    font-weight: bold;
    color: var(--text-secondary);
    cursor: pointer;
    border-radius: 50%;
    line-height: 1;
}
.post-actions-btn:hover {
    background-color: #f0f0f0;
}

/* 动态编辑模态框的样式 (它将复用现有的操作菜单样式) */
#post-actions-modal .custom-modal-footer button {
    width: 100%;
    border: none;
    border-bottom: 1px solid #dbdbdb;
    padding: 14px;
    font-size: 18px;
}
#post-actions-modal .custom-modal-footer button:last-child {
    border-bottom: none;
}
#post-actions-modal #cancel-post-action-btn {
    margin-top: 8px;
    border-radius: 8px;
    background-color: #f0f0f0;
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* 统一重置转账卡片内所有文字的特效和颜色 */
#chat-messages .transfer-card .transfer-title,
#chat-messages .transfer-card .transfer-amount,
#chat-messages .transfer-card .transfer-note {
    text-shadow: none !important; /* 强制移除任何发光或阴影效果 */
    color: white !important;      /* 强制锁定文字颜色为白色 */
}

/* 分别锁定各自的字体大小和字重，防止被篡改 */
#chat-messages .transfer-card .transfer-title {
    font-size: 16px !important;
    font-weight: 600 !important;
}

#chat-messages .transfer-card .transfer-amount {
    font-size: 28px !important;
    font-weight: bold !important;
}

#chat-messages .transfer-card .transfer-note {
    font-size: 13px !important;
    opacity: 0.9 !important;
}

/* ▼▼▼ 这是新增的样式，用于修正所有头部标题的居中问题 ▼▼▼ */
/* ▼▼▼ 这是新增的样式，用于修正所有头部标题的居中问题 ▼▼▼ */
.header > span:nth-child(2) {
    position: absolute;
    left: 50%;
    transform: translateX(calc(-50% - 2px)); /* 在-50%的基础上，再向左推2像素 */
    
    /* (可选但推荐) 防止长标题与两边按钮重叠 */
    max-width: 60%;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
/* ▲▲▲ 粘贴结束 ▲▲▲ */


/* ▼▼▼ 【全新】可视化消息编辑器样式 ▼▼▼ */
#message-editor-container {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.message-editor-block {
    background-color: #f9f9f9;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 12px;
}

.message-editor-block textarea {
    width: 100%;
    min-height: 60px;
    resize: vertical;
    border: 1px solid #ccc;
    border-radius: 6px;
    padding: 8px;
    font-size: 14px;
    box-sizing: border-box;
}

.message-editor-block .format-helpers {
    margin-top: 8px;
    margin-bottom: 0; /* 覆盖默认的 margin-bottom */
}

.message-editor-block .delete-block-btn {
    float: right;
    margin-top: -5px;
    background: none;
    border: none;
    color: #ff3b30;
    font-size: 20px;
    cursor: pointer;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】联系人选择器样式 ▼▼▼ */
.contact-picker-item {
    display: flex;
    align-items: center;
    padding: 10px 15px;
    cursor: pointer;
    border-bottom: 1px solid var(--border-color);
}
.contact-picker-item .checkbox {
    width: 20px;
    height: 20px;
    border: 2px solid #ccc;
    border-radius: 50%;
    margin-right: 15px;
    transition: all 0.2s ease;
}
.contact-picker-item.selected .checkbox {
    background-color: var(--accent-color);
    border-color: var(--accent-color);
    content: '✔';
    color: white;
    font-size: 14px;
    text-align: center;
    line-height: 20px;
}
.contact-picker-item .avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    margin-right: 12px;
}
.contact-picker-item .name {
    font-weight: 500;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】群成员管理界面样式 ▼▼▼ */
#member-management-list {
    padding: 0; /* 移除默认padding，让列表项撑满 */
}

.member-management-item {
    display: flex;
    align-items: center;
    padding: 12px 15px;
    border-bottom: 1px solid var(--border-color);
}

.member-management-item .avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    margin-right: 12px;
}

.member-management-item .name {
    flex-grow: 1;
    font-weight: 500;
}

.member-management-item .remove-member-btn {
    background-color: #ff3b30;
    color: white;
    border: none;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    font-size: 20px;
    line-height: 28px;
    text-align: center;
    cursor: pointer;
    flex-shrink: 0;
}

#member-management-actions {
    flex-shrink: 0;
    padding: 15px;
    border-top: 1px solid var(--border-color);
    background-color: #f7f7f7;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

#member-management-actions button {
    width: 100%;
    padding: 15px;
    background-color: var(--accent-color);
    color: white;
    border: none;
    border-radius: 8px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
}
#member-management-actions #create-new-member-btn {
    background-color: #4cd964; /* 新建用绿色，以示区分 */
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】外卖代付卡片样式 ▼▼▼ */
.message-bubble.is-waimai-request .content {
    padding: 0;
    background: transparent;
    box-shadow: none;
    border: none;
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
}

.waimai-card {
    width: 240px;
    border-radius: 12px;
    overflow: hidden;
    background-color: #fff;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
}

.waimai-header {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 10px 12px;
    border-bottom: 1px solid #f0f0f0;
}

.waimai-header .icon {
    width: 20px;
    height: 20px;
}

.waimai-header .title-group {
    display: flex;
    align-items: baseline;
    font-size: 14px;
    color: #8a8a8a;
}
.waimai-header .title-group .brand {
    font-weight: 600;
    color: #555;
    margin-right: 5px;
}
.waimai-header .title-group .separator {
    margin: 0 5px;
}

.waimai-catchphrase {
    font-size: 13px;
    color: #1f1f1f;
    padding: 12px;
}

.waimai-main {
    background-color: #FFD66B; /* 橙黄色背景 */
    padding: 12px;
    text-align: center;
}

.waimai-main .request-title {
    font-size: 12px;
    color: #856404;
    margin-bottom: 8px;
}

.waimai-main .payment-box {
    background-color: #fff;
    border-radius: 8px;
    padding: 15px 10px;
}

.waimai-main .payment-label {
    font-size: 13px;
    color: #8a8a8a;
}

.waimai-main .amount {
    font-size: 32px;
    font-weight: 700;
    color: #1f1f1f;
    margin: 4px 0 12px 0;
}

.waimai-main .countdown-label {
    font-size: 13px;
    color: #8a8a8a;
}
.waimai-main .countdown-timer {
    display: inline-flex;
    align-items: center;
    gap: 2px;
    margin-left: 5px;
}
.waimai-main .countdown-timer span {
    background-color: #333;
    color: white;
    padding: 2px 4px;
    border-radius: 2px;
    font-weight: bold;
    font-size: 12px;
}

.waimai-details-btn {
    width: 100%;
    padding: 10px 0;
    margin-top: 15px;
    border: none;
    border-radius: 6px;
    background-color: #FFC33A;
    color: #49380a;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】外卖响应状态样式 ▼▼▼ */

/* === 同意支付后的样式 === */
.message-bubble.status-paid .waimai-card {
    border: 2px solid #28a745; /* 绿色边框 */
}
.message-bubble.status-paid .waimai-main .request-title::before {
    content: '✅  ';
}
.message-bubble.status-paid .waimai-main .request-title {
    color: #155724;
    font-weight: 600;
    /* 重写 request-title 的内容 */
    content: "我已为您买单，请尽情享用吧～" !important;
    display: block;
    margin-bottom: 15px;
}

.message-bubble.status-paid .payment-box {
    display: none; /* 隐藏支付详情 */
}
.message-bubble.status-paid .waimai-details-btn {
    background-color: #28a745;
    color: white;
}

/* === 拒绝支付后的样式 === */
.message-bubble.status-rejected .waimai-card {
    border: 2px solid #dc3545; /* 红色边框 */
    opacity: 0.8;
}
.message-bubble.status-rejected .waimai-main {
    background-color: #e9ecef;
}
.message-bubble.status-rejected .waimai-main .request-title::before {
    content: '❌ ';
}
.message-bubble.status-rejected .waimai-main .request-title {
    color: #721c24;
    font-weight: 600;
    /* 重写 request-title 的内容 */
    content: "我拒绝了您的代付请求" !important;
    display: block;
    margin-bottom: 15px;
}
.message-bubble.status-rejected .payment-box {
    display: none; /* 隐藏支付详情 */
}
 .message-bubble.status-rejected .waimai-details-btn {
    background-color: #6c757d;
    color: white;
}

/* 强制重写 request-title 内容的技巧 */
.message-bubble[class*="status-"] .request-title {
    font-size: 0; /* 隐藏原始文本 */
}
.message-bubble[class*="status-"] .request-title::after {
    font-size: 14px; /* 让伪元素显示新文本 */
}
.message-bubble.status-paid .request-title::after {
    content: "我已为您买单，请尽情享用吧～";
}
.message-bubble.status-rejected .request-title::after {
    content: "我拒绝了您的代付请求";
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】外卖请求的用户操作按钮样式 ▼▼▼ */
.waimai-user-actions {
    display: flex;
    gap: 10px;
    padding: 0 12px 12px 12px; /* 在卡片底部留出空间 */
    background-color: #fff;
}

.waimai-user-actions button {
    flex: 1;
    padding: 10px;
    border-radius: 8px;
    border: 1.5px solid;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
}

.waimai-pay-btn {
    background-color: #28a745;
    border-color: #1f7a33;
    color: white;
}
.waimai-pay-btn:hover {
    background-color: #218838;
}

.waimai-decline-btn {
    background-color: #f8f9fa;
    border-color: #ced4da;
    color: #495057;
}
.waimai-decline-btn:hover {
    background-color: #e2e6ea;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* 确保这些页面的内容区能正确滚动，同时背景透明以显示父级颜色 */
#api-settings-screen .form-container,
#font-settings-screen .form-container,
#wallpaper-screen .form-container {
    padding-top: 100px;
    margin-top: -80px;
    /* 不再需要背景色，让父元素决定 */
}
#font-settings-screen,
#wallpaper-screen {
    /* 将背景色设置为变量，这样夜间模式才能覆盖它 */
    background-color: var(--secondary-bg);
}
/* 壁纸设置页面的预览区比较特殊，需要额外调整 */
#wallpaper-screen .form-container {
    align-items: center; /* 保持内容居中 */
}

/* ▼▼▼ 【全新】来电请求与视频通话界面样式 ▼▼▼ */

/* --- 来电请求模态框 --- */
#incoming-call-modal .incoming-call-content {
    background-color: rgba(40, 40, 40, 0.85);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border-radius: 20px;
    width: 280px;
    padding: 30px 20px;
    text-align: center;
    color: white;
    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
}

.caller-avatar {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    object-fit: cover;
    margin-bottom: 12px;
    border: 3px solid rgba(255,255,255,0.5);
}

.caller-name {
    font-size: 20px;
    font-weight: 600;
    margin-bottom: 5px;
}

.caller-text {
    font-size: 14px;
    color: #ccc;
    margin-bottom: 30px;
}

.incoming-call-actions {
    display: flex;
    justify-content: space-around;
    align-items: center;
}

.action-button-wrapper {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    font-size: 13px;
    color: #e0e0e0;
}

.call-action-btn {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    background-size: 50%;
    background-repeat: no-repeat;
    background-position: center;
    transition: transform 0.2s, box-shadow 0.2s;
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
}
.call-action-btn:active {
    transform: scale(0.9);
}

.call-action-btn.decline {
    background-color: #ff3b30;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13.5 16.5L3 6m18 6l-5.6-5.6a1.2 1.2 0 0 0-1.7 0L3 18.2a1.2 1.2 0 0 0-.3 1.2l1.2 3.6a1.2 1.2 0 0 0 1.2.9h15.6a1.2 1.2 0 0 0 1.2-1.2V7.7a1.2 1.2 0 0 0-.3-1.1z"/></svg>');
}

.call-action-btn.accept {
    background-color: #4cd964;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/></svg>');
    animation: pulse 1.5s infinite;
}

@keyframes pulse {
    0% { box-shadow: 0 0 0 0 rgba(76, 217, 100, 0.7); }
    70% { box-shadow: 0 0 0 15px rgba(76, 217, 100, 0); }
    100% { box-shadow: 0 0 0 0 rgba(76, 217, 100, 0); }
}

/* ▼▼▼ 请用这一整块【最终结构重写版】的代码，替换所有旧的 video-call 相关CSS ▼▼▼ */

/* 1. 通话屏幕总容器 (保持不变) */
#video-call-screen {
    background-color: #1c1c1e;
    color: white;
    display: flex; /* ★ 核心：它依然是flex容器 */
    flex-direction: column;
    overflow: hidden;
}

/* 2. 顶部栏和底部控制栏 (保持不变) */
.video-call-top-bar, .video-call-controls {
    position: absolute;
    left: 0;
    width: 100%;
    z-index: 10;
    box-sizing: border-box;
    pointer-events: none; /* 让它们不影响下方内容的点击 */
}
.video-call-top-bar {
    top: 0;
    padding: 15px 20px 30px; /* 增加底部padding */
    padding-top: 50px;
    background: linear-gradient(to bottom, rgba(0,0,0,0.5), transparent);
    text-align: center;
}
.video-call-controls {
    bottom: 0;
    display: flex;
    justify-content: space-around;
    align-items: center;
    padding: 20px;
    padding-bottom: 40px;
    background: linear-gradient(to top, rgba(0,0,0,0.5), transparent);
    pointer-events: all; /* 控制按钮需要能点击 */
}
#call-timer {
    font-size: 16px;
    font-weight: 500;
    letter-spacing: 1px;
}

/* 3. 【核心重构】默认文字通话的总容器 */
#text-call-interface {
    display: flex;
    flex-direction: column;
    width: 100%;
    height: 100%;
    overflow: hidden;
}

/* 4. 【核心重构】头像区域 */
.video-call-avatar-area {
    flex-shrink: 0; /* ★ 核心：高度雷打不动，绝不压缩 */
    display: flex;
    justify-content: center;
    align-items: center;
    padding-top: 100px; /* ★ 核心：与顶部状态栏拉开距离 */
    padding-bottom: 20px; /* ★ 核心：与下方气泡区拉开距离 */
}

/* 5. 【核心重构】气泡区域 */
#video-call-main {
    flex-grow: 1; /* ★ 核心：占据所有剩余的垂直空间 */
    min-height: 0; /* ★ 核心：一个防止flex溢出的重要保险丝 */
    margin: 0 15px 130px 15px; /* ★ 核心：定义四周边界，底部留足空间给按钮 */
    overflow-y: auto;
    padding: 15px;
    background-color: rgba(255, 255, 255, 0.08); /* 稍微调亮一点背景 */
    border-radius: 20px;
    display: flex;
    flex-direction: column;
    gap: 15px;
}

/* 6. 头像网格和头像本身样式 (微调) */
#participant-avatars-grid {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 20px;
}
.participant-avatar-wrapper {
    text-align: center;
}
.participant-avatar {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    object-fit: cover;
    border: 3px solid rgba(255, 255, 255, 0.2);
    transition: all 0.3s ease;
}
.participant-name {
    margin-top: 8px;
    font-size: 13px;
    color: #ccc;
}
.participant-avatar.speaking {
    border-color: #4cd964;
    box-shadow: 0 0 20px rgba(76, 217, 100, 0.6);
    transform: scale(1.05);
}

/* 7. 控制按钮样式 (保持不变) */
.control-btn {
    width: 70px; height: 70px; border-radius: 50%; border: none; cursor: pointer;
    background-repeat: no-repeat; background-position: center;
    transition: transform 0.2s, background-color 0.2s;
    pointer-events: all;
}
.control-btn:active { transform: scale(0.9); }
.control-btn.speak-btn { background-color: rgba(255,255,255,0.2); background-size: 55%; background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>'); }
.control-btn.hangup-btn { background-color: #ff3b30; background-size: 50%; background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13.5 16.5L3 6m18 6l-5.6-5.6a1.2 1.2 0 0 0-1.7 0L3 18.2a1.2 1.2 0 0 0-.3 1.2l1.2 3.6a1.2 1.2 0 0 0 1.2.9h15.6a1.2 1.2 0 0 0 1.2-1.2V7.7a1.2 1.2 0 0 0-.3-1.1z"/></svg>'); }
.control-btn.join-btn { background-color: #007bff; background-size: 50%; background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="20" y1="8" x2="20" y2="14"></line><line x1="17" y1="11" x2="23" y2="11"></line></svg>'); }

/* ▲▲▲ 新CSS替换结束 ▲▲▲ */

/* ▼▼▼ 【全新】视频通话对话气泡样式 ▼▼▼ */
.call-message-bubble {
    padding: 10px 15px;
    border-radius: 12px;
    max-width: 85%;
    line-height: 1.6;
    word-break: break-word;
    white-space: pre-wrap;
}

.call-message-bubble.ai-speech {
    background-color: rgba(255, 255, 255, 0.15);
    align-self: flex-start; /* AI发言靠左 */
}

.call-message-bubble.user-speech {
    background-color: #4cd964; /* 用户发言用绿色，类似微信 */
    align-self: flex-end;   /* 用户发言靠右 */
    text-align: left; /* 确保用户气泡内的文字是左对齐的 */
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */

/* ▼▼▼ 【全新添加】正在呼叫界面样式 ▼▼▼ */
#outgoing-call-screen {
    background-color: #1c1c1e;
    color: white;
    justify-content: center; /* 垂直居中 */
    align-items: center;   /* 水平居中 */
}

.outgoing-call-content {
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
}

.outgoing-call-actions {
    margin-top: 50px; /* 和上方文字拉开距离 */
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    font-size: 13px;
    color: #e0e0e0;
}
/* ▲▲▲ 添加结束 ▲▲▲ */

/* 1. 动态帖子的外层容器，我们需要它来定位和裁剪 */
.qzone-post-container {
    position: relative; /* 让内部的删除按钮可以相对于它定位 */
    overflow: hidden;   /* 隐藏掉超出部分的删除按钮 */
    border-radius: 12px;/* 和内部卡片保持一致的圆角 */
}

/* 2. 可滑动的内容卡片，增加一个平滑的过渡效果 */
.qzone-post-item {
    transition: transform 0.3s ease;
    background-color: var(--secondary-bg); /* 确保它有背景色，能盖住下面的删除按钮 */
    position: relative; /* 确保它在最上层 */
    z-index: 2;
}

/* 3. 【核心】这就是那个“删除”按钮的样式！*/
.qzone-post-delete-action {
    position: absolute; /* 绝对定位，脱离文档流 */
    top: 0;
    right: 0;
    bottom: 0;
    width: 90px; /* 删除按钮的宽度 */
    background-color: #ff3b30; /* 您想要的红色背景 */
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 500;
    cursor: pointer;
    z-index: 1; /* 确保它在卡片下面 */
}

/* 4. 当卡片左滑时，把它向左移动，露出删除按钮 */
.qzone-post-item.swiped {
    transform: translateX(-90px); /* 移动的距离和删除按钮的宽度一致 */
}

/* ▲▲▲ 粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这【一整块】全新的“拍一拍”样式，粘贴到 <style> 的末尾 ▼▼▼ */

/* 1. “拍一拍”的屏幕震动动画 */
@keyframes pat-shake {
    0%, 100% { transform: translateX(0); }
    10%, 30%, 50%, 70%, 90% { transform: translateX(-3px); }
    20%, 40%, 60%, 80% { transform: translateX(3px); }
}

.pat-animation {
    animation: pat-shake 0.4s ease-in-out;
}

/* 2. “拍一拍”系统提示消息的样式 */
.system-message {
    align-self: center; /* 居中显示 */
    padding: 4px 12px;
    margin: 5px 0;
    background-color: rgba(0, 0, 0, 0.1);
    color: var(--text-secondary);
    font-size: 12px;
    border-radius: 10px;
    text-align: center;
    max-width: 80%;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* 让“拍一拍”类型的 wrapper 居中 */
.message-wrapper.system-pat {
    justify-content: center;
    align-self: center;
    margin: 5px 0;
    max-width: 80%;
}
/* “拍一-拍”消息气泡的样式 */
.message-bubble.system-bubble {
    background-color: rgba(0, 0, 0, 0.1);
    color: var(--text-secondary);
    font-size: 12px;
    padding: 4px 12px;
    border-radius: 10px;
}

/* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */

/* === 修正：让顶部操作栏可以横向滚动 === */
#chat-input-actions-top {
    display: flex;
    gap: 8px;
    padding: 0 5px;

    /* --- 核心代码开始 --- */
    overflow-x: auto;      
    flex-wrap: nowrap;     
    -webkit-overflow-scrolling: touch; 

    scrollbar-width: none; 
    -ms-overflow-style: none;  
}

#chat-input-actions-top::-webkit-scrollbar {
    display: none; 
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* === 【全新】聊天界面头部状态栏样式 === */

/* === 【全新】聊天界面头部状态栏样式 === */

/* ▼▼▼ 用这块【居中修复版】的代码，替换旧的 #chat-header-title-wrapper 样式 ▼▼▼ */
#chat-header-title-wrapper {
    /* --- 核心修改：让标题区域绝对居中 --- */
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    /* ------------------------------------ */
    
    /* 保持其内部元素（标题和状态）的布局不变 */
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px; 
    
    /* (可选但推荐) 防止长标题与两边按钮重叠 */
    max-width: 60%;
    
    /* 注意：我们不再需要 flex-grow: 1; 了，因为绝对定位已经使其脱离了flex布局流 */
}
/* ▲▲▲ 替换结束 ▲▲▲ */

/* ▲▲▲ 替换结束 ▲▲▲ */

/* ▼▼▼ 请用这块代码替换你旧的 #chat-header-main-line 样式 ▼▼▼ */
#chat-header-main-line {
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative; /* 让公告按钮可以相对于它定位 */
}
/* ▲▲▲ 替换结束 ▲▲▲ */



/* ▼▼▼ 请用这块【终极修复版】代码，替换掉你旧的 #chat-header-title 样式 ▼▼▼ */
#chat-header-title {
    font-size: 16px;
    font-weight: 600;
    
    /* (这两行是上次修复定位问题的，必须保留！) */
    position: static !important;
    transform: none !important;

    /* ★★★ 核心修复：我们已经把导致省略号的四行代码全部删掉了！ ★★★ */
}
/* ▲▲▲ 替换结束 ▲▲▲ */




/* 3. 状态栏容器 */
#chat-header-status {
    display: flex;
    align-items: center;
    gap: 5px;
    font-size: 11px;
    color: var(--text-secondary);
    transition: all 0.3s ease;
}

/* 4. 状态小圆点 */
.status-dot {
    width: 7px;
    height: 7px;
    border-radius: 50%;
    background-color: #4cd964; /* 默认绿色，代表在线 */
    transition: background-color 0.3s ease;
}

/* 当AI状态为“忙碌”或“离开”时，让圆点变灰色 */
#chat-header-status.busy .status-dot {
    background-color: #cccccc;
}

/* 5. 状态文本 */
.status-text {
    font-weight: 500;
}

/* === 【全新美化版】回忆卡片样式 === */

/* 1. 卡片总容器：这里负责定义整体的背景色和边框 */
.memory-card {
    background-color: #fffaf0; /* 统一的、温暖的米黄色背景 */
    border-radius: 12px;
    padding: 15px; /* 在卡片四周留出内边距 */
    box-shadow: 0 2px 6px rgba(0,0,0,0.07);
    border-left: 5px solid #ffb74d; 
    display: flex; /* 让它成为flex容器，方便内部元素排列 */
    flex-direction: column; /* 让头部和内容垂直堆叠 */
    gap: 8px; /* 在头部和内容之间创造一个自然的间距 */
}

/* 2. 头部容器：现在只负责布局和分割线 */
.memory-card .header {
    border-bottom: 1px solid rgba(217, 129, 0, 0.15); /* 分割线颜色可以稍微加深一点 */
    padding-bottom: 8px; 
}

/* 3. 日期样式 (保持不变) */
.memory-card .header .date {
    font-size: 11px;
    color: #a1887f;
    margin-bottom: 4px; 
}

/* 4. 作者样式 (保持不变) */
.memory-card .header .author {
    font-weight: 600;
    color: #d98100;
    font-size: 15px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* 5. 内容区样式 (保持不变) */
.memory-card .content {
    font-size: 14px;
    line-height: 1.7;
    color: #5d4037;
    white-space: pre-wrap;
}

/* === 【全新】约定/倒计时卡片样式 === */
.countdown-card {
    background: linear-gradient(135deg, #667eea, #764ba2);
    color: white;
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 4px 15px rgba(118, 75, 162, 0.4);
    text-align: center;
    position: relative;
    overflow: hidden;
    flex-shrink: 0;
}
.countdown-card::before {
    content: '✨';
    position: absolute;
    top: -10px;
    left: -10px;
    font-size: 50px;
    opacity: 0.1;
    transform: rotate(-15deg);
}
.countdown-card .title {
    font-size: 18px;
    font-weight: 600;
    margin-bottom: 15px;
}
.countdown-card .timer {
    font-size: 28px;
    font-weight: 300;
    letter-spacing: 2px;
    margin-bottom: 15px;
}
.countdown-card .target-date {
    font-size: 12px;
    opacity: 0.8;
    border-top: 1px solid rgba(255,255,255,0.2);
    padding-top: 10px;
}

/* === 【全新】聊天锁定遮罩层样式 === */
#chat-lock-overlay {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    background-color: rgba(247, 247, 247, 0.9);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    z-index: 150; /* 比输入框高，比贴纸面板低 */
    display: none; /* 默认隐藏 */
    align-items: center;
    justify-content: center;
    padding: 20px;
    box-sizing: border-box;
    border-top: 1px solid var(--border-color);
    text-align: center;
}
#chat-lock-content {
    display: flex;
    flex-direction: column;
    gap: 15px;
}
#chat-lock-content .lock-text {
    color: var(--text-secondary);
    font-size: 14px;
}
#chat-lock-content .lock-action-btn {
    padding: 10px 20px;
    border-radius: 20px;
    border: 1px solid var(--accent-color);
    background-color: var(--accent-color);
    color: white;
    cursor: pointer;
}
#chat-lock-content .lock-action-btn.secondary {
    background-color: transparent;
    color: var(--accent-color);
}

/* ▼▼▼ 【全新】红包卡片样式 ▼▼▼ */
.message-bubble.is-red-packet .content {
    padding: 0;
    background: transparent;
    box-shadow: none;
    border: none;
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
}

.red-packet-card {
    width: 220px;
    border-radius: 8px;
    background: linear-gradient(160deg, #F96259, #E44D44);
    color: #ffd700; /* 金色文字 */
    padding: 12px;
    cursor: pointer;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    position: relative;
    overflow: hidden;
}

.red-packet-card.opened {
    background: linear-gradient(160deg, #d3c4a0, #c4b693);
    cursor: default;
}

.red-packet-card::before {
    content: '🧧';
    position: absolute;
    top: -5px;
    left: -5px;
    font-size: 30px;
    opacity: 0.2;
    transform: rotate(-10deg);
}

.rp-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
}

.rp-icon {
    width: 20px;
    height: 20px;
}

.rp-greeting {
    font-size: 15px;
    font-weight: 500;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.rp-type {
    font-size: 11px;
    color: white;
    opacity: 0.8;
    border-top: 1px solid rgba(255, 255, 255, 0.2);
    padding-top: 8px;
    margin-top: 8px;
}

.rp-claimed-info {
    font-size: 13px;
    color: white;
    margin-top: 10px;
    padding-top: 10px;
    border-top: 1px solid rgba(255,255,255,0.3);
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】红包详情列表样式 ▼▼▼ */
.rp-details-item {
    display: flex;
    align-items: center;
    padding: 8px 0;
    border-bottom: 1px solid #eee;
}
.rp-details-item:last-child {
    border-bottom: none;
}
.rp-details-item .name {
    flex-grow: 1;
    font-weight: 500;
    color: #333;
}
.rp-details-item .amount {
    font-weight: 500;
    color: #555;
}
.rp-details-item .lucky-king-tag {
    font-size: 10px;
    background-color: #ffd700;
    color: #a67c00;
    padding: 2px 5px;
    border-radius: 4px;
    margin-left: 8px;
    font-weight: bold;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】投票功能样式 ▼▼▼ */

/* 投票卡片在消息气泡中的样式 */
.message-bubble.is-poll .content {
    padding: 0;
    background: transparent;
    box-shadow: none;
    border: none;
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
}

/* 投票卡片主体 */
.poll-card {
    width: 250px;
    background-color: #f9f9f9;
    border-radius: 10px;
    border: 1px solid #e0e0e0;
    padding: 12px;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
}

.poll-card.closed {
    background-color: #e9ecef; /* 结束后变灰 */
}

/* 投票问题 */
.poll-question {
    font-weight: 600;
    font-size: 15px;
    margin-bottom: 12px;
    line-height: 1.4;
    word-break: break-word;
}

/* 投票选项列表 */
.poll-options-list {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

/* 单个投票选项 */
.poll-option-item {
    background-color: white;
    border: 1px solid #dcdcdc;
    border-radius: 8px;
    padding: 10px;
    cursor: pointer;
    position: relative;
    overflow: hidden;
    transition: background-color 0.2s;
}

.poll-card:not(.closed) .poll-option-item:hover {
    background-color: #f0f8ff;
}

/* 用户已投票的选项样式 */
.poll-option-item.voted {
    border-color: var(--accent-color);
    background-color: #e7f3ff;
    font-weight: 500;
}

/* 投票进度条 */
.poll-option-bar {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    background-color: rgba(0, 123, 255, 0.1);
    z-index: 1;
    transition: width 0.3s ease-in-out;
}

/* 选项内容（文字和票数），确保在进度条之上 */
.poll-option-content {
    position: relative;
    z-index: 2;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.poll-option-text {
    font-size: 14px;
}

.poll-option-votes {
    font-size: 13px;
    color: #8a8a8a;
    font-weight: 500;
}

/* 投票卡片底部 */
.poll-footer {
    margin-top: 12px;
    padding-top: 8px;
    border-top: 1px solid #e9e9e9;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 12px;
    color: var(--text-secondary);
}

.poll-total-votes {
    font-weight: 500;
}

.poll-action-btn {
    background: none;
    border: 1px solid var(--accent-color);
    color: var(--accent-color);
    padding: 4px 10px;
    border-radius: 15px;
    cursor: pointer;
    font-size: 12px;
}
.poll-card.closed .poll-action-btn {
    background-color: #6c757d;
    color: white;
    border-color: #6c757d;
}

/* 创建投票模态框的选项输入 */
.poll-option-input-wrapper {
    display: flex;
    align-items: center;
    gap: 8px;
}
.poll-option-input-wrapper input {
    flex-grow: 1;
}
.poll-option-input-wrapper .remove-option-btn {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    background-color: #f0f0f0;
    color: #ff3b30;
    border: none;
    cursor: pointer;
    font-size: 18px;
    line-height: 28px;
    text-align: center;
    flex-shrink: 0;
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* === 【全新】聊天头部“正在输入”状态样式 === */
#chat-header-title.typing-status {
    color: var(--text-secondary);
    animation: typing-pulse 1.5s infinite;
    font-style: italic;
}

@keyframes typing-pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.6; }
}

#chat-header-title {
    transition: opacity 0.2s ease-in-out;
}

@keyframes message-pop-in {
  from {
    opacity: 0;
    transform: translateY(15px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.message-wrapper.animate-in {
  animation: message-pop-in 0.3s cubic-bezier(0.25, 0.1, 0.25, 1) forwards;
  }

/* ▼▼▼ 【全新】App图标设置样式 ▼▼▼ */
#icon-settings-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
    gap: 20px;
    width: 100%;
    padding: 0 10px;
    box-sizing: border-box;
}

.icon-setting-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
}

.icon-preview {
    width: 60px;
    height: 60px;
    border-radius: 15px;
    background-size: cover;
    background-position: center;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

.change-icon-btn {
    padding: 4px 10px;
    font-size: 12px;
    border: 1px solid #ccc;
    background-color: #f0f0f0;
    border-radius: 5px;
    cursor: pointer;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】外观设置页面布局修正 ▼▼▼ */

/* 1. 修正滚动问题 */
#wallpaper-screen .form-container {
    /* 核心修正1: 解决flex布局下的滚动冲突，让滚动条能正常出现 */
    min-height: 0; 
}

/* 2. 修正壁纸预览被压扁的问题 */
#wallpaper-preview {
    /* 核心修正2: 防止预览框被过多的内容挤压变形，让它保持自己的高度 */
    flex-shrink: 0; 
}
/* ▲▲▲ 修正结束 ▲▲▲ */

/* ▼▼▼ 【全新】分享链接功能样式 (无图版) ▼▼▼ */

/* 1. 浏览器界面背景色和内容区样式 (保持不变) */
#browser-screen {
    background-color: #f8f9fa;
}
#browser-content {
    padding: 20px;
    font-size: 16px;
    line-height: 1.8;
    color: #333;
    overflow-y: auto;
    background-color: #f8f9fa;
}
#browser-content .article-title {
    font-size: 24px;
    font-weight: 700;
    margin-bottom: 10px;
}
#browser-content .article-meta {
    font-size: 13px;
    color: #8a8a8a;
    margin-bottom: 25px;
    padding-bottom: 15px;
    border-bottom: 1px solid #e0e0e0;
}
#browser-content .article-body {
    white-space: pre-wrap;
    word-break: break-word;
}
#browser-content .article-body p {
    margin-bottom: 1em;
}

/* 2. 聊天气泡中的链接卡片样式 (无图版) */
.message-bubble.is-link-share .content {
    padding: 0;
    background: transparent;
    box-shadow: none;
    border: none;
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
}

.link-share-card {
    width: 210px; 
    background-color: #fff;
    border-radius: 10px;
    border: 1px solid #e0e0e0;
    padding: 12px;
    cursor: pointer;
    transition: background-color 0.2s;
    display: flex;
    flex-direction: column;
    gap: 8px;
}
.link-share-card:hover {
    background-color: #f9f9f9;
}

.link-share-card .title {
    font-weight: 600;
    font-size: 15px;
    line-height: 1.4;
    color: #1f1f1f;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
    text-overflow: ellipsis;
}

.link-share-card .description {
    font-size: 13px;
    color: #8a8a8a;
    display: -webkit-box;
    -webkit-line-clamp: 3;
    -webkit-box-orient: vertical;
    overflow: hidden;
    text-overflow: ellipsis;
}

.link-share-card .footer {
    display: flex; /* 让图标和文字水平对齐 */
    align-items: center;
    gap: 6px; /* 图标和文字的间距 */
    font-size: 12px;
    color: var(--text-secondary);
    margin-top: 4px; /* 和上面的描述拉开一点距离 */
}
.link-share-card .footer-icon {
    width: 14px;
    height: 14px;
    flex-shrink: 0; /* 防止图标被压缩 */
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* 单条评论的容器，现在需要相对定位 */
.comment-item {
    position: relative;
    padding-right: 25px; /* 在右侧留出删除按钮的空间 */
}

/* 评论删除按钮的样式 */
.comment-delete-btn {
    position: absolute;
    top: 50%;
    right: 0;
    transform: translateY(-50%);
    width: 22px;
    height: 22px;
    line-height: 22px;
    text-align: center;
    border-radius: 50%;
    color: var(--text-secondary);
    font-size: 18px;
    cursor: pointer;
    transition: all 0.2s ease;
    opacity: 0; /* 默认隐藏 */
}

/* 鼠标悬停在评论上时，显示删除按钮 */
.comment-item:hover .comment-delete-btn {
    opacity: 1;
}

.comment-delete-btn:hover {
    background-color: #f0f0f0;
    color: #ff3b30;
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 【请求7】主屏幕预设保存按钮主题色适配 (请将这块代码也粘贴到 <style> 的末尾) ▼▼▼ */
#save-home-preset-btn {
    background-color: var(--accent-color);
    color: white;
}
/* ▲▲▲ 粘贴结束 ▲▲▲ */


/* ▼▼▼ 【全新】引用回复功能样式 ▼▼▼ */

/* 1. 输入框上方的“回复预览栏” */
#reply-preview-bar {
    display: none; /* 默认隐藏 */
    padding: 8px 12px;
    margin: 0 8px 8px 8px; /* 和输入框周围的边距保持一致 */
    background-color: rgba(0, 0, 0, 0.05);
    border-left: 3px solid var(--accent-color);
    border-radius: 6px;
    position: relative;
    font-size: 13px;
    color: var(--text-secondary);
}

#phone-screen.dark-mode #reply-preview-bar {
    background-color: rgba(255, 255, 255, 0.1);
}

.reply-preview-content .sender {
    font-weight: 600;
    color: var(--text-primary);
}

.reply-preview-content .text {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    display: block; /* 确保省略号生效 */
    max-width: 95%;
}

#cancel-reply-btn {
    position: absolute;
    top: 50%;
    right: 8px;
    transform: translateY(-50%);
    width: 20px;
    height: 20px;
    line-height: 20px;
    text-align: center;
    border-radius: 50%;
    background-color: rgba(0,0,0,0.1);
    cursor: pointer;
    font-size: 14px;
}

/* 2. 消息气泡内部的“引用消息块” */
.quoted-message {
    padding: 6px 10px;
    margin-bottom: 6px;
    background-color: rgba(0, 0, 0, 0.04);
    border-left: 2px solid var(--accent-color);
    border-radius: 4px;
    font-size: 0.9em; /* 字体比正文小一点 */
    opacity: 0.8;
    /* (已移除 overflow: hidden;) */
}

#phone-screen.dark-mode .quoted-message {
    background-color: rgba(255, 255, 255, 0.08);
    border-left-color: #a0cff1;
}

.quoted-message .quoted-sender {
    font-weight: 600;
    color: var(--accent-color);
}
#phone-screen.dark-mode .quoted-message .quoted-sender {
    color: #a0cff1;
}

.quoted-message .quoted-content {
    color: var(--text-secondary);
    white-space: normal;     /* 核心修正1: 允许文本正常换行 */
    word-break: break-word;  /* 核心修正2: 强制长单词或连续字符断开，防止溢出 */
    display: block;
    /* (已移除 overflow 和 text-overflow，因为我们需要多行显示而不是单行省略号) */
}

/* === 字体预览框样式 (修正后) === */

/* 将它修改为 ▼▼▼ */
#font-preview {
    padding: 20px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background-color: #f0f2f5; /* 统一为更浅的灰色，然后让夜间模式CSS去覆盖 */
    transition: background-color 0.3s, border-color 0.3s;
}

/* 预览框里的文字颜色，默认是黑色 */
#font-preview p {
    color: var(--text-primary);
}

/* 夜间模式下的修正样式 */
#phone-screen.dark-mode #font-preview {
    background-color: #1c1c1e; /* 深灰色背景 */
    border-color: #38383a;     /* 暗色边框 */
}

/* 夜间模式下，预览框里的文字变为白色 */
#phone-screen.dark-mode #font-preview p {
    color: #ffffff;
}

/* ▼▼▼ 【全新】精致版转账操作弹窗样式 ▼▼▼ */
.transfer-actions-content {
    background-color: #fff0f5; /* 粉嫩的背景色 */
    border-radius: 20px;
    width: 290px;
    padding: 20px;
    box-shadow: 0 5px 25px rgba(255, 105, 180, 0.3); /* 粉色阴影 */
    text-align: center;
    position: relative;
    border: 1px solid #ffcce0;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
}

.transfer-actions-header {
    font-size: 20px;
    font-weight: bold;
    color: #a35c7b; /* 深粉色标题 */
    margin-bottom: 15px;
}

.transfer-actions-body p {
    font-size: 15px;
    color: #555;
    margin: 0 0 25px 0;
    line-height: 1.5;
}

.transfer-actions-footer {
    display: flex;
    justify-content: space-between;
    gap: 15px;
}

.transfer-actions-footer .action-btn {
    flex: 1;
    padding: 12px;
    border: none;
    border-radius: 12px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
    color: white;
}

.transfer-actions-footer .action-btn:active {
    transform: scale(0.95);
}

.transfer-actions-footer .action-btn.accept {
    background: linear-gradient(135deg, #ff85b3, #ff69b4);
    box-shadow: 0 4px 10px rgba(255, 105, 180, 0.4);
}

.transfer-actions-footer .action-btn.decline {
    background: linear-gradient(135deg, #c2c2c2, #a0a0a0);
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
}

.transfer-actions-content .cancel-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    border: none;
    background-color: rgba(0, 0, 0, 0.1);
    color: #a35c7b;
    font-size: 20px;
    line-height: 28px;
    cursor: pointer;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* === 未读消息红点样式 === */
.unread-count-wrapper {
    flex-shrink: 0;
    width: 40px;
    display: flex;
    justify-content: center;
    align-items: flex-start;
    padding-top: 20px; /* 让红点和名字差不多高 */
}

.unread-count {
    min-width: 20px;
    height: 20px;
    padding: 0 6px;
    background-color: #ff3b30; /* iOS 风格的红色 */
    color: white;
    font-size: 13px;
    font-weight: 500;
    line-height: 20px;
    text-align: center;
    border-radius: 10px; /* 圆角矩形 */
    box-shadow: 0 1px 2px rgba(0,0,0,0.15);
    display: none; /* 默认隐藏 */
    justify-content: center;
    align-items: center;
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】通话记录页面与卡片样式 ▼▼▼ */

/* 确保页面背景色统一 */
#call-history-screen {
    background-color: #f0f2f5;
}

/* 通话记录卡片样式 */
.call-record-card {
    background-color: var(--secondary-bg);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    cursor: pointer;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    border-left: 5px solid var(--accent-color);
}
.call-record-card:hover {
    transform: translateY(-3px);
    box-shadow: 0 6px 12px rgba(0,0,0,0.1);
}

/* 卡片头部：包含日期和时长 */
.call-record-card .card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 13px;
    color: var(--text-secondary);
    margin-bottom: 12px;
    padding-bottom: 8px;
    border-bottom: 1px solid var(--border-color);
}
.call-record-card .card-header .duration {
    font-weight: 500;
    color: var(--text-primary);
}

/* 卡片主体：参与者头像 */
.call-record-card .card-body {
    display: flex;
    align-items: center;
}
.call-record-card .participants-avatars {
    display: flex;
    align-items: center;
}
.call-record-card .participant-avatar {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    object-fit: cover;
    border: 2px solid white;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}
/* 让头像有一个漂亮的堆叠效果 */
.call-record-card .participant-avatar:not(:first-child) {
    margin-left: -12px;
}
.call-record-card .participants-names {
    margin-left: 12px;
    font-weight: 600;
    color: var(--text-primary);
    font-size: 15px;
}

/* --- 通话详情弹窗样式 --- */
#transcript-modal-body {
    display: flex;
    flex-direction: column;
    gap: 12px;
    padding: 15px;
}
.transcript-entry {
    padding: 8px 12px;
    border-radius: 10px;
    max-width: 85%;
    line-height: 1.5;
    word-break: break-word;
}
.transcript-entry.user {
    background-color: #dcf8c6; /* 类似微信的绿色 */
    align-self: flex-end;
}
.transcript-entry.assistant {
    background-color: #ffffff;
    align-self: flex-start;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

#chat-list-title {
    cursor: pointer;
}

/* ▼▼▼ 【全新】通话记录卡片美化样式 ▼▼▼ */

.call-record-card .card-body {
    /* 将 body 改为 flex 布局，让标题和参与者信息垂直排列 */
    display: flex;
    flex-direction: column;
    gap: 8px; /* 标题和参与者信息之间的间距 */
}

.call-record-card .custom-title {
    font-size: 16px;
    font-weight: 600; /* 加粗，让它像个标题 */
    color: var(--text-primary);
    padding-bottom: 8px; /* 标题下的留白 */
    border-bottom: 1px solid var(--border-color); /* 在标题下加一条分割线 */
    margin-bottom: 4px; /* 和下面的参与者信息拉开一点距离 */
}

.call-record-card .participants-info {
    /* 这个新容器让头像和“与xx”能水平对齐 */
    display: flex;
    align-items: center;
}

/* 参与者名字的样式微调，让它不那么突出 */
.call-record-card .participants-names {
    margin-left: 12px;
    font-weight: 500; /* 不再加粗 */
    font-size: 14px; /* 稍微小一点 */
    color: var(--text-secondary); /* 使用次要文字颜色 */
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】语音转文字功能样式 ▼▼▼ */

/* 1. 语音文字内容的样式 */
.voice-transcript {
    font-size: 14px;         /* 文字大小 */
    line-height: 1.6;        /* 行高，让多行文本更易读 */
    color: var(--text-secondary); /* 使用次要文字颜色，与语音条区分 */
    padding: 8px 12px;       /* 内边距 */
    margin-top: 6px;         /* 和上方的语音条拉开一点距离 */
    background-color: rgba(0, 0, 0, 0.04); /* 给一个淡淡的背景，更有层次感 */
    border-radius: 6px;      /* 圆角 */
    word-break: break-word;  /* 确保长文本能正常换行 */
    display: none;           /* 默认隐藏 */
}

#phone-screen.dark-mode .voice-transcript {
    background-color: rgba(255, 255, 255, 0.1); /* 夜间模式下的背景色 */
}

/* 2. 旋转加载动画的样式 */
.loading-spinner {
    display: none; /* 默认隐藏 */
    width: 16px;
    height: 16px;
    border: 2px solid rgba(0, 0, 0, 0.2);
    border-top-color: var(--accent-color); /* 旋转部分的颜色 */
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin: 0 8px; /* 和波形图、时长保持一点间距 */
}

/* 3. 定义旋转动画 */
@keyframes spin {
    to {
        transform: rotate(360deg);
    }
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】分享记录查看器样式修正 ▼▼▼ */
#shared-history-viewer-content {
    display: flex;
    flex-direction: column; /* 让气泡垂直排列 */
    gap: 20px; /* 在每个气泡之间增加20像素的间距 */
    padding: 15px; /* 在容器四周也增加一些内边距，避免气泡贴边 */
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】播放器和歌词样式 ▼▼▼ */
#music-player-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 50;
    display: flex;
    justify-content: center;
    align-items: flex-start;
    padding-top: 60px;
    background-color: rgba(0,0,0,0.3);
    opacity: 0;
    visibility: hidden;
    transform: translateY(-50px);
    transition: opacity 0.4s ease-out, transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
}

#music-player-overlay.visible {
    opacity: 1;
    visibility: visible;
    transform: translateY(0);
}

.music-player-window { 
    width: 70%; 
    min-height: 420px;
    background-color: rgba(255, 255, 255, 0.6); 
    backdrop-filter: blur(20px); 
    -webkit-backdrop-filter: blur(20px); 
    border-radius: 25px; 
    box-shadow: 0 8px 32px 0 rgba(25, 25, 25, 0.37); 
    border: 1px solid rgba(255, 255, 255, 0.18); 
    padding: 25px; 
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    color: #1f1f1f; 
    position: relative;
    justify-content: space-between;
    padding-bottom: 15px;
}

.music-player-top-actions {
    position: absolute;
    top: 15px;
    left: 15px;
    right: 15px;
    width: calc(100% - 30px);
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.top-left-cluster {
    display: flex;
    align-items: center;
    gap: 15px;
}
#music-return-btn, #music-exit-btn {
    background: none;
    border: none;
    font-size: 28px;
    font-weight: 300;
    cursor: pointer;
    color: #555;
    padding: 5px;
    line-height: 1;
}
#music-exit-btn {
    font-size: 24px;
    font-weight: 400;
}

.music-progress-bar-container {
    width: 100%;
    display: flex;
    align-items: center;
    gap: 10px;
    margin-top: 25px;
    margin-bottom: 10px;
}
.time-display {
    font-size: 11px;
    color: #888;
    width: 35px;
    text-align: center;
    flex-shrink: 0;
    font-family: 'SF Mono', 'Menlo', monospace;
}
.progress-bar {
    flex-grow: 1;
    height: 5px;
    background-color: #e5e5e5;
    border-radius: 2.5px;
    cursor: pointer;
}
.progress-bar-fill {
    width: 0%;
    height: 100%;
    background-color: #333;
    border-radius: 2.5px;
}

#music-lyrics-container {
    width: 100%;
    height: 192px;
    overflow: hidden;
    position: relative;
    -webkit-mask-image: linear-gradient(transparent, black 20%, black 80%, transparent);
    mask-image: linear-gradient(transparent, black 20%, black 80%, transparent);
}

#music-lyrics-list {
    display: flex;
    flex-direction: column;
    align-items: center;
    transition: transform 0.5s cubic-bezier(0.25, 0.1, 0.25, 1);
}

.lyric-line {
    padding: 4px 0;
    font-size: 14px;
    color: #666;
    text-align: center;
    line-height: 1.5;
    transition: all 0.5s ease;
    opacity: 0.7;
    transform: scale(0.95);
}

.lyric-line.active {
    font-size: 16px;
    color: #000;
    opacity: 1;
    transform: scale(1);
}

.music-player-controls-wrapper {
    width: 100%;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.music-controls {
    margin-top: 0;
}

#music-return-btn, #music-exit-btn, #music-playlist-btn {
    position: relative;
}

#music-return-btn { top: -2px; }
#music-playlist-btn { top: -3px; }

.playlist-item-actions {
    display: flex;
    align-items: center;
    gap: 15px;
}
.playlist-action-btn {
    font-size: 18px;
    color: #888;
    cursor: pointer;
    transition: color 0.2s;
}
.playlist-action-btn:hover { color: #000; }
.delete-track-btn { font-size: 24px; color: #ff3b30; }
.delete-track-btn:hover { color: #c00; }
.lyrics-btn { font-weight: 500; }

/* ▼▼▼ 【最终头像放大版】请用这块代码替换所有相关的头像尺寸规则 ▼▼▼ */

/* 1. 普通头像样式（无框） */
.message-bubble .avatar {
    width: 38px;  /* ★ 修改点：将尺寸从 34px 放大到 42px */
    height: 38px; /* ★ 修改点：高度也同步放大 */
    border-radius:  20%;
    object-fit: cover;
    flex-shrink: 0; 
}

/* 2. 带框头像的容器样式 */
.avatar-with-frame {
    position: relative;
    width: 41px;  /* ★ 修改点：尺寸与普通头像保持一致 */
    height: 41px; /* ★ 修改点：高度也同步放大 */
    flex-shrink: 0;
}

/* ▲▲▲ 替换结束 ▲▲▲ */


/* ▼▼▼ 【全新】撤回消息样式 ▼▼▼ */

/* 1. 撤回消息的占位符样式 */
.recalled-message-placeholder {
    align-self: center; /* 居中显示 */
    padding: 4px 12px;
    margin: 5px 0;
    background-color: rgba(0, 0, 0, 0.1);
    color: var(--text-secondary);
    font-size: 12px;
    border-radius: 10px;
    text-align: center;
    max-width: 80%;
    cursor: pointer; /* 让它看起来可以点击 */
}

/* 2. 夜间模式下的适配 */
#phone-screen.dark-mode .recalled-message-placeholder {
    background-color: rgba(255, 255, 255, 0.15);
}

/* 3. AI撤回消息时的动画效果 */
@keyframes recall-animation {
  from {
    opacity: 1;
    transform: scale(1);
  }
  to {
    opacity: 0;
    transform: scale(0.8);
  }
}

.message-wrapper.recalled-animation {
  animation: recall-animation 0.3s ease-out forwards;
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】撤回消息样式修正 ▼▼▼ */

/* 强制撤回消息的占位符不换行，并保持内容居中 */
.recalled-message-placeholder {
    white-space: nowrap; /* 核心：禁止文本换行 */
    display: inline-block; /* 让背景根据内容自适应宽度 */
    padding: 4px 12px;
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】世界书分类列表样式 ▼▼▼ */
.world-book-group-container {
    border-bottom: 1px solid var(--border-color);
}
.world-book-group-container:first-child {
    border-top: 1px solid var(--border-color);
}
.world-book-group-header {
    display: flex;
    align-items: center;
    padding: 12px 15px;
    cursor: pointer;
    background-color: #f7f7f7;
}
.world-book-group-header .arrow {
    font-size: 14px;
    margin-right: 8px;
    transition: transform 0.2s ease;
}
.world-book-group-header.collapsed .arrow {
    transform: rotate(-90deg);
}
.world-book-group-header .group-name {
    font-weight: 600;
    font-size: 15px;
}
.world-book-group-content {
    max-height: 100000px; /* <--- 就是修改这里，把值改大即可 */
    overflow: hidden;
    transition: max-height 0.3s ease-in-out;
}
.world-book-group-content.collapsed {
    max-height: 0;
}
#phone-screen.dark-mode .world-book-group-header {
    background-color: #1c1c1e;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】红包/转账模态框页签样式 ▼▼▼ */
.frame-tabs {
    display: flex;
    background-color: #f0f0f0;
    padding: 4px;
    margin: 15px;
    border-radius: 8px;
}
.frame-tab {
    flex: 1;
    text-align: center;
    padding: 8px;
    font-size: 14px;
    font-weight: 500;
    color: #555;
    cursor: pointer;
    border-radius: 6px;
    transition: all 0.2s ease-in-out;
}
.frame-tab.active {
    background-color: #ffffff;
    color: #000000;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段全新的CSS粘贴到 <style> 的末尾 ▼▼▼ */

/* 1. 分类文件夹的样式 */
.wb-category-header {
    display: flex;
    align-items: center;
    padding: 10px 12px;
    cursor: pointer;
    background-color: #f0f2f5; /* 给文件夹一个淡淡的背景色以区分 */
    font-weight: 600; /* 加粗字体 */
}
#phone-screen.dark-mode .wb-category-header {
    background-color: #2c2c2e; /* 夜间模式下的背景色 */
}


/* 2. 展开/收起的小箭头 */
.wb-category-header .arrow {
    font-size: 12px;
    margin-right: 8px;
    transition: transform 0.2s ease;
}

/* 3. 当文件夹收起时，箭头旋转 */
.wb-category-header.collapsed .arrow {
    transform: rotate(-90deg);
}

/* 4. 存放书籍条目的容器 */
.wb-book-container {
    padding-left: 20px; /* 核心：让书籍条目向内缩进，看起来像在文件夹里 */
    max-height: 100000px; /* 一个足够大的值，用于动画 */
    overflow: hidden;
    transition: max-height 0.3s ease-in-out;
}

/* 5. 当文件夹收起时，书籍容器的高度变为0，实现动画效果 */
.wb-book-container.collapsed {
    max-height: 0;
}

/* 6. 单个书籍条目（覆盖默认的label样式，微调间距） */
.wb-book-container label {
    padding: 8px 12px;
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】世界书关联选择器 - 视觉优化 ▼▼▼ */

/* 1. 让分类标题更突出 */
.wb-category-header > span:last-of-type {
    font-size: 14px;
    font-weight: 700; /* 加粗 */
    color: var(--text-primary);
}

/* 2. 为箭头设置一个漂亮的颜色循环 */
#world-book-checkboxes-container .wb-category-header:nth-of-type(6n+1) .arrow { color: #007bff; } /* 蓝色 */
#world-book-checkboxes-container .wb-category-header:nth-of-type(6n+2) .arrow { color: #28a745; } /* 绿色 */
#world-book-checkboxes-container .wb-category-header:nth-of-type(6n+3) .arrow { color: #fd7e14; } /* 橙色 */
#world-book-checkboxes-container .wb-category-header:nth-of-type(6n+4) .arrow { color: #6f42c1; } /* 紫色 */
#world-book-checkboxes-container .wb-category-header:nth-of-type(6n+5) .arrow { color: #dc3545; } /* 红色 */
#world-book-checkboxes-container .wb-category-header:nth-of-type(6n+6) .arrow { color: #ffc107; } /* 黄色 */

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* === 头像框选择模态框样式 (这是新添加的) === */
.change-frame-btn {
    padding: 6px 10px;
    border: 1px solid #ccc;
    background-color: #f0f0f0;
    border-radius: 5px;
    cursor: pointer;
    font-size: 13px;
    margin-left: 10px;
}

#avatar-frame-modal .modal-content {
    height: 70%; /* 让窗口高一点 */
}

#avatar-frame-modal .modal-body {
    padding: 0;
    display: flex;
    flex-direction: column;
}
      
.frame-tabs {
    display: flex;
    border-bottom: 1px solid var(--border-color);
    flex-shrink: 0;
}

.frame-tab {
    flex: 1;
    padding: 12px;
    text-align: center;
    font-weight: 500;
    cursor: pointer;
    color: var(--text-secondary);
    border-bottom: 2px solid transparent;
}

.frame-tab.active {
    color: var(--accent-color);
    border-bottom-color: var(--accent-color);
}

.frame-content {
    flex-grow: 1;
    overflow-y: auto;
    padding: 15px;
}

.frame-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(70px, 1fr)); /* 每行自动填充，最小70px宽 */
    gap: 15px;
}

.frame-item {
    aspect-ratio: 1 / 1; /* 保持正方形 */
    border: 2px solid transparent;
    border-radius: 10px;
    cursor: pointer;
    background-color: #f0f0f0;
    background-size: cover;
    background-position: center;
    padding: 5px;
    transition: all 0.2s ease;
    position: relative; /* 为预览图做准备 */
}

.frame-item.selected {
    border-color: var(--accent-color);
    transform: scale(1.05);
}

.frame-item .preview-avatar {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
}

.frame-item .preview-frame {
    position: absolute;
    top: -7px;
    left: 0;
    width: 100%;
    height: 100%;
}

/* ▼▼▼ 把这些CSS加回去 ▼▼▼ */

.avatar-with-frame .avatar-img {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: 50%; /* 带框的头像通常是圆的 */
    object-fit: cover;
    z-index: 1;
}
/* ▼▼▼ 【最终修复版】请用这整块代码，替换掉旧的聊天和心声头像框规则 ▼▼▼ */

.avatar-with-frame .avatar-frame,
#inner-voice-avatar-frame {
    position: absolute;
    /* 核心修改1：将宽高统一设置为125%，确保能完全包裹34px的头像，并留出漂亮的边距 */
    width: 125%; 
    height: 125%;

    /* 核心修改2：使用标准的-50%来精确定位，确保头像框完美居中 */
    transform: translate(-50%, -50%); 
    
    /* 核心修改3：将定位基点也改为标准的50%，与transform配合使用 */
    top: 50%;
    left: 50%;

    z-index: 2;
    pointer-events: none;
}

/* ▲▲▲ 替换结束 ▲▲▲ */

/* ▲▲▲ 添加结束 ▲▲▲ */

/* ▼▼▼ 【最终美化版】聊天列表左滑置顶功能样式 (已修复Bug) ▼▼▼ */

/* 1. 外层包裹容器 (已移除 display:flex) */
.chat-list-item-swipe-container {
    position: relative;
    overflow: hidden;
}

/* 2. 可滑动的内容区 (保持不变) */
.chat-list-item-content {
    position: relative;
    z-index: 2;
    background-color: var(--secondary-bg);
    transition: transform 0.3s ease, background-color 0.3s ease;
    width: 100%;
    flex-shrink: 0;
}

/* 3. 【核心修改1】置顶聊天时，使用对比度更强的背景色 */
.chat-list-item-content.pinned {
    background-color: #f0f2f5; /* 日间模式下的置顶颜色 (已加深) */
}
#phone-screen.dark-mode .chat-list-item-content.pinned {
    background-color: #3a3a3c; /* 夜间模式下的置顶颜色 (已加深) */
}

/* 4. 隐藏的操作按钮区域 (保持不变) */
.swipe-actions {
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    z-index: 1;
    display: flex;
}

/* 5. 单个操作按钮的样式 (保持不变) */
.swipe-action-btn {
    height: 100%;
    padding: 0 20px;
    border: none;
    color: white;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 80px;
}

.swipe-action-btn.pin { background-color: #f0ad4e; }
.swipe-action-btn.unpin { background-color: #777; }
.swipe-action-btn.delete { background-color: #ff3b30; }

/* 6. 当内容区被滑开时 (保持不变) */
.chat-list-item-content.swiped {
    transform: translateX(-160px);
}

/* 7. 分割线的正确逻辑 (保持不变) */
.chat-list-item {
    border-bottom: none;
}
.chat-list-item-swipe-container:not(:last-child) {
     border-bottom: 1px solid var(--border-color);
}
.chat-group-container {
    border-bottom: 1px solid var(--border-color);
}
.chat-group-container:first-of-type {
    border-top: 1px solid var(--border-color);
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 用下面这段【新样式】，替换掉你旧的 .date-stamp 样式 ▼▼▼ */

/* 日期戳的外层包裹，让它像系统消息一样居中 */
.date-stamp-wrapper {
    justify-content: center;
    align-self: center;
    margin: 10px 0;
    max-width: 80%;
}

/* 日期戳的气泡本身 */
.date-stamp-bubble {
    background-color: rgba(0, 0, 0, 0.1);
    color: var(--text-secondary);
    font-size: 12px;
    padding: 4px 12px;
    border-radius: 10px;
}

/* 适配夜间模式 */
#phone-screen.dark-mode .date-stamp-bubble {
    background-color: rgba(255, 255, 255, 0.15);
}
/* ▲▲▲ 替换结束 ▲▲▲ */

/* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */
.chat-list-time {
    font-size: 12px;
    color: var(--text-secondary);
    text-align: right;
    margin-left: 8px; /* 和中间的信息区拉开一点距离 */
    flex-shrink: 0;   /* 防止在空间不足时被压缩 */
    align-self: flex-start; /* 让它和顶部的名字对齐 */
    padding-top: 2px; /* 微调垂直位置 */
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */
.chat-list-right-column {
    display: flex;
    flex-direction: column;
    align-items: flex-end; /* 让内容靠右对齐 */
    gap: 4px; /* 在时间和红点之间加一点点间距 */
    flex-shrink: 0;
    margin-left: 8px;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】锁屏与密码界面样式 ▼▼▼ */

/* 1. 锁屏界面的总容器 */
#lock-screen {
    /* 核心：用一个非常高的 z-index 确保它能覆盖所有其他屏幕 */
    z-index: 999; 
    background-size: cover;
    background-position: center;
    color: white;
    display: flex;
    flex-direction: column;
    justify-content: space-between; /* 让时钟和提示语上下分布 */
    align-items: center;
    padding: 80px 20px 50px 20px;
    box-sizing: border-box;
    transition: transform 0.3s ease-out;
}

/* 2. 锁屏时钟 (复用主屏幕时钟的样式) */
#lock-clock-container {
    text-align: center;
    text-shadow: 0 3px 8px rgba(0,0,0,0.4);
    flex-shrink: 0;
}
#lock-main-time {
    font-size: 80px;
    font-weight: 200;
}
#lock-main-date {
    font-size: 18px;
    font-weight: 500;
}

/* 3. “向上轻扫”的提示文字和动画 */
#unlock-hint {
    font-size: 16px;
    font-weight: 500;
    text-shadow: 0 1px 4px rgba(0,0,0,0.3);
    /* 添加一个呼吸动画，吸引用户注意 */
    animation: hint-pulse 2s infinite ease-in-out;
}
@keyframes hint-pulse {
    0%, 100% { opacity: 0.7; transform: translateY(0); }
    50% { opacity: 1; transform: translateY(-5px); }
}

/* 4. 密码输入弹窗的遮罩层 */
#password-modal-overlay {
    /* 使用一个半透明的毛玻璃效果背景 */
    background-color: rgba(0, 0, 0, 0.3);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    z-index: 1000; /* 比锁屏更高，确保在最上层 */
}

/* 5. 密码输入弹窗的内容区 */
.password-modal-content {
    background-color: rgba(255, 255, 255, 0.8);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    width: 280px;
    border-radius: 15px;
    padding: 20px;
    box-shadow: 0 5px 20px rgba(0,0,0,0.2);
    text-align: center;
    display: flex;
    flex-direction: column;
    gap: 15px;
    color: #333;
}
.password-modal-content p {
    font-size: 17px;
    font-weight: 600;
    margin: 0;
}

/* 6. 密码输入框 */
#password-input-field {
    width: 100%;
    padding: 12px;
    border: 1px solid rgba(0,0,0,0.1);
    border-radius: 8px;
    font-size: 16px;
    text-align: center;
    box-sizing: border-box;
    background-color: rgba(255,255,255,0.7);
}
#password-input-field:focus {
    outline: none;
    border-color: var(--accent-color);
}

/* 7. 密码弹窗的按钮区域 */
.password-actions {
    display: flex;
    gap: 10px;
    margin-top: 5px;
}
.password-actions button {
    flex: 1;
    padding: 12px;
    border: none;
    border-radius: 8px;
    font-size: 16px;
    font-weight: 500;
    cursor: pointer;
}
#password-cancel-btn {
    background-color: #e9ecef;
    color: #495057;
}
#password-confirm-btn {
    background-color: var(--accent-color);
    color: white;
}

/* 8. 密码错误时的晃动动画 */
@keyframes shake-error {
  0%, 100% { transform: translateX(0); }
  10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
  20%, 40%, 60%, 80% { transform: translateX(5px); }
}
.password-modal-content.error {
    animation: shake-error 0.4s ease-in-out;
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */


/* ▼▼▼ 用这块【最终修复版】代码，完整替换掉你旧的 .bubble-preset-manager 样式 ▼▼▼ */

/* 这是你要修改前的代码 */
/* ▼▼▼ 【全新】气泡/API样式预设功能CSS ▼▼▼ */
.bubble-preset-manager {
    display: flex;
    align-items: baseline; /* 核心修改：从 center 改为 baseline */
    gap: 10px; /* 元素之间的间距 */
}



/* ▲▲▲ 替换结束 ▲▲▲ */


/* 下拉框的样式，让它占据大部分空间 */
.bubble-preset-manager select {
    flex-grow: 1; /* 占据所有剩余空间 */
}

/* 管理按钮的样式，让它小巧精致 */
.bubble-preset-manager .action-btn {
    flex-shrink: 0; /* 防止按钮被压缩 */
    padding: 8px 10px;
    font-size: 13px;
    background-color: #e9ecef;
    color: var(--text-primary);
    border: 1px solid var(--border-color);
    border-radius: 5px;
    cursor: pointer;
    font-weight: 500;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 把这一整块全新的CSS，粘贴到 <style> 的末尾 ▼▼▼ */

/* 1. 让锁屏和主屏幕可以堆叠 */
/* 核心：把锁屏和主屏幕都设为绝对定位，这样它们才能重叠 */
#lock-screen, #home-screen {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}

/* 2. 定义毛玻璃背景层的样式 */
#lock-screen-background-blur {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1; /* 【核心修改1】它的层级现在和主屏幕一样低 */
    
    background-size: cover;
    background-position: center;

    /* 【核心修改2】魔法在这里！我们直接模糊这个元素本身 */
    filter: blur(20px);
    -webkit-filter: blur(20px);
    
    /* (可选但推荐) 轻微放大可以避免模糊后边缘变暗，效果更好 */
    transform: scale(1.1); 

    /* 【核心修改3】默认隐藏，且带有淡入淡出效果 */
    display: none;
    opacity: 0;
    transition: opacity 0.3s ease-out;
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 从这里开始复制 ▼▼▼ */

/* === 【最终修复版】世界书选择器列表样式 === */

/* 1. 分类文件夹行样式：用flex和gap创建固定间距，非常稳定 */
.wb-category-header {
    display: flex;
    align-items: center;
    gap: 8px; /* 箭头、复选框、文字之间的固定间距 */
    padding: 10px 12px;
    cursor: pointer;
    background-color: #f0f2f5;
    font-weight: 600;
    overflow: hidden; /* 防止任何意外溢出 */
}

/* 2. 分类文件夹里的文字样式：只负责截断，不负责布局 */
.wb-category-header > span:last-of-type {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    flex-shrink: 1; /* 允许文字部分在空间不足时被压缩 */
}

/* 3. 【核心修复】为分类和书目里的复选框“解绑”全局样式！ */
.wb-category-header input[type="checkbox"],
.wb-book-container input[type="checkbox"] {
    width: auto !important; /* 让它恢复自己的天然大小，!important确保最高优先级 */
    flex-shrink: 0;         /* 防止它被压缩，保持完整 */
}

/* 4. 具体书目行的样式：强制从左边开始排列，解决不同设备的显示差异 */
.wb-book-container label {
    display: flex;
    align-items: center;
    justify-content: flex-start; /* 强制所有内容从左边开始对齐 */
    padding: 8px 12px;
    gap: 10px; /* 复选框和文字的间距 */
    overflow: hidden;
}

/* 5. 具体书目的文字样式 */
.wb-book-container label .wb-book-name {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    text-align: left;
    flex-shrink: 1; /* 同样允许它被压缩 */
}

/* 6. 夜间模式适配 (保持不变) */
#phone-screen.dark-mode .wb-category-header {
    background-color: #2c2c2e;
}

/* 7. 小箭头的样式 (保持不变) */
.wb-category-header .arrow {
    font-size: 12px;
    transition: transform 0.2s ease;
    flex-shrink: 0; /* 防止箭头被压缩 */
}
.wb-category-header.collapsed .arrow {
    transform: rotate(-90deg);
}

/* 8. 书籍容器的样式 (保持不变) */
.wb-book-container {
    padding-left: 20px;
    max-height: 1000px;
    overflow: hidden;
    transition: max-height 0.3s ease-in-out;
}
.wb-book-container.collapsed {
    max-height: 0;
}


/* ▼▼▼ 【全新】鼠标拖动工具栏时的手势样式 ▼▼▼ */
#chat-input-actions-top.grabbing {
    cursor: grabbing;
    cursor: -webkit-grabbing;
    user-select: none; /* 防止拖动时选中文本 */
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【SVG终极版】发送定位功能样式 ▼▼▼ */

/* 1. 基础卡片和气泡样式 (保持不变) */
.message-bubble.is-location .content { padding: 0; background: transparent; box-shadow: none; border: none; backdrop-filter: none; -webkit-backdrop-filter: none; }
.location-card { width: 230px; background-color: #f7f7f7; border-radius: 12px; overflow: hidden; border: 1px solid #e0e0e0; box-shadow: 0 2px 5px rgba(0,0,0,0.08); }

/* 2. 【核心升级】地图区域现在直接用于容纳SVG */
.location-map-area {
    height: 90px;
    background-color: #f0f2f5;
    background-image:
        linear-gradient(rgba(0,0,0,0.05) 1px, transparent 1px),
        linear-gradient(90deg, rgba(0,0,0,0.05) 1px, transparent 1px);
    background-size: 20px 20px;
    padding: 5px; /* 给SVG一点呼吸空间 */
    box-sizing: border-box;
}
.location-map-area svg {
    width: 100%;
    height: 100%;
}

/* 3. 【全新】SVG内部元素的样式 */
/* 轨迹曲线 */
.svg-trajectory-path {
    stroke-width: 2px;
    stroke: rgba(180, 180, 180, 0.8);
    stroke-dasharray: 3 3; /* 虚线效果 */
    fill: none;
}
/* 定位点 (起点/终点) */
.svg-pin {
    stroke-width: 2px;
    stroke: white;
}
.svg-pin.user-pin { fill: #4CAF50; } /* 绿色用户点 */
.svg-pin.ai-pin { fill: #ff5252; } /* 红色AI点 */

/* 脚印图标 */
.svg-footprint {
    font-size: 14px;
    fill: rgba(0, 0, 0, 0.4);
}
/* 途经点地名标签 */
.svg-location-label {
    font-size: 10px;
    font-weight: 500;
    fill: #555;
    /* 给文字一点白色的描边，让它在复杂背景下更清晰 */
    stroke: white;
    stroke-width: 2px;
    paint-order: stroke;
}

/* 4. 卡片底部信息区域 (已升级) */
.location-info { padding: 12px; }
.location-address {
    font-size: 13px;
    line-height: 1.6;
    margin-bottom: 8px;
    color: #333;
}
.location-address .name-tag {
    font-weight: 600;
    color: var(--text-primary);
}
.location-address p.hidden { display: none; }
.location-distance {
    font-size: 12px;
    color: var(--text-secondary);
    border-top: 1px solid #e9e9e9;
    padding-top: 8px;
    text-align: center;
}
/* ▲▲▲ 升级版CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新 | 修复版】“一键重roll”按钮样式 ▼▼▼ */
#reroll-btn {
    /* --- 直接复用其他按钮的样式，确保外观统一 --- */
    font-size: 24px;
    padding: 0;
    width: 38px;
    height: 38px;
    line-height: 38px;
    text-align: center;
    border-radius: 50%;
    background-color: rgba(255, 255, 255, 0.5);
    color: var(--text-primary);
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
    /* 核心修复：边框颜色和其他按钮统一 */
    border: 1px solid rgba(0,0,0,0.05); 
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    
    /* 移除导致差异的阴影 */
    box-shadow: none; 

    /* 保留原有的交互动效 */
    transition: opacity 0.2s, transform 0.1s;
}

#reroll-btn:hover {
    opacity: 0.8;
}

#reroll-btn:active {
    transform: scale(0.9);
}

#reroll-btn svg {
    width: 20px;
    height: 20px;
}
/* ▲▲▲ 替换结束 ▲▲▲ */


/* ▼▼▼ 【最终美化版】悬浮歌词栏样式 ▼▼▼ */
#floating-lyrics-bar {
    position: absolute;
    /* 【问题1修复】默认位置改为顶部 */
    top: 50px; 
    left: 50%;
    transform: translateX(-50%);
    z-index: 100;
    
    display: none;
    align-items: center;
    justify-content: center;
    gap: 10px; /* 在歌词和按钮间增加间距 */

    width: 90%; 
    max-width: 320px; /* 同时设一个最大像素宽度，避免在宽屏上过长 */
    padding: 8px 12px; /* 稍微增加一点内边距以适应新宽度 */
    background-color: rgba(0, 0, 0, 0); 
    
    /* 【问题3需要】为字体颜色和背景透明度添加过渡动画 */
    transition: background-color 0.3s, opacity 0.3s;

    color: white;
    font-size: 14px;
    font-weight: 500; /* 字体稍微加粗 */
    text-align: center;
    border-radius: 12px;
    
    /* 文字阴影，让它在任何背景下都清晰 */
    text-shadow: 0 1px 3px rgba(0,0,0,0.5); 
    
    cursor: pointer;
    user-select: none;
    
    /* 【问题4需要】为关闭按钮准备 */
    overflow: visible; /* 允许按钮超出范围 */
}

/* 【问题4需要】关闭按钮的样式 */
#floating-lyrics-bar .close-btn,
#floating-lyrics-bar #lyrics-settings-btn {
    position: absolute;
    top: -8px;
    width: 20px;
    height: 20px;
    background-color: rgba(0,0,0,0.6);
    color: white;
    border-radius: 50%;
    border: 1px solid white;
    cursor: pointer;
    opacity: 0; /* 默认隐藏 */
    transition: opacity 0.2s;
    display: flex; /* 确保SVG能居中 */
    align-items: center;
    justify-content: center;
}

/* 把关闭按钮和设置按钮分开放置 */
#floating-lyrics-bar .close-btn { right: -8px; line-height: 18px; font-size: 14px; }
#floating-lyrics-bar #lyrics-settings-btn { right: 22px; } /* 放在关闭按钮旁边 */

/* 鼠标悬停在整个歌词栏上时，一起显示它们 */
#floating-lyrics-bar:hover .close-btn,
#floating-lyrics-bar:hover #lyrics-settings-btn {
    opacity: 1;
}

#floating-lyrics-bar.dragging {
    cursor: grabbing;
    cursor: -webkit-grabbing;
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】“查角色手机”功能相关样式 ▼▼▼ */

/* 角色选择列表项 */
.character-select-item {
    display: flex;
    align-items: center;
    padding: 10px 15px;
    border-bottom: 1px solid var(--border-color);
    cursor: pointer;
}
.character-select-item:hover {
    background-color: #f5f5f5;
}
.character-select-item img {
    width: 45px;
    height: 45px;
    border-radius: 50%;
    margin-right: 12px;
}
.character-select-item .name {
    font-weight: 500;
}

/* 角色手机的聊天气泡 (简化版) */
.character-chat-bubble {
    padding: 8px 12px;
    border-radius: 12px;
    max-width: 80%;
    word-break: break-word;
    line-height: 1.5;
}
.character-chat-bubble.sent {
    background-color: #dcf8c6;
    align-self: flex-end; /* 自己发的靠右 */
}
.character-chat-bubble.received {
    background-color: #ffffff;
    align-self: flex-start; /* 收到的靠左 */
}

/* ▼▼▼ 【美化版】角色手机数据列表项样式 ▼▼▼ */
.character-data-item {
    padding: 12px 15px;
    border-bottom: 1px solid #f0f0f0; /* 边框颜色变浅 */
    margin: 8px 10px; /* 增加外边距，形成卡片感 */
    border-radius: 8px; /* 增加圆角 */
    box-shadow: 0 1px 3px rgba(0,0,0,0.05); /* 增加非常淡的阴影 */
    transition: transform 0.2s, box-shadow 0.2s; /* 增加悬浮动画 */
    background-color: var(--secondary-bg);
}

.character-data-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.08);
}

.character-data-item .title {
    font-weight: 600;
    margin-bottom: 5px;
    color: #333; /* 标题颜色加深 */
}
.character-data-item .content {
    font-size: 14px;
    color: #555;
    line-height: 1.6;
    white-space: pre-wrap;
}
.character-data-item .meta {
    font-size: 12px;
    color: #888;
    margin-top: 10px;
    padding-top: 8px; /* 在meta上方增加一点距离和分割线 */
    border-top: 1px solid #f5f5f5;
    display: flex;
    justify-content: space-between;
}
/* ▲▲▲ 替换结束 ▲▲▲ */

/* ▼▼▼ 【V3修正版】角色手机“画中画”样式修正 ▼▼▼ */

/* 1. 【核心修正1】让手机外壳容器占据整个屏幕，并用内边距把手机框“推”下来 */
#character-phone-container {
    display: flex;
    justify-content: center;
    align-items: center;
    background-color: #ffffff; /* ★★★ 把这里改为纯白色 ★★★ */
    padding-top: 50px; 
    box-sizing: border-box; /* 确保内边距计算正确 */
}


/* 2. 手机边框样式 (修改后) */
.character-phone-frame {
    width: 95%;
    height: 98%;
    background-color: #111;
    border-radius: 30px;
    padding: 10px;
    box-shadow: none; /* ★★★ 就是修改这里 ★★★ */
    box-sizing: border-box;
    position: relative;
    display: flex;
}

/* ▼▼▼ 用下面这块【已修复】的代码替换旧的 #character-app-grid .app-icon .icon-bg 规则 ▼▼▼ */
#character-app-grid .app-icon .icon-bg {
    width: 65px;  /* 恢复原来的尺寸 */
    height: 65px; /* 恢复原来的尺寸 */
    border-radius: 18px; /* 恢复原来的圆角 */
    background-color: #fff5f7; /* 设置为你想要的淡粉色背景 */
}
/* ▲▲▲ 替换结束 ▲▲▲ */

/* 3. 【核心修正2】缩小APP图标内的SVG */
#character-app-grid .app-icon .icon-bg svg {
    width: 60%;  /* ★★★ 将SVG的宽度缩小到其容器的60% ★★★ */
    height: 60%; /* ★★★ 高度也同步缩小 ★★★ */
}

/* 4. 其余样式保持不变 */
.character-phone-inner-screen {
    flex-grow: 1;
    border-radius: 20px;
    overflow: hidden;
    position: relative;
    background-color: var(--secondary-bg) !important; /* 使用变量 */
}
.character-phone-notch {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    width: 100px;
    height: 20px;
    border-radius: 0 0 10px 10px;
    z-index: 10;
}
.character-phone-page {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s, visibility 0.3s;
}
.character-phone-page.active {
    opacity: 1;
    visibility: visible;
    z-index: 5;
}
/* ▼▼▼ 用这块【透明毛玻璃版】代码，完整替换掉旧的 .character-phone-header 样式 ▼▼▼ */

/* ▼▼▼ 用这块【透明毛玻璃版】代码，完整替换掉旧的 .character-phone-header 样式 ▼▼▼ */

.character-phone-header {
    flex-shrink: 0;
    margin: 10px 12px 10px; /* ★ 修改点1: 将上边距 35px 改为 0，让它贴顶 */
    height: 50px;           /* ★ 修改点2: 将高度从 48px 增加到 56px，让它更高一点 */

    /* ★ 核心修改1：变成一个更圆润的胶囊形状 */
    border-radius: 24px; /* 将圆角从16px增加到24px，看起来更圆润 */

    /* ★ 核心修改2：设置一个几乎透明的、带有毛玻璃效果的背景 */
    background-color: rgba(180, 180, 180, 0.2); /* 降低不透明度，营造透明感 */
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);

    /* ★ 核心修改3：让边框和阴影更精致，以适应透明感 */
    border: 1px solid rgba(255, 255, 255, 0.2); /* 边框也调得更透明 */
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);   /* 阴影稍微调整，更柔和 */

    /* ★ 核心修改4：强制文字和图标颜色变为白色，并加上阴影以保证清晰 */
    color: #ffffff; /* 标题文字变为白色 */
    text-shadow: 0 1px 3px rgba(0,0,0,0.3); /* 给文字加一点阴影，防止背景太亮看不清 */

    /* 布局部分保持不变 */
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 12px;
    box-sizing: border-box;
    font-size: 16px;
}


/* ★★★【重要】为了确保所有图标都变成白色，请把下面这段新代码也加到<style>里 ★★★ */
.character-phone-header .action-btn svg,
.character-phone-header .back-btn svg {
    color: #ffffff !important;
}

/* ▲▲▲ 替换结束 ▲▲▲ */

/* ★★★【重要】为了确保所有图标都变成白色，请把下面这段新代码也加到<style>里 ★★★ */
.character-phone-header .action-btn svg,
.character-phone-header .back-btn svg {
    color: #ffffff !important;
}

/* ▲▲▲ 替换结束 ▲▲▲ */

.character-phone-header .action-btn svg,
.character-phone-header .back-btn svg {
    color: var(--accent-color);
}
#character-chat-history-messages {
     background-color: var(--secondary-bg) !important; /* 使用变量 */      /* ★★★ 移除背景图片 ★★★ */
}
/* ▲▲▲ 样式修正结束 ▲▲▲ */

/* ▼▼▼ 【V5最终修复版】角色手机APP图标布局修正 ▼▼▼ */
/* ▼▼▼ 找到 #character-app-grid.app-grid-standard，修改其中的 padding-top 属性 ▼▼▼ */

#character-app-grid.app-grid-standard {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 20px 15px;
    padding: 20px;
    padding-top: 95px; /* ★★★ 把 50px 改成 95px，为新顶栏留出空间 ★★★ */
    box-sizing: border-box;
    width: 100%;
    flex-direction: initial; 
    align-items: initial;
}

/* ▲▲▲ 修改结束 ▲▲▲ */

/* ▲▲▲ 样式修正结束 ▲▲▲ */


/* ▼▼▼ 【全新】角色手机微信风格聊天气泡样式 ▼▼▼ */

/* 1. 聊天记录界面的背景色 */
#character-chat-history-messages {
    /* 移除之前版本可能存在的背景图片 */
    background-image: none;
}

/* 2. 消息气泡的通用容器样式 */
.character-chat-bubble-container {
    display: flex;
    gap: 10px;
    align-items: flex-start;
    margin-bottom: 12px;
    max-width: 80%; /* 限制气泡最大宽度 */
}

/* 3. 气泡的内容区域 */
.character-chat-bubble {
    position: relative;
    padding: 8px 12px;
    line-height: 1.5;
    word-break: break-word;
    border-radius: 6px;
    font-size: 15px;
}

/* 4. 头像样式 */
.character-chat-avatar {
    width: 36px;
    height: 36px;
    border-radius: 6px; /* 微信风格的圆角矩形头像 */
    flex-shrink: 0;
}

/* --- 我方（角色自己）的气泡 --- */
.character-chat-bubble-container.sent {
    align-self: flex-end; /* 整体靠右 */
    flex-direction: row-reverse; /* 布局反转：内容 -> 头像 */
}
.character-chat-bubble-container.sent .character-chat-bubble {
    background-color: #95ec69; /* 微信绿 */
    color: #000;
}
/* 我方气泡的小尾巴 */
.character-chat-bubble-container.sent .character-chat-bubble::after {
    content: "";
    position: absolute;
    right: -4px;
    top: 10px;
    width: 0;
    height: 0;
    border: 4px solid transparent;
    border-left-color: #95ec69;
    border-right: 0;
}

/* --- 对方（NPC或用户）的气泡 --- */
.character-chat-bubble-container.received {
    align-self: flex-start; /* 整体靠左 */
}
/* 对方气泡的小尾巴 */
.character-chat-bubble-container.received .character-chat-bubble::before {
    content: "";
    position: absolute;
    left: -4px;
    top: 10px;
    width: 0;
    height: 0;
    border: 4px solid transparent;
    border-right-color: #ffffff;
    border-left: 0;
}
/* ▼▼▼ 在这里添加下面这块新代码 ▼▼▼ */
.character-chat-bubble-container.received .character-chat-bubble {
    background-color: #ffffff; /* 微信白 */
    color: #000;
}
/* ▲▲▲ 添加结束 ▲▲▲ */

/* --- 功能性重置：针对图片/表情包，让气泡“消失” --- */
.character-chat-bubble-container .character-chat-bubble:has(img.sticker-image) {
    background: transparent !important;
    padding: 0 !important;
    border-radius: 0;
}
.character-chat-bubble-container .character-chat-bubble:has(img.sticker-image)::before,
.character-chat-bubble-container .character-chat-bubble:has(img.sticker-image)::after {
    content: none !important;
}
/* ▲▲▲ 样式添加结束 ▲▲▲ */
/* ▼▼▼ 【全新】角色手机新增APP页面样式 ▼▼▼ */

/* 1. 相册页面的网格布局 */
#character-album-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr); /* 每行3张图 */
    gap: 4px;
    padding: 4px;
}
.character-album-item {
    aspect-ratio: 1 / 1; /* 保持正方形 */
    background-color: #e0e0e0;
    cursor: pointer;
}
.character-album-item img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

/* 2. 银行页面的余额显示 */
.character-bank-balance-card {
    margin: 15px;
    padding: 20px;
    background: linear-gradient(135deg, #667eea, #764ba2);
    color: white;
    border-radius: 12px;
    text-align: center;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
}
.character-bank-balance-card .label {
    font-size: 14px;
    opacity: 0.8;
}
.character-bank-balance-card .amount {
    font-size: 32px;
    font-weight: 600;
    margin-top: 5px;
}

/* 3. 银行交易记录的颜色 */
.character-data-item .transaction-amount {
    font-weight: 600;
}
.character-data-item .transaction-amount.income {
    color: #4CAF50; /* 收入为绿色 */
}
.character-data-item .transaction-amount.expense {
    color: #F44336; /* 支出为红色 */
}

/* ▲▲▲ 样式添加结束 ▲▲▲ */

/* ▼▼▼ 【V5修正版】角色手机相册网格布局 ▼▼▼ */
#character-album-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr); /* 每行3张图 */
    gap: 4px;
    padding: 4px;
}
.character-album-item {
    aspect-ratio: 1 / 1; /* 保持正方形 */
    background-color: #e0e0e0;
    cursor: pointer;
}
.character-album-item img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}
/* ▲▲▲ 样式修正结束 ▲▲▲ */

/* ▼▼▼ 【全新】Markdown渲染增强样式 ▼▼▼ */

/* 1. 为角色手机里的所有Markdown内容设置基础样式 */
.character-data-item .content h1,
.character-data-item .content h2,
.character-data-item .content h3,
.character-data-item .content p {
    margin: 0 0 10px 0; /* 统一标题和段落的下边距 */
}
.character-data-item .content h1 { font-size: 1.5em; font-weight: 600; }
.character-data-item .content h2 { font-size: 1.3em; font-weight: 600; }
.character-data-item .content h3 { font-size: 1.1em; font-weight: 600; }

/* 2. 删除线样式 */
.character-data-item .content del {
    color: #8a8a8a;
}

/* 3. 遮挡/剧透效果 */
.character-data-item .content .spoiler {
    background-color: #333;
    color: #333; /* 文字和背景一个色，实现隐藏 */
    padding: 0 4px;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s ease-in-out;
}
/* 点击或鼠标悬停时显示内容 */
.character-data-item .content .spoiler:hover,
.character-data-item .content .spoiler:active {
    background-color: #f0f0f0;
    color: #000;
}

/* ▲▲▲ 样式添加结束 ▲▲▲ */

/* ▼▼▼ 【全新】角色手机日记美化与删除功能样式 ▼▼▼ */

/* 1. 让日记列表有更好的边距 */
#character-diary-list {
    padding: 10px;
    display: flex;
    flex-direction: column;
    gap: 12px; /* 增加日记之间的间距 */
}

/* 2. 美化单篇日记卡片 */
#character-diary-list .character-data-item {
    background-color: #fffaf0; /* 温暖的米黄色背景 */
    border-left: 4px solid #ffc107; /* 左侧加一条装饰线 */
    box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    position: relative; /* 为了定位删除按钮 */
    padding-bottom: 35px; /* 为底部的日期留出空间 */
}

/* 3. 美化日期显示，把它放到右下角 */
#character-diary-list .character-data-item .meta {
    position: absolute;
    bottom: 8px;
    right: 12px;
    border-top: none; /* 移除原来的上边框 */
    padding-top: 0;
    font-size: 11px;
    color: #bfa87a;
}

/* 4. 删除按钮的样式 */
.diary-delete-btn {
    position: absolute;
    top: 8px;
    right: 8px;
    width: 26px;
    height: 26px;
    border-radius: 50%;
    background-color: rgba(0,0,0,0.05);
    color: #bfa87a;
    border: none;
    cursor: pointer;
    font-size: 20px;
    line-height: 26px;
    text-align: center;
    opacity: 0; /* 默认隐藏 */
    transition: opacity 0.2s ease-in-out;
}
/* 鼠标悬停在日记上时显示按钮 */
#character-diary-list .character-data-item:hover .diary-delete-btn {
    opacity: 1;
}
.diary-delete-btn:hover {
    background-color: #ff3b30;
    color: white;
}
/* ▲▲▲ 样式添加结束 ▲▲▲ */

/* ▼▼▼ 【V6最终修复版】角色手机相册布局防溢出 ▼▼▼ */

/* 1. 【核心】为相册网格的容器强制禁止水平滚动 */
#character-album-grid.list-container {
    overflow-x: hidden;
}

/* 2. 重新定义网格布局 */
#character-album-grid {
    display: grid;
    /* 【核心】每行3个，但这次我们用calc()精确计算宽度 */
    grid-template-columns: repeat(3, calc(33.333% - 4px)); 
    gap: 6px; /* 稍微增大间隙，让calc有计算空间 */
    padding: 6px; /* 内边距和间隙保持一致 */
    box-sizing: border-box; /* 确保内边距和边框被包含在总宽度内 */
    align-content: start; /* <--- 就是加上这一行！ */
}

/* 3. 稍微缩小图片，确保它们不会撑破容器 */
.character-album-item img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block; /* 移除图片下方的微小空隙 */
}

/* ▲▲▲ 样式修正结束 ▲▲▲ */

/* ▼▼▼ 【V6独家定制】角色手机信纸风格日记样式 ▼▼▼ */

/* 1. 【核心】重塑日记卡片，让它像一张信纸 */
#character-diary-list .character-data-item {
    background-color: #fdfaf2; /* 温暖、柔和的米白/浅黄色，模拟信纸 */
    border: 1px solid #eaddc7;  /* 淡淡的纸张边缘色 */
    border-left: 3px solid #d4bda5; /* 左侧加一条稍深的线，像装订线 */
    box-shadow: 2px 2px 6px rgba(0,0,0,0.06); /* 更柔和的阴影 */
    position: relative;
    padding: 20px 15px 15px 20px; /* 调整内边距，给“小东西”留出空间 */
    font-family: Georgia, 'Times New Roman', 'Kaiti TC', 'STKaiti', serif; /* 使用更典雅的衬线字体 */
}

/* 2. 【小东西】用伪元素在左上角添加一个精致的纸夹 */
#character-diary-list .character-data-item::before {
    content: '📎'; /* 这是一个Emoji纸夹，简单又有效 */
    position: absolute;
    top: -12px;
    left: 15px;
    font-size: 24px;
    transform: rotate(-25deg); /* 让纸夹有一个随意的角度 */
    opacity: 0.8;
}

/* 3. 【核心】重置Markdown内容的字体，确保它们继承信纸的字体 */
#character-diary-list .character-data-item .content,
#character-diary-list .character-data-item .content h1,
#character-diary-list .character-data-item .content h2,
#character-diary-list .character-data-item .content h3 {
    font-family: inherit; /* 强制继承父元素的字体 */
    color: #4a443b; /* 使用深棕色文字，更有质感 */
}

#character-diary-list .character-data-item .content p {
    margin: 0 0 12px 0;
}

/* 4. 将日期移动到右上角，像信纸的落款日期 */
#character-diary-list .character-data-item .meta {
    position: absolute;
    top: 10px;
    right: 12px;
    font-size: 11px;
    color: #ae9c82; /* 匹配信纸风格的日期颜色 */
    font-style: italic; /* 斜体更有手写感 */
    border-top: none;
    padding-top: 0;
}

/* 5. 美化删除按钮，让它更融入信纸风格 */
#character-diary-list .character-data-item .diary-delete-btn {
    background-color: transparent;
    color: #c9bbae;
    font-size: 22px;
    transition: all 0.2s ease;
}

#character-diary-list .character-data-item .diary-delete-btn:hover {
    background-color: #e44d44;
    color: white;
    transform: scale(1.1);
}

/* ▲▲▲ 样式添加结束 ▲▲▲ */

/* ▼▼▼ 【全新】角色手机全APP美化样式 ▼▼▼ */

/* --- 1. 购物车样式 --- */
.character-cart-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 12px 15px;
    border-bottom: 1px solid #f0f0f0;
}
.character-cart-item:last-child {
    border-bottom: none;
}
.cart-item-icon {
    width: 40px;
    height: 40px;
    flex-shrink: 0;
    background-color: #f0f2f5;
    border-radius: 8px;
    display: flex;
    justify-content: center;
    align-items: center;
    color: var(--text-secondary);
}
.cart-item-info {
    flex-grow: 1;
}
.cart-item-info .title {
    font-weight: 500;
}
.cart-item-info .store {
    font-size: 12px;
    color: var(--text-secondary);
}
.cart-item-price {
    font-weight: 600;
    font-size: 15px;
}

/* --- 2. 浏览器历史样式 --- */
.character-browser-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 14px 15px;
    border-bottom: 1px solid #f0f0f0;
    cursor: pointer;
    transition: background-color 0.2s;
}
.character-browser-item:hover {
    background-color: #f9f9f9;
}
.browser-item-icon {
    font-size: 20px;
    color: var(--text-secondary);
}

/* --- 3. 银行交易明细样式 --- */
.character-bank-transaction {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 14px 15px;
    border-bottom: 1px solid #f0f0f0;
}
.transaction-details {
    display: flex;
    align-items: center;
    gap: 12px;
}
.transaction-icon {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 18px;
    color: white;
}

/* --- 4. 行动轨迹 (时间线) 样式 --- */
.character-trajectory-list {
    padding: 20px 15px 20px 30px; /* 左侧留出时间线的空间 */
}
.character-trajectory-item {
    position: relative;
    padding-bottom: 25px;
}
/* 时间轴的竖线 */
.character-trajectory-item::before {
    content: '';
    position: absolute;
    top: 5px;
    left: -18px;
    width: 2px;
    height: 100%;
    background-color: #e0e0e0;
}
.character-trajectory-item:last-child::before {
    display: none; /* 最后一个条目没有线 */
}
/* 时间轴的圆点 */
.character-trajectory-item::after {
    content: '';
    position: absolute;
    top: 5px;
    left: -23px;
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background-color: var(--accent-color);
    border: 2px solid white;
    box-shadow: 0 0 0 2px var(--accent-color);
}
.trajectory-item-content .meta {
    margin-top: 4px; /* 让时间和地点离标题近一点 */
}

/* --- 5. APP使用记录 (进度条) 样式 --- */
.character-app-usage-item {
    padding: 15px;
    border-bottom: 1px solid #f0f0f0;
}
.app-usage-header {
    display: flex;
    justify-content: space-between;
    margin-bottom: 8px;
    font-size: 14px;
}
.app-usage-header .name {
    font-weight: 500;
}
.app-usage-header .duration {
    color: var(--text-secondary);
}
.app-usage-bar-container {
    width: 100%;
    height: 6px;
    background-color: #e9ecef;
    border-radius: 3px;
    overflow: hidden;
}
.app-usage-bar {
    height: 100%;
    background-color: var(--accent-color);
    border-radius: 3px;
    transition: width 0.5s ease-in-out;
}
/* ▼▼▼ 【全新】后台活动设置界面样式 ▼▼▼ */
.char-list-item {
    display: flex;
    align-items: center;
    padding: 8px 5px;
    border-bottom: 1px solid #eee;
}
.char-list-item:last-child {
    border-bottom: none;
}
.char-list-item input[type="checkbox"] {
    margin-right: 10px;
    width: 18px;
    height: 18px;
}
.char-list-item .char-name {
    flex-grow: 1;
}
.char-list-item .char-freq-badge {
    font-size: 11px;
    font-weight: bold;
    padding: 3px 8px;
    border-radius: 10px;
    color: white;
}
.char-freq-badge.low { background-color: #28a745; }
.char-freq-badge.medium { background-color: #fd7e14; }
.char-freq-badge.high { background-color: #dc3545; }
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
/* ▼▼▼ 把这一整块全新的CSS，粘贴到 <style> 的末尾 ▼▼▼ */

/* === 【全新】视频通话可视化界面样式 === */

/* 1. 可视化界面的总容器，确保它能覆盖整个屏幕 */
#visual-call-interface {
    width: 100%;
    height: 100%;
    position: relative; /* 让内部元素可以相对于它定位 */
    overflow: hidden; /* 防止内容溢出 */
    background-color: #1c1c1e; /* 深色背景 */
    display: flex; /* 使用flex布局，方便内容排列 */
    flex-direction: column;
}

/* 2. 视频背景层，用于放置大小图 */
.video-background {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1; /* 确保它在最底层 */
}

/* 3. 大小图的通用容器样式 */
.video-container {
    position: absolute;
    background-color: #000;
    overflow: hidden;
    transition: all 0.3s ease-in-out; /* 为切换镜头添加动画 */
}
.video-container img {
    width: 100%;
    height: 100%;
    object-fit: cover; /* 保证图片填满容器且不变形 */
}

/* 4. 大图样式 (默认占满全屏) */
#video-main-view {
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}

/* 5. 小图样式 (画中画) */
#video-pip-view {
    top: 60px; /* 距离顶部一段距离 */
    right: 15px;
    width: 100px; /* 小窗宽度 */
    height: 178px; /* 小窗高度 (保持竖屏比例) */
    border-radius: 10px;
    border: 2px solid rgba(255, 255, 255, 0.3);
    box-shadow: 0 4px 10px rgba(0,0,0,0.3);
    cursor: pointer; /* 提示用户可以点击 */
}

/* 6. 聊天气泡区域 (覆盖在视频之上) */
#video-call-messages-visual {
    position: relative;
    z-index: 5; /* 层级比视频高 */
    flex-grow: 1; /* 占据除了顶部和底部栏之外的所有空间 */
    padding: 15px;
    overflow-y: auto; /* 内容多了可以滚动 */
    display: flex;
    flex-direction: column;
    gap: 15px;
    /* 关键：为了不让滚动条影响美观，把它隐藏掉 */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none;  /* IE 10+ */
}
#video-call-messages-visual::-webkit-scrollbar {
    display: none; /* Chrome, Safari, Opera*/
}

/* ▼▼▼ 用这【一小块】代码，替换掉旧的气泡样式，实现【无模糊】效果 ▼▼▼ */

/* 7. 【无模糊】高清透明聊天气泡 */
.visual-call-bubble {
    padding: 8px 12px;
    border-radius: 18px;
    max-width: 80%;
    line-height: 1.5;
    word-break: break-word;
    color: white;

    /* ★ 核心修改：彻底移除 backdrop-filter (模糊) 效果 */

    /* ★ 核心修改：提供一个简单的半透明黑色背景，以衬托文字 */
    background-color: rgba(0, 0, 0, 0.3); /* 这是一个关键值，可以在 0.2 (更透) 到 0.4 (更深) 之间微调 */

    /* ★ 核心修改：使用更清晰的边框来定义气泡轮廓 */
    border: 1px solid rgba(255, 255, 255, 0.25);

    /* ★ 核心修改：强化文字阴影，确保在任何清晰背景下都绝对可读 */
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.9);
}

.visual-call-bubble.user {
    align-self: flex-end;
    /* ★ 核心修改：用户气泡也使用无模糊的半透明背景 */
    background-color: rgba(40, 160, 70, 0.3); /* 使用一个更深的绿色来保证对比度 */
    border-color: rgba(255, 255, 255, 0.3);
}

/* ▲▲▲ 替换结束 ▲▲▲ */



.visual-call-bubble.ai {
    align-self: flex-start; /* AI的发言靠左 */
}

/* 8. 顶部和底部栏的层级要最高 */
#visual-call-interface .video-call-top-bar,
#visual-call-interface .video-call-controls {
    z-index: 10;
}

/* 9. 新增的控制按钮图标 (使用SVG) */
.control-btn.reroll-btn {
    background-color: rgba(255,255,255,0.2);
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg>');
    background-size: 50%;
}
.control-btn.switch-camera-btn {
    background-color: rgba(255,255,255,0.2);
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>');
    background-size: 50%;
}

/* 10. 挂断按钮需要一个新ID来区分 */
#hang-up-btn-visual {
    /* 样式继承自 .hangup-btn，无需额外添加 */
}

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
/* ▼▼▼ 【最终修复版】世界书选择器列表样式 ▼▼▼ */

/* 1. 分类文件夹行样式：用gap创建固定间距，超稳定 */
.wb-category-header {
    display: flex;
    align-items: center;
    gap: 8px; /* 箭头、复选框、文字之间的固定间距 */
    padding: 10px 12px;
    cursor: pointer;
    background-color: #f0f2f5;
    font-weight: 600;
    overflow: hidden; /* 防止任何意外 */
}

/* 2. 分类文件夹里的文字样式：只负责截断，不负责布局 */
.wb-category-header > span:last-of-type {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* 3. 【核心修复】为分类文件夹和书目里的复选框“解绑”全局样式！ */
.wb-category-header input[type="checkbox"],
.wb-book-container input[type="checkbox"] {
    width: auto !important; /* 让它恢复自己的天然大小，!important确保最高优先级 */
    flex-shrink: 0;         /* 防止它被压缩 */
}

/* 4. 具体书目行的样式：强制从左边开始排列，解决iOS问题 */
.wb-book-container label {
    display: flex;
    align-items: center;
    justify-content: flex-start; /* 强制所有内容从左边开始！*/
    padding: 8px 12px;
    gap: 10px; /* 复选框和文字的间距 */
    overflow: hidden;
}

/* 5. 具体书目的文字样式 */
.wb-book-container label .wb-book-name {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    text-align: left;
}

/* 6. 夜间模式适配 */
#phone-screen.dark-mode .wb-category-header {
    background-color: #2c2c2e;
}

/* 7. 小箭头的样式（保持不变） */
.wb-category-header .arrow {
    font-size: 12px;
    transition: transform 0.2s ease;
}
.wb-category-header.collapsed .arrow {
    transform: rotate(-90deg);
}

/* 8. 书籍容器的样式（保持不变） */
.wb-book-container {
    padding-left: 20px;
    max-height: 1000px;
    overflow: hidden;
    transition: max-height 0.3s ease-in-out;
}
.wb-book-container.collapsed {
    max-height: 0;
}

/* ▲▲▲ 粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】字体预设功能样式 ▼▼▼ */

#font-preset-container {
    width: 100%;
    display: flex;
    flex-direction: column;
    gap: 15px; /* 卡槽之间的间距 */
}

.font-preset-slot {
    border: 1px solid var(--border-color);
    border-radius: 12px;
    padding: 15px;
    display: flex;
    flex-direction: column;
    gap: 12px;
}

#phone-screen.dark-mode .font-preset-slot {
    border-color: #38383a;
}

.font-preset-slot.empty {
    justify-content: center;
    align-items: center;
    min-height: 80px;
    border-style: dashed;
}

.font-preview-text {
    font-size: 22px;
    padding: 10px;
    border-radius: 8px;
    text-align: center;
    min-height: 30px;
    transition: font-family 0.3s ease;
}

#phone-screen.dark-mode .font-preview-text {
    background-color: #2c2c2e;
    color: #fff;
}

.font-preset-info {
    font-size: 14px;
    color: var(--text-secondary);
    font-weight: 500;
}

.font-preset-actions {
    display: flex;
    gap: 10px;
    width: 100%;
}

.preset-btn {
    flex: 1;
    padding: 10px;
    border: none;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    background-color: var(--accent-color);
    color: white;
}

.preset-btn.secondary {
    background-color: #e9ecef;
    color: var(--text-primary);
    border: 1px solid var(--border-color);
}
#phone-screen.dark-mode .preset-btn.secondary {
    background-color: #3e3e42;
    border-color: #545458;
}

.preset-btn.delete {
    background-color: #ffdde5;
    color: #ff3b30;
    border: 1px solid #ffc2d1;
    max-width: 80px; /* 让删除按钮窄一点 */
    flex: 0 0 auto;
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
/* 【美化 V2】让后台活动设置的按钮更圆润、更立体 */
#background-activity-details .form-button-secondary {
    border-radius: 20px; /* 大幅增加圆角，形成胶囊形状 */
    padding-top: 10px;   /* 增加顶部内边距，让按钮更高 */
    padding-bottom: 10px;/* 增加底部内边距，让按钮更高 */
    font-weight: 500;    /* 字体稍微加粗一点 */
    transition: all 0.2s ease; /* 添加平滑的过渡效果 */
}

/* 为按钮添加一个微妙的点击效果 */
#background-activity-details .form-button-secondary:active {
    transform: scale(0.96); /* 点击时轻微缩小 */
    opacity: 0.8;         /* 点击时稍微变淡 */
}
/* ▼▼▼ 【全新】BGM搜索结果弹窗样式 ▼▼▼ */

/* ▼▼▼ 在这里添加下面这段新样式 ▼▼▼ */
#music-search-results-modal .modal-content {
    z-index: 220; /* 这个值比播放列表的 210 要高 */
}
/* ▲▲▲ 添加结束 ▲▲▲ */

.search-result-item {
    display: flex;
    flex-direction: column;
    padding: 12px 18px;
    border-bottom: 1px solid var(--border-color);
    cursor: pointer;
    transition: background-color 0.2s;
}

/* ▼▼▼ 【全新】BGM搜索结果弹窗样式 ▼▼▼ */

.search-result-item {
    display: flex;
    flex-direction: column;
    padding: 12px 18px;
    border-bottom: 1px solid var(--border-color);
    cursor: pointer;
    transition: background-color 0.2s;
}

.search-result-item:hover {
    background-color: rgba(0, 0, 0, 0.1);
}

#phone-screen.dark-mode .search-result-item:hover {
    background-color: rgba(255, 255, 255, 0.1);
}

.search-result-item .title {
    font-weight: 500;
    font-size: 15px;
    color: var(--text-primary);
}

.search-result-item .artist {
    font-size: 12px;
    color: var(--text-secondary);
    margin-top: 4px;
}

.search-result-item .source {
    font-size: 10px;
    color: var(--accent-color);
    background-color: rgba(0, 123, 255, 0.1);
    padding: 2px 6px;
    border-radius: 4px;
    font-weight: bold;
    margin-left: 8px;
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】BGM搜索源选择弹窗样式 ▼▼▼ */
#music-source-selector-modal .modal-body label {
    font-size: 16px;
    display: flex;
    align-items: center;
    gap: 10px;
}
#music-source-selector-modal .modal-body input[type="radio"] {
    width: 18px;
    height: 18px;
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 用这整块【布局微调版】样式，替换掉上一次的旧样式 ▼▼▼ */

/* 1. 闪烁动画 (保持不变) */
@keyframes flash-char {
    0%, 100% { opacity: 1; transform: scale(1); box-shadow: 0 0 3px rgba(255,192,203, 0); }
    50% { opacity: 0.8; transform: scale(1.08); box-shadow: 0 0 12px rgba(255,192,203, 0.9); }
}
@keyframes flash-user {
    0%, 100% { opacity: 1; transform: scale(1); box-shadow: 0 0 3px rgba(173,216,230, 0); }
    50% { opacity: 0.8; transform: scale(1.08); box-shadow: 0 0 12px rgba(173,216,230, 0.9); }
}

/* 2. 【核心修改】调整头像容器的下边距 */
#music-avatars-container {
    display: flex;
    justify-content: center;
    align-items: center;
    margin-bottom: 8px; /* <<<< 从 25px 减小到 8px，让它和下面的文字更近 */
    position: relative;
    z-index: 5;
}

/* 3. 单个头像样式 (保持不变) */
#music-avatars-container img {
    width: 35px;
    height: 35px;
    border-radius: 50%;
    object-fit: cover;
    border: 2px solid rgba(255, 255, 255, 0.8);
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
}

/* 4. 分开闪烁动画 (保持不变) */
#music-avatars-container.flashing #music-char-avatar {
    animation: flash-char 2.2s infinite ease-in-out;
}
#music-avatars-container.flashing #music-user-avatar {
    animation: flash-user 2.2s infinite ease-in-out 0.3s;
}

/* 5. 心电图样式 (保持不变) */
#heartbeat-line {
    width: 80px;
    height: 30px;
    overflow: visible;
    margin: 0 -15px;
    opacity: 0;
    transition: opacity 0.5s;
}
#music-avatars-container.flashing #heartbeat-line {
    opacity: 1;
}
.heartbeat-path {
    stroke: #FFC0CB;
    stroke-width: 1.5;
    fill: none;
    stroke-dasharray: 100;
    stroke-dashoffset: 100;
    animation: draw-line 2.2s infinite linear;
    filter: drop-shadow(0 0 3px #FFC0CB); 
}
.heartbeat-heart {
    display: none;
}
@keyframes draw-line {
    to { stroke-dashoffset: 0; }
}

/* 6. 【核心修改】调整“一起听了”文字的样式和边距 */
#music-time-counter {
    margin-bottom: 20px; /* <<<< 现在由它来负责和下面的封面拉开距离 */
    font-size: 11px;
    color: #666; /* 颜色稍微加深一点 */
    text-align: center;
}

/* 7. 唱片旋转动画 (保持不变) */
@keyframes spin-record {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

/* 8. 封面和歌词的切换容器 (保持不变) */
#music-display-area {
    width: 192px;
    height: 192px;
    margin-bottom: 15px;
    cursor: pointer;
    -webkit-tap-highlight-color: transparent;
    transition: transform 0.3s ease;
}
#music-display-area:active {
    transform: scale(0.98);
}

/* 9. 歌曲封面 (保持不变) */
#music-album-cover {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 50%;
    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    display: block;
}
#music-album-cover.rotating {
    animation: spin-record 10s linear infinite;
}
#music-album-cover.paused {
    animation-play-state: paused;
}

/* 10. 其他样式 (保持不变) */
#music-lyrics-container { display: none; }
#music-display-area.show-lyrics #music-album-cover { display: none; }
#music-display-area.show-lyrics #music-lyrics-container { display: block; }
#music-player-song-title { margin-bottom: 2px; }
#music-player-artist { margin-bottom: 10px; }
.music-player-window { min-height: 480px; }

/* ▲▲▲ 布局微调版样式粘贴结束 ▲▲▲ */
/* ▼▼▼ 【最终修复版】提升搜索相关弹窗的层级 ▼▼▼ */
#music-source-selector-modal,
#custom-modal-overlay {
    z-index: 250 !important; /* 这个值必须高于播放列表(210)，!important确保它拥有最高优先级 */
}
/* ▲▲▲ 粘贴结束 ▲▲▲ */
/* ▼▼▼ 步骤 1：把这一整块全新的CSS，粘贴到 <style> 的末尾 ▼▼▼ */

/* --- 1. 隐藏旧的主屏幕元素 --- */
/* 我们不再需要旧的锁屏时钟和图标网格了，新的布局会完全取代它们 */
#home-screen #clock-container,
#home-screen .app-grid {
    display: none !important;
}

/* --- 2. 【核心】重新定义主屏幕布局 --- */
/* 
   这将把你的主屏幕从一个简单的垂直列表，变成一个撑满全屏、
   使用Flexbox布局的强大容器，为新的“桌面式”布局打下基础。
*/
/* --- 2. 【核心】重新定义主屏幕布局 --- */
#home-screen {
    /* 使用一个漂亮的线性渐变作为默认背景，当然你可以在“外观设置”里随时换掉它 */
    background: linear-gradient(135deg, #6DD5FA, #2980B9);
    background-size: cover;
    background-position: center;
    
    /* 适配iPhone刘海和底部安全区 */
    padding-top: calc(20px + env(safe-area-inset-top));
    padding-bottom: calc(20px + env(safe-area-inset-bottom));
    
    /* ▼▼▼ 在这里添加下面这两行 ▼▼▼ */
    padding-left: 0;
    padding-right: 0;
    /* ▲▲▲ 添加结束 ▲▲▲ */

    /* 使用Flexbox让内容区和Dock栏上下分离 */
    display: flex;
    flex-direction: column;
    justify-content: space-between; 
    align-items: center;
    height: 100%; /* 确保它撑满屏幕 */
}


/* --- 3. 中间主要内容区 (个人资料卡 + 小组件 + App图标) --- */
#main-content-area {
    width: 100%;
    display: flex;
    flex-direction: column;
    gap: 30px; /* 卡片和下方图标的间距 */
    align-items: center;
    margin-top: 20px; /* 距离屏幕顶部一点距离 */
}

/* --- 4. 个人资料卡片 (这是视觉核心) --- */

/* 4a. 卡片外层容器：这是所有内部元素定位的“锚点” */
#profile-widget {
    position: relative; /* 关键：让内部的头像和伪元素可以相对于它进行绝对定位 */
    width: 100%;
    max-width: 380px;
    flex-shrink: 0;
}

/* 4b. 背景头图：只给顶部设置圆角 */
#profile-banner-img {
    display: block; 
    width: 100%;
    height: 150px;
    object-fit: cover;
    border-radius: 24px 24px 0 0; /* 只给顶部设置圆角 */
    position: relative;
    z-index: 1; /* 层级1：在最下方 */
}

/* 4c. 头像容器：精确定位，使其中心线与头图底部对齐 */
#profile-widget .profile-avatar-container {
    position: absolute;
    top: 80px; /* 从顶部向下偏移，让它一半在头图上，一半在下面 */
    left: 50%;
    transform: translateX(-50%);
    width: 80px;
    height: 80px;
    border-radius: 50%;
    background-color: white; /* 白色背景板，让头像更突出 */
    padding: 4px; /* 白色边框的效果 */
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    z-index: 3; /* 层级3：最高层，压住一切 */
}

#profile-avatar-img {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
}

/* 4d. 白色信息卡片：使用负外边距实现无缝拼接 */
#profile-widget .profile-info {
  /* 【修改后】白色到透明的渐变背景，并加上一层柔和的阴影 */
background: linear-gradient(to bottom, rgba(255, 255, 255, 0.85) 20%, rgba(255, 255, 255, 0));
box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
    border-radius: 24px;
    
    /* 核心魔法：使用负外边距，将卡片向上移动，与头图和头像重叠 */
    margin-top: -24px; 
    
    /* 同时，为上移的头像留出精确的空间，避免文字压住头像 */
    padding-top: 54px; /* 头像半径(40px) + 额外间距(14px) */
    
    min-height: 120px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    justify-content: center;
    padding-left: 15px;
    padding-right: 15px;
    padding-bottom: 15px;
    text-align: center;
    color: #1c1c1e;
    position: relative;
    z-index: 2; /* 层级2：在头图之上，但在头像之下 */
}

/* 4e. 个人资料内部的文字样式 */
#profile-username { font-size: 18px; font-weight: 600; margin: 0 0 2px 0; }
#profile-sub-username { font-size: 13px; color: #8a8a8a; margin: 0 0 10px 0; }
#profile-bio { font-size: 14px; margin: 0 0 12px 0; color: #333; }
#profile-location {
    font-size: 12px; color: #8a8a8a; margin: 0 auto; display: inline-flex;
    align-items: center; gap: 4px; background-color: rgba(0,0,0,0.05);
    padding: 3px 9px; border-radius: 10px;
}

/* --- 5. 桌面式布局 (小组件 + App图标) --- */
#desktop-layout {
    display: grid; /* 使用Grid布局，轻松实现两列 */
    grid-template-columns: 1fr 1.1fr; /* 左窄右宽的两列 */
    gap: 20px;
    width: 100%;
    align-items: start;
}
#desktop-widget-column {
    display: flex;
    flex-direction: row;
    justify-content: space-between; /* 【核心修改】将 space-around 改为 space-between */
    align-items: start;
    width: 100%;
}

/* 右侧App图标容器 */
#desktop-app-container {
    display: grid;
    grid-template-columns: 1fr 1fr; /* 两列图标 */
    gap: 25px;
    align-content: start;
}
.desktop-app-icon {
    display: flex; flex-direction: column; align-items: center; gap: 8px; cursor: pointer; text-align: center;
}
.icon-bg-desktop {
    width: 55px; height: 55px; border-radius: 14px; background-color: #f0f2f5; justify-content: center; box-shadow: 0 4px 10px rgba(0,0,0,0.1); transition: transform 0.2s ease; overflow: hidden;
}
.icon-bg-desktop img { width: 100%; height: 100%; object-fit: cover; border-radius: 0; }
.desktop-app-icon .label { color: #333; font-size: 13px; font-weight: 500; }
.desktop-app-icon:active .icon-bg-desktop { transform: scale(0.9); }


/* --- 6. 底部 Dock 栏 --- */
#desktop-dock {
    background-color: rgba(255, 255, 255, 0.15); /* 玻璃拟态背景 */
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-radius: 20px;
    padding: 15px 25px;
    display: flex;
    justify-content: center;
    gap: 30px;
    width: fit-content; /* 宽度自适应内容 */
    flex-shrink: 0;
}

/* --- 7. 【核心功能】为可编辑元素添加视觉反馈 --- */
.editable-text, .editable-image {
    cursor: pointer;
    transition: all 0.2s ease-in-out;
}

/* 鼠标悬停时，显示一个半透明的虚线外框，并轻微变暗，提示用户这里可以点 */
.editable-text:hover, .editable-image:hover {
    outline: 2px dashed rgba(0, 0, 0, 0.4);
    opacity: 0.85;
    border-radius: 4px; /* 让外框也有一点圆角 */
}

/* --- 8. 【锁屏兼容】让锁屏和主屏幕可以堆叠 --- */
#lock-screen, #home-screen {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}
#lock-screen {
    z-index: 999; /* 确保锁屏在最上层 */
}
/* ▼▼▼ 这是新增的桌面小组件样式 ▼▼▼ */

/* 单个小组件的总容器 */
.custom-widget-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px; /* 各个元素之间的垂直间距 */
}

.widget-bubble {
    position: relative;
    background-color: rgba(255, 255, 255, 0.9);
    color: #333;
    padding: 8px 12px;
    border-radius: 20px; /* 【核心修改】增加圆角，实现胶囊感 */
    font-size: 13px;
    font-weight: 500;
    /* 【核心修改】移除 min-width，让宽度自适应内容 */
    text-align: center;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}


/* 用伪元素给气泡加一个小尾巴，指向下面的圆形图片 */
.widget-bubble::after {
    content: '';
    position: absolute;
    bottom: -6px; /* 尾巴在气泡下方 */
    left: 50%;
    transform: translateX(-50%);
    border-width: 6px 6px 0;
    border-style: solid;
    border-color: rgba(255, 255, 255, 0.9) transparent transparent transparent;
}

.widget-circle-uploader {
    width: 65px; /* 从 80px 缩小 */
    height: 65px; /* 从 80px 缩小 */
    border-radius: 50%;
    border: 2px solid rgba(255, 255, 255, 0.5);
    box-shadow: 0 4px 10px rgba(0,0,0,0.15);
    padding: 3px;
    background-color: transparent; /* 【核心修改】将背景色改为透明 */ 
    box-sizing: border-box;
}


/* 这是替换后的第二块 */
.widget-circle-uploader img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 50%; /* 【核心】让图片也变成圆形，完美适应内边距 */
}


/* 下方的透明文字区域 */
.widget-subtext {
    background: transparent;
    border: none;
    color:  #333;
    text-shadow: 0 1px 3px rgba(0,0,0,0.5); /* 加一点文字阴影更清晰 */
    font-size: 13px;
    font-weight: 500;
    text-align: center;
}

/* ▲▲▲ 新增样式结束 ▲▲▲ */
/* ▼▼▼ 【V3最终美化版】主屏幕美化预设功能样式 ▼▼▼ */
.preset-manager-container {
    width: 100%;
    margin-top: 20px;
    padding-top: 20px;
    border-top: 1px solid var(--border-color);
}
#phone-screen.dark-mode .preset-manager-container {
    border-top-color: #3a3a3c;
}
.preset-manager-container .form-group {
    display: flex;
    flex-direction: column;
    gap: 10px;
}
.preset-manager-controls {
    display: grid;
    grid-template-columns: 1fr 1fr; /* 【核心】2x2 网格布局 */
    gap: 12px; /* 按钮间距 */
    width: 100%;
}
.preset-btn-capsule {
    padding: 12px 15px; /* 增加垂直内边距，让按钮更高更可爱 */
    border: none;
    border-radius: 25px; /* 更大的圆角，胶囊感更强 */
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 3px 6px rgba(0,0,0,0.08); /* 增加一点立体阴影 */
}
.preset-btn-capsule:active {
    transform: scale(0.96);
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}
.preset-btn-capsule:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    box-shadow: none;
    background-color: #e9ecef !important; /* 禁用时统一用灰色 */
    color: #adb5bd !important;
    border-color: #dee2e6 !important;
}
#phone-screen.dark-mode .preset-btn-capsule:disabled {
    background-color: #3a3a3c !important;
    color: #545458 !important;
}
.preset-btn-apply {
    background-color: var(--accent-color); /* 应用按钮使用主题色 */
    color: white;
    grid-column: 1 / -1; /* 【核心】让应用按钮独占一行，更突出 */
}
.preset-btn-save {
    background-color: #4cd964; /* 保存用绿色，代表创建 */
    color: white;
}
.preset-btn-secondary {
    background-color: #f8f9fa;
    color: var(--text-primary);
    border: 1px solid var(--border-color);
}
#phone-screen.dark-mode .preset-btn-secondary {
    background-color: #3a3a3c;
    border-color: #545458;
}
.preset-btn-delete {
    background-color: #ffdde5;
    color: #ff3b30;
}
#phone-screen.dark-mode .preset-btn-delete {
    background-color: #5c2b2b;
    color: #ff8a80;
}
/* ▲▲▲ 样式粘贴结束 ▲▲▲ */



/* ▼▼▼ 【V6最终修复版】夜间模式终极适配 (已修复所有页面适配问题) ▼▼▼ */

/* 核心：当 #phone-screen 拥有 .dark-mode 类时，激活以下所有样式 */

/* 1. 全局重新定义颜色变量 */
#phone-screen.dark-mode {
  --secondary-bg: #1c1c1e;
  --border-color: #38383a;
  --text-primary: #ffffff;
  --text-secondary: #8e8e93;
  --status-bar-text-color: #ffffff;
}

/* 2. 【基础】为所有屏幕和主要容器设置基础深色背景 */
#phone-screen.dark-mode,
#phone-screen.dark-mode .screen,
#phone-screen.dark-mode #chat-list,
#phone-screen.dark-mode #world-book-list,
#phone-screen.dark-mode .list-container,
#phone-screen.dark-mode .form-container,
#phone-screen.dark-mode #chat-messages {
    background-color: #000000 !important;
}

/* 3. 【主屏幕】专属样式 (从被删除的代码中恢复并整合) */
#phone-screen.dark-mode #home-screen {
    background: #111827; /* 深蓝色背景 */
}
#phone-screen.dark-mode #desktop-dock {
    background-color: rgba(55, 65, 81, 0.5); /* Dock栏深灰色玻璃效果 */
}
#phone-screen.dark-mode .desktop-app-icon .label,
#phone-screen.dark-mode .widget-subtext {
    color: #e5e7eb; /* 桌面文字变为浅灰色 */
    text-shadow: 0 1px 2px rgba(0,0,0,0.7); /* 加强阴影 */
}
#phone-screen.dark-mode #profile-widget .profile-info {
    background: linear-gradient(to bottom, rgba(28, 28, 30, 0.85) 20%, rgba(28, 28, 30, 0)); /* 信息卡片深灰色渐变 */
    color: #f9fafb;
}
#phone-screen.dark-mode #profile-username,
#phone-screen.dark-mode #profile-bio,
#phone-screen.dark-mode #profile-location span {
    color: #f9fafb; /* 信息卡片主文字白色 */
}
#phone-screen.dark-mode #profile-sub-username,
#phone-screen.dark-mode #profile-location {
    color: #9ca3af; /* 信息卡片次要文字灰色 */
}
#phone-screen.dark-mode #profile-location {
    background-color: rgba(255,255,255,0.1); /* 地点背景变亮 */
}
#phone-screen.dark-mode .widget-bubble {
    background-color: rgba(55, 65, 81, 0.9); /* 小组件气泡深灰色 */
    color: #e5e7eb; /* 小组件文字浅灰色 */
}
#phone-screen.dark-mode .widget-bubble::after {
    border-top-color: rgba(55, 65, 81, 0.9); /* 小尾巴颜色同步 */
}

/* 4. 【修复】适配所有页面的头部Header */
#phone-screen.dark-mode .header,
#phone-screen.dark-mode .qzone-header {
    background-color: rgba(28, 28, 30, 0.85) !important;
    border-bottom-color: var(--border-color) !important;
    color: var(--text-primary) !important; 
}

/* 5. 【修复】适配所有通用组件 (弹窗、输入框等) */
#phone-screen.dark-mode #chat-input-area,
#phone-screen.dark-mode #chat-list-bottom-nav {
    background-color: rgba(28, 28, 30, 0.85);
    border-top-color: var(--border-color);
}
#phone-screen.dark-mode #chat-input {
    background-color: var(--secondary-bg);
    color: var(--text-primary);
}
#phone-screen.dark-mode .modal-content,
#phone-screen.dark-mode #custom-modal {
    background-color: #2c2c2e;
}
#phone-screen.dark-mode .modal-header, 
#phone-screen.dark-mode .modal-footer,
#phone-screen.dark-mode .custom-modal-footer {
    border-color: var(--border-color);
}
#phone-screen.dark-mode .form-group input,
#phone-screen.dark-mode .form-group select,
#phone-screen.dark-mode .form-group textarea {
    background-color: var(--secondary-bg);
    color: var(--text-primary);
    border-color: var(--border-color);
}
#phone-screen.dark-mode .list-item,
#phone-screen.dark-mode .chat-list-item-swipe-container:not(:last-child) {
    border-bottom-color: var(--border-color);
}
#phone-screen.dark-mode .list-item:hover,
#phone-screen.dark-mode .chat-list-item:hover {
    background-color: #2c2c2e;
}

/* 6. 【解决】字体预设 & 外观设置页面深度适配 */
#phone-screen.dark-mode #font-settings-screen,
#phone-screen.dark-mode #wallpaper-screen {
    background-color: #000000;
}
#phone-screen.dark-mode .font-preset-slot,
#phone-screen.dark-mode #font-preview,
#phone-screen.dark-mode #wallpaper-preview {
    background-color: var(--secondary-bg);
    border-color: var(--border-color);
}
#phone-screen.dark-mode .preset-btn.secondary {
    background-color: #3e3e42;
    border-color: #545458;
}

/* 7. 【解决】“查手机”功能所有内部页面深度适配 */
#phone-screen.dark-mode #character-phone-container {
    background-color: #000000;
}
#phone-screen.dark-mode .character-phone-frame {
    background-color: #111;
}
#phone-screen.dark-mode .character-phone-inner-screen,
#phone-screen.dark-mode .character-phone-page {
    background-color: #000000;
}
#phone-screen.dark-mode .character-phone-header {
    background-color: rgba(28, 28, 30, 0.85) !important;
    border-bottom: 1px solid #38383a !important;
}
#phone-screen.dark-mode #character-app-grid .label {
    color: #e5e7eb;
}
#phone-screen.dark-mode .character-chat-list .chat-list-item:hover {
    background-color: #1c1c1e;
}
#phone-screen.dark-mode #character-chat-history-messages {
    background-color: #0e0e0e !important;
}
#phone-screen.dark-mode .character-chat-bubble.received {
    background-color: #2c2c2e;
}
#phone-screen.dark-mode .character-data-item,
#phone-screen.dark-mode .character-bank-transaction,
#phone-screen.dark-mode .character-cart-item,
#phone-screen.dark-mode .character-browser-item {
    background-color: #1c1c1e;
    border-color: #38383a;
}
#phone-screen.dark-mode .character-data-item .title,
#phone-screen.dark-mode .character-data-item .content,
#phone-screen.dark-mode .cart-item-price {
    color: var(--text-primary);
}
#phone-screen.dark-mode .character-bank-balance-card {
    background: linear-gradient(135deg, #3a3a3c, #1c1c1e);
}
#phone-screen.dark-mode #character-diary-list .character-data-item {
    background-color: #1a1510;
    border-color: #4a443b;
    border-left-color: #8c7d6b;
}
#phone-screen.dark-mode #character-select-item .name {
    color: #80CBC4 !important; /* 柔和的青色 */
}

/* 8. 【新增】修复聊天列表分组标题的背景色 */
#phone-screen.dark-mode .chat-group-header {
    background-color: #1c1c1e;
}
#phone-screen.dark-mode .chat-list-item-content.pinned {
    background-color: #3a3a3c;
}

/* ▲▲▲ CSS 代码粘贴结束 ▲▲▲ */
/* ▼▼▼ 步骤 1.1：将这整块【终极修复版】CSS粘贴到 <style> 的末尾 ▼▼▼ */

/* 核心修复：使用 !important 强制提升优先级，覆盖掉所有捣乱的内联样式 */

/* 1. 为所有需要适配的屏幕强制设置纯黑背景 */
#phone-screen.dark-mode #wallpaper-screen,
#phone-screen.dark-mode #font-settings-screen,
#phone-screen.dark-mode #api-settings-screen,
#phone-screen.dark-mode #character-selection-screen,
#phone-screen.dark-mode #world-book-screen,
#phone-screen.dark-mode #world-book-editor-screen,
#phone-screen.dark-mode .form-container, /* 确保所有表单容器也适配 */
#phone-screen.dark-mode .list-container { /* 确保所有列表容器也适配 */
    background-color: #000000 !important;
}

/* 2. 为“查手机”内部的所有页面强制设置纯黑背景 */
#phone-screen.dark-mode .character-phone-inner-screen,
#phone-screen.dark-mode .character-phone-page {
    background-color: #000000 !important;
}
#phone-screen.dark-mode #character-chat-history-messages {
    background-color: #0e0e0e !important; /* 聊天记录用深灰色 */
}

/* 3. 修复页面内部组件的背景色 */
#phone-screen.dark-mode #font-preview,
#phone-screen.dark-mode #wallpaper-preview {
    background-color: #1c1c1e !important;
    border-color: #38383a !important;
}

/* 4. 修复“查手机”里对方的聊天气泡颜色 */
#phone-screen.dark-mode .character-chat-bubble.received {
    background-color: #2c2c2e !important;
}
/* ▼▼▼ 【最终修复版】提升所有弹窗的层级 ▼▼▼ */
#music-source-selector-modal,
#music-search-results-modal {
    z-index: 250 !important; /* 这个值高于播放列表(210)，!important确保它拥有最高优先级 */
}
/* ▲▲▲ 粘贴结束 ▲▲▲ */
/* ▼▼▼ 把这一整块全新的CSS，粘贴到 <style> 的末尾 ▼▼▼ */

/* 【全新美化版】通用操作菜单按钮 */
#preset-actions-modal .custom-modal-footer button {
    width: 100%;
    border: none; /* 移除边框 */
    border-radius: 20px; /* ★★★ 修改这里！把 12px 改成了 20px ★★★ */
    padding: 14px;
    font-size: 16px; /* 字体稍微缩小一点，更精致 */
    font-weight: 500;
    margin-bottom: 8px; /* 按钮之间的垂直间距 */
    background-color: #f0f0f0; /* 统一的浅灰色背景 */
    color: var(--text-primary);
    transition: background-color 0.2s, transform 0.1s; /* 添加动画 */
}

/* 鼠标悬停和点击效果 */
#preset-actions-modal .custom-modal-footer button:hover {
    background-color: #e0e0e0;
}
#preset-actions-modal .custom-modal-footer button:active {
    transform: scale(0.98); /* 点击时轻微缩小 */
}

/* 单独美化“删除”按钮 */
#preset-actions-modal .custom-modal-footer button.btn-danger {
    background-color: #ffe5e5;
    color: #ff3b30;
}
#preset-actions-modal .custom-modal-footer button.btn-danger:hover {
    background-color: #ffcccc;
}

/* 美化“取消”按钮 */
#preset-actions-modal .custom-modal-footer button:last-child {
    background-color: #e9ecef;
    margin-top: 4px; /* 和上面的按钮稍微拉开一点距离 */
}
#preset-actions-modal .custom-modal-footer button:last-child:hover {
    background-color: #dcdfe3;
}

/* 移除按钮之间的分割线 */
#preset-actions-modal .custom-modal-footer button {
    border-bottom: none !important;
}

/* ▲▲▲ 粘贴结束 ▲▲▲ */
/* ▼▼▼ 把这一整块全新的CSS，粘贴到 <style> 的末尾 ▼▼▼ */

/* 【核心修正】提升通用操作菜单的层级，确保它能覆盖播放列表 */
#preset-actions-modal {
    z-index: 220; /* 这个值比播放列表(210)更高，就不会被挡住了 */
}

/* ▲▲▲ 粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】这是为“查手机”内容添加的删除按钮样式 ▼▼▼ */
.character-data-item, .character-cart-item, .character-browser-item, .character-bank-transaction, .character-trajectory-item, .character-app-usage-item, .character-album-item {
    position: relative; /* 让删除按钮可以相对于它定位 */
    padding-right: 35px; /* 在右边给删除按钮留出位置 */
}

.item-delete-btn {
    position: absolute;
    top: 50%;
    right: 10px;
    transform: translateY(-50%);
    width: 24px;
    height: 24px;
    background-color: #f0f0f0;
    color: #888;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    font-size: 18px;
    line-height: 24px;
    text-align: center;
    transition: all 0.2s ease;
}

.item-delete-btn:hover {
    background-color: #ff3b30;
    color: white;
}
/* ▲▲▲ 新增样式结束 ▲▲▲ */
/* ▼▼▼ 【全新】角色手机微信消息删除按钮样式 ▼▼▼ */
.character-chat-bubble-container {
    position: relative; /* 让删除按钮可以相对于它定位 */
}

.message-delete-btn {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    width: 22px;
    height: 22px;
    background-color: rgba(0, 0, 0, 0.1);
    color: #555;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    font-size: 16px;
    line-height: 22px;
    text-align: center;
    opacity: 0; /* 默认隐藏 */
    transition: all 0.2s ease;
}

.character-chat-bubble-container:hover .message-delete-btn {
    opacity: 1; /* 鼠标悬停时显示 */
}

.message-delete-btn:hover {
    background-color: #ff3b30;
    color: white;
}

/* 根据消息是左是右，调整删除按钮的位置 */
.character-chat-bubble-container.sent .message-delete-btn {
    left: -28px;
}
.character-chat-bubble-container.received .message-delete-btn {
    right: -28px;
}
/* ▲▲▲ 新增样式结束 ▲▲▲ */

/* ▲▲▲ CSS 粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新添加】强制修正所有设置页面的底部安全区 ▼▼▼ */
#font-settings-screen .form-container,
#wallpaper-screen .form-container,
#api-settings-screen .form-container,
#css-editor-screen .form-container {
    padding-bottom: calc(20px + env(safe-area-inset-bottom));
}
/* ▲▲▲ 添加结束 ▲▲▲ */


/* ▼▼▼ 【全新】iOS风格的滑动开关样式 ▼▼▼ */

.toggle-switch-label {
    display: flex;
    align-items: center;
    justify-content: space-between; /* 让文字和开关两端对齐 */
    cursor: pointer;
    user-select: none;
    width: 100%;
    padding: 10px 0; /* 增加一点上下间距 */
}

.toggle-switch-text {
    font-weight: 500;
    color: var(--text-primary);
}

/* 隐藏原始的 checkbox */
.toggle-switch-label input[type="checkbox"] {
    opacity: 0;
    width: 0;
    height: 0;
    position: absolute;
}

/* 开关的轨道 */
.toggle-switch-slider {
    position: relative;
    display: inline-block;
    width: 51px;
    height: 31px;
    background-color: #e9e9eb;
    border-radius: 34px;
    transition: background-color 0.2s;
    flex-shrink: 0; /* 防止被压缩 */
}

/* 开关的滑块 (那个白色圆点) */
.toggle-switch-slider::before {
    content: "";
    position: absolute;
    height: 27px;
    width: 27px;
    left: 2px;
    bottom: 2px;
    background-color: white;
    border-radius: 50%;
    transition: transform 0.2s;
    box-shadow: 0 1px 3px rgba(0,0,0,0.15);
}

/* 当 checkbox 被选中时，改变轨道的颜色 */
.toggle-switch-label input:checked + .toggle-switch-slider {
    background-color: #34c759; /* iOS 风格的绿色 */
}

/* 当 checkbox 被选中时，移动滑块 */
.toggle-switch-label input:checked + .toggle-switch-slider::before {
    transform: translateX(20px);
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
/* ▼▼▼ 这是为你新增的颜色样式 ▼▼▼ */

/* 1. 把时间的颜色强制设置为黑色 */
#status-bar-time {
    color: #000000 !important; /* !important 确保它优先级最高 */
}

/* 2. 把电池容器内的所有东西（图标边框、电量条、百分比文字）都设置为绿色 */
#status-bar-battery {
    color: #4CAF50 !important; /* 这是一个很好看的绿色 */
}

/* ▲▲▲ 新增样式结束 ▲▲▲ */
/* ▼▼▼ 这是步骤1需要粘贴的新样式 ▼▼▼ */

/* 让每一条评论都变成可点击的 */
.comment-item {
    cursor: pointer; /* 鼠标悬停时显示为小手形状 */
    transition: background-color 0.2s; /* 添加一个平滑的背景色过渡动画 */
    border-radius: 4px; /* 给一点点圆角，更好看 */
    padding: 2px 5px; /* 增加一点内边距，让点击区域更大 */
    margin: 0 -5px; /* 把上面的内边距抵消掉，保持对齐 */
}
.comment-item:hover {
    background-color: #f0f2f5; /* 鼠标放上去时，给一个淡淡的背景色 */
}
#phone-screen.dark-mode .comment-item:hover {
    background-color: #2c2c2e; /* 夜间模式下的悬停颜色 */
}

/* “回复”这两个字的样式 */
.comment-item .reply-text {
    color: var(--text-secondary);
    margin: 0 4px; /* 和两边的名字拉开一点距离 */
}

/* 被回复者的名字样式 */
.comment-item .reply-target-name {
    font-weight: 600;
    color: var(--accent-color);
    cursor: pointer;
    margin-right: 5px;
}
/* ▼▼▼ 【全新】聊天记录搜索功能样式 ▼▼▼ */

/* 搜索结果列表 */
#chat-search-results-list {
    flex-grow: 1; /* 占据剩余所有空间 */
    overflow-y: auto; /* 内容多了可以滚动 */
}

/* 单条搜索结果的样式 */
.search-result-item {
    padding: 12px 15px;
    border-bottom: 1px solid var(--border-color);
    cursor: pointer;
    display: flex;
    gap: 12px; /* 头像和内容的间距 */
    align-items: flex-start;
}
.search-result-item:hover {
    background-color: #f5f5f5;
}
#phone-screen.dark-mode .search-result-item:hover {
    background-color: #2c2c2e;
}

/* 结果中的头像 */
.search-result-item .avatar {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    flex-shrink: 0;
}

/* 结果右侧信息（名字、时间、内容） */
.search-result-info {
    display: flex;
    flex-direction: column;
    gap: 4px; /* 信息内部的垂直间距 */
    overflow: hidden; /* 防止内容过长溢出 */
}

/* 名字和时间的容器 */
.search-result-meta {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 12px;
    color: var(--text-secondary);
}

.search-result-meta .name {
    font-weight: 600;
    color: var(--text-primary);
    font-size: 14px;
}

/* 消息内容 */
.search-result-content {
    font-size: 14px;
    line-height: 1.5;
    word-break: break-all; /* 确保长文本能换行 */
}

/* 【核心】关键词高亮样式 */
.highlight {
    background-color: #FFDE5C; /* 亮黄色背景 */
    color: #5D4037; /* 深棕色文字，对比更清晰 */
    font-weight: bold;
    padding: 1px 3px;
    border-radius: 3px;
}

/* 跳转后消息的闪烁动画 */
@keyframes flash-highlight {
    0% { background-color: transparent; }
    25% { background-color: rgba(255, 222, 92, 0.7); }
    100% { background-color: transparent; }
}
.message-bubble.flash {
    animation: flash-highlight 1.5s ease-out;
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
/* ▼▼▼ 【最终修复】解决搜索结果看不见的问题 ▼▼▼ */
#chat-search-screen .form-container {
    padding-bottom: 20px; /* 给底部一点空间 */
}

#search-results-list {
    flex-grow: 1; /* 核心：让结果列表占据所有剩余的垂直空间 */
    overflow-y: auto; /* 核心：如果结果太多，让它自己出现滚动条 */
    min-height: 0; /* 一个神奇的CSS属性，用于解决flex布局下的溢出问题 */
    border-top: 1px solid var(--border-color); /* 在结果和按钮之间加一条分割线，更美观 */
    margin-top: 15px; /* 和上面的按钮拉开距离 */
    padding-top: 10px; /* 列表顶部的内边距 */
}
/* ▲▲▲ 修复结束 ▲▲▲ */
/* ▼▼▼ 把这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* 统一样式，让图标和文字按钮对齐 */
#music-playlist-panel .playlist-header .panel-btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
}

/* ▼▼▼ 用这块新代码替换旧的垃圾桶样式 ▼▼▼ */

/* 设置垃圾桶图标的默认样式 */
#delete-expired-songs-btn svg {
    color: inherit; /* 核心修改1: 平时颜色继承父元素，和"本地"等文字颜色一样，保持低调 */
    transition: color 0.2s, transform 0.2s; /* 添加transform过渡效果 */
    transform: translateY(3px); /* 核心修改2: 让图标整体下移3像素，视觉上更对齐 */
}

/* 设置鼠标悬停/点击时的样式 */
#delete-expired-songs-btn:hover svg,
#delete-expired-songs-btn:active svg {
    color: #ff3b30; /* 核心修改3: 鼠标放上去或点击时，才变为醒目的红色 */
}

/* ▲▲▲ 替换结束 ▲▲▲ */
/* ▼▼▼ 把这一整块全新的CSS，粘贴到 <style> 的末尾 ▼▼▼ */

/* 【核心】专门为角色手机里的日记删除按钮，重新定义位置 */
#character-diary-list .character-data-item .item-delete-btn {
    top: auto;         /* 解除顶部的定位 */
    right: auto;       /* 解除右侧的定位 */
    bottom: 8px;       /* 定位到距离底部8像素 */
    left: 8px;         /* 定位到距离左侧8像素 */
    opacity: 0;        /* 保持默认隐藏 */
    transition: opacity 0.2s ease; /* 保持淡入淡出动画 */
}

/* 【美化】鼠标悬停在整张日记卡片上时，才显示这个按钮 */
#character-diary-list .character-data-item:hover .item-delete-btn {
    opacity: 1;
}

/* ▲▲▲ 粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】心声功能样式 ▼▼▼ */

/* 1. 跳动的心动画 */
@keyframes heartbeat {
    0% { transform: scale(1); }
    50% { transform: scale(1.2); }
    100% { transform: scale(1); }
}
#char-heart-btn svg {
    animation: heartbeat 1.5s infinite ease-in-out;
}

/* 2. 心声面板主内容样式 (已修复) */
#inner-voice-avatar-wrapper::after {
    content: '';
    position: absolute;
    top: -3px;
    left: -3px;
    right: -3px;
    bottom: -3px;
    border: 1.5px solid transparent; /* 默认是透明边框，看不见 */
    border-radius: 50%;
    pointer-events: none;
    transition: border-color 0.2s ease-in-out; /* 添加平滑过渡 */
}
/* 【核心】仅当没有头像框时(.has-border)，才显示红线 */
#inner-voice-avatar-wrapper.has-border::after {
    border-color: #ff8a80; /* 你想要的红色轮廓线 */
}

#inner-voice-content-area p {
    white-space: pre-wrap; /* 让换行符和空格生效 */
    word-break: break-word; /* 防止长单词溢出 */
}

/* 3. 历史记录面板样式 */
.inner-voice-history-item {
    background-color: #fff;
    margin: 10px;
    padding: 12px;
    border-radius: 8px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.08);
}
.history-item-timestamp {
    font-size: 11px;
    color: #999;
    border-bottom: 1px solid #eee;
    padding-bottom: 8px;
    margin-bottom: 8px;
}
.history-item-content p {
    margin: 0 0 8px 0;
    font-size: 13px;
    line-height: 1.5;
    color: #444;
}
.history-item-content strong {
    font-size: 12px;
}
/* ▲▲▲ 心声功能样式结束 ▲▲▲ */
/* 【全新】心声历史记录单条删除按钮样式 */
.inner-voice-history-item {
    position: relative; /* 让删除按钮可以相对于它定位 */
}

.history-item-delete-btn {
    position: absolute;
    top: 8px;
    right: 8px;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    background-color: #f0f0f0;
    color: #888;
    border: none;
    cursor: pointer;
    font-size: 18px;
    line-height: 24px;
    text-align: center;
    transition: all 0.2s ease;
}

.history-item-delete-btn:hover {
    background-color: #ff3b30;
    color: white;
}
/* ▼▼▼ 在这里开始复制：【主题色版】可爱圆润按钮样式 ▼▼▼ */

/* --- 1. 再次设置通用的“可爱基础” --- */
#save-theme-btn,
#save-as-new-theme-btn,
#export-theme-btn,
#import-theme-btn,
#rename-theme-btn,
#delete-theme-btn {
    border: none;
    border-radius: 25px; /* 可爱的胶囊形状 */
    padding: 12px 18px;
    font-weight: 600;
    cursor: pointer;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.08);
    transition: all 0.2s ease-in-out;
    margin-top: 5px !important;
}

/* --- 2. 可爱的“按下”效果 --- */
#save-theme-btn:active,
#save-as-new-theme-btn:active,
#export-theme-btn:active,
#import-theme-btn:active,
#rename-theme-btn:active,
#delete-theme-btn:active {
    transform: scale(0.97);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

/* --- 3. 【核心修改】为不同功能的按钮设置配套颜色 --- */

/* “保存” 和 “另存为”：使用全局主题色！ */
#save-theme-btn,
#save-as-new-theme-btn {
    background-color: var(--accent-color); /* 这就是你的主题色！ */
    color: white;
}

/* “导出”、“导入”、“重命名”：使用柔和的次要样式 */
#export-theme-btn,
#import-theme-btn,
#rename-theme-btn {
    background-color: #f0f2f5;           /* 淡淡的灰色背景 */
    color: var(--accent-color);          /* 文字使用主题色 */
    border: 1px solid var(--accent-color); /* 再加一个主题色的边框，更精致 */
}

/* “删除”按钮：还是用可爱的粉红色来提醒，防止误触 */
#delete-theme-btn {
    background-color: #ffdde5; /* 淡淡的樱花粉背景 */
    color: #ff3b30;           /* 文字用醒目的红色 */
    border: 1px solid #ffc2d1;
}

/* --- 4. 鼠标放到不同按钮上时的颜色变化 --- */
#save-theme-btn:hover,
#save-as-new-theme-btn:hover {
    opacity: 0.85; /* 主题色按钮变淡一点点 */
}

#export-theme-btn:hover,
#import-theme-btn:hover,
#rename-theme-btn:hover {
    background-color: #e9ecef; /* 次要按钮背景加深一点点 */
}

#delete-theme-btn:hover {
    background-color: #ffc2d1; /* 删除按钮背景加深一点点 */
}

/* ▲▲▲ 复制到这里结束 ▲▲▲ */
/* ▼▼▼ 请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */
.action-icon.summon-npc svg {
    stroke-width: 1.5; /* 让图标线条稍微粗一点，更清晰 */
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
/* ▼▼▼ 请用下面这【一整块带有详细注释】的代码，完整替换掉你旧的微博主页布局CSS ▼▼▼ */

/* 1. 个人主页的滚动容器 (保持不变) */
#weibo-profile-page {
    flex-grow: 1;
    overflow-y: auto;
    background-color: #f0f2f5;
}

/* 2. 头部容器：负责背景图，并为下方内容留出空间 */
.weibo-profile-header {
    position: relative;
    height: 240px;
    /* 
      ★★★ 手动调整区：微博内容与上方区域的【上下间距】 ★★★
      这个值决定了你的第一条微博，和上方个人信息区域的距离。
      - 数值越大，间距越大，微博内容离得越远。
      - 数值越小，间距越小，微博内容离得越近。
      我已将它从 90px 减小到了 20px，你可以根据喜好再微调。
    */
    margin-bottom: -5px;/* ★ 修改这里 ★ */
}

/* 3. 背景图样式 (保持不变) */
.weibo-background {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
}

/* 4. 头像容器：实现悬浮效果的核心 */
.weibo-avatar-container {
    position: absolute;
    z-index: 3;
    width: 80px;
    height: 80px;
    border: 3px solid white;
    border-radius: 50%;
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    transform: none;

    /* ★★★ 手动调整区1: 头像位置 (左右 + 上下) ★★★ */

    /* --- 左右位置 --- */
    /* 数值越大，越往右。数值越小，越往左。*/
    left: 15px; /* ★ 修改这里 */

    /* --- 上下位置 --- */
    /* 数值越小 (比如 -50px), 越往下。数值越大 (比如 -30px), 越往上。*/
    bottom: 50px; /* ★ 修改这里 */
}

.weibo-avatar {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
}


/* 5. 昵称和职业信息 */
/* ★★★ 手动调整区2: 昵称位置 (左右 + 上下) ★★★ */
.weibo-nickname {
    position: absolute;
    z-index: 2;
    color: #1f1f1f;
    text-shadow: none;
    font-size: 18px;
    font-weight: 600;

    /* --- 左右位置 --- */
    /* 数值越大，越往右。数值越小，越往左。*/
    left: 35px; /* ★ 修改这里 */

    /* --- 上下位置 --- */
    /* 数值越小 (比如 -60px), 越往下。数值越大 (比如 -50px), 越往上。*/
    bottom: 30px; /* ★ 修改这里 */
}

/* ▼▼▼ 用这块新CSS替换掉旧的 ▼▼▼ */
#weibo-user-profession-display {
    position: absolute;
    left: 35px;          /* 修改：从 left 改为 right，让它靠右对齐 */
    bottom: -5px;        /* 修改：调整垂直位置，在头像下方 */
    z-index: 2;
    font-size: 13px;
    color: #8a8a8a;
    text-shadow: none;
    text-align: right;    /* 新增：让文字本身也靠右对齐，更美观 */
    cursor: pointer;      /* 新增：鼠标放上去时显示为小手形状 */
}








/* 6. 关注/粉丝/微博数据 */
/* ★★★ 手动调整区3: 关注/粉丝/微博 位置 (左右 + 上下) ★★★ */
.weibo-stats {
    position: absolute;
    z-index: 2;
    display: flex;
    gap: 20px;

    /* --- 左右位置 --- */
    /* 数值越大，越往右。数值越小，越往左。*/
    left: 35px; /* ★ 修改这里 */

    /* --- 上下位置 --- */
    /* 数值越小 (比如 -90px), 这行数据越往下。数值越大 (比如 -70px), 越往上。*/
    bottom: 15px; /* ★ 修改这里 */
}


/* 7. 单个数据项样式 (保持不变) */
.weibo-stat-item {
    display: flex;
    flex-direction: row;
    align-items: baseline;
    gap: 5px;
}
.weibo-stat-number {
    font-size: 14px;
    font-weight: 600;
    color: #333;
    text-shadow: none;
}
.weibo-stat-label {
    font-size: 13px;
    color: #888;
    text-shadow: none;
}

/* 8. 微博Feed列表 (保持不变) */
#my-weibo-feed-list {
    padding-top: 15px;
}

/* ▲▲▲ 微博样式替换结束 ▲▲▲ */



/* ▼▼▼ 【全新】微博页面框架和底部导航样式 ▼▼▼ */
#weibo-screen {
    display: flex;
    flex-direction: column;
}
.weibo-view {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: none; /* 默认隐藏所有页面 */
    flex-direction: column;
    background-color: #f0f2f5;
}
.weibo-view.active {
    display: flex; /* 只显示激活的页面 */
}
/* ▼▼▼ 【布局统一修复版】用这块代码完整替换掉你旧的 #weibo-bottom-nav 样式 ▼▼▼ */
#weibo-bottom-nav {
    /* --- 核心修改 --- */
    position: absolute; /* 1. 改为绝对定位，让它浮动起来 */
    bottom: 0;          /* 2. 固定在底部 */
    left: 0;            /* 3. 左侧对齐 */
    width: 100%;        /* 4. 宽度撑满 */
    
    /* --- 其他样式保持不变 --- */
    z-index: 15;
    display: flex;
    border-top: 1px solid var(--border-color);
    background-color: rgba(247, 247, 247, 0.9);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding-bottom: env(safe-area-inset-bottom);
}
/* ▲▲▲ 替换结束 ▲▲▲ */

.weibo-nav-item {
    flex: 1;
    text-align: center;
    padding: 12px 0;
    font-size: 14px;
    color: var(--text-secondary);
    cursor: pointer;
}
.weibo-nav-item.active {
    color: var(--accent-color);
    font-weight: 600;
}
/* ▲▲▲ 微博框架样式结束 ▲▲▲ */

/* ▼▼▼ 【全新】微博关注列表弹窗样式 ▼▼▼ */
#weibo-following-list-container {
    height: 100%;
    overflow-y: auto; /* 【核心】内容超出时显示垂直滚动条 */
}
.weibo-following-item {
    display: flex;
    align-items: center;
    padding: 10px 15px;
    border-bottom: 1px solid #f0f0f0;
}
.weibo-following-item:last-child {
    border-bottom: none;
}
.weibo-following-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    margin-right: 12px;
    object-fit: cover;
}
.weibo-following-name {
    font-weight: 500;
    color: var(--text-primary);
}
/* ▲▲▲ 关注列表样式结束 ▲▲▲ */

/* ▼▼▼ 【全新】让个人主页可编辑的元素有点击手势 ▼▼▼ */
#weibo-avatar-img,
#weibo-nickname,
#weibo-posts-item, /* 我们让整个“微博”区域可点击 */
#weibo-fans-item,  /* 整个“粉丝”区域可点击 */
#weibo-background-img /* 背景图也可点击 */ {
    cursor: pointer;
    transition: opacity 0.2s;
}
#weibo-avatar-img:hover,
#weibo-nickname:hover,
#weibo-posts-item:hover,
#weibo-fans-item:hover,
#weibo-background-img:hover {
    opacity: 0.8; /* 鼠标放上去时变淡一点，给用户反馈 */
}
/* ▲▲▲ 点击手势样式结束 ▲▲▲ */
/* ▼▼▼ 请用这块新代码替换旧的 #weibo-page-container 样式 ▼▼▼ */
#weibo-page-container {
    flex-grow: 1;
    position: relative;
    overflow: hidden;
    /* 核心修改：为绝对定位的导航栏预留出空间，防止内容被遮挡 */
    /* 50px 是导航栏的大致高度，env() 用于适配iPhone底部的小黑条 */
    padding-bottom: calc(50px + env(safe-area-inset-bottom));
    box-sizing: border-box; /* 确保内边距被正确计算在内 */
}
/* ▲▲▲ 替换结束 ▲▲▲ */

/* ▲▲▲ 替换结束 ▲▲▲ */

/* 确保个人主页的内容可以滚动 */
#weibo-profile-page {
    overflow-y: auto;
    height: 100%;
}
/* ▲▲▲ 修复CSS结束 ▲▲▲ */

/* ▲▲▲ 修复CSS结束 ▲▲▲ */
/* ▼▼▼ 【最终修复】提升微博关注列表弹窗的层级 ▼▼▼ */
#weibo-following-modal {
    z-index: 1001; /* 确保它能覆盖在其他页面之上 */
}
/* ▲▲▲ 修复结束 ▲▲▲ */
/* ▼▼▼ 把这一整块全新的微博帖子样式，粘贴到 <style> 标签的最末尾 ▼▼▼ */

/* ▼▼▼ 把这一整块全新的微博帖子样式，粘贴到 <style> 标签的最末尾 ▼▼▼ */

/* === 微博帖子专属样式 (已和动态分离) === */
/* === 微博帖子专属样式 (圆角卡片版) === */
.weibo-post-item {
    background-color: var(--secondary-bg);
    border-radius: 12px; /* ★ 修改这里，增加圆角，让它变得圆润可爱 */
    padding: 15px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.06); /* ★ 新增柔和的阴影，营造卡片悬浮感 */
    /* ★ 旧的 border-bottom 分割线已经被移除了，现在由父容器的 gap 属性负责间距 */
}
.weibo-post-item:last-child {
    /* 这个规则现在也不需要了，但保留着也没关系 */
    border-bottom: none;
}

.weibo-post-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 12px;
}

.weibo-post-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    object-fit: cover;
}

.weibo-post-info {
    display: flex;
    flex-direction: column;
}

.weibo-post-nickname {
    font-weight: 600;
    font-size: 15px;
    color: var(--text-primary);
}

.weibo-post-timestamp {
    font-size: 12px;
    color: var(--text-secondary);
}

.weibo-post-content {
    font-size: 15px; /* 微博正文字体稍大 */
    line-height: 1.7;
    color: #333;
    white-space: pre-wrap;
    word-break: break-word;
    margin-bottom: 10px;
}

.weibo-post-image {
    width: 100%;
    max-height: 400px;
    object-fit: cover;
    border-radius: 8px;
    margin-bottom: 10px;
}

.weibo-post-footer {
    border-top: 1px solid #f0f0f0;
    padding-top: 8px;
    margin-top: 10px;
}

.weibo-post-actions {
    display: flex;
    justify-content: space-around; /* 三个按钮均分空间 */
    margin-bottom: 10px;
}

.weibo-action-btn {
    display: flex;
    align-items: center;
    gap: 6px;
    color: var(--text-secondary);
    cursor: pointer;
    font-size: 14px;
}
.weibo-action-btn.liked {
    color: #ff5252; /* 点赞后变红 */
}
.weibo-action-btn svg {
    width: 20px;
    height: 20px;
}

.weibo-comments-container {
    padding: 10px;
    background-color: #f7f7f7;
    border-radius: 8px;
    font-size: 13px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin-bottom: 10px;
}

.weibo-comment-item .weibo-commenter-name {
    font-weight: 600;
    color: var(--accent-color);
}
.weibo-comment-item .weibo-comment-reply-tag {
    color: var(--text-secondary);
    margin: 0 4px;
}

.weibo-comment-input-area {
    display: flex;
    gap: 8px;
}

.weibo-comment-input {
    flex-grow: 1;
    border: none;
    background-color: #f0f2f5;
    border-radius: 14px;
    padding: 8px 12px;
    font-size: 13px;
}

.weibo-comment-send-btn {
    background-color: var(--accent-color);
    color: white;
    border: none;
    border-radius: 14px;
    padding: 0 15px;
    font-size: 13px;
    cursor: pointer;
}
/* ▲▲▲ 微博专属样式结束 ▲▲▲ */
/* ▲▲▲ 粘贴结束 ▲▲▲ */
/* ▼▼▼ 把这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* 单条评论的容器，现在需要相对定位，并为删除按钮留出空间 */
.weibo-comment-item {
    position: relative;
    padding-right: 25px; 
}

/* 评论删除按钮的样式 */
.comment-delete-btn {
    position: absolute;
    top: 50%;
    right: 0;
    transform: translateY(-50%);
    width: 22px;
    height: 22px;
    line-height: 22px;
    text-align: center;
    border-radius: 50%;
    color: var(--text-secondary);
    background-color: transparent; /* 背景透明 */
    border: none; /* 无边框 */
    font-size: 20px; /* 放大"×"号 */
    cursor: pointer;
    transition: all 0.2s ease;
    opacity: 0; /* 默认隐藏 */
}

/* 鼠标悬停在整条评论上时，才显示删除按钮 */
.weibo-comment-item:hover .comment-delete-btn {
    opacity: 1;
}

/* 鼠标悬停在删除按钮上时，给一点反馈效果 */
.comment-delete-btn:hover {
    background-color: #f0f0f0;
    color: #ff3b30; /* 变红色 */
}

#phone-screen.dark-mode .comment-delete-btn:hover {
    background-color: #3a3a3c; /* 夜间模式下的悬停背景色 */
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
/* ▼▼▼ 把这一整块全新的微博热搜样式，粘贴到 <style> 标签的最末尾 ▼▼▼ */

/* === 微博热搜列表样式 === */
#weibo-hot-search-list {
    background-color: var(--secondary-bg);
}

.hot-search-item {
    display: flex;
    align-items: center;
    padding: 12px 15px;
    border-bottom: 1px solid var(--border-color);
    cursor: pointer;
    transition: background-color 0.2s;
}

.hot-search-item:hover {
    background-color: #f5f5f5;
}
#phone-screen.dark-mode .hot-search-item:hover {
    background-color: #2c2c2e;
}

.hot-search-rank {
    width: 30px;
    font-size: 16px;
    font-weight: bold;
    color: var(--text-secondary);
    text-align: center;
    flex-shrink: 0;
}
/* 前三名用不同的颜色突出显示 */
.hot-search-item[data-rank="1"] .hot-search-rank { color: #f44336; }
.hot-search-item[data-rank="2"] .hot-search-rank { color: #ff9800; }
.hot-search-item[data-rank="3"] .hot-search-rank { color: #ffc107; }

.hot-search-content {
    flex-grow: 1;
    display: flex;
    align-items: center;
    gap: 8px;
    overflow: hidden;
}

.hot-search-topic {
    font-size: 15px;
    font-weight: 500;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.hot-search-tag {
    font-size: 10px;
    color: white;
    padding: 2px 6px;
    border-radius: 4px;
    flex-shrink: 0;
}
.hot-search-tag.hot { background-color: #f44336; }
.hot-search-tag.new { background-color: #ff9800; }
.hot-search-tag.rec { background-color: #2196f3; }

/* ▲▲▲ 微博热搜样式粘贴结束 ▲▲▲ */
/* ▼▼▼ 把这一整块全新的CSS，粘贴到 <style> 标签的最末尾 ▼▼▼ */

/* 1. 让帖子头部成为删除按钮的定位参考点 */
.weibo-post-header {
    position: relative; /* 关键！ */
}

/* 2. 删除按钮的样式 */
.weibo-post-delete-btn {
    position: absolute; /* 绝对定位，让它浮动起来 */
    top: 10px;          /* 距离顶部10像素 */
    right: 15px;         /* 距离右侧15像素 */
    width: 26px;
    height: 26px;
    background-color: rgba(0, 0, 0, 0.08); /* 半透明的背景 */
    color: var(--text-secondary); /* 使用全局的次要文字颜色 */
    border: none;
    border-radius: 50%; /* 圆形 */
    font-size: 20px;    /* "×"号的大小 */
    line-height: 26px;  /* 让"×"号垂直居中 */
    text-align: center;
    cursor: pointer;
    transition: all 0.2s ease; /* 添加平滑的动画效果 */
}

/* 鼠标放上去时，变成醒目的红色 */
.weibo-post-delete-btn:hover {
    background-color: #ff3b30;
    color: white;
    transform: scale(1.1); /* 轻微放大 */
}

/* ▲▲▲ 粘贴结束 ▲▲▲ */
/* ▼▼▼ 【微博布局终极修复】真正解决所有页面滚动不到底的问题 ▼▼▼ */

/* 1. 外层容器不再需要“垫子”，它的任务只是撑开空间 */
#weibo-page-container {
    flex-grow: 1;
    position: relative;
    overflow: hidden; /* 保持不变 */
}

/* 2. 【核心】把“垫子”加到真正滚动的列表自己身上！ */
#weibo-profile-page,
#weibo-following-feed-list,
#weibo-hot-search-list,
#weibo-plaza-feed-list,
#weibo-hottopic-feed-list {
    flex-grow: 1;
    overflow-y: auto;
    
    /* 
       魔法就在这里！我们为每个列表的底部，
       都加上一个和导航栏一样高的内边距（“垫子”）。
       这样列表滚动到底时，最后一条评论就会被这个内边距向上推，
       正好显示在底部导航栏的上方，不会再被挡住了！
    */
    padding-bottom: calc(50px + env(safe-area-inset-bottom));
    box-sizing: border-box; /* 确保内边距被正确计算 */
}

/* ▲▲▲ 修复结束 ▲▲▲ */

/* ▼▼▼ 把这段新样式粘贴到 <style> 的末尾 ▼▼▼ */
#post-visibility-groups label {
    display: block;
    padding: 5px 0;
}
#post-visibility-groups input {
    margin-right: 8px;
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
/* ▼▼▼ 【微博布局终极修复】解决所有页面滚动不到底的问题 ▼▼▼ */

/* 1. 移除外层容器上错误的多余“垫子” */
#weibo-page-container {
    padding-bottom: 0 !important;
}

/* 2. 【核心】把“垫子”（padding-bottom）加到真正滚动的列表自己身上！*/
#weibo-profile-page,
#weibo-following-feed-list,
#weibo-hot-search-list,
#weibo-plaza-feed-list,
#weibo-hottopic-feed-list {
    /* 
       魔法就在这里！我们为每个列表的底部，
       都加上一个和导航栏一样高的内边距（“垫子”）。
       calc(50px + env(safe-area-inset-bottom)) 会自动计算导航栏高度和iPhone底部安全区高度。
    */
    padding-bottom: calc(50px + env(safe-area-inset-bottom)) !important;
    box-sizing: border-box; /* 确保内边距被正确计算 */
}
/* ▼▼▼ 【问题1修复】微博编辑资料按钮强制显示 ▼▼▼ */
/* 请将这段代码粘贴到 <style> 标签的最末尾 */
#edit-weibo-profile-btn {
    display: flex !important; /* 强制显示为flex容器 */
    align-items: center;
    justify-content: center;
    color: var(--accent-color) !important; /* 强制使用主题色 */
}
#edit-weibo-profile-btn svg {
    stroke: currentColor !important; /* 确保SVG图标继承上面的颜色 */
}
/* ▲▲▲ 修复结束 ▲▲▲ */
/* ▼▼▼ 把这一整块全新的CSS，粘贴到 <style> 的末尾 ▼▼▼ */

/* 1. 让关注列表的每一行都能容纳新按钮 */
.weibo-following-item {
    align-items: center; /* 确保头像、名字和按钮垂直居中对齐 */
}

/* 2. 这是你新增的“操作”按钮的样式 */
.weibo-action-trigger-btn {
    margin-left: auto; /* 核心：让按钮自动靠到最右边 */
    padding: 5px 8px;
    cursor: pointer;
    border-radius: 50%; /* 圆形按钮，更美观 */
    transition: background-color 0.2s;
}
.weibo-action-trigger-btn:hover {
    background-color: #e0e0e0;
}
#phone-screen.dark-mode .weibo-action-trigger-btn:hover {
    background-color: #3a3a3c;
}
.weibo-action-trigger-btn svg {
    width: 20px;
    height: 20px;
    stroke: var(--text-secondary); /* 图标颜色跟随主题 */
    display: block; /* 解决一些对齐问题 */
}

/* 3. 为操作弹窗里的单选按钮美化一下 */
#weibo-action-type-select label {
    display: block;
    padding: 8px;
    border-radius: 6px;
    transition: background-color 0.2s;
}
#weibo-action-type-select label:hover {
    background-color: #f0f2f5;
}
#phone-screen.dark-mode #weibo-action-type-select label:hover {
    background-color: #2c2c2e;
}

/* ▲▲▲ 新增CSS粘贴结束 ▲▲▲ */
/* ▼▼▼ 【弹窗层级修复】粘贴这段代码到样式末尾 ▼▼▼ */
#weibo-action-modal {
    z-index: 1002; /* 这个值比关注列表(1001)更高，就不会被盖住了 */
}
/* ▼▼▼ 【全新】论坛/小组功能样式 ▼▼▼ */

/* 1. 小组列表卡片样式 */
.forum-group-item {
    background-color: var(--secondary-bg);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
}
.forum-group-item:hover {
    transform: translateY(-5px);
    box-shadow: 0 6px 15px rgba(0,0,0,0.12);
}
.forum-group-icon {
    font-size: 28px;
    margin-bottom: 10px;
}
.forum-group-name {
    font-weight: 600;
    font-size: 15px;
    margin-bottom: 5px;
}
.forum-group-desc {
    font-size: 12px;
    color: var(--text-secondary);
}

/* 2. 帖子列表项样式 */
.forum-post-item {
    padding: 15px;
    border-bottom: 1px solid var(--border-color);
    cursor: pointer;
}
.forum-post-item:hover {
    background-color: #f5f5f5;
}
#phone-screen.dark-mode .forum-post-item:hover {
    background-color: #2c2c2e;
}
.post-item-title {
    font-weight: 500;
    font-size: 16px;
    margin-bottom: 8px;
}
.post-item-meta {
    font-size: 12px;
    color: var(--text-secondary);
    display: flex;
    justify-content: space-between;
}

/* ▼▼▼ 请用这块新代码替换旧的 #post-detail-content 样式 ▼▼▼ */
#post-detail-content {
    flex-grow: 1;      /* 核心：让它占据所有可用的垂直空间 */
    overflow-y: auto;  /* 核心：如果内容超出，则允许自身滚动 */
    display: flex;
    flex-direction: column;
    padding: 20px;     /* 保留舒适的内边距 */
    /* 不再需要为绝对定位的输入框留出额外的padding-bottom */
}
/* ▲▲▲ 替换结束 ▲▲▲ */
.post-detail-header h1 {
    font-size: 22px;
    margin: 0 0 10px 0;
}
.post-detail-meta {
    font-size: 13px;
    color: var(--text-secondary);
    margin-bottom: 20px;
}
.post-detail-body {
    font-size: 16px;
    line-height: 1.7;
    white-space: pre-wrap;
    word-break: break-word;
    padding-bottom: 20px;
    border-bottom: 1px solid var(--border-color);
}
.post-comments-section {
    padding-top: 20px;
}
.post-comments-section h3 {
    font-size: 16px;
    margin: 0 0 15px 0;
    border-left: 3px solid var(--accent-color);
    padding-left: 10px;
}
.post-comment-item {
    padding: 12px 0;
    border-bottom: 1px solid #f0f0f0;
}
#phone-screen.dark-mode .post-comment-item {
    border-bottom-color: #2c2c2e;
}
.comment-author {
    font-weight: 600;
    color: var(--accent-color);
    margin-bottom: 5px;
}
.comment-content {
    font-size: 14px;
    line-height: 1.6;
}

/* 4. 帖子页底部输入框 */
/* ▼▼▼ 请用这块新代码替换旧的 #post-comment-input-area 样式 ▼▼▼ */
#post-comment-input-area {
    /* 
      我们移除了 position: absolute; 和相关的 bottom, left 属性，
      让它从一个“浮动层”变回一个正常的块级元素，自然地排在内容下方。
      其他的样式会从 .chat-input-area 类继承，无需担心。
    */
    width: 100%;
    box-sizing: border-box;
}
/* ▲▲▲ 替换结束 ▲▲▲ */


/* ▲▲▲ 论坛样式结束 ▲▲▲ */
/* ▼▼▼ 请将这段【全新】的论坛美化CSS，粘贴到<style>标签的末尾 ▼▼▼ */

/* 1. 美化帖子详情页底部的评论输入区域 */
#post-comment-input-area {
    padding: 10px 15px; /* 增加内边距，让它不贴边 */
    background-color: rgba(247, 247, 247, 0.9);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-top: 1px solid var(--border-color);
    /* 适配iPhone底部安全区 */
    padding-bottom: calc(10px + env(safe-area-inset-bottom));
}

/* 2. 【核心】美化评论输入框本身 */
#post-comment-input-area #post-comment-input {
    background-color: #f0f2f5; /* 浅灰色背景，更有层次感 */
    border: none;
    border-radius: 18px; /* 圆角，更柔和 */
    padding: 10px 15px;
    font-size: 14px;
    resize: none; /* 禁止用户拖拽大小 */
}

/* 夜间模式适配 */
#phone-screen.dark-mode #post-comment-input-area #post-comment-input {
    background-color: #2c2c2e;
}

/* 3. 美化发送按钮 */
#post-comment-input-area #send-post-comment-btn {
    height: 36px;
    border-radius: 18px; /* 和输入框保持一致的圆角 */
    padding: 0 20px;
}

/* 4. 【新增】AI生成评论按钮的样式 */
.generate-comments-container {
    padding: 10px 20px 0 20px;
    border-bottom: 8px solid #f0f2f5;
}

#phone-screen.dark-mode .generate-comments-container {
    border-bottom-color: #000;
}

#generate-forum-comments-btn {
    width: 100%;
    padding: 10px;
    border: none;
    border-radius: 8px;
    background-color: #e9f5ff;
    color: var(--accent-color);
    font-weight: 500;
    cursor: pointer;
    transition: background-color 0.2s;
}

#generate-forum-comments-btn:hover {
    background-color: #d4eaff;
}
/* ▲▲▲ 论坛美化CSS粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】论坛帖子/评论头像与楼层样式 ▼▼▼ */

/* 1. 帖子作者区域：使用flex布局让头像和名字并排 */
#post-detail-content .post-detail-header {
    display: flex;
    align-items: center;
    gap: 12px; /* 头像和右侧信息的间距 */
    padding-bottom: 20px;
    border-bottom: 1px solid var(--border-color);
    margin-bottom: 20px;
}

/* 2. 帖子作者的头像样式 */
.post-author-avatar {
    width: 45px;
    height: 45px;
    border-radius: 50%;
    object-fit: cover;
    flex-shrink: 0; /* 防止被压缩 */
}

/* 3. 包裹作者名字和时间的容器 */
.post-author-info {
    display: flex;
    flex-direction: column;
}

/* 4. 移除旧的标题和meta外边距，因为flex布局会处理间距 */
#post-detail-content .post-detail-header h1,
#post-detail-content .post-detail-meta {
    margin: 0;
}
#post-detail-content .post-detail-header h1 {
    font-size: 18px; /* 标题可以稍微小一点，更协调 */
    margin-bottom: 4px;
}

/* 5. 评论区每一条评论的布局 */
.post-comment-item {
    display: flex;
    gap: 10px; /* 头像和右侧内容的间距 */
    padding: 12px 0;
    border-bottom: 1px solid #f0f0f0;
}
#phone-screen.dark-mode .post-comment-item {
    border-bottom-color: #2c2c2e;
}

/* 6. 评论者的小头像 */
.comment-avatar-small {
    width: 35px;
    height: 35px;
    border-radius: 50%;
    object-fit: cover;
    flex-shrink: 0;
}

/* 7. 包裹评论所有文字内容的容器 */
.comment-details {
    display: flex;
    flex-direction: column;
    flex-grow: 1;
}

/* 8. 评论的头部：包含名字和楼层 */
.comment-header-line {
    display: flex;
    justify-content: space-between; /* 让名字靠左，楼层靠右 */
    align-items: center;
    margin-bottom: 5px;
}

/* 9. 评论楼层号的样式 */
.comment-floor {
    font-size: 12px;
    color: var(--text-secondary);
    font-weight: 500;
}

/* 10. 移除旧的评论作者外边距 */
.post-comment-item .comment-author {
    margin-bottom: 0;
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
/* ▼▼▼ 这是修复论坛评论区宽度问题的新增代码 ▼▼▼ */
#post-comment-input-area #post-comment-input {
    flex-grow: 1; /* ★★★ 核心代码就是这行！让输入框自动伸展，占满所有可用宽度 ★★★ */
    
    /* 下面这些是美化样式，让它和其他输入框风格统一，这次没有修改高度哦 */
    border: none;
    background-color: #f0f2f5; 
    border-radius: 18px;       
    padding: 10px 15px;        
    font-size: 14px;
    resize: none;             
    box-sizing: border-box;    
}

/* 夜间模式适配 */
#phone-screen.dark-mode #post-comment-input-area #post-comment-input {
    background-color: #2c2c2e;
}
/* ▲▲▲ 新增代码结束 ▲▲▲ */
/* ▼▼▼ 用这一整块全新的CSS，替换掉你旧的所有塔罗牌相关CSS ▼▼▼ */

/* 1. 占卜结果弹窗内的样式（纯文字版） */
#tarot-result-display {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 15px;
}
.tarot-result-question {
    font-size: 14px;
    font-weight: 500;
    color: var(--text-secondary);
    background-color: #f0f2f5;
    padding: 8px 12px;
    border-radius: 8px;
    width: 95%;
    text-align: center;
}
#phone-screen.dark-mode .tarot-result-question {
    background-color: #2c2c2e;
}
.tarot-spread-container {
    width: 100%;
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-items: center;
    gap: 10px;
}
.tarot-card-wrapper {
    background-color: #fff;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 8px;
    min-width: 120px;
    text-align: center;
    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
}
#phone-screen.dark-mode .tarot-card-wrapper {
    background-color: #1c1c1e;
}
.tarot-card-position {
    font-size: 12px;
    font-weight: 600;
    color: var(--accent-color);
    margin-bottom: 4px;
}
.tarot-card-name {
    font-size: 14px;
}

/* 3. 历史记录样式 (保持不变) */
#tarot-history-list {
    display: flex;
    flex-direction: column;
    gap: 12px;
}
.tarot-history-item {
    background-color: #f9f9f9;
    border-radius: 8px;
    padding: 12px;
    position: relative;
    border: 1px solid var(--border-color);
}
#phone-screen.dark-mode .tarot-history-item {
    background-color: #2c2c2e;
}
.tarot-history-item .question { font-weight: 600; margin-bottom: 8px; }
.tarot-history-item .details { font-size: 13px; color: var(--text-secondary); white-space: pre-wrap; }
.tarot-history-delete-btn {
    position: absolute;
    top: 5px; right: 5px; width: 24px; height: 24px;
    background-color: #e0e0e0; color: #888; border-radius: 50%;
    border: none; cursor: pointer; font-size: 18px; line-height: 24px; text-align: center;
}
#phone-screen.dark-mode .tarot-history-delete-btn {
    background-color: #3e3e42;
}
/* ▼▼▼ 第1步：从这里开始复制替换 ▼▼▼ */

#lovers-space-screen {
    background-color: #f0f2f5;   /* 保留一个备用背景色 */
    background-size: cover;      /* 背景图覆盖整个区域 */
    background-position: center; /* 背景图居中显示 */
    background-repeat: no-repeat;/* 背景图不重复 */
}

/* 头部 */
#ls-header {
    height: 220px;
    position: relative;
    /* 【核心修改】移除了 background-size 和 background-position */
    color: white;
    flex-shrink: 0;
    background-color: transparent; /* 【核心修改】让头部背景变透明，以显示下方的全屏背景 */
}

/* ▲▲▲ 第1步：复制替换到这里结束 ▲▲▲ */

/* --- 【最终修复版】修复情侣空间顶部按钮无法点击的问题 --- */
/* --- 【最终修复版】修复遮罩层拦截点击的问题 --- */

.ls-header-overlay {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    background: linear-gradient(to bottom, rgba(0,0,0,0.4), transparent, rgba(0,0,0,0.2));
    
    /* ▼▼▼ 核心修复：让这个遮罩层对鼠标事件“透明”！ ▼▼▼ */
    pointer-events: none; 
    /* ▲▲▲ 修复结束 ▲▲▲ */
}


/* --- 【已修复】情侣空间顶部栏层级问题 --- */

.ls-header-top-bar {
    position: relative;
    z-index: 3; /* ★★★ 核心修改：将层级从 2 提升到 3 ★★★ */
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px;
    padding-top: calc(15px + env(safe-area-inset-top));
}

#ls-char-name {
    font-size: 18px;
    font-weight: 600;
}
#ls-switch-char-btn { font-size: 16px; }

.ls-header-avatars {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    align-items: center;
    gap: 15px;
    z-index: 2;
}
.ls-header-avatars img {
    width: 65px;
    height: 65px;
    border-radius: 50%;
    border: 2px solid white;
    box-shadow: 0 4px 10px rgba(0,0,0,0.3);
}
.ls-header-avatars .heart-icon {
    font-size: 28px;
    color: #ff4d6d;
    text-shadow: 0 0 8px rgba(255, 255, 255, 0.8);
}

/* ▼▼▼ 请用这【一整块】全新的代码，完整替换旧的 #ls-tab-bar 和 .ls-tab-item 样式 ▼▼▼ */

/* 页签栏 (V2 - 悬浮撑满版) */
/* ▼▼▼ 请用这块【悬浮胶囊最终版】代码，完整替换掉你旧的 #ls-tab-bar 样式 ▼▼▼ */
#ls-tab-bar {
    display: flex;
    flex-shrink: 0;
    position: relative;
    z-index: 5;

    /* --- 核心修改在这里 --- */
    /* 1. 使用 margin 实现上下左右的边距，营造悬浮感 */
   margin: -20px 5px 10px 5px; /* 把左右的 15px 改成了 5px */
    
    /* 2. 为所有四个角都设置圆角，形成可爱的胶囊形状 */
    border-radius: 25px; 

    background-color: var(--secondary-bg);
    box-shadow: 0 4px 12px rgba(0,0,0,0.1); /* 阴影可以让悬浮感更强 */
}
/* ▲▲▲ 替换结束 ▲▲▲ */

/* 单个页签项目 (V2) */
.ls-tab-item {
    flex: 1;
    text-align: center;
    /* 核心修改：padding 从 12px 增加到 15px，让导航栏【拉长一点】(更高) */
    padding: 15px 0;
    font-weight: 500;
    color: var(--text-secondary);
    cursor: pointer;
    position: relative;
    /* 新增：为图标的缩放和颜色变化添加平滑过渡 */
    transition: color 0.2s ease;
}

/* 激活状态的页签 (V2) */
.ls-tab-item.active {
    color: var(--accent-color);
}

/* 激活状态的下划线指示器 (保持不变) */
.ls-tab-item.active::after {
    content: '';
    position: absolute;
    bottom: 8px; /* 微调位置以适应更高的导航栏 */
    left: 50%;
    transform: translateX(-50%);
    width: 28px;
    height: 3px;
    background-color: var(--accent-color);
    border-radius: 1.5px;
}

/* ▲▲▲ 替换结束 ▲▲▲ */


/* ▼▼▼ 【全新】这是为SVG图标新增的样式，请把它也粘贴到<style>里 ▼▼▼ */
.ls-tab-item svg {
    width: 24px;
    height: 24px;
    /* 为图标的大小和粗细变化添加平滑过渡 */
    transition: all 0.2s ease-in-out;
}

/* 激活状态的图标，会变得更粗、更大一点，非常醒目 */
.ls-tab-item.active svg {
    stroke-width: 2.5;
    transform: scale(1.1);
}
/* ▲▲▲ 新增样式结束 ▲▲▲ */

/* 内容区域 */
#ls-content-area {
    flex-grow: 1;
    position: relative;
    overflow: hidden;
}
.ls-view {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    overflow-y: auto;
    display: none;
    padding: 15px;
    box-sizing: border-box;
}
.ls-view.active {
    display: block;
}

/* 浮动添加按钮 */
/* ▼▼▼ 请用这块【终极居中修复版】代码，替换旧的 .ls-fab-btn 样式 ▼▼▼ */
/* ▼▼▼ 这是SVG适配版的最终代码 ▼▼▼ */
.ls-fab-btn {
    position: fixed;
    bottom: calc(30px + env(safe-area-inset-bottom));
    right: 30px;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background-color: var(--accent-color);
    color: white;
    border: none;
    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    cursor: pointer;
    z-index: 10;
    
    /* 依然使用Flexbox来居中SVG图标 */
    display: flex;
    justify-content: center;
    align-items: center;

    /* 移除所有与字体相关的属性 */
    /* font-size: 28px; (已移除) */
    /* line-height: normal; (已移除) */
}

/* (可选) 如果你觉得SVG有点小或大，可以微调它的大小 */
.ls-fab-btn svg {
    width: 24px;
    height: 24px;
}
/* ▲▲▲ 替换结束 ▲▲▲ */


/* 说说卡片 */
#ls-moments-list {
    display: flex;
    flex-direction: column;
    gap: 15px;
}
/* 说说卡片 */
/* ... */
.ls-moment-card {
    position: relative; /* ★★★ 核心修复：就是加上这一行！ ★★★ */
    background-color: var(--secondary-bg);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.08);
    display: flex;
    gap: 12px;
}
/* ... */

.ls-moment-card .avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    flex-shrink: 0;
}
.ls-moment-card .moment-main {
    display: flex;
    flex-direction: column;
}
.ls-moment-card .author {
    font-weight: 600;
    color: var(--text-primary);
}
.ls-moment-card .content {
    margin-top: 5px;
    font-size: 15px;
    line-height: 1.6;
    white-space: pre-wrap;
    word-break: break-word;
}
.ls-moment-card .timestamp {
    margin-top: 10px;
    font-size: 12px;
    color: var(--text-secondary);
}

/* 相册列表 */
/* ▼▼▼ 用这块新样式替换旧的 #ls-album-list ▼▼▼ */
#ls-album-list {
    display: grid;
    /* 核心修改：从2列变为3列，间距从15px缩小为5px */
    grid-template-columns: repeat(3, 1fr);
    gap: 5px;
}
/* ▲▲▲ 替换结束 ▲▲▲ */
.ls-album-item {
    cursor: pointer;
}
.ls-album-item .cover {
    width: 100%;
    aspect-ratio: 1 / 1;
    background-color: #e9ecef;
    background-size: cover;
    background-position: center;
    border-radius: 8px;
    margin-bottom: 8px;
}
.ls-album-item .name {
    font-weight: 500;
    text-align: center;
}

/* 照片上传预览 */
#ls-photo-preview-container {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    margin-bottom: 15px;
}
.ls-photo-preview-item {
    position: relative;
    aspect-ratio: 1 / 1;
}
.ls-photo-preview-item img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 6px;
}
.ls-photo-preview-item .remove-btn {
    position: absolute;
    top: -5px; right: -5px;
    width: 20px; height: 20px;
    background-color: #ff3b30;
    color: white;
    border-radius: 50%;
    border: none;
    line-height: 20px;
    text-align: center;
    cursor: pointer;
}

/* 情书和分享列表 */
.ls-list-item {
    background-color: var(--secondary-bg);
    border-radius: 8px;
    padding: 12px 15px;
    margin-bottom: 10px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.06);
    cursor: pointer;
}
.ls-list-item .title {
    font-weight: 500;
    margin-bottom: 5px;
}
.ls-list-item .meta {
    font-size: 12px;
    color: var(--text-secondary);
}
.ls-share-item .share-type {
    display: inline-block;
    padding: 2px 6px;
    font-size: 10px;
    border-radius: 4px;
    margin-right: 8px;
    color: white;
}
.share-type.song { background-color: #28a745; }
.share-type.movie { background-color: #fd7e14; }
.share-type.book { background-color: #6f42c1; }
/* ▼▼▼ 把这一整块全新的CSS，粘贴到 <style> 标签的最末尾 ▼▼▼ */

/* 【核心修复】让标题绝对居中，不再受两边按钮数量影响 */
#ls-header #ls-char-name {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    width: 60%; /* 限制最大宽度，防止与按钮重叠 */
    text-align: center;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* 【新增】头像和计数器的总容器，负责整体定位 */
.ls-avatar-and-counter-wrapper {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 2;
    display: flex;
    flex-direction: column; /* 让头像和计数器垂直排列 */
    align-items: center; /* 水平居中 */
    gap: 10px; /* 头像和计数器之间的垂直间距 */
}

/* 【修改】移除旧的头像绝对定位，因为它现在被新容器管理了 */
.ls-header-avatars {
    position: static; /* 改为静态定位 */
    transform: none;
    bottom: auto;
    left: auto;
    /* 其他样式（如头像大小、边框等）保持不变 */
}

/* 【修改】移除旧的计数器定位样式，让它在新容器里自然排列 */
#ls-days-counter {
    position: static;
    margin-top: 0;
    /* 其他样式（如字体颜色、阴影等）保持不变 */
}

/* ▲▲▲ 粘贴结束 ▲▲▲ */
/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* 1. 让相册项目成为删除按钮的定位参考点 */
.ls-album-item .cover {
    position: relative; /* 关键！ */
    overflow: hidden; /* 防止删除按钮溢出圆角 */
}

/* 2. 删除按钮的样式 */
.ls-photo-delete-btn {
    position: absolute;
    top: 5px;
    right: 5px;
    width: 24px;
    height: 24px;
    background-color: rgba(0, 0, 0, 0.6);
    color: white;
    border: none;
    border-radius: 50%;
    font-size: 18px;
    line-height: 24px; /* 确保 "×" 垂直居中 */
    text-align: center;
    cursor: pointer;
    opacity: 0; /* 默认隐藏 */
    transition: opacity 0.2s ease;
    z-index: 5; /* 确保在最上层 */
}

/* 3. 鼠标悬停在封面上时，显示删除按钮 */
.ls-album-item .cover:hover .ls-photo-delete-btn {
    opacity: 1;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
/* ▼▼▼ 这是为情侣空间“说说”新增的样式 ▼▼▼ */

/* 说说卡片底部的互动区（评论输入、删除按钮等） */
.ls-moment-footer {
    margin-top: 12px;
    padding-top: 10px;
    border-top: 1px solid #f0f0f0; /* 和内容区分隔开 */
}

/* 评论列表的容器 */
.ls-moment-comments-container {
    display: flex;
    flex-direction: column;
    gap: 8px; /* 每条评论之间的间距 */
    font-size: 14px;
    margin-bottom: 10px;
}

/* 每一条评论的样式 */
.ls-comment-item {
    position: relative; /* 为了定位删除按钮 */
    padding-right: 25px; /* 给删除按钮留出空间 */
    line-height: 1.5;
}

.ls-comment-item .commenter-name {
    font-weight: 600;
    color: var(--accent-color); /* 使用主题色 */
    margin-right: 5px;
}

/* 评论的删除按钮 */
.ls-comment-delete-btn {
    position: absolute;
    top: 50%;
    right: 0;
    transform: translateY(-50%);
    width: 22px;
    height: 22px;
    line-height: 22px;
    text-align: center;
    border-radius: 50%;
    color: var(--text-secondary);
    font-size: 18px;
    cursor: pointer;
    opacity: 0; /* 默认隐藏 */
    transition: all 0.2s ease;
}

/* 鼠标放上去才显示删除按钮 */
.ls-comment-item:hover .ls-comment-delete-btn {
    opacity: 1;
}
.ls-comment-delete-btn:hover {
    background-color: #f0f0f0;
    color: #ff3b30;
}

/* 评论输入区域的样式 */
.ls-comment-input-area {
    display: flex;
    gap: 8px;
    align-items: center;
}

.ls-comment-input-area input {
    flex-grow: 1;
    border: none;
    background-color: #f0f2f5;
    border-radius: 15px;
    padding: 8px 12px;
    font-size: 14px;
}

.ls-comment-input-area button {
    background-color: var(--accent-color);
    color: white;
    border: none;
    border-radius: 15px;
    padding: 8px 15px;
    font-size: 14px;
    cursor: pointer;
    flex-shrink: 0; /* 防止按钮被压缩 */
}

/* 说说卡片本身的删除按钮 */
.ls-moment-delete-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    width: 24px;
    height: 24px;
    background-color: rgba(0, 0, 0, 0.08);
    color: var(--text-secondary);
    border-radius: 50%;
    border: none;
    cursor: pointer;
    font-size: 18px;
    line-height: 24px;
    text-align: center;
    opacity: 0; /* 默认隐藏 */
    transition: all 0.2s ease;
}
.ls-moment-card:hover .ls-moment-delete-btn {
    opacity: 1; /* 鼠标放上去才显示 */
}
.ls-moment-delete-btn:hover {
    background-color: #ff3b30;
    color: white;
}

/* ▲▲▲ 新增样式结束 ▲▲▲ */

/* ▼▼▼ 把这一整块全新的CSS，粘贴到 <style> 标签的最末尾 ▼▼▼ */

/* ▼▼▼ 用这块【信纸美化版】代码，完整替换掉上一版的所有情书CSS ▼▼▼ */

/* --- 【全新美化版】情侣空间情书功能样式 --- */

/* 1. 情书列表为空时的提示 (不变) */
#ls-letters-list .ls-empty-placeholder {
    text-align: center;
    color: var(--text-secondary);
    padding: 50px 0;
}

/* 2. 单个情书卡片的样式 (已修改) */
.ls-love-letter-item {
    background-color: var(--secondary-bg);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.07);
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
    display: flex;
    gap: 12px;
    align-items: center;
}
.ls-love-letter-item:hover {
    transform: translateY(-3px);
    box-shadow: 0 6px 12px rgba(0,0,0,0.1);
}

/* 3. 情书图标的样式 (不变) */
.ls-love-letter-item .letter-icon {
    flex-shrink: 0;
    width: 45px;
    height: 45px;
    color: #ff8fab;
}

/* 4. 情书主要信息区 (已修改，加入头像) */
.ls-love-letter-item .letter-info {
    flex-grow: 1;
    overflow: hidden;
}
/* 【核心修改】收件人区域现在包含头像和名字 */
.ls-love-letter-item .letter-recipient {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 15px;
    font-weight: 600;
    margin-bottom: 5px;
}
.ls-love-letter-item .letter-recipient .avatar {
    width: 24px;
    height: 24px;
    border-radius: 50%;
}
.ls-love-letter-item .letter-preview {
    font-size: 13px;
    color: var(--text-secondary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* 5. 发信人信息 (不变) */
.ls-love-letter-item .letter-sender {
    flex-shrink: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
    font-size: 11px;
    color: var(--text-secondary);
}
.ls-love-letter-item .letter-sender .avatar {
    width: 30px;
    height: 30px;
    border-radius: 50%;
}

/* 6. 【全新】情书详情查看器 (信纸样式) */
#ls-letter-viewer-modal {
    z-index: 1001; /* 确保在最上层 */
}
.ls-letter-viewer-content {
    background-color: #fdfaef; /* 温馨的米黄色信纸背景 */
    width: 90%;
    max-width: 340px;
    height: 75%;
    border-radius: 15px;
    box-shadow: 0 8px 30px rgba(0,0,0,0.15);
    display: flex;
    flex-direction: column;
    font-family: 'Kaiti', 'STKaiti', serif; /* 使用更典雅的楷体 */
}
.letter-viewer-header {
    padding: 15px;
    border-bottom: 1px dashed #e0d9c7;
    display: flex;
    align-items: center;
    gap: 10px;
    color: #5d4037;
}
.letter-viewer-header .meta-avatar {
    width: 36px;
    height: 36px;
    border-radius: 50%;
}
.letter-viewer-header .recipient-info .label {
    font-size: 13px;
    color: #a1887f;
}
.letter-viewer-header .recipient-info .name {
    font-size: 16px;
    font-weight: 600;
}
.letter-viewer-body {
    flex-grow: 1;
    padding: 20px;
    font-size: 16px;
    line-height: 2; /* 更大的行高，模拟手写信的舒适感 */
    color: #4a443b;
    overflow-y: auto;
    white-space: pre-wrap;
    word-break: break-word;
}
.letter-viewer-footer {
    padding: 15px;
    border-top: 1px dashed #e0d9c7;
    display: flex;
    justify-content: space-between;
    align-items: flex-end;
}
.letter-viewer-footer .sender-info {
    font-size: 14px;
    color: #5d4037;
    font-weight: 600;
}
.letter-viewer-footer .sender-info .timestamp {
    font-size: 11px;
    color: #a1887f;
    font-weight: normal;
}
.letter-viewer-footer .letter-actions {
    display: flex;
    gap: 10px;
}
.letter-viewer-footer .letter-actions button {
    padding: 8px 15px;
    border-radius: 15px;
    border: 1px solid #d4bda5;
    background-color: transparent;
    color: #8c7b6c;
    cursor: pointer;
    font-size: 14px;
}
.letter-viewer-footer .letter-actions button.primary {
    background-color: #ff8fab;
    color: white;
    border-color: #ff8fab;
}

/* ▲▲▲ 样式替换结束 ▲▲▲ */
/* ▼▼▼ 这是为情书新增的样式 ▼▼▼ */

/* 1. 让情书卡片可以作为删除按钮的定位参考点 */
.ls-love-letter-item {
    position: relative; /* 关键！ */
}

/* 2. 删除按钮的样式 */
.ls-letter-delete-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    width: 24px;
    height: 24px;
    background-color: rgba(0, 0, 0, 0.1);
    color: #888;
    border: none;
    border-radius: 50%;
    font-size: 18px;
    line-height: 24px;
    text-align: center;
    cursor: pointer;
    opacity: 0; /* 默认隐藏 */
    transition: all 0.2s ease;
    z-index: 5; /* 确保在最上层 */
}

/* 3. 鼠标悬停在整张卡片上时，才显示删除按钮 */
.ls-love-letter-item:hover .ls-letter-delete-btn {
    opacity: 1;
}

/* 4. 鼠标悬停在删除按钮上时，给一点反馈效果 */
.ls-letter-delete-btn:hover {
    background-color: #ff3b30;
    color: white;
}
/* ▼▼▼ 把这一整块全新的CSS，粘贴到 <style> 标签的最末尾 ▼▼▼ */

/* --- 【全新】情侣空间-情侣提问样式 --- */

#ls-questions-list {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.ls-question-card {
    background-color: var(--secondary-bg);
    border-radius: 12px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    overflow: hidden; /* 防止内部元素溢出圆角 */
}

.ls-question-section,
.ls-answer-section {
    padding: 15px;
    display: flex;
    gap: 12px;
    align-items: flex-start;
}

.ls-question-section {
    border-bottom: 1px dashed var(--border-color);
}

.ls-question-card .qa-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    flex-shrink: 0;
}

.ls-question-card .qa-main {
    display: flex;
    flex-direction: column;
    width: 100%;
}

.ls-question-card .qa-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
}

.ls-question-card .qa-author {
    font-weight: 600;
}

.ls-question-card .qa-timestamp {
    font-size: 11px;
    color: var(--text-secondary);
}

.ls-question-card .qa-content {
    font-size: 15px;
    line-height: 1.6;
    white-space: pre-wrap;
    word-break: break-word;
}

.ls-answer-placeholder {
    padding: 20px;
    text-align: center;
}

.ls-answer-btn {
    padding: 8px 20px;
    border: 1px solid var(--accent-color);
    background-color: transparent;
    color: var(--accent-color);
    border-radius: 20px;
    cursor: pointer;
    font-weight: 500;
}

/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】这是为“情侣提问”新增的删除按钮样式 ▼▼▼ */

/* 1. 让提问卡片可以作为删除按钮的定位参考点 */
.ls-question-card {
    position: relative; /* 关键！ */
}

/* 2. 删除按钮的样式 */
.ls-question-delete-btn {
    position: absolute; /* 绝对定位，让它浮动起来 */
    top: 10px;
    right: 10px;
    width: 24px;
    height: 24px;
    background-color: rgba(0, 0, 0, 0.08); /* 半透明的背景 */
    color: var(--text-secondary); /* 使用全局的次要文字颜色 */
    border: none;
    border-radius: 50%; /* 圆形 */
    font-size: 18px;    /* "×"号的大小 */
    line-height: 24px;  /* 让"×"号垂直居中 */
    text-align: center;
    cursor: pointer;
    opacity: 0; /* 默认隐藏 */
    transition: all 0.2s ease; /* 添加平滑的动画效果 */
    z-index: 5; /* 确保在最上层 */
}

/* 3. 鼠标悬停在整张卡片上时，才显示删除按钮 */
.ls-question-card:hover .ls-question-delete-btn {
    opacity: 1;
}

/* 4. 鼠标悬停在删除按钮上时，给一点反馈效果 */
.ls-question-delete-btn:hover {
    background-color: #ff3b30;
    color: white;
}
/* ▲▲▲ 新增样式结束 ▲▲▲ */
/* ▼▼▼ 这是为“分享”功能新增的样式 ▼▼▼ */

.ls-share-item .title {
    font-weight: 600; /* 标题加粗 */
}

/* ▼▼▼ 用这块【已修复换行问题】的代码，替换掉旧的 .ls-share-item .summary 样式 ▼▼▼ */
.ls-share-item .summary {
    font-size: 14px;
    color: #666;
    margin-top: 8px;
    line-height: 1.6;
    /* --- 核心修改：允许文字自动换行 --- */
    white-space: normal;     /* <--- 允许换行 */
    overflow: visible;       /* <--- 允许内容溢出容器（即显示多行） */
    text-overflow: clip;     /* <--- 禁用省略号 */
    word-break: break-word;  /* <--- 防止超长单词或链接撑破布局 */
}
/* ▲▲▲ 替换结束 ▲▲▲ */


#phone-screen.dark-mode .ls-share-item .summary {
    color: #a0a0a0;
}

/* ▲▲▲ 新增样式结束 ▲▲▲ */
/* ▼▼▼ 【全新】这是情侣空间专属音乐播放器的CSS样式 ▼▼▼ */

/* 播放器主窗口的遮罩层 */
#ls-music-player-overlay {
    background-color: rgba(0, 0, 0, 0.4);
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
}

/* 播放列表面板的样式 (直接复用现有的) */
#ls-music-playlist-panel {
    /* 我们直接使用 .music-playlist-panel 的现有样式，省去重复代码 */
}

/* ▲▲▲ CSS样式粘贴结束 ▲▲▲ */
/* 【新增】隐藏情侣空间播放器中不需要的按钮 */
#ls-music-player-overlay #ls-playlist-btn,
#ls-music-player-overlay #ls-prev-btn,
#ls-music-player-overlay #ls-next-btn {
    display: none;
}

/* 【新增】居中播放/暂停按钮 */
#ls-music-player-overlay .music-controls {
    justify-content: center; /* 让剩下的按钮居中 */
}

/* ▲▲▲ CSS代码替换结束 ▲▲▲ */
/* 【新增】情侣空间播放器封面/歌词切换样式 */
#ls-display-area.show-lyrics #ls-album-cover {
    display: none; /* 当有 show-lyrics 类时，隐藏封面 */
}
#ls-display-area.show-lyrics #ls-lyrics-container {
    display: block !important; /* 当有 show-lyrics 类时，显示歌词 */
}

/* 【新增】歌词行样式 */
#ls-lyrics-container .lyric-line {
    padding: 4px 0;
    font-size: 14px;
    color: #666;
    opacity: 0.7;
    transition: all 0.5s ease;
}
#ls-lyrics-container .lyric-line.active {
    font-size: 16px;
    color: #000;
    opacity: 1;
    font-weight: 600;
}
/* ▼▼▼ 把这一整块全新的CSS，粘贴到 <style> 标签的最末尾 ▼▼▼ */

/* --- 【全新】情侣空间-情侣番茄钟样式 --- */

/* 主页布局 */
#ls-pomodoro-home {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

#ls-pomodoro-start-btn-container {
    padding: 20px;
    background-color: var(--secondary-bg);
    border-radius: 12px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    text-align: center;
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
}
#ls-pomodoro-start-btn-container:hover {
    transform: translateY(-5px);
    box-shadow: 0 6px 15px rgba(0,0,0,0.12);
}
#ls-pomodoro-start-icon {
    font-size: 32px;
    color: var(--accent-color);
    line-height: 1;
}
#ls-pomodoro-start-btn-container p {
    margin: 8px 0 0 0;
    font-weight: 500;
    color: var(--text-primary);
}

/* 历史记录列表 */
#ls-pomodoro-history-list {
    display: flex;
    flex-direction: column;
    gap: 10px;
}
.pomodoro-history-item {
    background-color: var(--secondary-bg);
    border-radius: 8px;
    padding: 12px 15px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.06);
    cursor: pointer;
}
.pomodoro-history-item:hover {
    background-color: #f9f9f9;
}
.pomodoro-history-item .task {
    font-weight: 500;
    margin-bottom: 5px;
}
.pomodoro-history-item .meta {
    font-size: 12px;
    color: var(--text-secondary);
}

/* ▼▼▼ 把下面这整块【锁机全屏版】代码，替换掉你旧的 #ls-pomodoro-timer-active 样式 ▼▼▼ */
#ls-pomodoro-timer-active {
    /* 核心修改1：将定位方式从 absolute 改为 fixed */
    /* 这会让计时器界面脱离原来的“情侣空间”页面，浮动在整个手机屏幕的最顶层！*/
    position: fixed; 
    
    /* 核心修改2：用这四个属性让它撑满整个屏幕 */
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    
    /* 核心修改3：设置一个超高的层级，确保它能盖住所有东西，实现“锁机”效果 */
    z-index: 2000; 
    
    background-size: cover;
    background-position: center;
    color: white;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    align-items: center;
    padding: 50px 20px;
    box-sizing: border-box;
    text-shadow: 0 2px 8px rgba(0,0,0,0.5);

    /* (可选优化) 为iPhone的刘海和底部小黑条留出安全距离，让界面更美观 */
    padding-top: calc(50px + env(safe-area-inset-top));
    padding-bottom: calc(50px + env(safe-area-inset-bottom));
}
/* ▲▲▲ 替换结束 ▲▲▲ */

/* ▼▼▼ 用这段新代码替换 ▼▼▼ */
.pomodoro-char-avatar-container {
    position: relative;
    text-align: center;
    width: 100%; /* <-- 就是新增了这一行！ */
}
/* ▲▲▲ 替换结束 ▲▲▲ */
#pomodoro-char-avatar {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    border: 3px solid rgba(255,255,255,0.8);
    cursor: pointer;
    transition: transform 0.2s;
}
#pomodoro-char-avatar:active {
    transform: scale(0.9);
}
/* ▼▼▼ 用这段【最终修复版】代码完整替换旧的 #pomodoro-char-log 样式 ▼▼▼ */
#pomodoro-char-log {
    position: absolute;
    top: 100%;
    margin-top: 12px;
    left: 50%;
    transform: translateX(-50%);
    background-color: rgba(0, 0, 0, 0.65);
    padding: 8px 12px;
    border-radius: 10px;
    font-size: 14px;
    max-width: 80%; /* <-- 核心修改在这里！让气泡可以变得更宽 */
    width: max-content; /* <-- 新增！确保气泡宽度根据内容自适应，但不会超过80% */
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s, visibility 0.3s, margin-top 0.3s; /* margin-top让动画更平滑 */
    pointer-events: none;
    white-space: pre-wrap;
    box-sizing: border-box; /* 新增！防止内边距导致布局问题 */
}
/* ▲▲▲ 替换结束 ▲▲▲ */


#pomodoro-char-log::after {
    content: '';
    position: absolute;
    bottom: 100%; /* <-- 修改这里 */
    left: 50%;
    transform: translateX(-50%);
    width: 0;
    height: 0;
    border: 6px solid transparent;
    border-bottom-color: rgba(0,0,0,0.65); /* <-- 修改这里 */
}


#pomodoro-char-log.visible {
    opacity: 1;
    visibility: visible; /* 新增 */
    margin-bottom: 22px; /* 核心修复3: 显示时向上移动一点，有一个“冒出来”的动画效果 */
}
/* ▲▲▲ 替换结束 ▲▲▲ */



/* 时间和任务显示 */
.pomodoro-timer-display {
    text-align: center;
}
#pomodoro-current-task {
    font-size: 20px;
    font-weight: 500;
    margin-bottom: 10px;
}
#pomodoro-time {
    font-size: 72px;
    font-weight: 200;
    letter-spacing: 2px;
}

/* 结束按钮 */
#pomodoro-end-btn {
    padding: 12px 30px;
    font-size: 16px;
    font-weight: 600;
    border: 2px solid white;
    background-color: rgba(255,255,255,0.2);
    color: white;
    border-radius: 25px;
    cursor: pointer;
}

/* 历史详情弹窗内的聊天气泡 */
#pomodoro-history-viewer-content {
    display: flex;
    flex-direction: column;
    gap: 15px;
}
.pomodoro-log-bubble {
    padding: 8px 12px;
    border-radius: 12px;
    max-width: 80%;
    background-color: #f0f0f0;
    align-self: flex-start;
    line-height: 1.5;
}
#phone-screen.dark-mode .pomodoro-log-bubble {
    background-color: #2c2c2e;
}

/* ▲▲▲ 新增CSS结束 ▲▲▲ */

/* --- 修复新增功能导致的滚动条问题 --- */

/* 1. 强制隐藏你不要的“情侣空间播放列表” */
#ls-music-playlist-panel {
    display: none !important;
}

/* 2. 确保主屏幕容器绝对不会出现滚动条，实现固定效果 */
#phone-screen {
    overflow: hidden !important;
}



/* === 【圈子评论区终极修复 - 覆盖继承版】 === */

/* 
   问题根源：圈子评论区(#post-comment-input-area)错误地继承了
   主聊天输入区(.chat-input-area)的样式，导致布局错乱。
   以下代码将针对圈子屏幕(#post-screen)下的评论区进行强制覆盖。
*/

/* 1. 强制重置评论区容器的布局，让它水平排列、垂直居中 */
#post-screen #post-comment-input-area {
    display: flex !important;
    flex-direction: row !important; /* 强制横向排列 */
    align-items: center !important;  /* 强制垂直居中，实现平行 */
    gap: 10px !important;            /* 设置输入框和按钮的间距 */
}

/* 2. 确保内层容器也正确伸展 */
#post-screen #post-comment-input-area .chat-input-main-row {
    flex-grow: 1 !important;
    display: flex !important;
    align-items: center !important;
    gap: 10px !important;
}

/* 3. 强制输入框的样式，并让它填满空间 */
#post-screen #post-comment-input {
    flex-grow: 1 !important; /* 解决右侧空白的关键！ */
    min-height: 40px;
    background-color: #f0f2f5 !important;
    border-radius: 20px !important;
    border: none !important;
    padding: 10px 15px !important;
    font-size: 14px !important;
    line-height: 1.5;
    resize: none;
    box-sizing: border-box;
}

/* 4. 强制发送按钮的样式 */
#post-screen #send-post-comment-btn {
    height: 40px !important;
    padding: 0 20px !important;
    border-radius: 20px !important;
    background-color: var(--accent-color) !important;
    color: white !important;
    font-weight: 600 !important;
    font-size: 14px !important;
    border: none !important;
    flex-shrink: 0; /* 防止按钮被压缩 */
}

/* 夜间模式适配 */
#phone-screen.dark-mode #post-screen #post-comment-input {
    background-color: #2c2c2e !important;
}
/* ▼▼▼ 这是新增的主屏幕滑动样式 ▼▼▼ */

/* 主屏幕滑动容器 */
.home-screen-slider {
    width: 100%;
    height: 100%; /* 确保它能撑满父容器 */
    display: flex; /* 让两页并排站好 */
    overflow-x: auto; /* 允许水平滚动 */
    overflow-y: hidden; /* 禁止垂直滚动 */
    scroll-snap-type: x mandatory; /* 这就是滑动的魔法！让它自动吸附到每一页 */
    -webkit-overflow-scrolling: touch; /* 在iOS上实现更平滑的滚动 */
    scrollbar-width: none; /* 隐藏滚动条 (Firefox) */
    -ms-overflow-style: none;  /* 隐藏滚动条 (IE) */
}
.home-screen-slider::-webkit-scrollbar {
    display: none; /* 隐藏滚动条 (Chrome, Safari) */
}

.home-page {
    width: 100%; /* 每一页都占满整个屏幕宽度 */
    height: 100%;
    flex-shrink: 0; /* 防止页面被压缩变形 */
    scroll-snap-align: start; /* 确保每次都对齐页面的开始位置 */
    
    /* 让页面内部的内容可以滚动 */
    overflow-y: auto;
    padding: 0 20px; /* 保持和你原来一样的左右边距 */
    box-sizing: border-box;
    position: relative; /* ★★★ 在这里添加这一行！ ★★★ */
}


/* 分页小圆点的容器 */
.pagination-dots {
    position: absolute;
    bottom: calc(100px + env(safe-area-inset-bottom)); /* 放在Dock栏上方 */
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 8px; /* 圆点之间的间距 */
}

/* 单个小圆点 */
.pagination-dots .dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background-color: rgba(255, 255, 255, 0.4); /* 未选中时的颜色 */
    transition: background-color 0.3s ease; /* 添加一个平滑的颜色过渡动画 */
}

/* 被选中的小圆点 */
.pagination-dots .dot.active {
    background-color: rgba(255, 255, 255, 0.9); /* 选中时变得更亮 */
}

/* ▲▲▲ 新增样式结束 ▲▲▲ */
/* ▼▼▼ 把这段新样式粘贴到 <style> 标签的最末尾 ▼▼▼ */

/* 这是第二页布局的全新样式 (V2 美化版) */

/* 1. 把头像小组件定位到左半屏的中间 */
#second-page-left-widget {
    position: absolute;
    top: 50px; 
    left: 25%; 
    transform: translateX(-50%); 
}

/* ★★★ 这是为头像小组件新增的放大和细边框样式 ★★★ */
#second-page-left-widget .widget-circle-uploader {
    width: 65px;  /* 头像宽度从 65px 放大到 80px */
    height: 65px; /* 头像高度从 65px 放大到 80px */
    border-width: 1px; /* 轮廓线从 2px 减小到 1px，变得很细 */
    padding: 1px; /* ★★★ 在这里添加这一行，把缝隙减小到1像素 ★★★ */
}
/* 2. 把右上角的图标改为并排排列 */
#second-page-top-right-apps {
    position: absolute;
    top: 50px;
    right: 30px;
    display: flex;
    gap: 30px; /* ★★★ 图标间距从 25px 增加到 30px，拉开距离 ★★★ */
}

/* 3. 文字颜色样式保持不变 */
#second-page-top-right-apps .desktop-app-icon .label {
    color: white;
    text-shadow: 0 1px 3px rgba(0,0,0,0.5);
}
/* ▼▼▼ 把这段新样式粘贴到 <style> 标签的最末尾 ▼▼▼ */

/* ▼▼▼ 请用这【一整块新代码】完整替换掉你上次添加的、关于第二页头像的所有CSS ▼▼▼ */

/* 1. 容器：移除元素间距，让头像和气泡靠拢 (保持不变) */
#second-page-left-widget {
    /* ★★★ 在这里新增一个宽度，作为“主宽度” ★★★ */
    width: 150px;
    gap: 0;
}

#second-page-bubble {
    margin-top: -10px;
    padding: 10px 15px;
    border-radius: 30px;
    /* ★★★ 修改点1：移除 min-width 和 display: inline-block ★★★ */
    /* min-width: 140px; */
    /* display: inline-block; */

    /* ★★★ 修改点2：添加下面这三行，让它占满父容器宽度并居中 ★★★ */
    width: 100%;
    box-sizing: border-box; /* 确保 padding 不会撑破布局 */
    text-align: center;     /* 让文字在变宽的容器里居中 */
    
    background-color: rgba(255, 255, 255, 0.4);
    color: #1c1c1e;
    text-shadow: none;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    position: relative;
    z-index: 1;
}



/* ★★★ 修改点2：在这里明确移除那个不想要的尖角 ★★★ */
#second-page-bubble::after {
    content: none; /* 强制移除继承自 .widget-bubble 的尖角伪元素 */
}

/* 3. 提升头像层级 (保持不变) */
#second-page-left-widget .widget-circle-uploader {
    position: relative; 
    z-index: 2;         
}

/* ▲▲▲ 替换结束 ▲▲▲ */
/* ▼▼▼ 把这一整块全新的CSS，粘贴到 <style> 标签的最末尾 ▼▼▼ */

/* 1. 新增气泡的容器，负责整体布局和宽度 */
#new-bubbles-container {
    display: flex;
    align-items: center;
    gap: 8px;
    /* ★★★ 核心修改：将固定的 180px 改为 100%，让它自动跟随父容器 ★★★ */
    width: 100%;
    margin-top: 8px;
}


/* ▼▼▼ 用这块【全新的代码】替换旧的 #flat-capsule-bubble 样式 ▼▼▼ */
/* ▼▼▼ 用这块【修改后】的代码替换旧的 #flat-capsule-bubble 样式 ▼▼▼ */
#flat-capsule-bubble {
    flex-grow: 1;
    min-width: auto;
    /* ★★★ 修改点1：高度从 44px 减小到 38px ★★★ */
    height: 35px;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0 15px;
    /* ★★★ 修改点2：新增背景色，将透明度从 0.4 提升到 0.6，让它更不透明 ★★★ */
    background-color: rgba(255, 255, 255, 0.4);
}
/* ▲▲▲ 替换结束 ▲▲▲ */

#flat-capsule-bubble::after {
    content: none; /* 移除继承来的小尾巴 */
}


/* ▼▼▼ 用这块【修改后】的代码替换旧的 #circular-bubble 样式 ▼▼▼ */
#circular-bubble {
    flex-shrink: 0;
    /* ★★★ 修改点1：宽度和高度都从 44px 减小到 38px ★★★ */
    width: 35px;
    height: 35px;
    border-radius: 50%;
    padding: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    min-width: auto;
    /* ★★★ 修改点2：新增背景色，与胶囊气泡保持一致，更不透明 ★★★ */
    background-color: rgba(255, 255, 255, 0.4);
}
/* ▲▲▲ 替换结束 ▲▲▲ */

/* 4. 移除圆形气泡的小尾巴 */
#circular-bubble::after {
    content: none;
}

/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* 1. 新头像组件的定位：中间偏上 */
#second-page-center-avatar {
    position: absolute;
    top: 235px; /* 控制上下位置，数值越小越靠上 */
    transform: translateX(-50%); /* 水平居中 */
    z-index: 5; /* 确保它在其他元素之上 */
}

/* 2. 新头像的尺寸和样式：比第一个大，且没有轮廓线 */
#second-page-center-avatar .widget-circle-uploader {
    width: 85px;  /* 比第一个头像(65px)大一圈 */
    height: 85px; /* 保持正圆 */
    border: none; /* 移除轮廓线 */
    padding: 0;   /* 移除内边距，让图片填满 */
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
/* ▼▼▼ 把这一整块全新的CSS，粘贴到 <style> 标签的最末尾 ▼▼▼ */

/* 1. 这是包裹头像和所有新气泡的总容器 (V2 加大版) */
/* 1. 这是包裹头像和所有新气泡的总容器 (V2 加大版) */
#center-avatar-wrapper {
    position: absolute;
    /* ★ 核心修改：将固定值改为可调节的变量，并提供一个默认值 190px */
    top: var(--second-page-center-avatar-top-offset, 190px); 
    transform: translateX(-55%);
    z-index: 5;
    
    /* ★ 修改点：把这个“看不见的盒子”的尺寸变大 */
    width: 300px;  /* 从 250px 增加到了 300px */
    height: 180px; /* 从 150px 增加到了 180px */
}





/* 2. 把你原来的头像在总容器里居中，这样它的位置看起来和原来一模一样 */
#second-page-center-avatar {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    /* 我们不再需要它自己来定位了，所以把旧的定位样式移除 */
}

#avatar-subtitle {
    position: absolute;
    bottom:  20px; /* ★ 修改点：把它从容器外面移到里面，位置更协调 */
    left: 50%;
    transform: translateX(-50%);
    
    background-color: transparent;
    border: none;
    outline: none;
    
    color: white;
    font-size: 14px;
    font-weight: 500;
    text-align: center;
    text-shadow: 0 1px 3px rgba(0,0,0,0.6);
    cursor: pointer;
    padding: 2px 8px;
}


/* 这是四个角落气泡的通用样式 */
.corner-bubble {
    position: absolute;
    background-color: rgba(255, 255, 255, 0.25);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 12px;
    padding: 8px 12px;
    color: white;
    font-size: 12px;
    font-weight: 500;
    text-align: center;
    text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    min-width: 80px; 
    cursor: pointer;
}

/* ▼▼▼ 在这里分别修改四个角落的位置 ▼▼▼ */

/* 5. 分别定位四个角落的气泡 */
#bubble-top-left {
    top: 40px;    /* 控制上下位置，数值越大越【往下】移 */
    left: -15px;   /* 控制左右位置，数值越大越【往右】移 */
}

#bubble-top-right {
    top: 40px;    /* 控制上下位置，数值越大越【往下】移 */
    right: -15px;  /* 控制左右位置，数值越大越【往左】移 */
}

#bubble-bottom-left {
    bottom: 40px; /* 控制上下位置，数值越大越【往上】移 */
    left: -15px;   /* 控制左右位置，数值越大越【往右】移 */
}

#bubble-bottom-right {
    bottom: 40px; /* 控制上下位置，数值越大越【往上】移 */
    right: -15px;  /* 控制左右位置，数值越大越【往左】移 */
}
/* ▼▼▼ 【这是修改后的版本】请用这整块代码替换旧的 ▼▼▼ */

/* 1. 总容器：移除了顶部的内边距 */
#new-custom-widget {
    position: absolute;
    bottom: 30px;
    right: 20px;
    width: 50%;
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 6px;
    /* padding-top: 50px;  <-- 这行已经被删掉了 */
}

/* 2. 【全新】头部容器：负责让月份和头像水平排列 */
/* 这是头部容器：负责让月份和头像水平排列 */
#new-widget-header {
    width: 100%;
    display: flex;
    justify-content: flex-end; /* 修改：让所有内容都靠右对齐 */
    align-items: center;
    gap: 70px; /* 新增：在月份和头像之间加一点间距 */
    margin-bottom: 5px;
}



/* 3. 月份：移除了绝对定位，现在是普通的flex项目 */
#widget-month-display {
    font-size: 25px;
    font-weight: 300;
    color: rgba(255, 255, 255, 0.85);
    text-shadow: 0 0 6px rgba(255, 255, 255, 0.6);
    line-height: 1;
}

/* 4. 头像：移除了不必要的样式，因为布局由父容器控制了 */
#new-custom-widget #new-widget-avatar {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    border: none;
    outline: none;
}

/* 5. 可编辑文字和分割线 (保持不变) */
#new-custom-widget .new-widget-text {
    background: transparent;
    border: none;
    outline: none;
    padding: 2px 4px;
    border-radius: 3px;
    color: rgba(255, 255, 255, 0.85);
    text-shadow: 0 0 6px rgba(255, 255, 255, 0.6);
    font-size: 13px;
    text-align: right;
    width: 100%;
    box-sizing: border-box;
}

#new-custom-widget .new-widget-divider {
    width: 60%;
    height: 1px;
    border-top: 1px dashed rgba(255, 255, 255, 0.3);
}
/* ▲▲▲ 替换结束 ▲▲▲ */
/* ▼▼▼ 【精致版】请用这整块代码替换旧的论坛帖子删除按钮样式 ▼▼▼ */

/* 1. 帖子列表项样式 (保持不变，只是确保右侧有足够空间) */
.forum-post-item {
    position: relative;
    padding-right: 40px; 
}

/* 2. 删除按钮的新样式 - 小巧精致版 */
.forum-post-delete-btn {
    position: absolute;
    top: 50%;
    right: 12px; /* 离边缘稍微近一点 */
    transform: translateY(-50%);

    /* --- 核心修改：尺寸变小 --- */
    width: 24px;
    height: 24px;

    /* --- 核心修改：外观更精致 --- */
    background-color: transparent; /* 默认背景透明，不突兀 */
    color: var(--text-secondary);  /* 默认颜色使用次要文字的灰色，更柔和 */
    border: none;
    border-radius: 50%;
    font-size: 18px;      /* 减小 "×" 的大小 */
    line-height: 24px;    /* 确保 "×" 垂直居中 */
    text-align: center;
    cursor: pointer;
    
    /* --- 核心修改：交互动效 --- */
    transition: all 0.2s ease; /* 为所有变化添加平滑过渡 */
}

/* 3. 鼠标悬停时的反馈效果 */
.forum-post-delete-btn:hover {
    background-color: #ff3b30; /* 悬停时才显示醒目的红色背景 */
    color: white;              /* "×" 变为白色 */
    transform: translateY(-50%) scale(1.1); /* 轻微放大，更有动感 */
}

/* ▲▲▲ 替换结束 ▲▲▲ */
/* 1. 定义一个通用的、控制所有主屏幕文字颜色的变量 (保持不变) */
#phone-screen {
    --home-icon-widget-text-color: #FFFFFF;
}

/* 2. 【核心】创建一个“超级选择器”，一次性选中所有需要变色的文字 */
/* 这次我们加入了顶部状态栏和底部Dock栏的图标文字 */
.desktop-app-icon .label,                        /* ▼▼▼ 核心修改：移除了前面的ID限定，让它能同时选中主屏幕和Dock栏的图标文字 ▼▼▼ */
#desktop-widget-column .widget-bubble,           
#desktop-widget-column .widget-subtext,        
#second-page-left-widget .widget-bubble,           
#second-page-left-widget .widget-subtext,        
#avatar-subtitle,                                
.corner-bubble,                                   
#new-custom-widget .new-widget-text,              
#widget-month-display,
#status-bar                                     /* ★★★ 新增：顶部状态栏 ★★★ */
{
    color: var(--home-icon-widget-text-color) !important;
    text-shadow: 0 1px 4px rgba(0,0,0,0.6) 
}
/* ▼▼▼ 【全新】去除主屏幕字体阴影的样式 ▼▼▼ */
#phone-screen.no-home-font-shadow .app-icon .label,
#phone-screen.no-home-font-shadow .desktop-app-icon .label,
#phone-screen.no-home-font-shadow .widget-bubble,
#phone-screen.no-home-font-shadow .widget-subtext,
#phone-screen.no-home-font-shadow #avatar-subtitle,
#phone-screen.no-home-font-shadow .corner-bubble,
#phone-screen.no-home-font-shadow .new-widget-text,
#phone-screen.no-home-font-shadow #widget-month-display,
#phone-screen.no-home-font-shadow #profile-username,
#phone-screen.no-home-font-shadow #profile-sub-username,
#phone-screen.no-home-font-shadow #profile-bio,
#phone-screen.no-home-font-shadow #profile-location,
#phone-screen.no-home-font-shadow #clock-container {
    text-shadow: none !important;
}
/* ▲▲▲ 新增样式结束 ▲▲▲ */

/* ▼▼▼ 【全新】这是微博主页头像框的专属样式 ▼▼▼ */
.weibo-avatar-container .weibo-avatar-frame{
    position: absolute;
    width: 121%; /* 相对大小，你可以微调 */
    height: 121%;
    /* 使用transform进行精确定位，确保完美居中 */
    transform: translate(-50%, -57%);
    top: 50%;
    left: 50%;
    z-index: 4; /* 确保在头像之上 */
    pointer-events: none; /* 让鼠标事件可以穿透它 */
}


/* ▼▼▼ 【全新】这是微博帖子作者头像框的专属样式 ▼▼▼ */

/* 这是帖子头部，头像和框的总容器 */
.weibo-post-header .avatar-with-frame {
    position: relative;
    /* 核心：尺寸和原来的头像保持一致 */
    width: 40px;
    height: 40px;
    flex-shrink: 0;
}

/* 容器内的头像图片 */
.weibo-post-header .avatar-with-frame .avatar-img {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
    position: absolute;
    top: 0;
    left: 0;
    z-index: 1; /* 确保在框的下面 */
}

/* 容器内的头像框图片 */
.weibo-post-header .avatar-with-frame .avatar-frame {
    position: absolute;
    width: 121%; /* 相对大小，你可以微调 */
    height: 121%;
    /* 使用transform进行精确定位，确保完美居中 */
    transform: translate(-50%, -57%);
    top: 50%;
    left: 50%;
    z-index: 4; /* 确保在头像之上 */
    pointer-events: none; /* 让鼠标事件可以穿透它 */
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */

/* ▼▼▼ 【全新】这是主屏幕头像框的专属样式 ▼▼▼ */
#profile-widget .profile-avatar-container .weibo-avatar-frame {
    position: absolute;
    width: 121%; /* 相对大小，你可以微调 */
    height: 121%;
    /* 使用transform进行精确定位，确保完美居中 */
    transform: translate(-50%, -57%);
    top: 50%;
    left: 50%;
    z-index: 4; /* 确保在头像之上 */
    pointer-events: none; /* 让鼠标事件可以穿透它 */
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */


/* ▼▼▼ 把这段全新的CSS，粘贴到你 <style> 标签的最末尾 ▼▼▼ */

.weibo-background {
    /* 核心代码：使用 mask-image 创建一个从上到下的渐变蒙版 */
    
    /* a. -webkit- 前缀是为了兼容旧版的 Chrome 和 Safari 浏览器 */
    -webkit-mask-image: linear-gradient(
        to bottom,          /* 渐变方向：从上到下 */
        
        /* ★★★ 这里是你可以自己调整的地方 ★★★ */
        black 60%,          /* 前60%的部分是完全不透明的 (黑色=不透明) */
        transparent 100%    /* 从60%的位置开始，到底部(100%)，逐渐过渡到完全透明 */
    );
    
    /* b. 这是标准语法，兼容现代浏览器 */
    mask-image: linear-gradient(
        to bottom,
        black 60%,
        transparent 100%
    );
}

/* ▲▲▲ 粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】圈子分类标签样式 ▼▼▼ */
.category-tag-container {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    margin-top: 8px;
}
.category-tag {
    font-size: 11px;
    font-weight: 500;
    color: var(--accent-color);
    background-color: #e7f3ff;
    padding: 3px 8px;
    border-radius: 10px;
}
#phone-screen.dark-mode .category-tag {
    background-color: rgba(10, 132, 255, 0.2);
    color: #0A84FF;
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】圈子/小组分类筛选功能样式 ▼▼▼ */

/* 筛选图标的样式 */
.header .filter-btn {
    font-size: 20px; /* 图标大小 */
    cursor: pointer;
    color: var(--accent-color); /* 跟随主题色 */
    position: relative; /* 为了定位小红点 */
}

/* 当筛选生效时，图标上显示一个小点提示 */
.header .filter-btn.active::after {
    content: '';
    position: absolute;
    top: 0;
    right: 0;
    width: 8px;
    height: 8px;
    background-color: #ff3b30;
    border-radius: 50%;
    border: 1.5px solid var(--secondary-bg);
}

/* 筛选弹窗内的分类列表 */
#forum-filter-category-list {
    display: flex;
    flex-wrap: wrap; /* 自动换行 */
    gap: 10px; /* 标签之间的间距 */
    padding: 10px;
}

#forum-filter-category-list label {
    display: inline-flex;
    align-items: center;
    background-color: #f0f2f5;
    padding: 6px 12px;
    border-radius: 15px;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.2s ease;
}

#phone-screen.dark-mode #forum-filter-category-list label {
    background-color: #3a3a3c;
}

#forum-filter-category-list input[type="checkbox"] {
    display: none; /* 隐藏原始的复选框 */
}

/* 选中后的样式 */
#forum-filter-category-list input[type="checkbox"]:checked + span {
    color: white;
    font-weight: 500;
}

/* 默认给标签一个好看的颜色循环 */
#forum-filter-category-list label:nth-of-type(6n+1) input:checked + span { background-color: #007bff; }
#forum-filter-category-list label:nth-of-type(6n+2) input:checked + span { background-color: #28a745; }
#forum-filter-category-list label:nth-of-type(6n+3) input:checked + span { background-color: #fd7e14; }
#forum-filter-category-list label:nth-of-type(6n+4) input:checked + span { background-color: #6f42c1; }
#forum-filter-category-list label:nth-of-type(6n+5) input:checked + span { background-color: #dc3545; }
#forum-filter-category-list label:nth-of-type(6n+6) input:checked + span { background-color: #ffc107; }

/* 标签内的文字部分，也需要设置样式，特别是选中后的背景色 */
#forum-filter-category-list label span {
    padding: 6px 12px;
    margin: -6px -12px; /* 抵消label的padding，让背景色填满 */
    border-radius: 15px;
    transition: all 0.2s ease;
}
/* ▲▲▲ 样式粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】游戏大厅样式 ▼▼▼ */
#game-hall-grid {
    display: grid;
    grid-template-columns: 1fr; /* 每行一个游戏 */
    gap: 15px; /* 游戏卡片之间的间距 */
}

.game-card {
    background-color: var(--secondary-bg);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    display: flex;
    align-items: center;
    gap: 15px;
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
}

.game-card:hover {
    transform: translateY(-3px);
    box-shadow: 0 6px 12px rgba(0,0,0,0.1);
}

.game-card .game-icon {
    font-size: 32px;
    width: 50px;
    height: 50px;
    flex-shrink: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    background-color: #f0f2f5;
    border-radius: 10px;
}

#phone-screen.dark-mode .game-card .game-icon {
    background-color: #2c2c2e;
}

.game-card .game-info .game-title {
    font-weight: 600;
    font-size: 16px;
    color: var(--text-primary);
}

.game-card .game-info .game-desc {
    font-size: 13px;
    color: var(--text-secondary);
    margin-top: 4px;
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】狼人杀游戏样式 ▼▼▼ */

/* 游戏设置页的玩家选择列表 */
.player-selection-item {
    display: flex;
    align-items: center;
    padding: 10px 15px;
    border-bottom: 1px solid var(--border-color);
}
.player-selection-item:last-child {
    border-bottom: none;
}
.player-selection-item input[type="checkbox"] {
    width: 20px;
    height: 20px;
    margin-right: 15px;
}
.player-selection-item img {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    margin-right: 10px;
}
.player-selection-item .name {
    font-weight: 500;
}
.player-selection-item .type-tag {
    font-size: 11px;
    color: var(--text-secondary);
    background-color: #f0f0f0;
    padding: 2px 6px;
    border-radius: 4px;
    margin-left: auto;
}

/* 游戏主界面布局 */
#werewolf-game-content {
    display: flex;
    flex-direction: column;
    height: 100%;
    overflow: hidden;
    padding: 10px;
    box-sizing: border-box;
}

/* 玩家座位网格 */
#werewolf-players-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
    gap: 10px;
    padding: 10px;
    flex-shrink: 0;
}

.player-seat {
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
}
.player-seat .player-avatar {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    border: 3px solid transparent;
    object-fit: cover;
    transition: all 0.3s ease;
}
.player-seat .player-avatar.speaking {
    border-color: #4cd964; /* 绿色边框表示正在发言 */
    box-shadow: 0 0 10px #4cd964;
}
.player-seat .player-avatar.dead {
    filter: grayscale(100%);
    opacity: 0.5;
}
.player-seat .player-name {
    font-size: 12px;
    font-weight: 500;
    text-align: center;
    max-width: 60px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}
.player-seat .player-role-indicator {
    position: absolute;
    top: -2px;
    right: -2px;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background-color: #ff3b30; /* 红色代表狼人 */
    color: white;
    font-size: 12px;
    font-weight: bold;
    display: none; /* 默认隐藏 */
    justify-content: center;
    align-items: center;
    border: 1px solid white;
}

/* 游戏日志区域 */
#werewolf-log-container {
    flex-grow: 1;
    background-color: rgba(0,0,0,0.05);
    border-radius: 10px;
    padding: 10px;
    overflow-y: auto;
    margin: 10px 0;
    min-height: 0; /* flex布局下滚动的关键 */
}
.log-entry {
    padding: 6px;
    border-bottom: 1px solid rgba(0,0,0,0.05);
    font-size: 14px;
    line-height: 1.5;
}
.log-entry.system {
    color: var(--accent-color);
    font-weight: bold;
    text-align: center;
    background-color: rgba(0, 123, 255, 0.05);
    border-radius: 5px;
}
.log-entry.speech .speaker {
    font-weight: 600;
}

/* 玩家操作区 */
#werewolf-action-area {
    flex-shrink: 0;
    padding: 10px;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 15px;
    min-height: 50px;
}
#werewolf-action-area button {
    padding: 10px 20px;
}
#werewolf-action-area .vote-target-grid {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    justify-content: center;
}
#werewolf-action-area .vote-target-btn {
    padding: 8px 12px;
    font-size: 13px;
    background-color: #e9ecef;
    color: var(--text-primary);
    border: 1px solid var(--border-color);
}
#werewolf-action-area .vote-target-btn.selected {
    background-color: var(--accent-color);
    color: white;
    border-color: var(--accent-color);
}
/* ▲▲▲ 狼人杀样式结束 ▲▲▲ */
/* ▼▼▼ 【全新】狼人杀发言日志美化样式 ▼▼▼ */

/* 包含头像和文字的总容器 */
.log-entry.speech {
    display: flex;
    align-items: flex-start; /* 顶部对齐 */
    gap: 10px;               /* 头像和文字的间距 */
    padding: 8px 6px;
    border-bottom: 1px solid rgba(0,0,0,0.05); /* 每条发言之间的分割线 */
}

/* 发言者的圆形小头像 */
.speech-avatar {
    width: 32px;
    height: 32px;
    border-radius: 50%; /* 完美圆形 */
    flex-shrink: 0;     /* 防止头像被压缩 */
    object-fit: cover;
}

/* 包裹名字和发言内容的新容器 */
.speech-content {
    display: flex;
    flex-direction: column; /* 名字和内容垂直排列 */
    gap: 2px;
}

/* 发言者名字的样式 */
.speech-content .speaker {
    font-weight: 600;
    font-size: 13px;
    color: var(--text-secondary); /* 使用次要文字颜色，不那么刺眼 */
}

/* 发言内容的样式 */
.speech-content .speech-text {
    word-break: break-word; /* 确保长篇发言能正确换行 */
    line-height: 1.6;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */



/* ▼▼▼ 【这是为你新增的X社交App图标样式】粘贴到 <style> 的末尾 ▼▼▼ */
#second-page-x-social-app {
    position: absolute;
    /* 控制上下位置。我把值调大了，让它更靠下，和“圈子”图标对齐 */
    top: 100px;  /* ★ 修改这里 ★ */
    
    /* 控制左右位置。我把值调小了，让它更靠右，和“情侣空间”图标对齐 */
    right: 0px; /* ★ 修改这里 ★ */
}

/* 把新图标的文字也变成白色，和其他图标统一 */
#second-page-x-social-app .label {
    color: white;
    text-shadow: 0 1px 3px rgba(0,0,0,0.5);
}
/* ▲▲▲ 新增样式粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】海龟汤游戏样式 ▼▼▼ */

.sts-log-entry {
    padding: 8px 10px;
    margin-bottom: 8px;
    border-radius: 8px;
    line-height: 1.6;
}

/* 系统消息 (谜面、提示等) */
.sts-log-entry.system {
    background-color: #e9ecef;
    color: var(--text-secondary);
    text-align: center;
    font-weight: 500;
}
#phone-screen.dark-mode .sts-log-entry.system {
    background-color: #2c2c2e;
}

/* 玩家提问 */
.sts-log-entry.question {
    background-color: #fff;
    border: 1px solid var(--border-color);
}
#phone-screen.dark-mode .sts-log-entry.question {
    background-color: #1c1c1e;
}
.sts-log-entry .speaker {
    font-weight: 600;
    color: var(--accent-color);
}

/* ▼▼▼ 【全新】海龟汤 - 出题人回答气泡美化 ▼▼▼ */
.sts-log-entry.answer {
    text-align: right;
}
.sts-log-entry.answer .answer-text {
    display: inline-block;
    padding: 8px 12px; /* 增加内边距，让气泡更饱满 */
    border-radius: 18px; /* 增加圆角 */
    font-weight: 500; /* 字体不用太粗 */
    background-color: #f0f2f5; /* 统一的、中性的浅灰色背景 */
    color: var(--text-primary); /* 文字颜色使用主题的主色，适配夜间模式 */
    box-shadow: 0 1px 2px rgba(0,0,0,0.08); /* 稍微调整阴影 */
}

/* 移除旧的、按颜色区分的样式，确保所有回答都用上面的新样式 */
.sts-log-entry.answer .answer-text.yes,
.sts-log-entry.answer .answer-text.no,
.sts-log-entry.answer .answer-text.irrelevant {
    background-color: #f0f2f5; /* 确保所有都用这个颜色 */
}

/* 夜间模式适配 */
#phone-screen.dark-mode .sts-log-entry.answer .answer-text,
#phone-screen.dark-mode .sts-log-entry.answer .answer-text.yes,
#phone-screen.dark-mode .sts-log-entry.answer .answer-text.no,
#phone-screen.dark-mode .sts-log-entry.answer .answer-text.irrelevant {
     background-color: #3a3a3c; /* 夜间模式下的深灰色 */
}
/* ▲▲▲ 替换结束 ▲▲▲ */


/* AI猜测 */
.sts-log-entry.guess {
    font-style: italic;
    color: #fd7e14;
    border-left: 3px solid #fd7e14;
    padding-left: 12px;
}

/* 玩家座位上的身份指示器 */
.player-seat .player-role-indicator.riddle-master {
    background-color: #ffc107; /* 黄色代表出题人 */
    display: flex;
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】海龟汤聊天日志美化样式 ▼▼▼ */
.sts-log-entry.question,
.sts-log-entry.answer,
.sts-log-entry.guess {
    display: flex;
    align-items: flex-start; /* 头像和气泡顶部对齐 */
    gap: 10px;
    max-width: 85%;
    margin-bottom: 12px;
}

/* 提问和猜测靠左 */
.sts-log-entry.question,
.sts-log-entry.guess {
    align-self: flex-start;
}

/* 回答靠右 */
.sts-log-entry.answer {
    align-self: flex-end;
    flex-direction: row-reverse; /* 关键：让头像在右边 */
}

/* 头像样式 */
.sts-log-avatar {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    object-fit: cover;
    flex-shrink: 0;
}

/* ▼▼▼ 【全新】海龟汤聊天日志美化样式 (气泡透明版) ▼▼▼ */
.sts-log-entry.question .sts-log-content,
.sts-log-entry.guess .sts-log-content {
    background-color: transparent; /* <-- 修改点1：背景改为透明 */
    border-radius: 8px;
    padding: 8px 12px;
    border: none; /* <-- 修改点2：移除边框，让它彻底“消失” */
}

#phone-screen.dark-mode .sts-log-entry.question .sts-log-content,
#phone-screen.dark-mode .sts-log-entry.guess .sts-log-content {
    background-color: #1c1c1e;
}

/* 修正回答气泡的样式，因为它不是一个完整的块 */
.sts-log-entry.answer .answer-text {
    box-shadow: 0 1px 2px rgba(0,0,0,0.1);
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
.player-seat .player-avatar.active-turn {
    border-color: #007bff; /* 使用主题色作为边框颜色 */
    box-shadow: 0 0 15px rgba(0, 123, 255, 0.7); /* 添加发光效果 */
    animation: sts-pulse-glow 1.5s infinite ease-in-out; /* 应用动画 */
}

@keyframes sts-pulse-glow {
    0%, 100% {
        box-shadow: 0 0 15px rgba(0, 123, 255, 0.7);
    }
    50% {
        box-shadow: 0 0 25px rgba(0, 123, 255, 1);
    }
}
/* ▼▼▼ 【海龟汤布局修复】请将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */
#sts-game-log {
    display: flex;
    flex-direction: column;
}
/* ▲▲▲ 修复结束 ▲▲▲ */
/* ▼▼▼ 【全新】海龟汤聊天日志美化样式 ▼▼▼ */
.sts-log-entry.question,
.sts-log-entry.answer,
.sts-log-entry.guess {
    display: flex;
    align-items: flex-start; /* 头像和气泡顶部对齐 */
    gap: 10px;
    max-width: 85%;
    margin-bottom: 12px;
    /* 移除旧的背景和边框，因为现在由子元素处理 */
    background-color: transparent;
    border: none;
}

/* 提问和猜测（猜题方）靠左 */
.sts-log-entry.question,
.sts-log-entry.guess {
    align-self: flex-start;
}

/* 回答（出题人）靠右 */
.sts-log-entry.answer {
    align-self: flex-end;
    flex-direction: row-reverse; /* 关键：让头像在右边 */
}

/* 头像样式 */
.sts-log-avatar {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    object-fit: cover;
    flex-shrink: 0;
}

/* 包含发言人和内容的气泡 */
.sts-log-entry.question .sts-log-content,
.sts-log-entry.guess .sts-log-content {
    background-color: #fff;
    border-radius: 8px;
    padding: 8px 12px;
    border: 1px solid var(--border-color);
}

#phone-screen.dark-mode .sts-log-entry.question .sts-log-content,
#phone-screen.dark-mode .sts-log-entry.guess .sts-log-content {
    background-color: #1c1c1e;
}

/* 修正回答气泡的样式，因为它不是一个完整的块 */
.sts-log-entry.answer .answer-text {
    box-shadow: 0 1px 2px rgba(0,0,0,0.1);
}

/* 让日志容器支持flex布局的对齐 */
#sts-game-log {
    display: flex;
    flex-direction: column;
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
/* ▼▼▼ 【海龟汤输入区终极修复版】 ▼▼▼ */

/* 1. 强制重置整个输入区域的布局为“横向排列”并“垂直居中” */
#sts-action-area {
    display: flex !important;
    flex-direction: row !important;
    align-items: center !important; /* 核心修正：从 flex-end 改为 center，实现垂直居中 */
    gap: 8px !important;
}

/* 2. 强制内部的 main-row 也垂直居中，并让它填满空间 */
#sts-action-area .chat-input-main-row {
    flex-grow: 1 !important;
    display: flex !important;
    align-items: center !important; /* 核心修正：内部也保持垂直居中 */
    gap: 8px !important;
}

/* 3. 美化输入框本身，并让它自动撑满宽度 */
#sts-action-area #sts-question-input {
    flex-grow: 1; 
    border: none;
    padding: 10px 15px;
    border-radius: 20px;
    background-color: var(--secondary-bg);
    font-size: 16px;
    resize: none;
    max-height: 100px; 
    line-height: 1.5;
}

/* 4. 统一所有按钮的高度和样式，让它们和输入框完美适配 */
#sts-action-area #guess-sts-answer-btn,
#sts-action-area #send-sts-question-btn {
    height: 40px; 
    border-radius: 20px;
    padding: 0 15px;
    flex-shrink: 0;
    font-size: 14px;
    font-weight: 600;
}

/* 5. 夜间模式适配 */
#phone-screen.dark-mode #sts-action-area #sts-question-input {
    background-color: #2c2c2e;
    color: var(--text-primary);
}
/* ▲▲▲ 修复结束 ▲▲▲ */
/* ▼▼▼ 【全新】剧本杀游戏样式 ▼▼▼ */

/* 游戏主界面布局 */
#script-kill-game-content {
    display: flex;
    flex-direction: column;
    height: 100%;
    overflow: hidden;
    padding: 10px;
    box-sizing: border-box;
}

/* 玩家座位区 (复用狼人杀的样式) */
#script-kill-players-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
    gap: 10px;
    padding: 10px;
    flex-shrink: 0;
}

/* 游戏日志区 (复用狼人杀的样式) */
#script-kill-log-container {
    flex-grow: 1;
    background-color: rgba(0,0,0,0.05);
    border-radius: 10px;
    padding: 10px;
    overflow-y: auto;
    margin: 10px 0;
    min-height: 0; /* flex布局下滚动的关键 */
}

/* 玩家操作区 (复用狼人杀的样式) */
#script-kill-action-area {
    flex-shrink: 0;
    padding: 10px;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 15px;
    min-height: 50px;
}
#script-kill-action-area button {
    padding: 10px 20px;
}

/* 投票选项样式 */
#sk-vote-options-list label {
    display: block;
    padding: 8px;
    border-radius: 6px;
    cursor: pointer;
}
#sk-vote-options-list label:hover {
    background-color: #f0f2f5;
}
#phone-screen.dark-mode #sk-vote-options-list label:hover {
    background-color: #2c2c2e;
}

/* 线索卡片样式 */
.sk-evidence-card {
    background-color: var(--secondary-bg);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 12px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
}
.sk-evidence-card .source {
    font-size: 12px;
    color: var(--text-secondary);
    margin-bottom: 8px;
}
.sk-evidence-card .description {
    font-size: 14px;
    line-height: 1.6;
}

/* ▲▲▲ 剧本杀样式结束 ▲▲▲ */
/* ▼▼▼ 把这一整块全新的CSS，粘贴到 <style> 标签的最末尾 ▼▼▼ */

/* 【全新】剧本杀可视化编辑器样式 */

/* 角色/线索卡片的容器 */
.sk-item-container {
    display: flex;
    flex-direction: column;
    gap: 10px;
    background-color: #f0f2f5;
    padding: 10px;
    border-radius: 8px;
    min-height: 50px;
    border: 1px solid var(--border-color);
}
#phone-screen.dark-mode .sk-item-container {
    background-color: #2c2c2e;
}

/* 单个角色/线索的卡片 */
.sk-editor-item {
    background-color: var(--secondary-bg);
    padding: 10px 15px;
    border-radius: 6px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.08);
    position: relative;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.sk-editor-item .item-info .item-name {
    font-weight: 600;
}
.sk-editor-item .item-info .item-meta {
    font-size: 12px;
    color: var(--text-secondary);
}

/* 卡片上的编辑/删除按钮 */
.sk-editor-item .item-actions {
    display: flex;
    gap: 8px;
}
.sk-editor-item .item-actions button {
    padding: 4px 8px;
    font-size: 13px;
    border-radius: 5px;
    cursor: pointer;
}

/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】“你说我猜”游戏样式 ▼▼▼ */

/* 游戏日志区域 */
#guess-what-game-log {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

/* 单条日志条目 */
.guess-log-entry {
    padding: 8px 12px;
    border-radius: 12px;
    line-height: 1.6;
    max-width: 90%;
    word-break: break-word;
}

/* 系统提示，例如游戏开始、谁的回合 */
.guess-log-entry.system {
    background-color: #e9ecef;
    color: var(--text-secondary);
    text-align: center;
    font-weight: 500;
    font-size: 13px;
    align-self: center;
}
#phone-screen.dark-mode .guess-log-entry.system {
    background-color: #2c2c2e;
}

/* 玩家发言的气泡（通用） */
.guess-log-entry.user-turn,
.guess-log-entry.ai-turn {
    display: flex;
    gap: 10px;
    align-items: flex-start;
}

/* 玩家发言内容 */
.guess-log-entry .bubble {
    background-color: #fff;
    padding: 8px 12px;
    border-radius: 8px;
    border: 1px solid var(--border-color);
}
#phone-screen.dark-mode .guess-log-entry .bubble {
    background-color: #2c2c2e;
}

/* AI发言气泡（靠左） */
.guess-log-entry.ai-turn {
    align-self: flex-start;
}

/* 用户发言气泡（靠右） */
.guess-log-entry.user-turn {
    align-self: flex-end;
    flex-direction: row-reverse; /* 头像在右边 */
}
.guess-log-entry.user-turn .bubble {
    background-color: #dcf8c6; /* 类似微信的绿色 */
}
#phone-screen.dark-mode .guess-log-entry.user-turn .bubble {
    background-color: #3b5b32; /* 夜间模式下的绿色 */
}

/* 气泡内的头像 */
.guess-log-entry .avatar {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    flex-shrink: 0;
}

/* 气泡内的名字和内容 */
.guess-log-entry .name {
    font-size: 12px;
    font-weight: 600;
    color: var(--text-secondary);
    margin-bottom: 4px;
}

/* 游戏输入区美化 */
#guess-what-action-area {
    display: flex !important;
    flex-direction: row !important;
    align-items: center !important; /* 保持垂直居中 */
    gap: 8px !important;
    width: 100%; /* 新增：让整个容器撑满宽度 */
    box-sizing: border-box; /* 新增：确保内边距和边框被正确计算在内 */
}


#guess-what-action-area #guess-what-user-input {
    flex-grow: 1;
    border: none;
    padding: 10px 15px;
    border-radius: 20px;
    background-color: var(--secondary-bg);
    font-size: 16px;
    resize: none;
    max-height: 100px;
    line-height: 1.5;
}
#guess-what-action-area #send-guess-what-input-btn {
    height: 40px;
    border-radius: 20px;
    padding: 0 15px;
    flex-shrink: 0;
    font-size: 14px;
    font-weight: 600;
}
#phone-screen.dark-mode #guess-what-action-area #guess-what-user-input {
    background-color: #2c2c2e;
    color: var(--text-primary);
}

/* ▲▲▲ “你说我猜”游戏样式结束 ▲▲▲ */
/* ▼▼▼ 【剧本杀AI生成器布局修复】请将这整块全新的CSS粘贴到 <style> 标签的最末尾 ▼▼▼ */

/* 1. 【核心】让整个弹窗的内容区(modal-body)能够正确地撑满剩余空间并滚动 */
#sk-ai-generator-modal .modal-body {
    flex-grow: 1;      /* 允许内容区占据 header 和 footer 之间的所有可用垂直空间 */
    min-height: 0;     /* 解决flex布局中一个常见的滚动条失效问题，非常关键 */
    /* overflow-y: auto;  <-- 这个属性你的 .modal-body 已经有了，所以不用重复写 */
}

/* 2. 【核心】指定包含“预览框”的那个 form-group 也需要能够弹性增长 */
/* 我们用 :last-of-type 精准定位到最后一个 .form-group */
#sk-ai-generator-modal .modal-body .form-group:last-of-type {
    flex-grow: 1;       /* 让它吃掉所有剩余的垂直空间 */
    min-height: 0;      /* 同样是为了兼容性 */
    display: flex;        /* 把它自己也变成flex容器 */
    flex-direction: column; /* 让它里面的 label 和 preview 垂直排列 */
}

/* 3. 【核心】最后，确保预览框本身能够撑满它的父容器，并且在内容过多时自己滚动 */
#sk-ai-result-preview {
    flex-grow: 1;      /* 撑满父容器(.form-group)的空间 */
    overflow-y: auto;  /* 当代码超出时，显示它自己的滚动条，而不是让整个弹窗滚动 */
    
    /* (可选美化) 给一个最小高度，防止在没内容时完全塌陷 */
    min-height: 100px; 
}

/* ▲▲▲ 粘贴结束 ▲▲▲ */


/* ▼▼▼ 【游戏输入区终极修复版】 ▼▼▼ */

/* 1. 强制重置两个游戏输入区域的容器布局 */
#sts-action-area,
#guess-what-action-area {
    display: flex !important;
    flex-direction: row !important; /* 关键：从纵向改为横向 */
    align-items: center !important;  /* 关键：让所有子元素垂直居中 */
    gap: 8px !important;            /* 设置元素之间的间距 */
    width: 100%;                     /* 新增：让整个容器宽度撑满 */
    box-sizing: border-box;          /* 新增：确保内边距和边框被正确计算 */
}

/* 2. 强制内部的 .chat-input-main-row 也能正确伸展和对齐 */
#sts-action-area .chat-input-main-row,
#guess-what-action-area .chat-input-main-row {
    flex-grow: 1 !important;
    display: flex !important;
    align-items: center !important;
    gap: 8px !important;
}

/* 3. 美化输入框本身，并让它自动撑满宽度 */
#sts-action-area #sts-question-input,
#guess-what-action-area #guess-what-user-input {
    flex-grow: 1; /* 核心：让输入框自动伸展，占满所有可用宽度 */
    min-height: 40px; /* 保证最小高度 */
    border: none;
    padding: 10px 15px;
    border-radius: 20px;
    background-color: var(--secondary-bg);
    font-size: 16px;
    resize: none;
    max-height: 100px;
    line-height: 1.5;
    box-sizing: border-box;
}

/* 4. 统一所有按钮的高度和样式，让它们和输入框完美适配 */
#sts-action-area button,
#guess-what-action-area button {
    height: 40px; 
    border-radius: 20px;
    padding: 0 15px;
    flex-shrink: 0; /* 防止按钮被压缩 */
    font-size: 14px;
    font-weight: 600;
}

/* 5. 夜间模式适配 */
#phone-screen.dark-mode #sts-action-area #sts-question-input,
#phone-screen.dark-mode #guess-what-action-area #guess-what-user-input {
    background-color: #2c2c2e;
    color: var(--text-primary);
}
/* ▲▲▲ 修复结束 ▲▲▲ */
/* === 【独家定制】隐藏游戏大厅返回按钮的 "退出" 文字 === */
#exit-werewolf-game-btn,
#exit-sts-game-btn,
#exit-script-kill-game-btn,
#exit-guess-what-game-btn,
#exit-ludo-game-btn,
#exit-undercover-game-btn { /* <--- 修改在这里 */
    font-size: 0 !important;
    color: transparent !important;
}

#exit-werewolf-game-btn::before,
#exit-sts-game-btn::before,
#exit-script-kill-game-btn::before,
#exit-guess-what-game-btn::before,
#exit-ludo-game-btn::before,
#exit-undercover-game-btn::before { /* <--- 还有这里 */
    content: '‹';
    font-size: 24px !important;
    color: var(--accent-color) !important;
}

/* ▼▼▼ 【V3最终版】游戏发言输入区通用美化样式 (已居中) ▼▼▼ */

/* 1. 让所有游戏的发言区域容器都水平居中 */
#werewolf-action-area.speaking-mode,
#script-kill-action-area.speaking-mode,
#undercover-action-area.speaking-mode { /* ★ 新增了 #undercover-action-area */
    display: flex;
    flex-direction: row;
    align-items: center;
    gap: 8px;
    width: 100%;
    padding: 10px 12px !important; /* 增加上下内边距，让区域不贴底 */
    box-sizing: border-box;
    justify-content: center; /* ★★★ 这就是实现居中的核心代码！ ★★★ */
}

/* 2. 美化所有游戏的发言输入框 */
#werewolf-action-area.speaking-mode #user-speech-input,
#script-kill-action-area.speaking-mode #user-sk-speech-input,
#undercover-action-area.speaking-mode #undercover-user-speech-input {
    /* ★★★ 核心修改：我们移除了 flex-grow: 1; 属性！★★★ */
    /* 这样输入框就不会无限伸展，而是保持一个自然的宽度 */
    
    border: 1px solid #ccc; /* 增加一个淡淡的边框，让它更清晰 */
    padding: 10px 15px;
    border-radius: 20px;
    background-color: var(--secondary-bg);
    font-size: 16px;
    resize: none;
    max-height: 100px;
    line-height: 1.5;
    width: auto; /* 确保宽度是自适应的 */
    height: auto;
    min-width: 200px; /* 给一个最小宽度，防止内容少时太窄 */
}

/* 3. 美化所有游戏的“发言/结束发言”按钮 */
#werewolf-action-area.speaking-mode #end-speech-btn,
#script-kill-action-area.speaking-mode #sk-end-speech-btn,
#undercover-action-area.speaking-mode #undercover-end-speech-btn {
    height: 40px;
    border-radius: 20px;
    padding: 0 20px; /* 增加左右内边距，让按钮更饱满 */
    flex-shrink: 0;
    font-size: 14px;
    font-weight: 600;
    margin: 0 !important; 
    width: auto !important;
    background-color: var(--accent-color);
    color: white;
    border: none;
}

/* 4. 夜间模式适配 */
#phone-screen.dark-mode #werewolf-action-area.speaking-mode #user-speech-input,
#phone-screen.dark-mode #script-kill-action-area.speaking-mode #user-sk-speech-input,
#phone-screen.dark-mode #undercover-action-area.speaking-mode #undercover-user-speech-input {
    background-color: #2c2c2e;
    color: var(--text-primary);
    border-color: #444; /* 夜间模式下的边框颜色 */
}

/* ▲▲▲ 最终版样式粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】宠物功能样式 ▼▼▼ */

#chat-pet {
    transition: transform 0.2s ease-out; /* 为拖动添加一点平滑过渡 */
}

#chat-pet:active {
    cursor: grabbing;
    transform: scale(1.1); /* 拖动时稍微放大，给用户反馈 */
    filter: brightness(0.9);
}

#chat-pet img {
    width: 100%;
    height: 100%;
    object-fit: contain; /* 自定义图片等比缩放 */
    -webkit-user-drag: none; /* 防止图片被意外拖动 */
    user-drag: none;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】宠物数值面板样式 ▼▼▼ */

#pet-stats-area {
    display: flex;
    flex-direction: column;
    gap: 12px; /* 每个数值条之间的间距 */
    margin-bottom: 20px;
    padding: 15px;
    background-color: #f9f9f9;
    border-radius: 8px;
    border: 1px solid var(--border-color);
}

#phone-screen.dark-mode #pet-stats-area {
    background-color: #2c2c2e;
}

.stat-bar-container {
    display: flex;
    align-items: center;
    gap: 8px;
}

.stat-bar-container .stat-label {
    width: 60px; /* 固定标签宽度，让进度条对齐 */
    font-size: 14px;
    font-weight: 500;
    flex-shrink: 0;
}

.stat-bar {
    flex-grow: 1;
    height: 18px;
    background-color: #e9ecef;
    border-radius: 9px;
    overflow: hidden;
    position: relative;
}

#phone-screen.dark-mode .stat-bar {
    background-color: #3e3e42;
}

.stat-bar-fill {
    height: 100%;
    border-radius: 9px;
    transition: width 0.5s ease-in-out;
    display: flex;
    justify-content: center;
    align-items: center;
    color: white;
    font-size: 10px;
    font-weight: bold;
    text-shadow: 0 0 2px rgba(0,0,0,0.5);
}

/* 为不同的数值条设置不同的颜色 */
#pet-hunger-bar .stat-bar-fill {
    background: linear-gradient(135deg, #fd7e14, #ffc107);
}
#pet-happiness-bar .stat-bar-fill {
    background: linear-gradient(135deg, #28a745, #20c997);
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】宠物亲密度进度条颜色 ▼▼▼ */
#pet-intimacy-user-bar .stat-bar-fill {
    background: linear-gradient(135deg, #ff8fab, #ffc3a0); /* 对你：温暖的粉橙色 */
}
#pet-intimacy-char-bar .stat-bar-fill {
    background: linear-gradient(135deg, #a1c4fd, #c2e9fb); /* 对Ta：柔和的天蓝色 */
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】宠物聊天界面样式 ▼▼▼ */
#pet-chat-messages .message-wrapper {
    max-width: 85%;
}

#pet-chat-messages .message-bubble {
    display: flex;
    align-items: flex-start;
    gap: 10px;
}

#pet-chat-messages .message-bubble .avatar {
    width: 34px;
    height: 34px;
    border-radius: 50%;
}

#pet-chat-messages .message-bubble .content {
    padding: 8px 12px;
    border-radius: 10px;
    line-height: 1.5;
}

#pet-chat-messages .message-wrapper.user {
    align-self: flex-end;
}
#pet-chat-messages .message-wrapper.user .message-bubble {
    flex-direction: row-reverse;
}
#pet-chat-messages .message-wrapper.user .content {
    background-color: #dcf8c6;
}

#pet-chat-messages .message-wrapper.pet {
    align-self: flex-start;
}
#pet-chat-messages .message-wrapper.pet .content {
    background-color: #fff;
}

#phone-screen.dark-mode #pet-chat-messages {
    background-color: #000;
}
#phone-screen.dark-mode #pet-chat-messages .message-wrapper.user .content {
    background-color: #26491d;
}
#phone-screen.dark-mode #pet-chat-messages .message-wrapper.pet .content {
    background-color: #2c2c2e;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
/* ▼▼▼ 【布局终极修复】用这整块代码替换你上一次添加的宠物聊天输入框样式 ▼▼▼ */

/* 1. 让弹窗内容区适配新布局 (保持不变) */
#pet-chat-modal .modal-content {
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

/* 2. 消息区域 (保持不变) */
#pet-chat-modal #pet-chat-messages {
    flex-grow: 1;
    min-height: 0;
    overflow-y: auto;
    padding: 20px 15px;
    background-color: #f0f2f5;
    display: flex;
    flex-direction: column;
    gap: 15px;
}

/* 3. 气泡样式 (保持不变) */
#pet-chat-modal .message-bubble .content { padding: 0; background: transparent; box-shadow: none; border: none; }
#pet-chat-modal .message-wrapper.user .content { background-color: #007AFF; color: white; padding: 10px 14px; border-radius: 18px 18px 4px 18px; max-width: 100%; }
#pet-chat-modal .message-wrapper.pet .content { background-color: #ffffff; color: #1c1c1e; padding: 10px 14px; border-radius: 18px 18px 18px 4px; max-width: 100%; box-shadow: 0 1px 2px rgba(0,0,0,0.05); }

/* --- ▼▼▼ 核心修复区域 ▼▼▼ --- */

/* 4. 重置输入区域的背景和边框 (保持不变) */
#pet-chat-modal #pet-chat-input-area {
    border-top: 1px solid #e0e0e0;
    background-color: #f7f7f7;
    padding: 10px 12px;
    padding-bottom: calc(10px + env(safe-area-inset-bottom));
}

/* 5. 【核心修复】让输入框和发送按钮的容器变成 Flex 布局 */
#pet-chat-modal #pet-chat-input-area .chat-input-main-row {
    display: flex;           /* 关键：让内部元素横向排列 */
    align-items: center;     /* 关键：让输入框和按钮垂直居中对齐，实现“平行” */
    gap: 8px;                /* 输入框和按钮之间的间距 */
}

/* 6. 美化输入框，并【让它撑满宽度】 */
#pet-chat-modal #pet-chat-input {
    flex-grow: 1;            /* 关键：让输入框占据所有剩余的宽度 */
    background-color: white;
    border: 1px solid #ddd;
    border-radius: 18px;
    padding: 8px 15px;
    line-height: 1.5;
    min-height: 38px;
    max-height: 100px;
    resize: none;            /* 禁止用户手动拖拽大小 */
    box-sizing: border-box;  /* 确保padding不会撑破布局 */
}

/* 7. 美化发送按钮，并固定其大小 */
#pet-chat-modal #send-to-pet-btn {
    flex-shrink: 0;          /* 防止按钮被压缩 */
    background-color: #007AFF;
    color: white;
    border: none;
    border-radius: 18px;
    height: 38px;
    padding: 0 20px;
    font-weight: 600;
    cursor: pointer;         /* 鼠标放上去时显示小手 */
}

/* 8. 夜间模式适配 (保持不变) */
#phone-screen.dark-mode #pet-chat-modal #pet-chat-messages { background-color: #000; }
#phone-screen.dark-mode #pet-chat-modal .message-wrapper.pet .content { background-color: #2c2c2e; }
#phone-screen.dark-mode #pet-chat-modal #pet-chat-input-area { background-color: #1c1c1e; border-top-color: #38383a; }
#phone-screen.dark-mode #pet-chat-modal #pet-chat-input { background-color: #2c2c2e; border-color: #38383a; color: white; }

/* ▲▲▲ 修复结束 ▲▲▲ */
/* ▼▼▼ 把这一整块全新的CSS，粘贴到 <style> 标签的最末尾 ▼▼▼ */

/* --- 【全新】情侣空间-情绪日记样式 --- */

/* 日记视图主容器 */
#ls-diary-view {
    display: flex;
    flex-direction: column;
    gap: 20px;
}

/* 日历容器 */
.ls-calendar-wrapper {
    background-color: var(--secondary-bg);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
}

.ls-calendar-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
    font-size: 16px;
    font-weight: 600;
}

.ls-calendar-header button {
    background: none;
    border: none;
    font-size: 20px;
    cursor: pointer;
    color: var(--accent-color);
}

.ls-calendar-weekdays {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    text-align: center;
    font-size: 12px;
    color: var(--text-secondary);
    margin-bottom: 10px;
}

.ls-calendar-grid {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    gap: 5px;
}

.ls-calendar-day {
    aspect-ratio: 1 / 1;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    align-items: center;
    border-radius: 6px;
    cursor: pointer;
    transition: background-color 0.2s;
    position: relative;
    padding-top: 4px;
}
.ls-calendar-day:hover {
    background-color: #f0f2f5;
}
.ls-calendar-day.empty {
    cursor: default;
    pointer-events: none;
}
.ls-calendar-day.today .day-number {
    background-color: var(--accent-color);
    color: white;
    border-radius: 50%;
    width: 22px;
    height: 22px;
    line-height: 22px;
}

.ls-calendar-day .day-number {
    font-size: 13px;
    font-weight: 500;
    margin-bottom: 4px;
}

.ls-calendar-day .mood-emojis {
    display: flex;
    gap: 4px;
    font-size: 16px;
    position: absolute;
    bottom: 5px;
}

/* 心情罐子 */
.ls-mood-jar-wrapper {
    background-color: var(--secondary-bg);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    text-align: center;
}

.ls-mood-jar-wrapper h3 {
    margin: 0 0 15px 0;
    font-size: 16px;
}

/* ▼▼▼ 用这块【修复后】的代码替换旧的 .ls-mood-jar 样式 ▼▼▼ */
.ls-mood-jar {
    width: 100%;
    max-width: 100%;           /* ★ 核心修改1: 使用max-width防止溢出 */
    box-sizing: border-box;    /* ★ 核心修改2: 确保padding不会导致宽度计算错误 */
    min-height: 80px;
    background-color: #f0f2f5;
    border-radius: 8px;
    padding: 10px;
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    align-content: flex-start;
    justify-content: center;
    overflow: auto; /* ★ 核心修改3 (保险): 如果内容实在太多，就用滚动条兜底 */
}
/* ▲▲▲ 替换结束 ▲▲▲ */


.ls-mood-jar .mood-emoji-item {
    font-size: 22px;
}

/* 日记编辑弹窗 */
#ls-emoji-selector .emoji-option {
    padding: 5px;
    border-radius: 8px;
    transition: background-color 0.2s;
}
#ls-emoji-selector .emoji-option.selected {
    background-color: #e0e0e0;
    transform: scale(1.2);
}

/* 日记查看弹窗 */
.ls-diary-entry-block {
    background-color: #f9f9f9;
    border-radius: 8px;
    padding: 15px;
    border-left: 4px solid var(--accent-color);
}
.ls-diary-entry-block .entry-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 10px;
}
.ls-diary-entry-block .entry-header .mood-emoji {
    font-size: 32px;
}
.ls-diary-entry-block .entry-header .author {
    font-weight: 600;
    font-size: 16px;
}
.ls-diary-entry-block .entry-content {
    line-height: 1.7;
    white-space: pre-wrap;
    word-break: break-word;
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 把这一整块全新的CSS，粘贴到 <style> 标签的最末尾 ▼▼▼ */

/* --- 【全新】情侣空间-日记通知卡片样式 --- */

/* 1. 让包裹卡片的气泡本身变透明 */
.message-bubble.is-ls-diary-notification .content {
    padding: 0;
    background: transparent;
    box-shadow: none;
    border: none;
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
}

/* 2. 卡片主体样式 */
.ls-diary-notification-card {
    width: 220px; /* 卡片宽度 */
    background: linear-gradient(135deg, #fff5f8, #ffebee); /* 温柔的粉色渐变背景 */
    border-radius: 12px;
    padding: 15px;
    cursor: pointer;
    border: 1px solid #ffdde1; /* 淡淡的粉色边框 */
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    position: relative;
    overflow: hidden; /* 隐藏溢出的装饰元素 */
    transition: transform 0.2s, box-shadow 0.2s; /* 添加点击动效 */
}
.ls-diary-notification-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
}

/* 3. 卡片右上角的装饰性图标 */
.ls-diary-notification-card::before {
    content: '💌';
    position: absolute;
    top: -5px;
    right: 10px;
    font-size: 30px;
    opacity: 0.1;
    transform: rotate(15deg);
}

/* 4. 卡片头部（图标和标题） */
.ls-diary-card-header {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 15px;
    font-weight: 600;
    color: #c85c7c; /* 稍深的粉色，保证清晰度 */
    margin-bottom: 10px;
    padding-bottom: 8px;
    border-bottom: 1px solid rgba(200, 92, 124, 0.2);
}

/* 5. 卡片正文 */
.ls-diary-card-body p {
    font-size: 14px;
    color: #5c474b; /* 深棕色，易于阅读 */
    margin: 0 0 12px 0;
    line-height: 1.6;
}

/* 6. 卡片底部提示文字 */
.ls-diary-card-footer {
    font-size: 12px;
    color: #c85c7c;
    text-align: right;
    font-weight: 500;
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */


/* ▼▼▼ 【独家定制】宠物互动按钮 2x2 网格布局 (最终加强版) ▼▼▼ */

/* 1. 使用 !important 强制开启网格布局，对抗样式冲突 */
#pet-interaction-area {
    display: grid !important;        /* 关键：强制使用 grid 布局 */
    grid-template-columns: 1fr 1fr;  /* 两列网格 */
    gap: 10px;                       /* 按钮间距 */
    max-width: 220px;                /* 适当放宽最大宽度，给按钮更多空间 */
    margin: 15px auto !important;    /* 强制居中 */
}

/* 2. 调整按钮尺寸，并强制文字不换行 */
#pet-interaction-area button {
    /* 尺寸和文字 */
    padding: 8px 12px;
    font-size: 14px;
    white-space: nowrap;             /* 关键：强制文字在同一行显示，防止换行 */
    
    /* 形状和美化 */
    border-radius: 18px;
    width: 100%;
    font-weight: 600;
    background-color: #f0f2f5;
    color: var(--accent-color);
    border: 1.5px solid var(--accent-color);
    cursor: pointer;
    transition: all 0.2s ease-in-out;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}

/* 3. 交互效果保持不变 */
#pet-interaction-area button:hover {
    background-color: var(--accent-color);
    color: white;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}

#pet-interaction-area button:active {
    transform: translateY(0) scale(0.98);
    box-shadow: 0 1px 2px rgba(0,0,0,0.08);
}

/* ▲▲▲ 美化样式结束 ▲▲▲ */


/* --- 【最终版】情侣空间右上角按钮美化与独立微调 --- */

/* 1. 收紧按钮容器的整体间距 */
#ls-header .header-actions {
    gap: 0px; /* ★ 修改这里：将按钮间的间距减小到0，让它们紧挨着 */
}

/* 2. 保持按钮的基础样式（这部分不变） */
#ls-header .action-btn {
    padding: 8px; 
    border-radius: 50%;
    transition: background-color 0.2s;
}
#ls-header .action-btn:hover {
    background-color: rgba(255, 255, 255, 0.2);
}

/* 3. 【核心】为每个按钮添加独立的微调功能 */

/* “设置”按钮的独立位置 */
#ls-settings-btn {
    position: relative; /* 启用相对定位，这是微调的关键 */
    top: 0px;           /* 【调上下】: 正数往下移，负数往上移 */
    left: 40px;          /* 【调左右】: 正数往右移，负数往左移 */
}

/* “更换背景”按钮的独立位置 */
#ls-change-bg-btn {
    position: relative;
    top: 0px;          
    left: 30px;          
}

/* “切换”按钮的独立位置 */
#ls-switch-char-btn {
    position: relative;
    top: -5px;
    left: 15px;
}

/* ▼▼▼ 【独家定制】情侣空间心动音波图标 ▼▼▼ */

/* 1. 移除旧的爱心字符和发光效果 */
.ls-header-avatars .heart-icon {
    font-size: 0; /* 让'❤'字符消失 */
    text-shadow: none; /* 移除文字阴影 */
    
    /* 2. 为新图标设置一个容器大小，您可以根据喜好微调 */
    width: 80px;
    height: 28px;
    
    /* 3. 【核心】将你图片中的音波心动图设置为背景 */
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='80' height='24' viewBox='0 0 80 24'%3E%3Cg fill='%23ff8fab'%3E%3Crect x='0' y='10' width='3' height='4' rx='1.5'/%3E%3Crect x='5' y='8' width='3' height='8' rx='1.5'/%3E%3Crect x='10' y='11' width='3' height='2' rx='1.5'/%3E%3Crect x='15' y='6' width='3' height='12' rx='1.5'/%3E%3Crect x='20' y='9' width='3' height='6' rx='1.5'/%3E%3Cpath transform='translate(25 0) scale(1.1)' d='M22 8.879c0-5.323-5.326-5.323-7.5-1.121C12.277 2.235 7 3.556 7 8.879 7 14.155 14.5 20 14.5 20S22 14.155 22 8.879z'/%3E%3Crect x='55' y='9' width='3' height='6' rx='1.5'/%3E%3Crect x='60' y='6' width='3' height='12' rx='1.5'/%3E%Crect x='65' y='11' width='3' height='2' rx='1.5'/%3E%3Crect x='70' y='8' width='3' height='8' rx='1.5'/%3E%3Crect x='75' y='10' width='3' height='4' rx='1.5'/%3E%3C/g%3E%3C/svg%3E");
    background-size: contain; /* 确保图标完整显示 */
    background-repeat: no-repeat;
    background-position: center;
    
    /* 4. （可选）微调垂直位置，让它和头像更对齐 */
    position: relative;
    top: -2px; 
}

/* ▲▲▲ 定制样式结束 ▲▲▲ */

/* ▼▼▼ 这是为你新增的日历居中修复代码 ▼▼▼ */

/* 1. 强制让每一天的格子内容都不要溢出，避免互相影响 */
.ls-calendar-day {
    overflow: hidden;
    text-align: center; /* 再次强调文本居中，更稳定 */
}

/* 2. 【核心修复】将蓝圈本身也变成一个flex居中容器 */
/* 这能确保里面的数字，无论如何都会在圈圈的正中间 */
.ls-calendar-day.today .day-number {
    display: flex;
    justify-content: center;
    align-items: center;
}

/* ▲▲▲ 修复结束 ▲▲▲ */

/* ▼▼▼ 【独家定制】情侣空间返回按钮美化 ▼▼▼ */
#ls-header .back-btn {
    /* 1. 核心修改：将箭头颜色设为您想要的白色 */
    color: white;
    
    /* 2. 统一样式：让它和圈子返回按钮一样，拥有40x40px的圆形点击区域 */
    width: 40px;
    height: 40px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background-color 0.2s ease;
    cursor: pointer;
}

/* 3. 为它添加与其他按钮统一的、漂亮的悬停效果 */
#ls-header .back-btn:hover {
    background-color: rgba(255, 255, 255, 0.2);
}
/* ▲▲▲ 新增样式结束 ▲▲▲ */
/* ▼▼▼ 【全新】记忆互通选择框美化样式 ▼▼▼ */

/* 1. 让每个选项的标签(label)成为一个flex容器 */
.memory-link-option {
    display: flex;
    align-items: center; /* 垂直居中对齐 */
    gap: 10px;           /* 元素之间的间距 */
    padding: 8px 12px !important;  /* 增加内边距，!important确保生效 */
    cursor: pointer;
}

/* 2. 单独为复选框设置样式，防止被全局样式影响 */
.memory-link-option input[type="checkbox"] {
    width: 18px !important;  /* 固定宽度 */
    height: 18px !important; /* 固定高度 */
    margin: 0 !important;    /* 移除外边距 */
    flex-shrink: 0;          /* 防止被压缩 */
}

/* 3. 设置头像的样式 */
.memory-link-avatar {
    width: 28px;
    height: 28px;
    border-radius: 50%; /* 圆形头像 */
    object-fit: cover;  /* 保证图片不变形 */
    flex-shrink: 0;     /* 防止被压缩 */
}

/* 4. 设置名字的样式 */
.memory-link-name {
    /* 默认样式即可，它会自动填充剩余空间 */
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】记忆互通选择框美化样式 ▼▼▼ */
#memory-link-checkboxes-container label {
    display: flex;           /* 1. 使用Flex布局，让头像和文字横向排列 */
    align-items: center;     /* 2. 垂直居中对齐 */
    gap: 10px;               /* 3. 在头像、复选框和文字之间创建间距 */
    padding: 10px 12px;      /* 4. 增加内边距，让每一行更高、更易于点击 */
    cursor: pointer;         /* 5. 鼠标放上去时显示小手图标 */
    transition: background-color 0.2s; /* 6. 添加悬停效果 */
}

#memory-link-checkboxes-container label:hover {
    background-color: #f0f2f5; /* 7. 鼠标悬停时给一个淡淡的背景色 */
}

#memory-link-checkboxes-container .avatar-preview {
    width: 30px;             /* 8. 设置头像的尺寸 */
    height: 30px;
    border-radius: 50%;      /* 9. 圆形头像 */
    object-fit: cover;       /* 10. 确保图片不变形 */
    flex-shrink: 0;          /* 11. 防止头像在空间不足时被压缩 */
}

#memory-link-checkboxes-container input[type="checkbox"] {
    /* 12. 调整复选框的大小和位置，使其更协调 */
    width: 18px;
    height: 18px;
    margin: 0;
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */

/* ▼▼▼ 【V6 最终修正版】心声面板（边框问题修复） ▼▼▼ */

/* 1. 基础布局 (保持不变) */
#inner-voice-modal .modal-body { position: relative; min-height: 450px; }
#inner-voice-avatar-wrapper,
#inner-voice-char-name,
#inner-voice-adopter-info { position: absolute; transition: all 0.3s ease; }

/* 2. 角色主头像的容器：在这里添加 padding 和 background-color */
#inner-voice-avatar-wrapper {
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    width: 65px;
    height: 65px;
    border-radius: 50%;
    
    /* --- ▼▼▼ 核心修改在这里 ▼▼▼ --- */
    padding: 4px; /* ★ 新增：向内挤压4像素，为红线留出空间。你可以自己调整这个数值，比如3px或5px */
    background-color: #fff; /* ★ 新增：让内边距的区域显示为白色，形成一个“白环” */
    box-sizing: border-box; /* ★ 新增：确保padding不会把容器撑大，这很重要 */
    /* --- ▲▲▲ 修改结束 ▲▲▲ --- */

    box-shadow: 0 0 0 1.5px transparent;
    transition: box-shadow 0.2s ease-in-out;
}

/* 当需要显示边框时，改变 box-shadow 的颜色 (已修改为粉色) */
#inner-voice-avatar-wrapper.has-border {
    box-shadow: 0 0 0 1.5px #ff8fab; /*  <-- 就是修改这里！*/
}


/* 4. 移除之前制造冲突的 ::after 伪元素 (保持不变) */
#inner-voice-avatar-wrapper::after {
    display: none;
}

/* 角色主头像的图片样式（保持不变） */
#inner-voice-avatar-wrapper #inner-voice-avatar {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
    border: none; 
}

/* 头像框的样式（保持不变） */
/* ▼▼▼ 【最终微调版】请用这整块代码，替换掉旧的聊天和心声头像框规则 ▼▼▼ */

.avatar-with-frame .avatar-frame,
#inner-voice-avatar-frame {
    position: absolute;
    width: 110%;
    height: 115%;
    transform: translate(-50%, -56%);
    top: 50%;
    left: 50%;
    z-index: 2;
    pointer-events: none;
}


/* ▲▲▲ 替换结束 ▲▲▲ */


/* 5. 角色名字和领养人信息的位置 (保持不变) */
#inner-voice-char-name {
    top: 95px; left: 50%; transform: translateX(-50%); font-weight: 600; font-size: 16px; color: #333; text-align: center;
}
#inner-voice-adopter-info {
    top: 125px; left: 50%; transform: translateX(-50%); display: flex; align-items: center; gap: 8px; font-size: 13px; color: #666;
}
#inner-voice-adopter-info img { width: 24px; height: 24px; border-radius: 50%; }

/* 6. 内容区距离 (保持不变) */
#inner-voice-content-area { margin-top: 165px; }

/* ▼▼▼ 【全新 | CSS变量版】心声面板卡片和标签样式 ▼▼▼ */

/* 这是心声面板里，每个项目（例如“服装”的整个卡片）的样式 */
#inner-voice-content-area > div {
    /* 核心修改：我们把颜色和透明度变成了可以被JS修改的变量 */
    background-color: rgba(var(--iv-card-bg-rgb, 255, 255, 255), var(--iv-card-opacity, 0.7));

    border-radius: 16px;
    padding: 15px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    border: 1px solid rgba(255, 255, 255, 0.9);
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
    transition: background-color 0.3s; /* 添加平滑过渡 */
}

/* ▼▼▼ 【最终修复版】心声面板标签样式 ▼▼▼ */

/* 1. 先定义所有标签的通用样式，确保形状、字体颜色、阴影等都保持不变 */
#inner-voice-content-area strong {
    padding: 3px 10px;
    border-radius: 12px;
    color: white !important; /* 强制字体颜色为白色 */
    text-shadow: 0 1px 2px rgba(0,0,0,0.2); /* 保持文字阴影 */
}

/* 2. 然后，再为每个标签单独设置可变的背景颜色 */
#inner-voice-content-area div:nth-of-type(1) strong {
    background-color: var(--iv-color-clothing, #f0a1a8); /* 服装 */
}
#inner-voice-content-area div:nth-of-type(2) strong {
    background-color: var(--iv-color-behavior, #81c784); /* 行为 */
}
#inner-voice-content-area div:nth-of-type(3) strong {
    background-color: var(--iv-color-thoughts, #64b5f6); /* 心声 */
}
#inner-voice-content-area div:nth-of-type(4) strong {
    background-color: var(--iv-color-naughty, #ba68c8); /* 坏心思 */
}

/* ▲▲▲ 修复结束 ▲▲▲ */


/* ▲▲▲ 替换结束 ▲▲▲ */


/* ▲▲▲ 定制样式结束 ▲▲▲ */

/*
  【独家定制】单独修改心声头像框的大小和位置
  使用说明：
  1. 将下面这整块代码粘贴到 <style> 标签的最末尾。
  2. 修改下面的 width, height, top, left 的数值来调整头像框。
*/
#inner-voice-avatar-frame {
    /*
     * 控制大小：数值越大，头像框越大。
     * 例如：120% (比原来小), 150% (比原来大)
     */
    width: 100%; 
    height: 100%; 

    /*
     * 控制位置：以头像中心为原点 (50%, 50%) 进行微调
     */

    /* 控制【上下】位置：小于50%则上移，大于50%则下移 */
    top: 43%; /* 示例：稍微向上移动了一点 */

    /* 控制【左右】位置：小于50%则左移，大于50%则右移 */
    left: 50%; /* 示例：保持水平居中 */
    
    /* 
      以下为保持居中和显示效果必须的属性，请勿修改 
    */
    position: absolute;
    transform: translate(-50%, -50%);
    z-index: 2;
    pointer-events: none;
}
/* ▼▼▼ 【全新】这是微博私信功能的所有新样式，请粘贴到 <style> 的末尾 ▼▼▼ */

/* --- 私信列表页面 --- */
#weibo-dm-list .dm-list-item {
    display: flex;
    align-items: center;
    padding: 10px 15px;
    cursor: pointer;
    border-bottom: 1px solid var(--border-color);
}
#weibo-dm-list .dm-list-item:hover {
    background-color: #f5f5f5;
}
#phone-screen.dark-mode #weibo-dm-list .dm-list-item:hover {
    background-color: #2c2c2e;
}
#weibo-dm-list .dm-avatar {
    width: 45px;
    height: 45px;
    border-radius: 50%;
    margin-right: 12px;
    object-fit: cover;
}
#weibo-dm-list .dm-info {
    flex-grow: 1;
    overflow: hidden;
}
#weibo-dm-list .dm-name {
    font-weight: 500;
    font-size: 16px;
    margin-bottom: 4px;
}
#weibo-dm-list .dm-last-msg {
    font-size: 13px;
    color: var(--text-secondary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* --- 私信详情页面 --- */
#weibo-dm-messages {
    background-color: #f0f2f5 !important;
}
#phone-screen.dark-mode #weibo-dm-messages {
    background-color: #000000 !important;
}

/* 复用主聊天界面的气泡样式，但为粉丝和角色定义特定对齐方式 */
#weibo-dm-messages .message-wrapper.fan {
    align-self: flex-start;
}
#weibo-dm-messages .message-wrapper.fan .message-bubble {
    flex-direction: row;
}
#weibo-dm-messages .message-wrapper.fan .content {
    background-color: #ffffff;
    border-radius: 2px 18px 18px 18px;
}

#weibo-dm-messages .message-wrapper.char {
    align-self: flex-end;
}
#weibo-dm-messages .message-wrapper.char .message-bubble {
    flex-direction: row-reverse;
}
#weibo-dm-messages .message-wrapper.char .content {
    background-color: #ff8200; /* 微博橙色 */
    color: white;
    border-radius: 18px 2px 18px 18px;
}

#phone-screen.dark-mode #weibo-dm-messages .message-wrapper.fan .content {
    background-color: #2c2c2e;
}
#phone-screen.dark-mode #weibo-dm-messages .message-wrapper.char .content {
    background-color: #e67300;
}

/* ★★★ 这是你需要的【删除按钮】的样式 ★★★ */
.dm-message-delete-btn {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    width: 22px;
    height: 22px;
    background-color: rgba(0, 0, 0, 0.1);
    color: #555;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    font-size: 16px;
    line-height: 22px;
    text-align: center;
    opacity: 0; /* 默认隐藏 */
    transition: all 0.2s ease;
}
/* 鼠标悬停在消息上时显示按钮 */
#weibo-dm-messages .message-wrapper:hover .dm-message-delete-btn {
    opacity: 1;
}
.dm-message-delete-btn:hover {
    background-color: #ff3b30;
    color: white;
}
/* 调整按钮位置，让它出现在气泡旁边 */
#weibo-dm-messages .message-wrapper.fan .dm-message-delete-btn {
    right: -28px; /* 修改：从 left 改为 right，把它放到右边 */
    left: auto;   /* 新增：取消左侧定位，确保 right 生效 */
}
#weibo-dm-messages .message-wrapper.char .dm-message-delete-btn {
    right: -28px;
}
/* ▼▼▼ 【全新】聊天总结功能样式 ▼▼▼ */

/* 总结管理弹窗内的列表 */
#summary-list {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

/* 单条总结卡片 */
.summary-item-card {
    background-color: #f9f9f9;
    border-radius: 8px;
    padding: 12px;
    border: 1px solid var(--border-color);
    position: relative;
}

#phone-screen.dark-mode .summary-item-card {
    background-color: #2c2c2e;
}

.summary-item-card .summary-content {
    font-size: 14px;
    line-height: 1.6;
    white-space: pre-wrap;
    word-break: break-word;
    max-height: 100px;
    overflow: hidden;
    text-overflow: ellipsis;
}

.summary-item-card .summary-meta {
    font-size: 11px;
    color: var(--text-secondary);
    margin-top: 8px;
    padding-top: 8px;
    border-top: 1px solid var(--border-color);
    display: flex;
    justify-content: space-between;
}

.summary-item-card .summary-actions {
    position: absolute;
    top: 8px;
    right: 8px;
    display: flex;
    gap: 8px;
}

.summary-item-card .summary-actions button {
    background: none;
    border: none;
    cursor: pointer;
    font-size: 18px;
    color: var(--text-secondary);
    padding: 5px;
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
/* ▼▼▼ 把这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* 聊天总结弹窗底部按钮的美化 */
#summary-viewer-modal .modal-footer button {
    width: auto; /* 让宽度自适应 */
    margin-top: 0; /* 移除顶部外边距 */
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
/* ▼▼▼ 把这一整块全新的CSS，粘贴到 <style> 标签的最末尾 ▼▼▼ */

/* --- “桃宝”App 整体布局 --- */
#taobao-screen {
    background-color: #f0f2f5;
}

/* 顶部页签 */
.taobao-tabs {
    display: flex;
    flex-shrink: 0;
    border-bottom: 1px solid var(--border-color);
    background-color: var(--secondary-bg);
}
.taobao-tab {
    flex: 1;
    padding: 12px 0;
    text-align: center;
    font-weight: 500;
    color: var(--text-secondary);
    border: none;
    background: none;
    cursor: pointer;
    position: relative;
}
.taobao-tab.active {
    color: #FF5722; /* 淘宝橙 */
}
.taobao-tab.active::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
    width: 40px;
    height: 3px;
    background-color: #FF5722;
    border-radius: 1.5px;
}

/* 内容区域 */
.taobao-content {
    flex-grow: 1;
    position: relative;
    overflow: hidden;
}
.taobao-view {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    overflow-y: auto;
    display: none;
    padding: 15px;
    box-sizing: border-box;
}
.taobao-view.active {
    display: block;
}

/* --- 首页/商品视图 --- */
#product-category-tabs {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
    overflow-x: auto;
    padding-bottom: 5px; /* for scrollbar */
    scrollbar-width: none;
    -ms-overflow-style: none;
}
#product-category-tabs::-webkit-scrollbar { display: none; }

#product-category-tabs .category-tab-btn {
    padding: 6px 12px;
    border-radius: 15px;
    border: 1px solid var(--border-color);
    background-color: var(--secondary-bg);
    white-space: nowrap;
    cursor: pointer;
}
#product-category-tabs .category-tab-btn.active {
    background-color: #FFEFE9;
    color: #FF5722;
    border-color: #FF5722;
}

.product-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
}
.product-card {
    background-color: var(--secondary-bg);
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 1px 4px rgba(0,0,0,0.08);
    cursor: pointer;
}
.product-card .product-image {
    width: 100%;
    aspect-ratio: 1 / 1;
    object-fit: cover;
    background-color: #f0f2f5;
}
.product-card .product-info {
    padding: 8px;
}
.product-card .product-name {
    font-size: 14px;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
    min-height: 2.8em; /* 保证两行的高度 */
}
.product-card .product-price {
    font-size: 16px;
    font-weight: bold;
    color: #FF5722;
    margin-top: 5px;
}
.product-card .product-price::before {
    content: '¥';
    font-size: 12px;
    margin-right: 2px;
}

/* --- 我的/余额视图 --- */
#user-balance-container {
    background: linear-gradient(135deg, #FF9A8B 0%, #FF6A88 100%);
    color: white;
    padding: 30px 20px;
    border-radius: 12px;
    text-align: center;
    text-shadow: 0 1px 3px rgba(0,0,0,0.2);
}
#user-balance-container h2 {
    font-size: 40px;
    margin: 10px 0 20px 0;
}
#top-up-btn {
    background-color: rgba(255,255,255,0.9);
    color: #FF5722;
}

/* --- 订单/物流视图 --- */
.order-list {
    display: flex;
    flex-direction: column;
    gap: 15px;
}
.order-item {
    background-color: var(--secondary-bg);
    border-radius: 8px;
    padding: 12px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.06);
    display: flex;
    gap: 12px;
}
.order-item .product-image {
    width: 70px;
    height: 70px;
    border-radius: 6px;
    flex-shrink: 0;
}
.order-item .order-info {
    flex-grow: 1;
}
.order-item .product-name {
    font-weight: 500;
}
.order-item .order-status {
    font-size: 13px;
    color: #28a745;
    margin-top: 8px;
    font-weight: 500;
}
.order-item .order-time {
    font-size: 12px;
    color: var(--text-secondary);
    margin-top: 4px;
}

/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 把这一整块全新的CSS，粘贴到 <style> 标签的最末尾 ▼▼▼ */

/* --- “桃宝”App 搜索栏样式 --- */
.taobao-search-bar {
    display: flex;
    gap: 10px;
    padding: 0 0 15px 0; /* 只在下方留出间距 */
}

#product-search-input {
    flex-grow: 1;
    border: 1px solid #FF5722;
    padding: 10px 15px;
    border-radius: 20px;
    font-size: 14px;
    outline: none;
}

#product-search-btn {
    background-color: #FF5722;
    color: white;
    border: none;
    border-radius: 20px;
    padding: 0 20px;
    font-weight: 500;
    cursor: pointer;
}

/* --- AI生成结果弹窗内的样式 --- */
#ai-product-results-grid .product-card {
    position: relative; /* 为了定位“添加”按钮 */
    padding-bottom: 40px; /* 为按钮留出空间 */
    cursor: default; /* 在弹窗里，卡片本身不可点击 */
}

.add-to-my-page-btn {
    position: absolute;
    bottom: 8px;
    left: 8px;
    right: 8px;
    width: calc(100% - 16px);
    padding: 8px 0;
    background-color: #4CAF50; /* 绿色，代表添加 */
    color: white;
    border: none;
    border-radius: 6px;
    font-weight: 500;
    cursor: pointer;
    transition: background-color 0.2s;
}

.add-to-my-page-btn:hover {
    background-color: #45a049;
}

.add-to-my-page-btn:disabled {
    background-color: #cccccc;
    cursor: not-allowed;
}


/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 把这一整块全新的CSS，粘贴到 <style> 标签的最末尾 ▼▼▼ */

/* --- 购物车页签上的小红点 --- */
.taobao-tab {
    position: relative;
}
#cart-item-count-badge {
    position: absolute;
    top: 5px;
    right: 15px;
    min-width: 18px;
    height: 18px;
    padding: 0 5px;
    background-color: #FF5722;
    color: white;
    font-size: 11px;
    border-radius: 9px;
    line-height: 18px;
}

/* --- 商品卡片上的“加入购物车”按钮 --- */
.product-card .add-cart-btn {
    position: absolute;
    bottom: 5px;
    right: 5px;
    width: 28px;
    height: 28px;
    background-color: #FF5722;
    color: white;
    border: none;
    border-radius: 50%;
    font-size: 18px;
    line-height: 28px;
    text-align: center;
    cursor: pointer;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    transition: transform 0.2s;
}
.product-card .add-cart-btn:active {
    transform: scale(0.9);
}

/* --- 购物车列表 --- */
#cart-item-list {
    display: flex;
    flex-direction: column;
    gap: 10px;
    padding-bottom: 70px; /* 为底部的结算栏留出空间 */
}
.cart-item {
    background-color: var(--secondary-bg);
    border-radius: 8px;
    padding: 12px;
    display: flex;
    align-items: center;
    gap: 12px;
}
.cart-item .product-image {
    width: 80px;
    height: 80px;
    border-radius: 6px;
    flex-shrink: 0;
    cursor: pointer; /* 让图片可点击 */
}
.cart-item .cart-item-info {
    flex-grow: 1;
    cursor: pointer; /* 让信息区也可点击 */
}
.cart-item .product-name {
    font-weight: 500;
}
.cart-item .product-price {
    color: #FF5722;
    font-weight: bold;
    margin-top: 8px;
}
.cart-item .quantity-controls {
    display: flex;
    align-items: center;
    gap: 8px;
}
.cart-item .quantity-controls button {
    width: 24px;
    height: 24px;
    border: 1px solid #ccc;
    background-color: #f0f0f0;
    border-radius: 50%;
    cursor: pointer;
}
.cart-item .delete-cart-item-btn {
    width: 30px;
    height: 30px;
    border: none;
    background: none;
    color: #999;
    font-size: 24px;
    cursor: pointer;
    flex-shrink: 0;
}

/* --- 购物车结算栏 --- */
#cart-checkout-bar {
    position: fixed; /* ★★★ 核心修改：从 absolute 改为 fixed ★★★ */
    bottom: 0;
    left: 0;
    right: 0; /* (推荐) 配合 left:0 自动撑满宽度，更稳妥 */
    /* width: 100%; (可以保留或删除) */
    z-index: 10; /* (推荐) 确保它始终在最上层 */
    padding: 10px 15px;
    padding-bottom: calc(10px + env(safe-area-inset-bottom));
    background-color: var(--secondary-bg);
    border-top: 1px solid var(--border-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
    box-sizing: border-box;
}

#cart-checkout-bar .total-price {
    font-weight: bold;
}
#cart-checkout-bar #cart-total-price {
    color: #FF5722;
    font-size: 18px;
}
#cart-checkout-bar #checkout-btn {
    background-color: #FF5722;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 20px;
    font-weight: 500;
    cursor: pointer;
}

/* --- 商品详情弹窗 --- */
#product-detail-body {
    text-align: center;
}
#product-detail-body .product-image {
    width: 80%;
    max-width: 250px;
    border-radius: 8px;
    margin-bottom: 15px;
}
#product-detail-body .product-name {
    font-size: 18px;
    font-weight: 600;
    margin-bottom: 10px;
}
#product-detail-body .product-price {
    font-size: 24px;
    font-weight: bold;
    color: #FF5722;
    margin-bottom: 20px;
}
#product-detail-body .product-price::before {
    content: '¥';
    font-size: 16px;
}

/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 把这一整块全新的CSS，粘贴到 <style> 标签的最末尾 ▼▼▼ */

/* --- 商品详情弹窗 - 评价区 --- */
#product-reviews-section {
    padding: 0 15px 15px 15px; /* 和主体内容保持一致的内边距 */
    border-top: 1px solid var(--border-color);
    margin-top: 15px;
}
#product-reviews-section h3 {
    font-size: 16px;
    margin: 15px 0;
}
#product-reviews-list {
    display: flex;
    flex-direction: column;
    gap: 15px;
    max-height: 150px; /* 给一个最大高度，内容多了可以滚动 */
    overflow-y: auto;
    margin-bottom: 15px;
}
.product-review-item {
    font-size: 14px;
    line-height: 1.6;
    border-bottom: 1px solid #f0f0f0;
    padding-bottom: 10px;
}
.product-review-item .review-author {
    font-weight: 500;
    color: var(--text-secondary);
    margin-bottom: 5px;
}
#generate-reviews-btn {
    width: 100%;
    margin-top: 10px;
    background-color: #fff7e6;
    color: #fa8c16;
    border-color: #ffd591;
}

/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 把这一整块全新的CSS，粘贴到 <style> 标签的最末尾 ▼▼▼ */

/* --- 余额明细列表样式 --- */
.transaction-item {
    background-color: var(--secondary-bg);
    border-radius: 8px;
    padding: 12px 15px;
    margin-bottom: 10px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.06);
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.transaction-info .description {
    font-weight: 500;
}
.transaction-info .timestamp {
    font-size: 12px;
    color: var(--text-secondary);
    margin-top: 4px;
}
.transaction-amount {
    font-weight: bold;
    font-size: 16px;
}
.transaction-amount.income {
    color: #4CAF50; /* 收入为绿色 */
}
.transaction-amount.expense {
    color: #F44336; /* 支出为红色 */
}

/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】这是为物流详情页新增的样式，请粘贴到 <style> 的末尾 ▼▼▼ */

#logistics-content-area {
    padding: 20px;
    background-color: #f5f5f5;
}

#phone-screen.dark-mode #logistics-content-area {
    background-color: #121212;
}

/* 顶部商品信息卡片 */
.logistics-product-summary {
    display: flex;
    gap: 15px;
    padding: 15px;
    margin-bottom: 20px;
    background-color: var(--secondary-bg);
    border-radius: 12px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.08);
}

.logistics-product-summary .product-image {
    width: 60px;
    height: 60px;
    border-radius: 8px;
    flex-shrink: 0;
}

.logistics-product-summary .info .name {
    font-weight: 600;
    font-size: 15px;
}

.logistics-product-summary .info .status {
    font-size: 13px;
    color: #FF5722; /* 淘宝橙 */
    margin-top: 5px;
    font-weight: 500;
}

/* 时间轴容器 */
.logistics-timeline {
    position: relative;
    padding-left: 25px; /* 为时间轴的竖线和圆点留出空间 */
    background-color: var(--secondary-bg);
    padding: 20px 20px 20px 30px;
    border-radius: 12px;
}

/* 时间轴的竖线 */
.logistics-timeline::before {
    content: '';
    position: absolute;
    left: 15px;
    top: 20px;
    bottom: 20px;
    width: 2px;
    background-color: #e0e0e0;
}

#phone-screen.dark-mode .logistics-timeline::before {
    background-color: #38383a;
}

/* 每一个物流步骤 */
.logistics-step {
    position: relative;
    margin-bottom: 25px;
}

.logistics-step:last-child {
    margin-bottom: 0;
}

/* 时间轴上的圆点 */
.logistics-step::before {
    content: '';
    position: absolute;
    left: -22px; 
    top: 5px;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background-color: #ccc;
    border: 2px solid var(--secondary-bg);
    z-index: 1;
}

/* 最新的一条物流状态，让它的圆点更突出 */
.logistics-step:first-child::before {
    background-color: #FF5722;
    transform: scale(1.3);
}

.logistics-step-content .status-text {
    font-weight: 500;
    font-size: 14px;
    margin-bottom: 5px;
    line-height: 1.5;
}

.logistics-step-content .timestamp {
    font-size: 12px;
    color: var(--text-secondary);
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】这是为“分享给Ta代付”按钮新增的样式 ▼▼▼ */
#share-cart-to-char-btn {
    background-color: #FF9800; /* 使用一个温暖的橙色，区别于结算按钮 */
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 20px;
    font-weight: 500;
    cursor: pointer;
    transition: background-color 0.2s; /* 添加悬停效果 */
}
#share-cart-to-char-btn:hover {
    background-color: #F57C00;
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】这是为“购物车代付请求”新增的卡片样式 ▼▼▼ */

/* 1. 让包裹卡片的气泡本身变透明 */
.message-bubble.is-cart-share-request .content {
    padding: 0;
    background: transparent;
    box-shadow: none;
    border: none;
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
}

/* 2. 卡片主体样式 */
.cart-share-card {
    width: 230px;
    border-radius: 12px;
    background-color: #fff;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    overflow: hidden;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    border: 2px solid transparent; /* 为不同状态准备的边框 */
    transition: all 0.3s ease;
}

/* 3. 卡片头部 */
.cart-share-header {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 12px 15px;
    background-color: #FFF8E1; /* 温暖的米黄色 */
    color: #FFA000;
}
.cart-share-header .icon {
    font-size: 24px;
    font-weight: bold;
}
.cart-share-header .title {
    font-size: 16px;
    font-weight: 600;
}

/* 4. 卡片内容区域 */
.cart-share-body {
    padding: 15px;
    text-align: center;
}
.cart-share-body .label {
    font-size: 13px;
    color: #888;
}
.cart-share-body .amount {
    font-size: 32px;
    font-weight: 700;
    color: #FF5722; /* 淘宝橙 */
    margin: 5px 0 15px 0;
}
.cart-share-body .status-text {
    font-weight: 500;
    color: var(--accent-color);
}

/* 5. 不同状态下的样式 */
.cart-share-card.paid {
    border-color: #4CAF50; /* 绿色 */
}
.cart-share-card.paid .status-text {
    color: #4CAF50;
}
.cart-share-card.rejected {
    border-color: #F44336; /* 红色 */
    opacity: 0.8;
}
.cart-share-card.rejected .status-text {
    color: #F44336;
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】这是为“为Ta购买”和礼物通知卡片新增的样式 ▼▼▼ */

/* 1. “为Ta购买”按钮的样式 */
#buy-for-char-btn {
    background-color: #4CAF50; /* 使用一个代表“礼物”的绿色 */
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 20px;
    font-weight: 500;
    cursor: pointer;
    transition: background-color 0.2s;
}
#buy-for-char-btn:hover {
    background-color: #45a049;
}

/* 2. 让包裹礼物卡片的气泡变透明 */
.message-bubble.is-gift-notification .content {
    padding: 0;
    background: transparent;
    box-shadow: none;
    border: none;
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
}

/* 3. 礼物通知卡片主体样式 */
.gift-card {
    width: 230px;
    border-radius: 12px;
    background-color: #fff;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    overflow: hidden;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
}
.gift-card-header {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 12px 15px;
    background-color: #e8f5e9; /*淡淡的绿色背景*/
    color: #2e7d32;
}
.gift-card-header .icon {
    font-size: 24px;
    font-weight: bold;
}
.gift-card-header .title {
    font-size: 16px;
    font-weight: 600;
}
.gift-card-body {
    padding: 15px;
}
.gift-card-body .greeting {
    font-size: 14px;
    margin-bottom: 10px;
}
.gift-card-items {
    font-size: 13px;
    color: #555;
    max-height: 60px;
    overflow: hidden;
    text-overflow: ellipsis;
    margin-bottom: 10px;
}
.gift-card-footer {
    padding-top: 10px;
    border-top: 1px solid #f0f0f0;
    text-align: right;
    font-weight: bold;
}
.gift-card-footer .total-price {
    color: #FF5722;
}
/* ▲▲▲ 新增样式结束 ▲▲▲ */
/* ▼▼▼ 把这一整块全新的CSS，粘贴到 <style> 的末尾 ▼▼▼ */

/* 1. 让角色主页的内容区可以独立滚动 */
#weibo-char-profile-page {
    flex-grow: 1;
    overflow-y: auto;
    background-color: #f0f2f5;
}

/* 2. 修正夜间模式下主页和新页面的背景色 */
#phone-screen.dark-mode #weibo-profile-page,
#phone-screen.dark-mode #weibo-char-profile-page {
    background-color: #000;
}

/* 3. 为角色主页上的职业显示添加样式 (已修改) */
#weibo-char-profession-display {
    position: absolute;
    /* 定位：从右侧标签改为与“关注”数据左对齐 */
    left: 35px;
    /* 垂直位置：放在“关注”数据行的下方，-5px会让它更靠下一点 */
    bottom: -5px;
    right: auto; /* 清除掉旧的 right 定位，避免冲突 */
    z-index: 2;
    
    /* 外观：从半透明标签改为和你主页一致的灰色普通文字 */
    font-size: 13px;
    color: #8a8a8a;
    text-shadow: none;
    background-color: transparent;
    padding: 0;
    border-radius: 0;
}


/* 4. 给关注列表的“查看主页”按钮添加样式 */
.weibo-following-item .view-profile-btn {
    margin-left: auto; /* 让按钮自动靠右 */
    padding: 5px 10px;
    font-size: 13px;
    font-weight: 500;
    color: var(--accent-color);
    background-color: #e7f3ff;
    border: none;
    border-radius: 12px;
    cursor: pointer;
}
#phone-screen.dark-mode .weibo-following-item .view-profile-btn {
    background-color: rgba(0, 123, 255, 0.2);
}

/* ▲▲▲ 新增CSS粘贴结束 ▲▲▲ */
/* ▼▼▼ 【层级修复】请将这段新CSS粘贴到 <style> 的末尾 ▼▼▼ */

/* 强制提升头像框选择弹窗的层级，确保它能覆盖在其他弹窗之上 */
#avatar-frame-modal {
    z-index: 1005; 
}

/* ▲▲▲ 修复结束 ▲▲▲ */
/* ▼▼▼ 这是新增的样式 ▼▼▼ */

/* 这是我们新加的、包裹头像的可点击区域的样式 */
.weibo-post-avatar-clickable {
    cursor: pointer; /* 鼠标放上去时显示为小手形状 */
    transition: opacity 0.2s ease-in-out; /* 添加一个平滑的过渡动画 */
}

/* 鼠标悬停时，让头像稍微变暗一点，给用户一个明确的反馈 */
.weibo-post-avatar-clickable:hover {
    opacity: 0.85;
}

/* ▲▲▲ 新增样式结束 ▲▲▲ */
/* ▼▼▼ 【全新】语音播放动画样式 ▼▼▼ */
.message-bubble.is-voice-message.playing .voice-waveform div {
    animation: wave-play 1s ease-in-out infinite;
}

@keyframes wave-play {
  0%, 100% { height: 2px; }
  25% { height: 12px; }
  50% { height: 6px; }
  75% { height: 18px; }
}
/* ▲▲▲ 样式粘贴结束 ▲▲▲ */


/* ============ “查手机”功能美化代码 v2.0 (支持自定义图片) 开始 ============ */

/* --- 步骤1: 缩小图标尺寸 (保持不变) --- */
#character-app-grid .app-icon .icon-bg {
    width: 50px !important;
    height: 50px !important;
    border-radius: 13px !important;
}
#character-app-grid .app-icon .label {
    font-size: 12px;
}

/* --- 步骤2: 将容器改为自由定位的“桌面”布局 (保持不变) --- */
#character-app-grid {
    display: block !important;
    grid-template-columns: none !important;
    gap: 0 !important;
    position: relative !important;
    height: 100% !important;
}

/* --- 步骤3: 让所有App图标“浮”起来 (保持不变) --- */
#character-app-grid .app-icon {
    position: absolute !important;
}

/* --- 步骤4: 【核心修改】为我们新的图片位设置样式 --- */
.char-phone-widget {
    position: absolute;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15); /* 加个阴影更好看 */
    border: 2px solid rgba(255,255,255,0.5); /* 加个白边更有质感 */
    overflow: hidden; /* 防止图片溢出圆角 */
    cursor: pointer; /* 鼠标放上去是小手形状，提示可以点击 */
    transition: transform 0.2s ease; /* 添加点击动效 */
    background-color: #e0e0e0; /* 图片加载前的占位颜色 */
}
.char-phone-widget:active {
    transform: scale(0.95); /* 点击时缩小一点点 */
}
.char-phone-widget img {
    width: 100%;
    height: 100%;
    object-fit: cover; /* 保证图片填满且不变形 */
}

/* ============================================== */
/* === ★★★ 手动精调区：在这里修改位置和大小 ★★★ === */
/* ============================================== */

/* --- 左上角的图片位 --- */
#char-phone-widget-1 {
    /* --- 在这里调整【上下位置】(数字越大越往下)--- */
    top: 60px;
    /* --- 在这里调整【左右位置】(数字越大越往右)--- */
    left: 20px;
    /* --- 在这里调整【大小】--- */
    width: 110px;
    height: 110px;
    border-radius: 22px; /* 圆角 (建议是宽度的1/5左右) */
}

/* --- 右下角的图片位 --- */
#char-phone-widget-2 {
    /* --- 在这里调整【上下位置】(数字越大越往上)--- */
    bottom: 60px;
    /* --- 在这里调整【左右位置】(数字越大越往左)--- */
    right: 20px;
    /* --- 在这里调整【大小】--- */
    width: 110px;
    height: 110px;
    border-radius: 22px; /* 圆角 */
}

/* --- APP 图标位置调整 (这部分保持不变) --- */
#character-app-grid .app-icon:nth-child(1) { top: 70px; left: 150px; }
#character-app-grid .app-icon:nth-child(2) { top: 70px; left: 215px; }
#character-app-grid .app-icon:nth-child(3) { top: 155px; left: 30px; }
#character-app-grid .app-icon:nth-child(4) { top: 155px; left: 95px; }
#character-app-grid .app-icon:nth-child(5) { top: 155px; left: 160px; }
#character-app-grid .app-icon:nth-child(6) { top: 240px; left: 225px; }
#character-app-grid .app-icon:nth-child(7) { top: 240px; left: 30px; }
#character-app-grid .app-icon:nth-child(8) { top: 240px; left: 95px; }
#character-app-grid .app-icon:nth-child(9) { top: 325px; left: 30px; }
#character-app-grid .app-icon:nth-child(10) { top: 325px; left: 95px; }

/* ============ “查手机”功能美化代码 结束 ============ */

/* ▼▼▼ 【最终修复版】只为“微博”和“粉丝”增加点击区域 ▼▼▼ */

/*
 * 核心原理不变，但这次我们使用了更精确的 ID 选择器，
 * 只选中 #weibo-posts-item (微博) 和 #weibo-fans-item (粉丝) 这两个元素。
 */
#weibo-posts-item,
#weibo-fans-item {
    padding: 8px 10px;
    margin: -8px -10px;
    border-radius: 8px;
    transition: background-color 0.2s;
}

/* 为这两个按钮添加点击时的背景色反馈 */
#weibo-posts-item:active,
#weibo-fans-item:active {
    background-color: rgba(0, 0, 0, 0.08); /* 点击时给一个淡淡的灰色背景 */
}

/* 在夜间模式下的点击反馈颜色 */
#phone-screen.dark-mode #weibo-posts-item:active,
#phone-screen.dark-mode #weibo-fans-item:active {
    background-color: rgba(255, 255, 255, 0.1);
}
/* ▲▲▲ 最终修复版样式结束 ▲▲▲ */


/* ======================================================================= /
/ === ★★★ 角色手机桌面美化布局 v16.0 (垂直居中偏移版) ★★★ === /
/ ======================================================================= */

/* --- 1. 总控制台 & 布局变量 --- */
#character-phone-screen {
    position: relative !important;
    
    /* --- ★★★ 唯一的【垂直位置】总控制器 ★★★ --- */
    /* 调整这个值，就能让所有图标和小组件一起上下移动 */
    /* 增加数值 = 整体下移；减小数值 = 整体上移 */
    /* 我帮你设置了一个看起来比较居中的初始值 */
    --global-vertical-offset: 10px;
    
    /* (水平居中部分，保持不变) */
    --grid-width: 345px;
    --grid-left-edge: calc((100% - var(--grid-width)) / 2);
}

/* --- 2. 准备工作 (保持不变) --- */
#character-app-grid {
    position: absolute !important; top: 0; left: 0; width: 100%; height: 100%;
    display: block !important; grid-template-columns: none !important; gap: 0 !important;
}
#character-app-grid .app-icon,
#char-phone-widget-1,
#char-phone-widget-2 {
    position: absolute !important;
}

/* --- 3. App图标样式 (保持不变) --- */
#character-app-grid .app-icon .icon-bg {
    width: 40px !important; height: 40px !important;
    background: transparent !important; box-shadow: none !important; border: none !important;
}
#character-app-grid .app-icon .label {
    font-size: 12px; color: #fff; padding-top: 8px;
    text-shadow: 0 1px 3px rgba(0,0,0,0.5);
}

/* --- 4. 小组件位置和尺寸 (★核心修改: 应用全局偏移) --- */
#char-phone-widget-1 {
    top: calc(var(--global-vertical-offset) + 90px); /* 90px 是你固定的值 */
    left: calc(var(--grid-left-edge) + 30px);
    width: 135px; height: 135px; border-radius: 22px;
}
#char-phone-widget-2 {
    top: calc(var(--global-vertical-offset) + 480px); /* 480px 是你固定的值 */
    left: calc(var(--grid-left-edge) + 180px);
    width: 135px; height: 135px; border-radius: 22px;
}

/* --- 5. App图标位置 (★核心修改: 应用全局偏移) --- */
/* 第1行 */
#character-app-grid .app-icon:nth-child(1) { top: calc(var(--global-vertical-offset) + 155px); left: calc(var(--grid-left-edge) + 185px); }
#character-app-grid .app-icon:nth-child(2) { top: calc(var(--global-vertical-offset) + 155px); left: calc(var(--grid-left-edge) + 250px); }
/* 第2行 */
#character-app-grid .app-icon:nth-child(3) { top: calc(var(--global-vertical-offset) + 270px); left: calc(var(--grid-left-edge) + 30px); }
#character-app-grid .app-icon:nth-child(4) { top: calc(var(--global-vertical-offset) + 270px); left: calc(var(--grid-left-edge) + 105px); }
#character-app-grid .app-icon:nth-child(5) { top: calc(var(--global-vertical-offset) + 270px); left: calc(var(--grid-left-edge) + 180px); }
/* 第3行 */
#character-app-grid .app-icon:nth-child(6) { top: calc(var(--global-vertical-offset) + 375px); left: calc(var(--grid-left-edge) + 105px); }
#character-app-grid .app-icon:nth-child(7) { top: calc(var(--global-vertical-offset) + 375px); left: calc(var(--grid-left-edge) + 185px); }
#character-app-grid .app-icon:nth-child(8) { top: calc(var(--global-vertical-offset) + 375px); left: calc(var(--grid-left-edge) + 250px); }
/* 第4行 */
#character-app-grid .app-icon:nth-child(9) { top: calc(var(--global-vertical-offset) + 480px); left: calc(var(--grid-left-edge) + 30px); }
#character-app-grid .app-icon:nth-child(10) { top: calc(var(--global-vertical-offset) + 480px); left: calc(var(--grid-left-edge) + 105px); }


/* ▼▼▼ 【查手机功能 | 图标对齐终极修复 V4】 ▼▼▼ */
/*
 * 解决方案：
 * 1. (保留) 使用负外边距，将应用名(.label)向上拉，使其紧贴图标。
 * 2. (新增) 对包含默认SVG图标的整个.app-icon元素，也使用一个负的margin-top，
 *    使其整体向上移动，从而和其他自定义图标在垂直方向上完美对齐。
 */

/* 步骤1：让文字紧贴图标 (这是上次的成功修复，我们保留它) */
#character-app-grid .app-icon:has(.icon-bg > svg) .label {
    margin-top: -7px !important;
    padding-top: 0px !important;
}

/* 步骤2：让图标和文字作为一个整体，向上移动 */
#character-app-grid .app-icon:has(.icon-bg > svg) {
    margin-top: -8px; /* 这个负值会把整个图标+文字的组合向上拉 */
}
/* ▲▲▲ 修复代码结束 ▲▲▲ */
/* ▼▼▼ 这是步骤1需要粘贴的新样式 ▼▼▼ */

/* 让每一条评论都变成可点击的，并增加悬停效果 */
.weibo-comment-item {
    cursor: pointer; /* 鼠标悬停时显示为小手形状 */
    transition: background-color 0.2s; /* 添加一个平滑的背景色过渡动画 */
    border-radius: 4px; /* 给一点点圆角，更好看 */
    padding: 2px 5px; /* 增加一点内边距，让点击区域更大 */
    margin: 0 -5px; /* 把上面的内边距抵消掉，保持对齐 */
}
.weibo-comment-item:hover {
    background-color: #f0f2f5; /* 鼠标放上去时，给一个淡淡的背景色 */
}
#phone-screen.dark-mode .weibo-comment-item:hover {
    background-color: #2c2c2e; /* 夜间模式下的悬停颜色 */
}

/* “回复”这两个字的样式，让它更柔和 */
.weibo-comment-item .weibo-comment-reply-tag {
    color: var(--text-secondary);
    margin: 0 4px; /* 和两边的名字拉开一点距离 */
}

/* 被回复者的名字样式，让它和普通评论者名字一样可以点击 */
.weibo-comment-item .reply-target-name {
    font-weight: 600;
    color: var(--accent-color);
    cursor: pointer;
    margin-right: 5px;
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】角色手机App内壁纸样式 ▼▼▼ */

/* 当内部屏幕有壁纸时，设置背景图的显示方式 */
.character-phone-inner-screen.has-app-wallpaper {
    background-size: cover;
    background-position: center;
}

/* 关键：让所有App页面的内容列表背景变透明 */
.character-phone-inner-screen.has-app-wallpaper .list-container,
.character-phone-inner-screen.has-app-wallpaper #character-chat-history-messages {
    background-color: transparent !important;
}

/* 为了保证文字的可读性，我们给列表项和卡片加上半透明的背景 */
.character-phone-inner-screen.has-app-wallpaper .character-data-item,
.character-phone-inner-screen.has-app-wallpaper .character-cart-item,
.character-phone-inner-screen.has-app-wallpaper .character-browser-item,
.character-phone-inner-screen.has-app-wallpaper .character-bank-transaction,
.character-phone-inner-screen.has-app-wallpaper .chat-list-item {
    background-color: rgba(255, 255, 255, 0.7);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    border: 1px solid rgba(255, 255, 255, 0.2);
}

/* 同样为聊天气泡增加半透明效果 */
.character-phone-inner-screen.has-app-wallpaper .character-chat-bubble-container.received .character-chat-bubble {
    background-color: rgba(255, 255, 255, 0.85);
}
.character-phone-inner-screen.has-app-wallpaper .character-chat-bubble-container.sent .character-chat-bubble {
    background-color: rgba(149, 236, 105, 0.85); /* 微信绿，但带一点透明 */
}

/* 适配夜间模式的半透明颜色 */
#phone-screen.dark-mode .character-phone-inner-screen.has-app-wallpaper .character-data-item,
#phone-screen.dark-mode .character-phone-inner-screen.has-app-wallpaper .chat-list-item {
     background-color: rgba(28, 28, 30, 0.7);
}
#phone-screen.dark-mode .character-phone-inner-screen.has-app-wallpaper .character-chat-bubble-container.received .character-chat-bubble {
    background-color: rgba(44, 44, 46, 0.85);
}
#phone-screen.dark-mode .character-phone-inner-screen.has-app-wallpaper .character-chat-bubble-container.sent .character-chat-bubble {
     background-color: rgba(48, 93, 32, 0.85); /* 夜间模式的绿色 */
}
/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】这是为“游戏分享”新增的颜色样式 ▼▼▼ */
.share-type.game {
    background-color: #9c27b0; /* 一个代表游戏的神秘紫色 */
}
/* ▲▲▲ 新增样式结束 ▲▲▲ */
/* ▼▼▼ 【全新】心动飞行棋样式 ▼▼▼ */

/* --- 游戏主界面布局 --- */
#ludo-game-content {
    display: flex;
    flex-direction: column;
    height: 100%;
    overflow: hidden;
    padding: 15px;
    box-sizing: border-box;
    gap: 15px;
    background-color: #fff0f5; /* 温柔的淡粉色背景 */
}

#phone-screen.dark-mode #ludo-game-content {
    background-color: #2c1e22; /* 夜间模式下的深粉紫色 */
}

/* --- 棋盘容器与棋盘本身 --- */
#ludo-board-container {
    position: relative;
    width: 100%;
    height: 280px; /* 给棋盘一个固定的高度 */
    flex-shrink: 0;
    background-color: rgba(255, 255, 255, 0.5);
    border-radius: 10px;
    padding: 10px;
    box-sizing: border-box;
}

#ludo-board {
    display: grid;
    grid-template-columns: repeat(10, 1fr); /* 10x6的网格布局 */
    grid-template-rows: repeat(6, 1fr);
    width: 100%;
    height: 100%;
    gap: 3px;
}

/* --- 棋盘格子样式 --- */
.ludo-cell {
    border-radius: 4px;
    background-color: rgba(255, 192, 203, 0.3); /* 淡淡的粉色格子 */
    position: relative;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 14px;
    font-weight: bold;
    color: #db7093;
}

/* 起点和终点格子 */
.ludo-cell.start { background-color: #90ee90; color: #2e8b57; }
.ludo-cell.end { background-color: #ffd700; color: #b8860b; }

/* 特殊事件格子 */
.ludo-cell.event-truth { background-color: #ffb6c1; } /* 真心话 */
.ludo-cell.event-dare { background-color: #add8e6; }  /* 大冒险 */
.ludo-cell.event-kiss { background-color: #ff69b4; }  /* 亲亲 */
.ludo-cell.event-hug { background-color: #ffdab9; }   /* 抱抱 */

.ludo-cell .cell-number {
    font-size: 10px;
    position: absolute;
    top: 2px;
    left: 3px;
    color: rgba(0,0,0,0.2);
}

/* --- 棋子样式 --- */
.ludo-piece {
    position: absolute;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    background-size: cover;
    background-position: center;
    border: 2px solid white;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    z-index: 10;
}
.ludo-piece.user { border-color: #87cefa; }
.ludo-piece.char { border-color: #ffc0cb; }

/* --- 游戏日志 --- */
#ludo-log-container {
    flex-grow: 1;
    background-color: rgba(255, 255, 255, 0.5);
    border-radius: 10px;
    padding: 10px;
    overflow-y: auto;
    min-height: 0;
}
#ludo-game-log .log-entry {
    padding: 6px 8px;
    font-size: 14px;
    border-bottom: 1px solid rgba(0,0,0,0.05);
    line-height: 1.5;
}
#ludo-game-log .log-entry.system {
    color: #db7093;
    font-style: italic;
    text-align: center;
}
#ludo-game-log .log-entry.user { color: #007bff; }
#ludo-game-log .log-entry.char { color: #e83e8c; }
#ludo-game-log .log-entry strong { font-weight: 900; }


/* --- 操作区与骰子动画 --- */
#ludo-action-area {
    flex-shrink: 0;
    padding: 10px 0;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 60px;
}
#ludo-dice-container {
    perspective: 1000px;
}
.dice {
    width: 50px;
    height: 50px;
    position: relative;
    transform-style: preserve-3d;
    transition: transform 1s;
    cursor: pointer;
}
.dice.rolling { animation: roll-dice 1.5s ease-out; }
@keyframes roll-dice {
    0% { transform: rotateX(0deg) rotateY(0deg); }
    100% { transform: rotateX(1080deg) rotateY(720deg); }
}
.dice .face {
    position: absolute;
    width: 50px;
    height: 50px;
    border: 1px solid #ccc;
    background: white;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 24px;
    font-weight: bold;
}
.face.front  { transform: rotateY(0deg) translateZ(25px); }
.face.back   { transform: rotateY(180deg) translateZ(25px); }
.face.right  { transform: rotateY(90deg) translateZ(25px); }
.face.left   { transform: rotateY(-90deg) translateZ(25px); }
.face.top    { transform: rotateX(90deg) translateZ(25px); }
.face.bottom { transform: rotateX(-90deg) translateZ(25px); }

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】飞行棋问题类型标签样式 ▼▼▼ */
.question-type-tag {
    font-size: 10px;
    font-weight: bold;
    padding: 3px 8px;
    border-radius: 10px;
    color: white;
    margin-left: 10px;
    flex-shrink: 0;
}
.question-type-tag.both-answer {
    background-color: #ff8fab; /* 粉色代表共同回答 */
}
.question-type-tag.single-answer {
    background-color: #87ceeb; /* 蓝色代表一人回答 */
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】飞行棋结算卡片样式 ▼▼▼ */
#ludo-summary-content h3 {
    text-align: center;
    color: var(--accent-color);
    margin-bottom: 15px;
    font-size: 20px;
    font-weight: bold;
}
#ludo-summary-content .ludo-qa-log {
    margin-top: 20px;
    padding-top: 15px;
    border-top: 1px solid var(--border-color);
    max-height: 300px; /* 给问答记录一个最大高度，内容多了可以滚动 */
    overflow-y: auto;
}
#ludo-summary-content h4 {
    margin-bottom: 10px;
    color: var(--text-primary);
}
#ludo-summary-content .qa-item {
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 1px dashed #eee;
}
#ludo-summary-content .qa-item:last-child {
    border-bottom: none;
}
#ludo-summary-content .qa-question {
    font-weight: 600;
    color: #db7093; /* 一个可爱的粉紫色 */
    margin-bottom: 8px;
}
#ludo-summary-content .qa-answer {
    padding-left: 15px;
    font-size: 14px;
    color: var(--text-secondary);
}
#ludo-summary-content .qa-answer strong {
    color: var(--text-primary);
}
#phone-screen.dark-mode #ludo-summary-content .qa-answer {
    color: #bbb;
}


/* ▼▼▼ 【独家定制】角色手机消息列表 - 可爱磨砂透明圆角版 v3.0 ▼▼▼ */

/* 1. 给消息列表容器增加内边距和间距，为卡片留出呼吸空间 */
#character-chat-list.list-container {
    padding: 15px 10px;
    display: flex;
    flex-direction: column;
    gap: 15px; /* “我”的卡片和“其他人”卡片之间的间距 */
}

/* 2. 重置所有列表项的基础样式，移除旧的边框 */
#character-chat-list .chat-list-item {
    border-bottom: none !important;
}

/* 3. 【你的专属】单独设置“我的消息”(第一个)的可爱胶囊样式 */
#character-chat-list > .chat-list-item {
    background-color: rgba(255, 255, 255, 0.1); /* 超级透明的白色背景 */
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border-radius: 25px; /* 可爱的胶囊圆角 */
    border: 1px solid rgba(255, 255, 255, 0.15); /* 淡淡的亮边，增加质感 */
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1); /* 柔和的阴影，营造悬浮感 */
    padding: 15px; /* 增加内边距，让内容更舒服 */
    color: white; /* 文字颜色也变成白色 */
    text-shadow: 0 1px 2px rgba(0,0,0,0.3); /* 给文字加一点阴影保证清晰度 */
}
#character-chat-list > .chat-list-item .last-msg {
    color: rgba(255, 255, 255, 0.7); /* 预览消息的文字颜色淡一点 */
}


/* 4. 【你的专属】设置“其他人消息”容器的样式 */
.npc-chat-group {
    background-color: rgba(255, 255, 255, 0.1); /* 同样超级透明 */
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border-radius: 25px; /* 容器本身也是圆角 */
    border: 1px solid rgba(255, 255, 255, 0.15);
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    overflow: hidden; /* 关键！让内部的列表项严格遵守容器的圆角 */
    padding: 5px 0; /* 容器内部的上下留白 */
}

/* 5. 设置容器内部单个消息的样式 */
.npc-chat-group .chat-list-item {
    background-color: transparent !important; /* 内部的项完全透明 */
    border-bottom: 1px solid rgba(255, 255, 255, 0.1) !important; /* 用淡淡的亮线分隔 */
    padding: 12px 15px;
    color: white; /* 文字颜色也是白色 */
    text-shadow: 0 1px 2px rgba(0,0,0,0.3);
}
.npc-chat-group .chat-list-item .last-msg {
    color: rgba(255, 255, 255, 0.7);
}

/* 6. 移除容器内【最后一个】消息的下划线，让卡片底部更干净 */
.npc-chat-group .chat-list-item:last-child {
    border-bottom: none !important;
}
/* ▲▲▲ 定制结束 ▲▲▲ */



/* ======================================================================= */
/* ===         修复“查手机-外观设置”中预览图过大的问题 v1.0         === */
/* ======================================================================= */

/* 1. 修复手机壁纸和App内壁纸的预览 */
/* 
   问题原因：之前的样式是 background-size: cover，会强制图片填满预览框，导致裁剪。
   解决方案：改为 background-size: contain，让图片在框内完整显示。
*/
#char-phone-wallpaper-preview,
#char-phone-app-wallpaper-preview {
    background-size: contain !important; 
    background-repeat: no-repeat !important; /* 防止图片在无法填满时重复平铺 */
}

/* 2. 修复两个桌面小组件的图片预览 */
/* 
   问题原因：和上面类似，但对于<img>标签，控制显示方式的属性是 object-fit。
   解决方案：同样将 cover 改为 contain。
*/
#char-phone-widget-preview-1,
#char-phone-widget-preview-2 {
    object-fit: contain !important;
    /* (可选美化) 为没有图片时的预览框加个底色，更好看 */
    background-color: #f0f2f5; 
}
/* ======================================================================= */
/* ===         【V2 最终修复】修复查手机-小组件预览图过大问题         === */
/* ======================================================================= */

#char-phone-widget-preview-1,
#char-phone-widget-preview-2 {
    background-size: contain !important;      /* 核心：让背景图完整显示 */
    background-repeat: no-repeat !important; /* 防止图片重复平铺 */
    background-position: center !important;  /* 确保图片居中 */
}


/* ▼▼▼ 【独家定制】心动飞行棋输入框 - 粉色按钮版 v1.0 ▼▼▼ */

/* 1. 输入区域的容器样式 (保持不变) */
#ludo-action-area {
    display: flex !important;
    flex-direction: row !important;
    align-items: center !important;
    gap: 8px !important;
    padding: 10px 12px !important;
}

/* 2. 文本输入框的样式 (保持不变) */
#ludo-action-area #ludo-user-speech-input {
    flex-grow: 1; 
    border: none;
    padding: 10px 15px;
    border-radius: 20px;
    background-color: var(--secondary-bg);
    font-size: 16px;
    resize: none;
    max-height: 100px; 
    line-height: 1.5;
    box-sizing: border-box;
}

/* 3. “确认回答”按钮的样式 (已修改为粉色) */
#ludo-action-area .form-button {
    width: auto !important;
    height: 40px; 
    border-radius: 20px;
    padding: 0 20px;
    flex-shrink: 0; 
    font-size: 14px;
    font-weight: 600;
    margin: 0 !important;
    border: none;
    cursor: pointer;
    
    /* ★★★ 核心修改：使用可爱的粉色渐变和阴影 ★★★ */
    background: linear-gradient(135deg, #ff8fab, #fb6f92);
    color: white;
    box-shadow: 0 4px 10px rgba(251, 111, 146, 0.3);
    transition: all 0.2s ease-in-out;
}

/* ★★★ 新增：为按钮添加更生动的交互效果 ★★★ */
#ludo-action-area .form-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 12px rgba(251, 111, 146, 0.4);
}
#ludo-action-area .form-button:active {
    transform: translateY(0) scale(0.98);
    box-shadow: 0 2px 5px rgba(251, 111, 146, 0.3);
}

/* 4. 夜间模式适配 (保持不变) */
#phone-screen.dark-mode #ludo-action-area #ludo-user-speech-input {
    background-color: #2c2c2e;
    color: var(--text-primary);
}
/* ▲▲▲ 美化代码结束 ▲▲▲ */
/* ▼▼▼ 【全新】心声面板背景图样式 ▼▼▼ */
#inner-voice-main-panel.modal-content {
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    /* 我们给它加一个过渡效果，让背景切换更平滑 */
    transition: background-image 0.3s ease-in-out;
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】“谁是卧底”游戏样式 ▼▼▼ */

/* 玩家头像上显示角色身份的小图标 */
.player-seat .player-role-display {
    position: absolute;
    bottom: 0;
    right: 0;
    background-color: rgba(0, 0, 0, 0.6);
    color: white;
    font-size: 10px;
    padding: 2px 5px;
    border-radius: 5px;
    font-weight: bold;
}

/* “你说我猜”发言输入区的美化 */
#undercover-action-area.speaking-mode {
    display: flex;
    flex-direction: row;
    align-items: center;
    gap: 8px;
    width: 100%;
    padding: 0;
}
#undercover-action-area.speaking-mode #undercover-user-speech-input {
    flex-grow: 1;
    border: none;
    padding: 10px 15px;
    border-radius: 20px;
    background-color: var(--secondary-bg);
    font-size: 16px;
    resize: none;
    max-height: 100px;
    line-height: 1.5;
    width: auto !important; 
    height: auto !important;
}
#undercover-action-area.speaking-mode #undercover-end-speech-btn {
    height: 40px;
    border-radius: 20px;
    padding: 0 15px;
    flex-shrink: 0;
    font-size: 14px;
    font-weight: 600;
    margin: 0 !important; 
    width: auto !important;
    background-color: var(--accent-color);
    color: white;
    border: none;
}
#phone-screen.dark-mode #undercover-action-area.speaking-mode #undercover-user-speech-input {
    background-color: #2c2c2e;
    color: var(--text-primary);
}

/* ▼▼▼ 第2步：将这段新样式粘贴到 <style> 的末尾 ▼▼▼ */

/* --- 【全新】用户发出的“解除关系”卡片样式 --- */

/* 1. 让卡片的容器气泡变透明，消除默认背景 */
.message-bubble.is-ls-disconnect .content {
    padding: 0;
    background: transparent;
    box-shadow: none;
    border: none;
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
}

/* 2. 卡片主体样式 */
.lovers-space-disconnect-card {
    width: 220px; /* 宽度可以自己调整 */
    background: linear-gradient(135deg, #f5f7fa, #e9ecef); /* 浅灰色渐变，更有质感 */
    border-radius: 12px;
    border: 1px solid #ced4da;
    display: flex;
    align-items: center;
    gap: 15px; /* 图标和文字的间距 */
    padding: 15px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}

/* 3. 夜间模式下的卡片颜色 */
#phone-screen.dark-mode .lovers-space-disconnect-card {
    background: linear-gradient(135deg, #495057, #343a40);
    border-color: #6c757d;
}

/* 4. 心碎 Emoji 图标的样式 */
.lovers-space-disconnect-card .icon {
    font-size: 32px; /* Emoji 大小 */
    line-height: 1;
}

/* 5. 文字区域的样式 */
.lovers-space-disconnect-card .text-content .title {
    font-weight: 600;
    font-size: 16px;
    color: var(--text-primary);
}

/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】这是User自己的私信功能的所有新样式 ▼▼▼ */

/* --- 1. 私信列表页面 --- */
#user-dm-list-container .dm-list-item {
    display: flex;
    align-items: center;
    padding: 12px 15px;
    cursor: pointer;
    border-bottom: 1px solid var(--border-color);
}
#user-dm-list-container .dm-list-item:hover {
    background-color: #f5f5f5;
}
#phone-screen.dark-mode #user-dm-list-container .dm-list-item:hover {
    background-color: #2c2c2e;
}
#user-dm-list-container .dm-avatar {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    margin-right: 12px;
    object-fit: cover;
}
#user-dm-list-container .dm-info {
    flex-grow: 1;
    overflow: hidden;
}
#user-dm-list-container .dm-name-line {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 5px;
}
#user-dm-list-container .dm-name {
    font-weight: 600;
    font-size: 16px;
}
#user-dm-list-container .dm-persona-tag {
    font-size: 10px;
    color: var(--text-secondary);
    background-color: #f0f0f0;
    padding: 2px 6px;
    border-radius: 4px;
}
#phone-screen.dark-mode #user-dm-list-container .dm-persona-tag {
    background-color: #3a3a3c;
}
#user-dm-list-container .dm-last-msg {
    font-size: 14px;
    color: var(--text-secondary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* --- 2. 私信详情页面 (聊天界面) --- */
#user-dm-messages-container {
    background-color: #f0f2f5 !important;
}
#phone-screen.dark-mode #user-dm-messages-container {
    background-color: #000000 !important;
}

/* 复用主聊天界面的气泡样式，但为粉丝和User定义特定对齐方式 */
#user-dm-messages-container .message-wrapper.fan {
    align-self: flex-start;
}
#user-dm-messages-container .message-wrapper.fan .message-bubble {
    flex-direction: row;
}
#user-dm-messages-container .message-wrapper.fan .content {
    background-color: #ffffff; /* 粉丝用白色气泡 */
    color: var(--text-primary);
    border-radius: 2px 18px 18px 18px;
}

#user-dm-messages-container .message-wrapper.user-self { /* 使用新class，避免冲突 */
    align-self: flex-end;
}
#user-dm-messages-container .message-wrapper.user-self .message-bubble {
    flex-direction: row-reverse;
}
/* 你自己的消息，使用微博的橙色 */
#user-dm-messages-container .message-wrapper.user-self .content {
    background-color: #ff8200; 
    color: white;
    border-radius: 18px 2px 18px 18px;
}

/* 夜间模式适配 */
#phone-screen.dark-mode #user-dm-messages-container .message-wrapper.fan .content {
    background-color: #2c2c2e;
}
#phone-screen.dark-mode #user-dm-messages-container .message-wrapper.user-self .content {
    background-color: #e67300;
}

/* ▼▼▼ 用这【一整块】代码，替换掉你旧的 user-dm-input-area 相关样式 ▼▼▼ */

/* --- 1. 私信输入区域的整体背景和边距 (这部分保持不变) --- */
#user-dm-input-area {
    border-top: 1px solid var(--border-color);
    background-color: #f7f7f7;
    padding: 10px 12px;
    padding-bottom: calc(10px + env(safe-area-inset-bottom));
}

/* --- 2. 核心布局：强制输入框和按钮在同一行 --- */
/* 我们用一个更精确的选择器，来确保样式能生效 */
#user-dm-detail-screen .chat-input-main-row {
    display: flex;         /* 关键：设为flex布局 */
    flex-direction: row;   /* 关键：强制横向排列 */
    align-items: flex-end; /* 让多行输入时，按钮和输入框底部对齐，更好看 */
    gap: 8px;              /* 输入框和按钮组之间的间距 */
}

/* --- 3. 输入框：让它自动伸展，占满左侧所有空间 --- */
#user-dm-input-area #user-dm-input {
    flex-grow: 1; /* 关键！ */
    
    /* 下面是输入框的外观，保持不变 */
    border: 1px solid #ddd;
    border-radius: 18px;
    padding: 8px 15px;
    line-height: 1.5;
    min-height: 38px;
    max-height: 100px;
    resize: none;
    background-color: #fff;
}

/* --- 4. 按钮容器：让所有按钮在里面横向排列 --- */
#user-dm-input-area #input-actions-wrapper {
    display: flex;
    align-items: flex-end;
    gap: 8px;
    flex-shrink: 0; /* 防止按钮们被挤压变形 */
}

/* --- 5. 【你的要求】修改“发送”按钮为圆角矩形 --- */
#user-dm-input-area #user-dm-send-btn {
    height: 38px;
    border-radius: 8px; /* ★★★ 修改点在这里！从 18px 改为 8px ★★★ */
    background-color: #ff8200;
    /* --- 以下为补充样式，让按钮更好看 --- */
    border: none;
    color: white;
    font-weight: 600;
    font-size: 14px;
    padding: 0 15px; /* 让文字不那么拥挤 */
}

/* --- 6. 其他两个图标按钮的样式 (保持不变) --- */
#user-dm-input-area .chat-action-icon-btn {
    width: 38px;
    height: 38px;
    border-radius: 50%;
    padding: 0;
    font-size: 24px;
    background-color: rgba(0,0,0,0.05);
    color: var(--text-primary);
    border: 1px solid rgba(0,0,0,0.05);
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
}

/* --- 7. 夜间模式适配 (保持不变) --- */
#phone-screen.dark-mode #user-dm-input-area {
    background-color: #1c1c1e;
    border-top-color: #38383a;
}
#phone-screen.dark-mode #user-dm-input-area #user-dm-input {
    background-color: #2c2c2e;
    border-color: #38383a;
    color: white;
}
#phone-screen.dark-mode #user-dm-input-area .chat-action-icon-btn {
     background-color: rgba(255,255,255,0.1);
     border-color: rgba(255,255,255,0.1);
}

/* ▲▲▲ 替换结束 ▲▲▲ */
/* ▼▼▼ 【全新】这是为User私信输入框新增的按钮样式 ▼▼▼ */

#user-dm-input-area #input-actions-wrapper {
    display: flex;
    align-items: flex-end; /* 确保按钮底部对齐 */
    gap: 8px; /* 按钮之间的间距 */
}

/* 复用主聊天界面的小图标按钮样式 */
#user-dm-input-area .chat-action-icon-btn {
    width: 38px;
    height: 38px;
    border-radius: 50%;
    padding: 0;
    font-size: 24px;
    background-color: rgba(0,0,0,0.05);
    color: var(--text-primary);
    border: 1px solid rgba(0,0,0,0.05);
}

#phone-screen.dark-mode #user-dm-input-area .chat-action-icon-btn {
     background-color: rgba(255,255,255,0.1);
     border-color: rgba(255,255,255,0.1);
}
/* ▲▲▲ 新增样式结束 ▲▲▲ */
/* ▼▼▼ 【全新】这是User私信删除功能的所有新样式 ▼▼▼ */

/* --- 单条消息删除按钮 --- */
/* 1. 让每条消息的容器可以作为删除按钮的定位参考点 */
#user-dm-messages-container .message-wrapper {
    position: relative;
}

/* 2. 删除按钮本身的样式 */
.user-dm-message-delete-btn {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    width: 22px;
    height: 22px;
    background-color: rgba(0, 0, 0, 0.1);
    color: #555;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    font-size: 16px;
    line-height: 22px;
    text-align: center;
    opacity: 0; /* 默认隐藏 */
    transition: all 0.2s ease;
    z-index: 10;
}

/* 3. 鼠标悬停在整条消息上时，才显示删除按钮 */
#user-dm-messages-container .message-wrapper:hover .user-dm-message-delete-btn {
    opacity: 1;
}
.user-dm-message-delete-btn:hover {
    background-color: #ff3b30;
    color: white;
}

/* 4. 根据消息是粉丝的还是你的，决定按钮的位置 */
#user-dm-messages-container .message-wrapper.fan .user-dm-message-delete-btn {
    right: -28px; /* 放在气泡右边 */
}
#user-dm-messages-container .message-wrapper.user-self .user-dm-message-delete-btn {
    left: -28px; /* 放在气泡左边 */
}

/* --- 左滑删除整个对话 --- */
/* 1. 滑动容器 */
.user-dm-list-item-swipe-container {
    position: relative;
    overflow: hidden;
    background-color: var(--secondary-bg);
}

/* 2. 可滑动的内容区 */
.user-dm-list-item-content {
    position: relative;
    z-index: 2;
    background-color: inherit;
    transition: transform 0.3s ease;
}
.user-dm-list-item-content.swiped {
    transform: translateX(-80px); /* 向左滑动80px，露出删除按钮 */
}

/* 3. 隐藏在后面的操作按钮区域 */
.user-dm-swipe-actions {
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    z-index: 1;
    display: flex;
}

/* 4. “删除”按钮的样式 */
.user-dm-swipe-actions .swipe-action-btn {
    height: 100%;
    padding: 0 20px;
    border: none;
    color: white;
    font-weight: 500;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 80px;
    background-color: #ff3b30; /* 红色背景 */
}

/* 5. 修复分割线，让滑动效果更完美 */
#user-dm-list-container .dm-list-item {
    border-bottom: none; /* 移除原始的分割线 */
}
#user-dm-list-container .user-dm-list-item-swipe-container:not(:last-child) {
    border-bottom: 1px solid var(--border-color); /* 在滑动容器上添加新分割线 */
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】续火花图标样式 ▼▼▼ */
.streak-indicator {
    display: inline-flex;
    align-items: center;
    gap: 3px;
    font-size: 13px; /* 调整了字体大小，让它更精致 */
    color: #ff6f00; /* 温暖的橙色 */
    font-weight: bold;
    margin-left: 8px; /* 和角色名字拉开一点距离 */
    text-shadow: 0 0 5px rgba(255, 152, 0, 0.5); /* 加一点发光效果 */
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
/* ▼▼▼ 把这一整块全新的CSS，粘贴到 <style> 的最末尾 ▼▼▼ */

/* --- 【全新】群成员管理列表样式 --- */
#member-management-list .list-container-title {
    padding: 10px 15px;
    font-size: 14px;
    color: var(--text-secondary);
    background-color: #f0f2f5;
}
#phone-screen.dark-mode #member-management-list .list-container-title {
    background-color: #1c1c1e;
}

#member-management-list .member-management-item {
    background-color: var(--secondary-bg);
}

/* 单个成员项 */
.member-management-item {
    display: flex;
    align-items: center;
    padding: 10px 15px;
    border-bottom: 1px solid var(--border-color);
}

.member-management-item .avatar {
    width: 40px;
    height: 40px;
    border-radius: 6px; /* 方形圆角头像 */
    margin-right: 12px;
}

/* 成员信息（昵称、头衔、身份） */
.member-management-item .info {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    gap: 4px;
}
.member-management-item .info .name {
    font-weight: 500;
}
.member-management-item .info .tags {
    display: flex;
    align-items: center;
    gap: 6px;
}

/* 身份标签（群主/管理员） */
.member-management-item .role-tag {
    font-size: 10px;
    padding: 2px 6px;
    border-radius: 4px;
    font-weight: bold;
    color: white;
}
.role-tag.owner { background-color: #ffc107; } /* 黄色 */
.role-tag.admin { background-color: #28a745; } /* 绿色 */

/* 头衔标签 */
.member-management-item .title-tag {
    font-size: 11px;
    color: var(--text-secondary);
    background-color: #f0f2f5;
    padding: 2px 6px;
    border-radius: 4px;
}
#phone-screen.dark-mode .member-management-item .title-tag {
    background-color: #3a3a3c;
}

/* 操作按钮 */
.member-management-item .actions {
    display: flex;
    gap: 8px;
}
.member-management-item .actions button {
    padding: 5px 10px;
    font-size: 12px;
    border-radius: 5px;
    cursor: pointer;
    border: 1px solid var(--border-color);
    background-color: #f8f9fa;
}
#phone-screen.dark-mode .member-management-item .actions button {
    background-color: #3e3e42;
    border-color: #545458;
}
.member-management-item .actions button.danger {
    border-color: #ff4d4f;
    color: #ff4d4f;
}

/* --- 【全新】聊天界面内的身份/头衔标签 --- */
.group-sender-tags {
    display: inline-flex;
    align-items: center;
    gap: 5px;
    margin-left: 6px;
    vertical-align: middle;
}
.group-role-tag, .group-title-tag {
    font-size: 10px;
    padding: 1px 5px;
    border-radius: 8px;
    font-weight: 500;
    line-height: 1.4;
}
.group-role-tag.owner {
    background-color: #FFF2C2;
    color: #D98C00;
    border: 1px solid #FFE89D;
}
.group-role-tag.admin {
    background-color: #D4EDDA;
    color: #155724;
    border: 1px solid #C3E6CB;
}
.group-title-tag {
    background-color: #f0f2f5;
    color: var(--text-secondary);
}

#phone-screen.dark-mode .group-role-tag.owner { background-color: #594200; color: #FFD466; border-color: #795B00;}
#phone-screen.dark-mode .group-role-tag.admin { background-color: #104A3C; color: #76DDC4; border-color: #176854;}
#phone-screen.dark-mode .group-title-tag { background-color: #3a3a3c; }

/* ▲▲▲ 新CSS粘贴结束 ▲▲▲ */
/* ▼▼▼ 【独家定制】请将这段【全新】的CSS代码，粘贴到<style>标签的末尾 ▼▼▼ */

/* 核心：专门为用户（user）在群聊中的消息行定义样式 */
.message-wrapper.user .group-sender-line {
    /* 1. 定位：从左侧定位改为右侧定位，与你的头像对齐 */
    left: auto;
    right: 50px; /* 原来是 left: 50px */

    /* 2. 布局翻转：这是实现“标签在左，昵称在右”的关键！*/
    flex-direction: row-reverse; 
}

/* ▲▲▲ 粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】群公告功能样式 ▼▼▼ */

/* 这是我们新加的群公告小黑板图标的样式 */
/* ▼▼▼ 请用这块代码替换你旧的 #group-announcement-btn 样式 ▼▼▼ */
#group-announcement-btn {
    display: none; /* JS控制显示，保持不变 */
    position: absolute; /* 核心修改：绝对定位 */
    left: 100%; /* 定位在标题的右边 */
    top: 50%; /* 垂直居中的第一步 */
    transform: translateY(-50%); /* 垂直居中的第二步 */
    margin-left: 5px; /* 与标题的间距 */

    /* 保持视觉样式 */
    display: flex;
    align-items: center;
    justify-content: center;
    width: 30px;
    height: 30px;
    cursor: pointer;
    color: var(--accent-color);
    transition: background-color 0.2s;
    border-radius: 50%;
}
/* ▲▲▲ 替换结束 ▲▲▲ */
#group-announcement-btn:hover {
    background-color: rgba(0,0,0,0.05); /* 鼠标悬停时给一点反馈 */
}
#phone-screen.dark-mode #group-announcement-btn:hover {
    background-color: rgba(255,255,255,0.1);
}

/* 公告弹窗的样式 */
#group-announcement-modal .modal-content {
    height: 70%; /* 让弹窗高一些，方便看公告 */
}

/* 公告内容的显示区域 */
#group-announcement-modal .modal-body {
    white-space: pre-wrap; /* 让换行符生效 */
    word-break: break-word; /* 防止长单词溢出 */
    line-height: 1.7; /* 增加行高，更易读 */
    font-size: 15px;
}

/* 编辑公告时，文本域的样式 */
#group-announcement-modal textarea {
    width: 100%;
    height: 100%; /* 占满整个内容区 */
    min-height: 300px;
    box-sizing: border-box;
    border: 1px solid var(--border-color);
    border-radius: 6px;
    padding: 10px;
    font-size: 15px;
    line-height: 1.7;
    resize: vertical; /* 允许用户垂直拖动调整大小 */
}

/* ▲▲▲ 新增CSS结束 ▲▲▲ */

/* ▼▼▼ 【独家定制】群聊昵称与标签顺序修复 ▼▼▼ */

/* 1. 全局定义显示顺序：让标签永远在名字前面 */
.group-sender-line > .group-sender-tags {
    order: 1;
}
.group-sender-line > .sender-name {
    order: 2;
}

/* 2. 为【AI/他人消息】设置对齐方式 (靠左) */
.message-wrapper.ai .group-sender-line {
    justify-content: flex-start; /* 确保内容从左边开始 */
}

/* 3. 【核心修复】修正【你的消息】的对齐方式 (靠右) */
/* 这块代码会覆盖掉旧的、导致顺序错乱的规则 */
.message-wrapper.user .group-sender-line {
    left: auto;
    right: 50px; /* 保持原有的右侧定位 */
    flex-direction: row; /* 移除旧的“反转”效果 */
    justify-content: flex-end; /* 让内容块整体靠右，这样名字就能贴近你的头像了 */
}

/* ▲▲▲ 修复结束 ▲▲▲ */
/* ▼▼▼ 【全新】用户表情面板批量删除功能样式 ▼▼▼ */

/* 1. 当表情面板进入选择模式时，隐藏“添加/上传”按钮 */
#sticker-panel.selection-mode #add-sticker-btn,
#sticker-panel.selection-mode #upload-sticker-btn {
    display: none;
}

/* 2. 为表情格子添加选择框的视觉效果 */
.sticker-item.in-selection-mode::before {
    content: '';
    position: absolute;
    top: 5px;
    right: 5px;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    border: 2px solid rgba(0,0,0,0.2);
    background-color: rgba(255,255,255,0.7);
    transition: all 0.2s ease-in-out;
}

/* 3. 当表情被选中时，让选择框变成带对勾的√ */
.sticker-item.selected::before {
    background-color: var(--accent-color); /* 使用你的主题色 */
    border-color: var(--accent-color);
    content: '✔';
    color: white;
    font-size: 14px;
    text-align: center;
    line-height: 20px;
}

/* 4. 底部批量删除操作栏的样式 */
#sticker-panel-footer {
    padding: 10px 15px;
    /* 适配iPhone底部安全区 */
    padding-bottom: calc(10px + env(safe-area-inset-bottom));
    background-color: rgba(247, 247, 247, 0.9);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-top: 1px solid var(--border-color);
    flex-shrink: 0;
}

#sticker-panel-footer button {
    width: 100%;
    padding: 12px;
    border: none;
    border-radius: 8px;
    background-color: #ff3b30; /* 醒目的红色 */
    color: white;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
}

#sticker-panel-footer button:disabled {
    background-color: #ccc;
    cursor: not-allowed;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】角色表情包批量删除功能样式 ▼▼▼ */

/* 1. 当进入选择模式时，隐藏顶部的“批量添加/本地上传”按钮 */
#char-sticker-manager-screen.selection-mode .panel-btn {
    display: none;
}

/* 2. 角色表情包的底部操作栏样式，和用户表情包的类似 */
#char-sticker-footer {
    padding: 10px 15px;
    padding-bottom: calc(10px + env(safe-area-inset-bottom));
    background-color: rgba(247, 247, 247, 0.9);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-top: 1px solid var(--border-color);
    flex-shrink: 0;
}

#char-sticker-footer button {
    width: 100%;
    padding: 12px;
    border: none;
    border-radius: 8px;
    background-color: #ff3b30;
    color: white;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
}

#char-sticker-footer button:disabled {
    background-color: #ccc;
    cursor: not-allowed;
}

/* 3. 为页签内容区添加 active 类，用于JS控制显示/隐藏 */
.frame-content {
    display: none;
}
.frame-content.active {
    display: flex;
    flex-direction: column;
    flex-grow: 1;
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】这是为心声面板编辑功能新增的CSS ▼▼▼ */

/* 当头部有这个class时，强制隐藏底部边框 */
#inner-voice-main-panel .modal-header.no-border {
    border-bottom: none !important;
}

/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* 强制提升“心声样式编辑器”的层级，确保它能覆盖在心声面板之上 */
#inner-voice-editor-modal {
    z-index: 1001; /* 这个值比心声面板的默认层级(1000)要高 */
}

/* ▲▲▲ 修复结束 ▲▲▲ */
/* ▼▼▼ 【全新】这是为心声面板图标新增的颜色控制样式 ▼▼▼ */

/* 1. 为心声面板定义一个CSS变量，并设置默认颜色 */
#inner-voice-main-panel {
    --iv-icon-color: #ff8a80; /* 你可以修改这个默认的粉红色 */
}

/* 2. 让所有目标图标的颜色都使用这个变量 */
#close-inner-voice-modal {
    color: var(--iv-icon-color);
}

#inner-voice-edit-btn svg,
#change-inner-voice-bg-btn svg,
#inner-voice-history-btn svg {
    /* 核心：将图标的线条颜色设置为我们定义的变量 */
    stroke: var(--iv-icon-color);
}
/* ▲▲▲ 新增样式结束 ▲▲▲ */
/* ▼▼▼ 【全新】AI生成群成员按钮样式 ▼▼▼ */
#member-management-actions #ai-generate-members-btn {
    background-color: #007bff; /* 一个醒目的蓝色 */
    color: white;
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】约会大作战App样式 (V5 - 终极修复版) ▼▼▼ */

#date-a-live-screen {
    background-color: #f0f2f5;
}
#phone-screen.dark-mode #date-a-live-screen {
    background-color: #000;
}

/* ★★★ 这是本次唯一的、但最关键的修改区域 ★★★ */
#dating-scene-content {
    flex: 1; /* ★★★ 核心1: 让内容区占据父容器（屏幕）的所有剩余空间 */
    min-height: 0; /* ★★★ 核心2: flex布局的一个重要技巧，防止内容溢出时产生意外的布局问题 */
    overflow-y: auto; /* ★★★ 核心3: 当内容超出容器高度时，自动显示垂直滚动条！*/

    padding: 20px;
    display: flex;
    flex-direction: column;
    gap: 20px; 
}
/* ★★★ 修改结束 ★★★ */


.dating-scene-card {
    width: 100%;
    background-color: var(--secondary-bg);
    border-radius: 12px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    overflow: hidden;
    position: relative; 
    transition: transform 0.3s ease, opacity 0.3s ease;
    
    /* 保持卡片内部为垂直flex布局，确保图片在上，文字在下 */
    display: flex;
    flex-direction: column;
    flex-shrink: 0; /* 防止卡片自身被意外压缩 */
}

.dating-scene-delete-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    background-color: rgba(0, 0, 0, 0.5);
    color: white;
    border: none;
    font-size: 20px;
    line-height: 28px;
    text-align: center;
    cursor: pointer;
    z-index: 5;
    opacity: 0;
    transition: background-color 0.2s;
}
.dating-scene-card:hover .dating-scene-delete-btn {
    opacity: 1;
}
.dating-scene-delete-btn:hover {
    background-color: #ff3b30;
}

.dating-scene-image-container {
    width: 100%;
    aspect-ratio: 16 / 10;
    background-color: #e9ecef;
    display: flex;
    justify-content: center;
    align-items: center;
    color: var(--text-secondary);
    font-size: 14px;
    flex-shrink: 0; 
}
#phone-screen.dark-mode .dating-scene-image-container {
    background-color: #2c2c2e;
}

.dating-scene-image-container .loading-spinner {
    width: 30px;
    height: 30px;
    border: 3px solid rgba(0,0,0,0.1);
    border-top-color: var(--accent-color);
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

.dating-scene-image-container img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.dating-scene-info {
    padding: 15px;
    text-align: center;
    flex-shrink: 0; /* 防止文字区域被压缩 */
}

.dating-scene-info .name {
    font-size: 18px;
    font-weight: 600;
    color: var(--text-primary);
}

.dating-scene-info .cost {
    font-size: 16px;
    color: #FF5722;
    font-weight: bold;
    margin-top: 8px;
}
/* ▲▲▲ 样式结束 ▲▲▲ */
/* ▼▼▼ 【全新】借钱列表项美化样式 ▼▼▼ */
#borrow-money-char-list .character-select-item {
    gap: 12px; /* 在头像和名字之间增加一些间距 */
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】借条卡片样式 ▼▼▼ */
.message-bubble.is-borrow-request .content {
    padding: 0;
    background: transparent;
    box-shadow: none;
    border: none;
}

.borrow-card {
    width: 220px;
    border-radius: 12px;
    background: linear-gradient(135deg, #e0c3fc, #8ec5fc); /* 温柔的紫蓝色渐变 */
    color: white;
    padding: 15px;
    box-shadow: 0 4px 12px rgba(142, 197, 252, 0.4);
    position: relative;
    overflow: hidden;
}
.borrow-card::before {
    content: '💸'; /* 飞钱的Emoji作为装饰 */
    position: absolute;
    top: -5px;
    right: 10px;
    font-size: 32px;
    opacity: 0.15;
    transform: rotate(15deg);
}

.borrow-card .borrow-header {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 16px;
    font-weight: 600;
    margin-bottom: 10px;
    padding-bottom: 8px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.3);
}
.borrow-card .borrow-header span {
    color: #4a00e0; /* 深紫色突出借钱对象 */
    text-shadow: 0 0 5px rgba(255,255,255,0.5);
}

.borrow-card .borrow-body .label {
    font-size: 13px;
    opacity: 0.8;
}

.borrow-card .borrow-body .amount {
    font-size: 32px;
    font-weight: 700;
    margin: 4px 0 10px 0;
}

.borrow-card .borrow-body .reason {
    font-size: 12px;
    line-height: 1.5;
    opacity: 0.9;
    padding-top: 8px;
    margin-top: 8px;
    border-top: 1px solid rgba(255, 255, 255, 0.2);
    word-break: break-all;
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* 1. 主容器 (保持不变) */
#dating-game-screen {
    background-color: #000;
    color: white;
}

/* 2. 背景图层 (最底层) */
#dating-game-background {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background-size: cover;
    background-position: center;
    transition: background-image 0.5s ease-in-out, filter 0.5s ease-in-out;
    filter: blur(3px) brightness(0.8);
    transform: scale(1.05);
    z-index: 1; /* ★★★ 核心修改：明确指定层级为 1 ★★★ */
}

/* 4. UI层 (最顶层) */
.dating-game-ui-overlay {
    position: relative; /* 相对定位，因为它需要自然地排在最上层 */
    width: 100%; height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: flex-end; /* 将内容推到底部 */
    padding-bottom: calc(env(safe-area-inset-bottom) + 15px);
    box-sizing: border-box;
    z-index: 3; /* ★★★ 核心修改：明确指定层级为 3，比立绘高，确保它永远在最上面！ ★★★ */
}
#dating-game-screen .header {
    position: absolute;
    top: 0;
    width: 100%;
    box-sizing: border-box;
    background-color: rgba(0,0,0,0.3);
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
    border-bottom: 1px solid rgba(255,255,255,0.2);
    color: white;
}
#dating-game-screen .header .back-btn {
    color: white;
}

/* --- ▼▼▼ 这里是本次修改的核心区域 ▼▼▼ --- */

.dating-game-textbox {
    display: flex; /* 1. 改为Flex布局 */
    flex-direction: column;
    justify-content: space-between; /* 2. 让内容和提示分开 */
    background-color: rgba(0, 0, 0, 0.75);
    padding: 15px 20px;
    margin: 0 15px 15px 15px;
    border-radius: 12px;
    border: 1px solid rgba(255,255,255,0.1);
    min-height: 120px; /* 3. 设置一个固定的最小高度 */
    transition: opacity 0.5s, transform 0.5s;
    cursor: pointer;
    /* 4. 移除 overflow: auto，禁止其自身滚动 */
}

/* --- ▼▼▼ 在 .dating-game-textbox 规则之后，粘贴下面这段新代码 ▼▼▼ --- */

/* 文本内容的容器，我们给它一个淡入淡出的动画 */
.dating-game-textbox #dating-game-text-content {
    transition: opacity 0.2s ease-in-out;
}
/* 当句子切换时，先让旧句子淡出 */
.dating-game-textbox #dating-game-text-content.fade-out {
    opacity: 0;
}

/* “点击继续”的提示 */
.dating-game-textbox .continue-indicator {
    display: block;
    text-align: right;
    margin-top: 10px;
    font-size: 14px;
    color: #888;
    animation: pulse-indicator 1.5s infinite;
}
@keyframes pulse-indicator {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
}

/* --- ▲▲▲ 新增代码结束 ▲▲▲ --- */


.dating-game-choices {
    display: flex;
    flex-direction: column;
    gap: 10px;
    padding: 0 15px;
    margin-bottom: 15px;
}

.dating-game-choice-btn {
    width: 100%;
    padding: 15px;
    background-color: rgba(255, 255, 255, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.3);
    color: white;
    border-radius: 25px;
    font-size: 15px;
    font-weight: 500;
    cursor: pointer;
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
    transition: background-color 0.2s, transform 0.1s;
}

.dating-game-choice-btn.input-action {
    background-color: rgba(0, 123, 255, 0.4);
    border-color: rgba(0, 123, 255, 0.6);
}

.dating-game-choice-btn:hover {
    background-color: rgba(255, 255, 255, 0.4);
}
.dating-game-choice-btn:active {
    transform: scale(0.98);
}
/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】约会大作战-文游界面UI增强样式 ▼▼▼ */

/* 1. 为文游界面顶部栏添加按钮容器 (这段代码已包含在步骤1中，如果已添加可忽略) */
#dating-game-screen .header {
    justify-content: space-between;
}

/* 3. 立绘层 (中间层) */
#dating-game-sprite-container {
    position: absolute;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
    width: 80%;
    height: auto;
    max-height: 80%;
    pointer-events: none;
    transition: all 0.5s ease-in-out;
    z-index: 2; /* ★★★ 核心修改：明确指定层级为 2，比背景高 ★★★ */
}
#dating-game-sprite-container img {
    width: 100%;
    height: 100%;
    object-fit: contain;
    filter: drop-shadow(0 4px 8px rgba(0,0,0,0.5));
}

/* 3. 设置弹窗样式 */
#dating-game-settings-modal .modal-content {
    height: 85%;
}
#dating-game-settings-modal .form-group {
    margin-bottom: 15px;
}
#dating-game-settings-modal hr {
    margin: 15px 0;
}
#dating-game-settings-modal .modal-body {
    padding-bottom: 15px;
}

/* 4. 立绘定位控制的样式 */
.position-controls {
    display: flex;
    gap: 10px;
    align-items: center;
}
.position-controls label {
    flex-shrink: 0;
}
.position-controls input[type="range"] {
    flex-grow: 1;
}

/* ▲▲▲ 样式粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】这是为“立绘预设”功能新增的所有CSS样式 ▼▼▼ */

/* --- 立绘组编辑器 --- */
.sprite-edit-card {
    background-color: #f9f9f9;
    border-radius: 8px;
    padding: 12px;
    border: 1px solid var(--border-color);
    position: relative;
    display: flex;
    gap: 15px;
    align-items: flex-start;
}
#phone-screen.dark-mode .sprite-edit-card {
    background-color: #2c2c2e;
}

.sprite-edit-card .preview-container {
    width: 80px;
    height: 120px;
    background-color: #e9ecef;
    border-radius: 6px;
    border: 1px dashed #ccc;
    background-size: contain;
    background-position: center;
    background-repeat: no-repeat;
    flex-shrink: 0;
}
#phone-screen.dark-mode .sprite-edit-card .preview-container {
    background-color: #3a3a3c;
    border-color: #555;
}

.sprite-edit-card .fields-container {
    display: flex;
    flex-direction: column;
    gap: 10px;
    flex-grow: 1;
}
.sprite-edit-card textarea {
    min-height: 50px;
    resize: vertical;
}

.sprite-edit-card .delete-sprite-btn {
    position: absolute;
    top: -8px;
    right: -8px;
    width: 24px;
    height: 24px;
    background-color: #ff3b30;
    color: white;
    border: none;
    border-radius: 50%;
    font-size: 16px;
    line-height: 24px;
    text-align: center;
    cursor: pointer;
}

/* --- 立绘组管理列表 --- */
.sprite-group-list-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px 15px;
    border-bottom: 1px solid var(--border-color);
}
.sprite-group-list-item:hover {
    background-color: #f5f5f5;
}
#phone-screen.dark-mode .sprite-group-list-item:hover {
    background-color: #2c2c2e;
}
.sprite-group-list-item .group-name {
    font-weight: 500;
}
.sprite-group-list-item .group-actions button {
    margin-left: 8px;
    padding: 5px 10px;
    font-size: 13px;
}
/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】约会大作战-立绘定位控制样式 ▼▼▼ */

/* 这是包裹每个滑块（标签+滑块本身）的容器 */
.sprite-edit-card .position-controls {
    display: flex;
    align-items: center;
    gap: 10px; /* 标签和滑块的间距 */
    margin-top: 8px;
}

/* 这是“X 位置”、“Y 位置”、“大小”这些文字标签的样式 */
.sprite-edit-card .position-controls label {
    flex-shrink: 0; /* 防止标签文字被压缩换行 */
    width: 90px;    /* 给一个固定的宽度，让所有滑块能左对齐 */
    font-size: 13px;
    color: var(--text-secondary);
}

/* 这是滑块旁边的实时数值显示的样式 */
.sprite-edit-card .position-controls .pos-value {
    font-weight: 500;
    color: var(--text-primary);
}

/* 这是滑块本身的样式 */
.sprite-edit-card .position-controls input[type="range"] {
    flex-grow: 1; /* 让滑块占据所有剩余空间 */
    width: 100%;  /* 确保它能撑满 */
}

/* ▲▲▲ 新样式粘贴结束 ▲▲▲ */
/* ▼▼▼ 【全新】这是约会场景专属的“好感度”和“欲望值”心形UI样式 ▼▼▼ */

/* ▼▼▼ 【独家定制】这是为你修改后的“左上角”版本 ▼▼▼ */

/* 这是包裹两个数值条的总容器 */
#dating-values-container {
    position: absolute;
    
    /* ▼▼▼ 核心修改1：调整垂直位置，把它明确地放到Header下方 ▼▼▼ */
    /* 你的Header高度是110px，我们再加10px的间距，所以设置为120px */
    top: 120px; 
    
    /* ▼▼▼ 核心修改2：调整水平位置，从右边移动到左边 ▼▼▼ */
    left: 15px; /* 原来是 right: 15px; */

    z-index: 5;
    display: none;
    flex-direction: column;
    gap: 8px;
    
    /* ▼▼▼ 核心修改3：让内部元素靠左对齐，更好看 ▼▼▼ */
    align-items: flex-start; /* 原来是 align-items: flex-end; */
}
/* ▲▲▲ 替换结束 ▲▲▲ */


/* 这是每一行数值条（例如“浪漫值”那一行）的样式 */
.value-display {
    display: flex;
    align-items: center;
    gap: 4px; /* 心与心之间的间距 */
    background-color: rgba(0, 0, 0, 0.2); /* 给一个半透明的深色背景板，让心形更突出 */
    padding: 4px 8px;
    border-radius: 12px;
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
}

/* 这是单个心形图标的样式 */
.value-display svg {
    width: 20px;
    height: 20px;
    stroke-width: 1.5; /* 描边宽度 */
    transition: all 0.3s ease-in-out; /* 为填充和颜色变化添加动画 */
}

/* 这是“浪漫值”图标的颜色 */
#romance-value svg {
    color: #ff8fab; /* 可爱的粉红色 */
    stroke: #ffc2d1; /* 描边用更淡的粉色 */
}
/* 这是“性欲值”图标的颜色 */
#lust-value svg {
    color: #ffde59; /* 诱人的金黄色 */
    stroke: #ffeda6; /* 描边用更淡的黄色 */
}

/* “空心”状态：填充色为透明 */
.value-display svg .heart-fill {
    fill: transparent;
}
/* “实心”状态：填充色为图标的颜色 */
.value-display svg.filled .heart-fill {
    fill: currentColor;
}
/* ▲▲▲ 新增CSS样式结束 ▲▲▲ */
/* ▼▼▼ 【全新】约会完成度进度条样式 ▼▼▼ */

/* ▼▼▼ 这是为你修复后的进度条样式 ▼▼▼ */

/* 这是进度条的容器 (已移至底部) */
#dating-completion-bar-container {
    position: absolute;
    bottom: calc(20px + env(safe-area-inset-bottom)); 
    
    /* 其他样式保持不变 */
    left: 15px;
    right: 15px;
    height: 18px;
    background-color: rgba(0, 0, 0, 0.3);
    border-radius: 9px;
    border: 1px solid rgba(255, 255, 255, 0.2);
    box-shadow: 0 1px 3px rgba(0,0,0,0.2) inset;
    overflow: hidden;
    z-index: 4;
    display: none;
    transition: width 0.5s ease-in-out;
}
/* ▲▲▲ 替换结束 ▲▲▲ */

/* 进度条的填充部分 */
#dating-completion-bar-fill {
    width: 0%; /* 初始为0% */
    height: 100%;
    /* 使用一个漂亮的粉色渐变作为填充色 */
    background: linear-gradient(90deg, #ff8fab, #fb6f92);
    border-radius: 9px;
    transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1); /* 平滑的宽度变化动画 */
}

/* 进度条上的百分比文字 */
#dating-completion-text {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 12px;
    color: white;
    font-weight: bold;
    text-shadow: 0 1px 2px rgba(0,0,0,0.6); /* 文字阴影，确保清晰 */
}

/* ▲▲▲ 新增CSS结束 ▲▲▲ */
/* ▼▼▼ 【全新】约会结算卡片样式 ▼▼▼ */

#dating-summary-overlay {
    background-color: rgba(0, 0, 0, 0.7);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
}

.dating-summary-card {
    background-color: transparent;
    width: 320px;
    height: 500px;
    perspective: 1000px; /* 为3D翻转效果设置透视 */
}

.dating-summary-card-inner {
    position: relative;
    width: 100%;
    height: 100%;
    text-align: center;
    transition: transform 0.6s;
    transform-style: preserve-3d;
    box-shadow: 0 4px 20px rgba(0,0,0,0.2);
    border-radius: 20px;
}

/* 当卡片被翻转时 */
.dating-summary-card.is-flipped .dating-summary-card-inner {
    transform: rotateY(180deg);
}

/* 卡片的正面和背面 */
.card-front, .card-back {
    position: absolute;
    width: 100%;
    height: 100%;
    -webkit-backface-visibility: hidden; /* Safari */
    backface-visibility: hidden;
    border-radius: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 20px;
    box-sizing: border-box;
}

/* 正面样式 */
.card-front {
    color: white;
    background: linear-gradient(135deg, #a8b2c5, #8e9eab); /* 期待之夜的默认灰色渐变 */
    transition: background 0.3s;
}

/* 不同评级的背景颜色 */
.card-front.romantic {
    background: linear-gradient(135deg, #ff8fab, #fb6f92); /* 粉色渐变 */
}
.card-front.passionate {
    background: linear-gradient(135deg, #ffda79, #ffb142); /* 黄色渐变 */
}
/* ▼▼▼ 这是为你定制的“完美之夜”薰衣草色，请用它替换旧的 .card-front.perfect 样式 ▼▼▼ */
.card-front.perfect {
    /* 核心修改：这里使用了从淡紫到略深紫色的优雅渐变，营造出浪漫梦幻的感觉 */
    background: linear-gradient(135deg, #d1c4e9, #b39ddb); 
}

.card-front #summary-card-avatar {
    width: 120px;
    height: 120px;
    border-radius: 50%;
    border: 4px solid rgba(255, 255, 255, 0.8);
    box-shadow: 0 5px 15px rgba(0,0,0,0.2);
    object-fit: cover;
    margin-bottom: 20px;
}

.card-front #summary-card-rating {
    font-size: 28px;
    font-weight: bold;
    text-shadow: 0 2px 4px rgba(0,0,0,0.3);
    margin: 0 0 10px 0;
}

.card-front .summary-card-tip {
    font-size: 14px;
    opacity: 0.8;
    margin-top: auto; /* 将提示推到底部 */
}

.summary-card-actions {
    display: flex;
    gap: 15px;
    width: 100%;
    margin-top: 20px;
}

.summary-card-actions button {
    flex: 1;
    padding: 12px;
    border-radius: 20px;
    border: none;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
}

#summary-share-btn {
    background-color: rgba(255, 255, 255, 0.9);
    color: #333;
}
#summary-close-btn {
    background-color: rgba(0, 0, 0, 0.2);
    color: white;
}

/* 背面样式 */
.card-back {
    background-color: #f8f9fa;
    color: #333;
    transform: rotateY(180deg);
    justify-content: flex-start; /* 内容从顶部开始 */
}

.card-back-header {
    width: 100%;
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding-bottom: 10px;
    margin-bottom: 10px;
    border-bottom: 1px solid #e0e0e0;
    flex-shrink: 0;
}
.card-back-header span {
    font-weight: 600;
}
.card-back-header button {
    background: none;
    border: none;
    color: var(--accent-color);
    font-size: 16px;
    cursor: pointer;
}

.card-back-content {
    width: 100%;
    flex-grow: 1;
    overflow-y: auto;
    text-align: left;
    line-height: 1.6;
    font-size: 14px;
}
.card-back-content p {
    margin: 0 0 10px 0;
}

/* 聊天记录里分享卡片的样式 */
.message-bubble.is-dating-summary .content {
    padding: 0;
    background: transparent;
    box-shadow: none;
    border: none;
}

.dating-summary-chat-card {
    width: 220px;
    height: 120px;
    border-radius: 12px;
    padding: 15px;
    color: white;
    cursor: pointer;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
    position: relative;
    overflow: hidden;
}
.dating-summary-chat-card::before {
    content: '💖';
    position: absolute;
    top: -10px;
    left: -10px;
    font-size: 40px;
    opacity: 0.1;
    transform: rotate(-15deg);
}

.dating-summary-chat-card .rating {
    font-size: 20px;
    font-weight: bold;
    text-shadow: 0 1px 3px rgba(0,0,0,0.3);
}

.dating-summary-chat-card .tip {
    font-size: 12px;
    opacity: 0.8;
    margin-top: 8px;
}
/* ▲▲▲ 新增CSS样式结束 ▲▲▲ */
/* ▼▼▼ 把这一整块全新的CSS，粘贴到 <style> 的末尾 ▼▼▼ */

/* --- 【全新】约会历史记录功能样式 --- */

/* 历史记录页面的主容器 */
#dating-history-list {
    background-color: #f0f2f5;
}
#phone-screen.dark-mode #dating-history-list {
    background-color: #1c1c1e;
}

/* 历史列表中的卡片，我们让它更适合列表显示 */
#dating-history-list .dating-summary-card {
    width: 100%; /* 卡片宽度撑满 */
    height: 180px; /* 给一个固定的高度，让列表更整齐 */
    position: relative; 
    transform: none;
    left: auto;
    top: auto;
    margin: 0; /* 移除模态框的居中外边距 */
}

/* 历史列表中的卡片，正面样式微调 */
#dating-history-list .card-front {
    padding: 15px;
    justify-content: center;
    cursor: pointer; /* 鼠标放上去时显示小手，提示可以点击 */
}

#dating-history-list .card-front img {
    width: 70px !important;
    height: 70px !important;
    margin-bottom: 10px !important;
    border-radius: 50% !important;
    border: 3px solid rgba(255,255,255,0.7) !important;
    box-shadow: 0 4px 10px rgba(0,0,0,0.2) !important;
}

#dating-history-list .card-front h2 {
    font-size: 22px !important;
    margin: 0 0 5px 0 !important;
}

#dating-history-list .card-front p {
    margin-top: 5px !important;
}

/* 历史列表中的卡片，背面样式微调 */
#dating-history-list .card-back-header {
    flex-shrink: 0; /* 防止头部被压缩 */
}
#dating-history-list .card-back-content {
    font-family: sans-serif; /* 背面可以用更易读的非衬线字体 */
    font-size: 13px;
    line-height: 1.6;
}

/* ▲▲▲ 新增CSS样式结束 ▲▲▲ */



    </style>
    <!-- ▼▼▼ 在这里添加下面这行 ▼▼▼ -->
    <style id="custom-theme-style"></style>

</head>
<body>
        <div id="phone-screen">
            <div id="status-bar">
                <span id="status-bar-time">12:00</span>
                <div id="status-bar-battery" class="battery-container">
                    <span class="battery-text">--%</span>
                    <div class="battery-icon">
                        <div class="battery-level"></div>
                    </div>
                </div>
            </div>
            <div id="notification-bar"><img id="notification-avatar" src=""><div id="notification-content"><div class="name"></div><div class="message"></div></div></div>

<!-- ▼▼▼ 【全新】在这里粘贴悬浮歌词栏的代码 ▼▼▼ -->
<div id="floating-lyrics-bar">
    <span id="floating-lyric-text">♪</span>
    <!-- 【问题4修复】用包含SVG的div替换旧的span -->
    <div id="lyrics-settings-btn" style="cursor: pointer; display: flex; align-items: center; justify-content: center;">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="3"></circle>
            <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
        </svg>
    </div>
    <span class="close-btn">×</span>
</div>
<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 在这里粘贴下面这行新代码 ▼▼▼ -->
<div id="lock-screen-background-blur" style="display: none;"></div>
<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->
            
<!-- ▼▼▼ 用下面这【一整块】修改后的代码，替换掉你旧的 <div id="home-screen"...>...</div> ▼▼▼ -->
<div id="home-screen" class="screen active">
    
    <!-- 我们用一个滑动容器把页面包起来 -->
    <div class="home-screen-slider">
        <!-- 这是你的第一页，我们把原来的内容都放进来 -->
        <div class="home-page">
            <div id="main-content-area">
                <div id="profile-widget">
                    <img id="profile-banner-img" src="https://i.postimg.cc/k495F4W5/profile-banner.jpg" class="editable-image">
                    <!-- ▼▼▼ 用下面这整块代码，替换旧的 profile-avatar-container ▼▼▼ -->
<div class="profile-avatar-container">
    <img id="profile-avatar-img" src="https://i.postimg.cc/qRqpK5kP/anime-avatar.jpg" class="editable-image">
    <!-- ▼▼▼ 我们在这里新增了一个用于显示头像框的img元素 ▼▼▼ -->
    <img id="profile-avatar-frame" class="weibo-avatar-frame" src="" style="display: none;">
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->

                    <div class="profile-info">
                        <p id="profile-username" class="editable-text">你的昵称</p>
                        <p id="profile-sub-username" class="editable-text">@your_id</p>
                        <p id="profile-bio" class="editable-text">点击这里编辑你的个性签名</p>
                        <p id="profile-location" class="editable-text" data-placeholder="点击编辑地点"><svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"></path></svg><span>点击编辑地点</span></p>
                    </div>
                </div>
                <div id="desktop-layout">
                    <div id="desktop-widget-column">
                        <div class="custom-widget-container">
                            <div id="widget-bubble-1" class="widget-bubble editable-text" contenteditable="true">点击编辑文字</div>
                            <div class="widget-circle-uploader">
                                <img id="widget-image-1" src="https://i.postimg.cc/qRqpK5kP/anime-avatar.jpg" class="editable-image" title="点击更换图片">
                            </div>
                            <div id="widget-subtext-1" class="widget-subtext editable-text" contenteditable="true">点击编辑文字</div>
                        </div>
                        <div class="custom-widget-container">
                            <div id="widget-bubble-2" class="widget-bubble editable-text" contenteditable="true">点击编辑文字</div>
                            <div class="widget-circle-uploader">
                                <img id="widget-image-2" src="https://i.postimg.cc/k495F4W5/profile-banner.jpg" class="editable-image" title="点击更换图片">
                            </div>
                            <div id="widget-subtext-2" class="widget-subtext editable-text" contenteditable="true">点击编辑文字</div>
                        </div>
                    </div>
                    <div id="desktop-app-container">
                        <div class="desktop-app-icon" onclick="showScreen('chat-list-screen')"><div class="icon-bg-desktop"><img id="icon-img-qq" src="https://i.postimg.cc/MTC3Tkw8/IMG-6436.jpg" alt="QQ"></div><span class="label">QQ</span></div>
                        <div class="desktop-app-icon" onclick="showScreen('world-book-screen')"><div class="icon-bg-desktop"><img id="icon-img-world-book" src="https://i.postimg.cc/HWf1JKzn/IMG-6435.jpg" alt="世界书"></div><span class="label">世界书</span></div>
                        <div id="check-phone-btn" class="desktop-app-icon">
                            <div class="icon-bg-desktop"><img id="icon-img-check-phone" src="https://i.postimg.cc/RVwpwr0r/IMG-8348.jpg" alt="查手机"></div>
                            <span class="label">查手机</span>
                        </div>
                        <div class="desktop-app-icon" id="weibo-app-icon">
                            <div class="icon-bg-desktop"><img id="icon-img-weibo" src="https://i.postimg.cc/PqBY5wBq/weibo-icon.png" alt="微博"></div>
                            <span class="label">微博</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

<!-- 这是我们新增的第二页，现在是自定义布局 -->
<div class="home-page">
<!-- 这是左半边的头像小组件 -->
<div id="second-page-left-widget" class="custom-widget-container">
    <div class="widget-circle-uploader">
        <img id="widget-image-3" src="https://i.postimg.cc/qRqpK5kP/anime-avatar.jpg" class="editable-image" title="点击更换图片">
    </div>
    
    <!-- ▼▼▼ 这是我们新增的可编辑胶囊气泡 ▼▼▼ -->
    <div id="second-page-bubble" class="widget-bubble editable-text" contenteditable="true">
        点击编辑文字
    </div>
    <!-- ▲▲▲ 新增结束 ▲▲▲ -->
<!-- ▼▼▼ 在这里添加下面这段全新的HTML代码 ▼▼▼ -->
<div id="new-bubbles-container">
    <div id="flat-capsule-bubble" class="widget-bubble editable-text" contenteditable="true">可编辑</div>
    <div id="circular-bubble" class="widget-bubble editable-text" contenteditable="true">文字</div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->

</div>
    <!-- 这是右上角的两个并排图标 -->
    <div id="second-page-top-right-apps">
        <div class="desktop-app-icon" onclick="showScreen('forum-screen')">
            <div class="icon-bg-desktop"><img id="icon-img-forum" src="https://i.postimg.cc/pr0T3WfC/douban-icon.png" alt="圈子"></div>
            <span class="label">圈子</span>
        </div>
        <div class="desktop-app-icon" id="lovers-space-app-icon">
            <div class="icon-bg-desktop"><img id="icon-img-lovers-space" src="https://i.postimg.cc/d1wZ39xW/lovers-space-icon.png" alt="情侣空间"></div>
            <span class="label">情侣空间</span>
        </div>

<!-- 这是你现在的代码 -->
<div id="second-page-x-social-app" class="desktop-app-icon" onclick="showScreen('x-social-screen')">
    <div class="icon-bg-desktop"><img id="icon-img-x-social" src="https://i.postimg.cc/8P1H0vQ8/x-logo.png" alt="X社交"></div>
    <span class="label">X社交</span>
</div>



<!-- ▼▼▼ 用下面这整块【修复后】的代码，替换掉你旧的 id="center-avatar-wrapper" 的那个 div ▼▼▼ -->
<div id="center-avatar-wrapper">
    <!-- 这是你原来的头像，我们把它放在了新容器的中心 -->
    <div id="second-page-center-avatar" class="custom-widget-container">
        <div class="widget-circle-uploader">
            <img id="widget-image-4" src="https://i.postimg.cc/qRqpK5kP/anime-avatar.jpg" class="editable-image" title="点击更换图片">
        </div>
    </div>
    
    <!-- 这是修复后的、头像下方的可编辑文字框 -->
    <div id="avatar-subtitle" class="editable-text">点击编辑文字</div>

    <!-- 这是修复后的、头像四个角的可编辑气泡 -->
    <div class="corner-bubble editable-text" id="bubble-top-left">左上角</div>
    <div class="corner-bubble editable-text" id="bubble-top-right">右上角</div>
    <div class="corner-bubble editable-text" id="bubble-bottom-left">左下角</div>
    <div class="corner-bubble editable-text" id="bubble-bottom-right">右下角</div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
 <!-- ▼▼▼ 在第二个 <div class="home-page"> 的闭合标签前，粘贴下面这段代码 ▼▼▼ -->
<div style="position: absolute; top: 100px; right: 85px;">
    <div class="desktop-app-icon" onclick="showScreen('game-hall-screen')">
        <div class="icon-bg-desktop">
            <img id="icon-img-game-hall" src="https://i.postimg.cc/P5gL5z2g/game-controller-icon.png" alt="游戏大厅">
        </div>
        <span class="label">游戏大厅</span>
    </div>
</div>
<!-- ▲▲▲ 新增图标代码结束 ▲▲▲ -->
    </div>
<!-- ▼▼▼ 【这是修改后的版本】请用这整块代码，完整替换掉旧的 id="new-custom-widget" ▼▼▼ -->
<div id="new-custom-widget">
    <!-- 我们用一个新的容器把月份和头像包起来 -->
    <div id="new-widget-header">
        <div id="widget-month-display"></div>
        <img id="new-widget-avatar" src="https://i.postimg.cc/qRqpK5kP/anime-avatar.jpg" class="editable-image">
    </div>
    <div id="new-widget-text-1" class="new-widget-text editable-text" contenteditable="true">可编辑文字</div>
    <div class="new-widget-divider"></div>
    <div id="new-widget-text-2" class="new-widget-text editable-text" contenteditable="true">可编辑文字</div>
    <div class="new-widget-divider"></div>
    <div id="new-widget-text-3" class="new-widget-text editable-text" contenteditable="true">可编辑文字</div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
<!-- ▼▼▼ 把下面这一整块【全新的代码】，粘贴到第二个 <div class="home-page"> 的【内部】最底部 ▼▼▼ -->
<!-- 这是我们新增的“桃宝”App图标 -->
<div style="position: absolute; bottom: 75px; left: 35px;">
    <div class="desktop-app-icon" id="taobao-app-icon">
        <div class="icon-bg-desktop"><img id="icon-img-taobao" src="https://i.postimg.cc/k47tXg1j/taologo.png" alt="桃宝"></div>
        <span class="label" style="color: white; text-shadow: 0 1px 3px rgba(0,0,0,0.5);">桃宝</span>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 在这里粘贴下面这块新代码 ▼▼▼ -->
<!-- 这是我们新增的“约会大作战”App图标 -->
<div style="position: absolute; bottom: 75px; left: 105px;">
    <div class="desktop-app-icon" id="date-a-live-app-icon">
        <div class="icon-bg-desktop"><img id="icon-img-date-a-live" src="https://i.postimg.cc/W36mYgP5/DAL-icon.jpg" alt="约会大作战"></div>
        <span class="label" style="color: white; text-shadow: 0 1px 3px rgba(0,0,0,0.5);">约会大作战</span>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->

<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
</div>
    </div>
    
    <!-- 底部 Dock 栏保持不变 -->
    <div id="desktop-dock">
        <div class="desktop-app-icon" onclick="showScreen('api-settings-screen')"><div class="icon-bg-desktop"><img id="icon-img-api-settings" src="https://i.postimg.cc/MK8rJ8t7/IMG-6438.jpg" alt="API设置"></div><span class="label">API设置</span></div>
        <div class="desktop-app-icon" onclick="showScreen('font-settings-screen')"><div class="icon-bg-desktop"><img id="icon-img-font" src="https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg" alt="字体"></div><span class="label">字体</span></div>
        <div class="desktop-app-icon" onclick="showScreen('wallpaper-screen')">
            <div class="icon-bg-desktop"><img id="icon-img-wallpaper" src="https://i.postimg.cc/T1j03pQr/IMG-6440.jpg" alt="外观设置"></div>
            <span class="label">外观设置</span>
        </div>
    </div>

    <!-- 这是我们新增的小圆点 -->
    <div class="pagination-dots">
        <span class="dot active"></span>
        <span class="dot"></span>
    </div>
</div>
<!-- ▲▲▲ HTML 替换结束 ▲▲▲ -->

<!-- ▲▲▲ HTML 替换结束 ▲▲▲ -->
<!-- ▼▼▼ 用下面这【一整块功能最全】的代码，完整替换掉你旧的 id="weibo-screen" 的整个 div ▼▼▼ -->
<div id="weibo-screen" class="screen">
    <!-- 这个容器将存放微博的所有页面 -->
    <div id="weibo-page-container">

        <!-- 页面1: 我的主页 (已改造) -->
        <div id="weibo-my-profile-view" class="weibo-view active">
            <!-- 头部 -->
            <div class="header">
                <span class="back-btn" onclick="showScreen('home-screen')"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg></span>
                <span>我的主页</span>
                <div class="header-actions">
                              <!-- ▼▼▼ 在这里添加新的私信按钮 ▼▼▼ -->
            <span class="action-btn" id="weibo-my-dms-btn" title="我的私信">
                <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline></svg>
            </span>
            <!-- ▲▲▲ 添加结束 ▲▲▲ -->
                    <!-- 【核心修改】我们在这里新增了一个“编辑”按钮 -->
                    <span class="action-btn" id="edit-weibo-profile-btn" title="编辑资料">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M12 20h9"></path>
                            <path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>
                        </svg>
                    </span>
                    <span class="action-btn" id="create-weibo-post-btn" style="font-size: 28px; font-weight: 300;">+</span>
                </div>
            </div>
            <!-- 主页内容区 -->
            <div id="weibo-profile-page">
                <div class="weibo-profile-header">
                    <img id="weibo-background-img" src="https://i.postimg.cc/mk93Y3j1/weibo-bg-default.jpg" class="weibo-background">
                  <!-- ▼▼▼ 用下面这整块代码，替换旧的 weibo-avatar-container ▼▼▼ -->
<div class="weibo-avatar-container">
    <img id="weibo-avatar-img" src="https://files.catbox.moe/q6z5fc.jpeg" class="weibo-avatar">
    <!-- ▼▼▼ 我们在这里新增了一个用于显示头像框的img元素 ▼▼▼ -->
    <img id="weibo-avatar-frame" class="weibo-avatar-frame" src="" style="display: none;">
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->

                    <div class="weibo-nickname" id="weibo-nickname">你的昵称</div>
                    <!-- 【核心修改】在这里新增一个显示职业的地方 -->
                    <!-- ▼▼▼ 用这行新代码替换掉旧的 ▼▼▼ -->
<div id="weibo-user-profession-display">点击设置职业</div>

                    <div class="weibo-stats">
                        <div id="weibo-following-btn" class="weibo-stat-item">
                            <span id="weibo-following-count" class="weibo-stat-number">0</span>
                            <span class="weibo-stat-label">关注</span>
                        </div>
                        <div id="weibo-posts-item" class="weibo-stat-item">
                            <span id="weibo-posts-count" class="weibo-stat-number">0</span>
                            <span class="weibo-stat-label">微博</span>
                        </div>
                        <div id="weibo-fans-item" class="weibo-stat-item">
                            <span id="weibo-fans-count" class="weibo-stat-number">0</span>
                            <span class="weibo-stat-label">粉丝</span>
                        </div>
                    </div>
                </div>
                <div id="my-weibo-feed-list" style="padding: 15px; display: flex; flex-direction: column; gap: 15px;">
                    <!-- “我的微博”列表将由JS动态生成在这里 -->
                </div>
            </div>
        </div>

        <!-- 页面2: 关注的人 (保持不变) -->
        <div id="weibo-following-view" class="weibo-view">
            <div class="header">
                <span class="back-btn" onclick="showScreen('home-screen')"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg></span>
                <span>关注的人</span>
                <span class="action-btn" id="clear-following-feed-btn" style="font-size: 16px; font-weight: 500;">清空</span>
            </div>
            <div id="weibo-following-feed-list" style="flex-grow: 1; overflow-y: auto; padding: 15px; display: flex; flex-direction: column; gap: 15px;">
                <!-- 关注的人的微博列表将由JS动态生成在这里 -->
            </div>
        </div>
        
        <!-- 页面3: 热搜 (保持不变) -->
        <div id="weibo-hot-search-view" class="weibo-view">
             <div class="header">
                <span class="back-btn" onclick="showScreen('home-screen')"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg></span>
                <span>热搜</span>
                <div class="header-actions">
                    <span class="action-btn" id="generate-hot-search-btn" title="生成热搜">
                        <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
                    </span>
                </div>
            </div>
            <div id="weibo-hot-search-list" style="flex-grow: 1; overflow-y: auto;">
                <p style="text-align:center; color: #8a8a8a; margin-top: 50px;">点击右上角放大镜生成热搜</p>
            </div>
        </div>

        <!-- 页面4: 广场 (保持不变) -->
        <div id="weibo-plaza-view" class="weibo-view">
            <div class="header">
                <span class="back-btn" onclick="showScreen('home-screen')"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg></span>
                <span>广场</span>
                <div class="header-actions">
                    <span class="action-btn" id="generate-plaza-feed-btn" title="生成广场动态">
                        <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
                    </span>
                </div>
            </div>
            <div id="weibo-plaza-feed-list" style="flex-grow: 1; overflow-y: auto; padding: 0;">
                 <p style="text-align:center; color: #8a8a8a; margin-top: 50px;">点击右上角放大镜生成广场动态</p>
            </div>
        </div>

        <!-- 页面5: 热搜详情页 (保持不变) -->
        <div id="weibo-hottopic-feed-view" class="weibo-view">
            <div class="header">
                <span class="back-btn" id="back-from-hottopic-btn"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg></span>
                <span id="weibo-hottopic-title">热搜话题</span>
                <div class="header-actions">
                     <span class="action-btn" id="refresh-hottopic-feed-btn" title="换一批">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg>
                    </span>
                </div>
            </div>
            <div id="weibo-hottopic-feed-list" style="flex-grow: 1; overflow-y: auto; padding: 0;">
                <!-- 热搜微博列表将由JS动态生成 -->
            </div>
        </div>
    </div>

    <!-- 底部导航栏 -->
    <div id="weibo-bottom-nav">
        <div class="weibo-nav-item" data-view="weibo-hot-search-view">热搜</div>
        <div class="weibo-nav-item" data-view="weibo-plaza-view">广场</div>
        <div class="weibo-nav-item" data-view="weibo-following-view">关注的人</div>
        <div class="weibo-nav-item active" data-view="weibo-my-profile-view">我的微博</div>
    </div>
</div>
<!-- ▲▲▲ HTML 替换结束 ▲▲▲ -->
   
<!-- ▼▼▼ 请用这整块【最终版】代码，完整替换掉你旧的 id="world-book-screen" 的 div ▼▼▼ -->
<div id="world-book-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <span>世界书</span>
        <div class="header-actions">
            
            <!-- ★★★ 核心修改就在这里 ★★★ -->
            <!-- 我们把 "导入" 两个字，换成了一段SVG代码，并加上了 title 提示 -->
            <span class="action-btn" id="import-world-book-btn" title="导入世界书">
                <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                    <polyline points="17 8 12 3 7 8"></polyline>
                    <line x1="12" y1="3" x2="12" y2="15"></line>
                </svg>
            </span>
            <!-- ▲▲▲ 修改结束 ▲▲▲ -->

            <span class="action-btn" id="manage-world-book-categories-btn">管理分类</span>
            <span class="action-btn" id="add-world-book-btn">+</span>
        </div>
    </div>
    <div id="world-book-list"></div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->


            <div id="world-book-editor-screen" class="screen">
                <div class="header">
                    <span class="back-btn" onclick="showScreen('world-book-screen')">‹</span>
                    <span id="world-book-editor-title">编辑世界书</span>
                    <span class="save-btn" id="save-world-book-btn">保存</span>
                </div>
                <div class="form-container">
                    <div class="form-group">
                        <label for="world-book-name-input">书名</label>
                        <input type="text" id="world-book-name-input" placeholder="请输入世界书的名称...">
                    </div>

        <!-- ▼▼▼ 【全新】在这里添加分类选择 ▼▼▼ -->
        <div class="form-group">
            <label for="world-book-category-select">分类</label>
            <select id="world-book-category-select">
                <!-- 选项将由JS动态生成 -->
            </select>
        </div>
        <!-- ▲▲▲ 添加结束 ▲▲▲ -->

                    <div class="form-group" style="height: 100%;">
                        <label for="world-book-content-input">内容</label>
                        <textarea id="world-book-content-input" placeholder="在此处输入详细的世界观设定..."></textarea>
                    </div>
                </div>
            </div>

            <div id="api-settings-screen" class="screen"><div class="header"><span class="back-btn" onclick="showScreen('home-screen')">‹</span><span>API 设置</span><span style="width: 30px;"></span></div><div class="form-container"><p style="font-size: 14px; color: #666; background-color: #f0f0f0; padding: 10px; border-radius: 8px;">提示: 若要使用“发送图片”功能, 请务必选择支持Vision(视觉)的模型, 如<code style="background-color: #e0e0e0; padding: 2px 4px; border-radius: 4px;">gpt-4o</code>或<code style="background-color: #e0e0e0; padding: 2px 4px; border-radius: 4px;">gpt-4-vision-preview</code>。</p><div class="form-group"><label for="proxy-url">反代地址 (不需要添加/v1噢~)</label><input type="text" id="proxy-url" placeholder="例如: https://api.openai.com"></div><div class="form-group"><label for="api-key">密钥 (直连轮询用英文逗号隔开)</label><input type="password" id="api-key" placeholder="sk-..."></div><div class="form-group"><label for="model-select">模型</label><select id="model-select"></select></div>
<!-- ▼▼▼ 请将这段【全新的HTML代码】粘贴到 “模型” 下拉框的 form-group 之后 ▼▼▼ -->
<div class="form-group">
    <label>API 预设</label>
    <div class="bubble-preset-manager"> <!-- 复用现有样式 -->
        <select id="api-preset-select" class="form-group select"></select>
        <button id="manage-api-presets-btn" class="action-btn">管理</button>
    </div>
</div>
<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->
 <!-- ▼▼▼ 请将这段【全新的HTML代码】粘贴到这里 ▼▼▼ -->
<div class="form-group">
    <label for="temperature-slider">模型温度 (Temperature): <span id="temperature-value">0.8</span></label>
    <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px; margin-bottom: 10px;">
        数值越高，回复越随机、有创造性，但可能偏离人设。数值越低，回复越稳定、可预测。推荐值: 0.7 - 1.2
    </p>
    <input type="range" id="temperature-slider" min="0" max="2" step="0.1" value="0.8" style="width: 100%;">
</div>
<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->
<button class="form-button" id="fetch-models-btn">拉取模型</button>

<!-- ▼▼▼ 从这里开始，是全新的后台活动设置区 ▼▼▼ -->
<hr style="margin:20px 0; opacity:.3">

<!-- 1. 总开关 -->
<div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
    <label for="background-activity-switch" style="margin-bottom: 0;">
        启用后台角色活动 (总开关)
        <p style="font-size: 12px; font-weight: normal; color: #ff6b6b; margin-top: 5px;">
            警告：开启后会显著增加API调用和费用！
        </p>
    </label>
    <!-- 【重要】我们把原来的 checkbox 换成了更美观的 iOS 风格开关 -->
    <label class="toggle-switch">
        <input type="checkbox" id="background-activity-switch">
        <span class="slider"></span>
    </label>
</div>

<!-- 2. 后台活动详细设置 (默认隐藏，由总开关控制) -->
<div id="background-activity-details" style="display: none;">
    <div class="form-group" style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
        <label for="background-interval-input" style="margin-bottom: 0;">
            后台活动检测间隔 (秒)
            <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                建议值 60-300。值越大，费用越低，但角色反应越慢。
            </p>
        </label>
        <input type="number" id="background-interval-input" min="30" value="60" style="width: 80px; text-align: center;">
    </div>

    <!-- 3. 角色选择与频率设置 -->
    <div class="form-group">
        <label>设置角色活动频率</label>
        <div id="background-activity-char-list" style="max-height: 150px; overflow-y: auto; background: #f9f9f9; padding: 10px; border-radius: 8px; border: 1px solid var(--border-color);">
            <!-- 角色列表将由JS动态生成在这里 -->
        </div>
        <div style="display: flex; gap: 10px; margin-top: 10px;">
            <button id="bg-select-all-chars" class="form-button-secondary" style="flex:1; margin:0;">全选</button>
            <button id="bg-deselect-all-chars" class="form-button-secondary" style="flex:1; margin:0;">全不选</button>
        </div>
    </div>

    <div class="form-group">
    <label>为选中角色设置频率</label>
    <div style="display: flex; gap: 10px;">
        <button class="form-button-secondary bg-freq-btn" data-freq="low" style="flex:1; margin:0; border-color: #28a745;">低</button>
        <button class="form-button-secondary bg-freq-btn" data-freq="medium" style="flex:1; margin:0; border-color: #fd7e14;">中</button>
        <button class="form-button-secondary bg-freq-btn" data-freq="high" style="flex:1; margin:0; border-color: #dc3545;">高</button>
        <!-- ▼▼▼ 就是新增了这个“关闭”按钮 ▼▼▼ -->
        <button class="form-button-secondary bg-freq-btn" data-freq="none" style="flex:1; margin:0; border-color: #aaa;">关闭</button>
    </div>
    <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 8px;">
        频率越高，角色主动行为的概率越大，费用也越高。
    </p>
</div>
</div>
<!-- ▲▲▲ 全新的后台活动设置区结束 ▲▲▲ -->


<!-- ▼▼▼ 在这里新增 ▼▼▼ -->
<div class="form-group" style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
    <label for="block-cooldown-input" style="margin-bottom: 0;">
        AI被拉黑后冷静期 (小时)
        <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
            被拉黑超过这个时间后，AI才有几率重新申请好友。
        </p>
    </label>
    <input type="number" id="block-cooldown-input" min="0.1" step="0.1" value="1" style="width: 80px; text-align: center;">
</div>
<!-- ▲▲▲ 新增结束 ▲▲▲ -->
<!-- ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼ -->
<hr style="margin:20px 0; opacity:.3">
<p style="font-size: 14px; color: #666; background-color: #f0f0f0; padding: 10px; border-radius: 8px;">以下是 Minimax 语音（TTS）的设置，用于AI发送语音消息。</p>
<div class="form-group">
    <label for="minimax-group-id">Minimax Group ID</label>
    <input type="text" id="minimax-group-id" placeholder="输入你的 Minimax Group ID">
</div>
<div class="form-group">
    <label for="minimax-api-key">Minimax API Key</label>
    <input type="password" id="minimax-api-key" placeholder="输入你的 Minimax API Key">
</div>
<!-- ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼ -->
<div class="form-group">
    <label for="minimax-speech-model-select">Minimax 语音模型 (TTS Model)</label>
    <select id="minimax-speech-model-select">
        <!-- 选项将由JS填充 -->
    </select>
</div>
<button class="form-button" id="fetch-minimax-speech-models-btn">拉取语音模型</button>
<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->
<hr style="margin:20px 0; opacity:.3">
<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->
<button class="form-button" id="save-api-settings-btn">保存设置</button>
			<hr style="margin:20px 0; opacity:.3">
<button class="form-button form-button-secondary" id="clear-orphaned-data-btn" style="margin-top: 10px; border-color: #ff9966; color: #ff9966;">🧹 清理失效数据</button>
			<button class="form-button" id="export-data-btn">导出数据</button>

<!-- ① 普通按钮，和“导出”一个 class -->
<button class="form-button" id="import-btn">导入备份文件</button>

<!-- ② 真正的文件选择器，完全隐藏 -->
<input id="import-data-input" type="file" accept="application/json" hidden>
</div></div>
<!-- ▼▼▼ 用下面这段代码，完整替换掉你原来的 chat-list-screen ▼▼▼ -->
<div id="chat-list-screen" class="screen">
    
    <!-- 主头部 (只在消息列表显示) -->
    <div class="header" id="main-chat-list-header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
<span id="chat-list-title">消息</span>
        <div class="header-actions">
            <span class="action-btn" id="add-group-chat-btn" title="创建群聊"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M17.5 17.5C19.1569 17.5 20.5 16.1569 20.5 14.5C20.5 12.8431 19.1569 11.5 17.5 11.5C15.8431 11.5 14.5 12.8431 14.5 14.5C14.5 16.1569 15.8431 17.5 17.5 17.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M21 21L19 19" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M8.5 11.5C10.1569 11.5 11.5 10.1569 11.5 8.5C11.5 6.84315 10.1569 5.5 8.5 5.5C6.84315 5.5 5.5 6.84315 5.5 8.5C5.5 10.1569 6.84315 11.5 8.5 11.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M12.5 14.5H4.5C3.39543 14.5 2.5 15.3954 2.5 16.5V18.5H12.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></span>
            <!-- ▼▼▼ 这是我们新加的导入按钮 ▼▼▼ -->
<span class="action-btn" id="import-character-card-btn" title="导入角色卡">
    <svg width="22" height="22" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
        <polyline points="17 8 12 3 7 8"></polyline>
        <line x1="12" y1="3" x2="12" y2="15"></line>
    </svg>
</span>
<!-- ▲▲▲ 导入按钮结束 ▲▲▲ -->
            <span class="action-btn" id="add-chat-btn">+</span>
        </div>
    </div>

    <!-- 消息列表视图 -->
    <div id="messages-view" class="chat-list-view active">
        <div id="chat-list">
            <!-- JS会在这里生成聊天列表 -->
        </div>
    </div>

    <!-- 动态界面视图 -->
    <div id="qzone-screen" class="chat-list-view">
        <div class="qzone-header">
            <span class="back-btn" id="qzone-back-btn">‹</span> <!-- 这个按钮现在只负责从动态返回 -->
            <span>好友动态</span>
        </div>
        <div class="qzone-content">
            <div class="qzone-profile-header">
                <div id="qzone-banner-container" class="qzone-banner-container">
                    <img id="qzone-banner-img" src="https://files.catbox.moe/r5heyt.gif" alt="背景">
                    <input type="file" id="qzone-banner-input" accept="image/*" hidden>
                </div>
                <div class="qzone-user-info">
                    <div id="qzone-avatar-container" class="qzone-avatar-container">
                        <img id="qzone-avatar-img" src="https://files.catbox.moe/q6z5fc.jpeg" alt="头像">
                        <input type="file" id="qzone-avatar-input" accept="image/*" hidden>
                    </div>
                    <span id="qzone-nickname">{{user}}</span>
                </div>
            </div>
            <div class="qzone-actions-bar">
                <div class="action-item" id="create-shuoshuo-btn"><span>说说</span></div>
                <div class="action-item" id="create-post-btn"><span>动态</span></div>
                <div class="action-item" id="open-album-btn"><span>相册</span></div>
            </div>
            <div id="qzone-posts-list"></div>
        </div>
    </div>

    <!-- 收藏界面视图 -->
    <div id="favorites-view" class="chat-list-view">
    <div class="header"> 
        <span class="back-btn" id="favorites-back-btn">‹</span>
        <span>我的收藏</span>
        <!-- 新增的编辑按钮 -->
        <span class="action-btn" id="favorites-edit-btn">编辑</span>
    </div>

        <!-- 【新增】搜索栏容器 -->
        <div class="search-bar-container">
            <input type="search" id="favorites-search-input" placeholder="搜索收藏的标题、内容或作者...">
            <button id="favorites-search-clear-btn" class="search-clear-btn" style="display: none;">×</button>
        </div>

        <div id="favorites-list" class="list-container">
            <!-- 收藏内容将由JS动态生成在这里 -->
        </div>

<!-- 新增：收藏页底部操作栏 -->
<div id="favorites-action-bar" style="display: none;">
    <button id="favorites-delete-selected-btn" class="action-bar-btn">删除 (0)</button>
</div>

    </div>

<!-- ▼▼▼ 【全新】回忆录界面视图 ▼▼▼ -->
<div id="memories-view" class="chat-list-view">
    <div class="header"> 
        <span class="back-btn" id="memories-back-btn">‹</span>
        <span>我们的回忆</span>
            <span class="action-btn" id="add-countdown-btn">+</span>
        </div>
    <div id="memories-list" class="list-container" style="padding: 15px; display: flex; flex-direction: column; gap: 15px;">
        <!-- 回忆卡片将由JS动态生成在这里 -->
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->

   
    <!-- 底部导航栏 -->
<div id="chat-list-bottom-nav">
    <div class="nav-item active" data-view="messages-view">
        <span>消息</span>
    </div>
    <div class="nav-item" data-view="qzone-screen">
        <span>动态</span>
    </div>
    <!-- ▼▼▼ 在“动态”和“收藏”之间，加入这个新页签 ▼▼▼ -->
    <div class="nav-item" data-view="memories-view">
        <span>回忆</span>
    </div>
    <!-- ▲▲▲ 添加结束 ▲▲▲ -->
    <div class="nav-item" data-view="favorites-view">
        <span>收藏</span>
    </div>
</div>
</div>
<!-- ▲▲▲ 替换区域结束 ▲▲▲ -->

<!-- ▼▼▼ 请将这段新的 HTML 粘贴到 id="chat-list-screen" 的 div 之后 ▼▼▼ -->
<div id="album-screen" class="screen">
    <!-- 1. 页面头部，包含返回按钮和标题 -->
    <div class="header">
        <span class="back-btn" id="album-back-btn">‹</span>
        <span>我的相册</span>
        <span class="action-btn" id="create-album-btn-page">+</span>
    </div>
    
    <!-- 2. 页面内容容器 -->
    <div class="list-container">
        <div id="album-grid-page">
            <!-- 相册列表将由 JS 动态生成在这里 -->
        </div>
    </div>
</div>
<!-- ▲▲▲ 新的 HTML 粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 请将这段新的 HTML 粘贴到 id="album-screen" 的 div 之后 ▼▼▼ -->
<div id="album-photos-screen" class="screen">
    <!-- 1. 页面头部 -->
    <div class="header">
        <span class="back-btn" id="album-photos-back-btn">‹</span>
        <span id="album-photos-title">相册名称</span>
        <span class="action-btn" id="album-upload-photo-btn">上传</span>
    </div>
    
    <!-- 2. 页面内容容器 -->
    <div class="list-container">
        <div id="photos-grid-page">
            <!-- 照片列表将由 JS 动态生成在这里 -->
        </div>

<!-- ▼▼▼ 请将这段新的 HTML 粘贴到所有模态框的末尾 ▼▼▼ -->
<div id="photo-viewer-modal" class="modal">
    <!-- 1. 关闭按钮 -->
    <button id="photo-viewer-close-btn">×</button>
    
    <!-- 2. 上一张照片按钮 -->
    <button id="photo-viewer-prev-btn" class="nav-arrow">‹</button>
    
    <!-- 3. 图片容器 -->
    <div class="photo-viewer-content">
        <img id="photo-viewer-image" src="" alt="全屏照片预览">
    </div>
    
    <!-- 4. 下一张照片按钮 -->
    <button id="photo-viewer-next-btn" class="nav-arrow">›</button>
</div>
<!-- ▲▲▲ 新的 HTML 粘贴结束 ▲▲▲ -->

    </div>
</div>
<!-- ▲▲▲ 新的 HTML 粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 粘贴到 #album-photos-screen 的 div 之后 ▼▼▼ -->
<input type="file" id="album-photo-input" accept="image/*" multiple hidden>
            
<!-- ▼▼▼ 请用这【一整块】全新的代码，完整替换掉您文件中旧的 #chat-interface-screen 及其所有内容 ▼▼▼ -->
<div id="chat-interface-screen" class="screen">

<div class="header">
    <!-- 默认控件：包含标题、状态栏和常规按钮 -->
    <div class="default-controls">
        <span class="back-btn" id="back-to-list-btn">‹</span>
        
        <!-- 标题和状态的容器 -->
        <div id="chat-header-title-wrapper">
            <div id="chat-header-main-line">
                <span id="chat-header-title">聊天对象</span>
                    <!-- ▼▼▼ 【全新】群公告按钮 ▼▼▼ -->
    <span id="group-announcement-btn" title="群公告">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
            <line x1="7" y1="15" x2="17" y2="15"></line>
        </svg>
    </span>
    <!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
            </div>
            <div id="chat-header-status">
                <span class="status-dot"></span>
                <span class="status-text">在线</span>
            </div>
        </div>

        <div class="header-actions">
            <!-- 【正确位置】心声按钮在这里 -->
            <span class="action-btn" id="char-heart-btn" title="心声" style="display: none; cursor: pointer;">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#ff4d6d" stroke="#ffc3d0" stroke-width="1.5">
                    <path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/>
                </svg>
            </span>
            <span class="action-btn" id="listen-together-btn" title="一起听"><img src="https://i.postimg.cc/dV8sdNcx/210-20250618115221.png" alt="一起听"></span>
            <span class="action-btn" id="chat-settings-btn" title="聊天设置"><img src="https://i.postimg.cc/bvPq64cv/CCA834-BA-5-A90-408-D-94-FA-7-EE156-B6-A765.png" alt="设置"></span>
        </div>
    </div>

    <!-- 多选模式控件 -->
    <div class="selection-controls">
        <span id="selection-cancel-btn">取消</span>
        <span id="selection-count"></span>
        <div class="header-actions">
           <span id="selection-favorite-btn" class="action-btn">收藏</span>
           <span id="selection-share-btn" class="action-btn">分享</span> 
           <span id="selection-delete-btn" class="action-btn" style="color: #ff3b30;">删除</span>
        </div>
    </div>
</div>
<!-- ▼▼▼ 在 #chat-interface-screen 内，header 的 div 之后添加 ▼▼▼ -->

<div id="chat-pet-container" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0; pointer-events: none; z-index: 10;">
    <div id="chat-pet" style="display: none; position: absolute; cursor: grab; user-select: none; pointer-events: all; font-size: 80px; line-height: 1; text-align: center;">
        <!-- 宠物会显示在这里 -->
    </div>
</div>

<!-- ▲▲▲ 添加结束 ▲▲▲ -->

    <!-- 聊天消息区域 (保持不变) -->
    <div id="chat-messages"><div id="typing-indicator">对方正在输入...</div></div>

    <!-- 输入区域 (这是修改后的最终版本) -->
    <div id="chat-input-area">
        <div id="reply-preview-bar">
            <div class="reply-preview-content">
                <div class="sender">回复 xxx:</div>
                <div class="text">被引用的消息内容...</div>
            </div>
            <span id="cancel-reply-btn">×</span>
        </div>
        <div id="chat-input-actions-top">
            <button id="open-sticker-panel-btn" class="chat-action-icon-btn action-button" title="表情面板"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                <line x1="12" y1="5" x2="12" y2="19"></line>
                <line x1="5" y1="12" x2="19" y2="12"></line>
            </svg></button>
            
            <!-- “重新生成回复”按钮的新家 -->
            <button id="reroll-btn" class="action-button" title="重新生成回复"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="23 4 23 10 17 10"></polyline>
                <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
            </svg></button>
            
            <button id="send-photo-btn" class="chat-action-icon-btn action-button" title="发送照片"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/><circle cx="12" cy="13" r="4"/></svg></button>
            <button id="upload-image-btn" class="chat-action-icon-btn action-button" title="上传图片"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" ><path d="M21 3.5H3C2.44772 3.5 2 3.94772 2 4.5V19.5C2 20.0523 2.44772 20.5 3 20.5H21C21.5523 20.5 22 20.0523 22 19.5V4.5C22 3.94772 21.5523 3.5 21 3.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M16.5 13.5C17.6046 13.5 18.5 12.6046 18.5 11.5C18.5 10.3954 17.6046 9.5 16.5 9.5C15.3954 9.5 14.5 10.3954 14.5 11.5C14.5 12.6046 15.3954 13.5 16.5 13.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M22 14.5L18 10.5L10.3333 18.5M12.5 16L9 12.5L2 19.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></button>
            <button id="transfer-btn" class="chat-action-icon-btn action-button" title="转账">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M7 4L12 12L17 4M12 12V20M8 10H16M8 13H16"></path>
            </svg>
            </button>
            <button id="voice-message-btn" class="chat-action-icon-btn action-button" title="发送语音"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><path d="M12 19v4"/><path d="M8 23h8"/></svg></button>
            <button id="send-waimai-request-btn" class="chat-action-icon-btn action-button" title="发起外卖请求"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z"/><line x1="3" y1="6" x2="21" y2="6"/><path d="M16 10a4 4 0 0 1-8 0"/></svg></button>
            <button id="video-call-btn" class="chat-action-icon-btn action-button" title="视频通话"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="23 7 16 12 23 17 23 7"></polygon><rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect></svg></button>
            <button id="group-video-call-btn" class="chat-action-icon-btn action-button" title="群视频通话"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg></button>
            <button id="send-poll-btn" class="chat-action-icon-btn action-button" title="发起投票"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 6h10"/><path d="M6 6h.01"/><path d="M8 12h10"/><path d="M6 12h.01"/><path d="M8 18h10"/><path d="M6 18h.01"/></svg></button>
            <button id="share-link-btn" class="chat-action-icon-btn action-button" title="分享链接"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path></svg></button>
            <button id="send-location-btn" class="chat-action-icon-btn action-button" title="发送定位">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
                    <circle cx="12" cy="10" r="3"></circle>
                </svg>
            </button>
<!-- ▼▼▼ 用下面这整块代码，替换你原来的那个 <button id="open-tarot-btn">...</button> ▼▼▼ -->
<button id="open-tarot-btn" class="chat-action-icon-btn action-button" title="塔罗占卜">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <!-- 背景左侧卡牌 -->
        <path d="M7 6.5L4 7.5V17.5L7 16.5V6.5Z" stroke="currentColor" stroke-width="2.6" stroke-linejoin="round"/>
        <!-- 背景右侧卡牌 -->
        <path d="M17 6.5L20 7.5V17.5L17 16.5V6.5Z" stroke="currentColor" stroke-width="2.6" stroke-linejoin="round"/>
        <!-- 前方中心卡牌 -->
        <rect x="7" y="5" width="10" height="15" rx="1.5" stroke="currentColor" stroke-width="2.6"/>
        <!-- 中心卡牌的星星 -->
        <path d="M12 9.5L13.12 11.79L15.61 12.17L13.8 13.92L14.24 16.4L12 15.2L9.76 16.4L10.2 13.92L8.39 12.17L10.88 11.79L12 9.5Z" fill="currentColor"/>
    </svg>
</button>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->

<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 【歪头杀·满分可爱猫】请用这块代码替换旧的宠物按钮 <button> ▼▼▼ -->
<button id="pet-action-btn" class="chat-action-icon-btn action-button" title="我的宠物">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <!-- 主体轮廓: 耳朵不对称，营造歪头效果 -->
        <path d="M3.5 14.5C3.5 20.5 20.5 20.5 20.5 14.5C20.5 9 17.5 5.5 12.5 8.7C6.5 4.5 3.5 9 3.5 14.5Z" stroke="currentColor" stroke-width="2.6" stroke-linecap="round" stroke-linejoin="round"/>
        <!-- 眼睛 -->
        <circle cx="8.5" cy="15" r="1.5" fill="currentColor"/>
        <circle cx="15.5" cy="15" r="1.5" fill="currentColor"/>
        <!-- 左边两根小胡须 -->
        <path d="M4.5 14.3L2.5 13.3" stroke="currentColor" stroke-width="2.6" stroke-linecap="round"/>
        <path d="M4.5 15.7L2.5 16.7" stroke="currentColor" stroke-width="2.6" stroke-linecap="round"/>
        <!-- 右边两根小胡须 -->
        <path d="M19.5 14.3L21.5 13.3" stroke="currentColor" stroke-width="2.6" stroke-linecap="round"/>
        <path d="M19.5 15.7L21.5 16.7" stroke="currentColor" stroke-width="2.6" stroke-linecap="round"/>
    </svg>
</button>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->





        </div>
        <div id="chat-input-main-row">
            <textarea id="chat-input" rows="1" placeholder="输入消息..."></textarea>
            <div id="input-actions-wrapper">
                <button id="wait-reply-btn" title="等待回复"><img src="https://i.postimg.cc/q72zq80N/ECE92-BBC-BE57-48-E9-BB2-C-345-B6019-C4-B2.png" alt="等待回复"></button>
                <button id="send-btn" class="action-button">发送</button>
            </div>
        </div>
    </div>
<!-- ▼▼▼ 在这里新增 ▼▼▼ -->
<div id="chat-lock-overlay">
    <div id="chat-lock-content"></div>
</div>
<!-- ▲▲▲ 新增结束 ▲▲▲ -->

<!-- ▼▼▼ 用这块新代码替换旧的 #sticker-panel ▼▼▼ -->
<div id="sticker-panel">
    <div id="sticker-panel-header">
        <span class="panel-btn" id="close-sticker-panel-btn">取消</span>
        <span class="title">表情包</span>
        <!-- 【核心修改1】在这里新增“编辑”和“完成”按钮 -->
        <div style="display: flex; gap: 10px;">
            <span class="panel-btn" id="edit-user-stickers-btn">编辑</span>
            <span class="panel-btn" id="done-user-stickers-btn" style="display: none;">完成</span>
            <span class="panel-btn" id="add-sticker-btn">添加</span>
            <span class="panel-btn" id="upload-sticker-btn">上传</span>
        </div>
    </div>
    <div id="sticker-grid"></div>
    <!-- 【核心修改2】在底部新增一个用于批量删除的操作栏，默认隐藏 -->
    <div id="sticker-panel-footer" style="display: none;">
        <button id="delete-selected-user-stickers-btn">删除已选 (0)</button>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
<input type="file" id="sticker-upload-input" accept="image/*" style="display: none;" multiple>
    <input type="file" id="image-upload-input" accept="image/*" style="display: none;">
    
    <!-- 音乐播放器 (保持不变) -->
<div id="music-player-overlay">
<div class="music-player-window">
    <!-- 1. 顶部头像区域 -->
    <div id="music-avatars-container">
        <img id="music-char-avatar" src="" alt="角色头像">
        <svg id="heartbeat-line" viewBox="0 0 80 30">
            <path class="heartbeat-path" d="M 5 15 Q 20 0 30 15 T 55 15 L 75 15"></path>
            <path class="heartbeat-heart" d="M 0 -2 a 2 2 0 0 1 4 0 v 2 a 2 2 0 0 1 -4 0 z"></path>
        </svg>
        <img id="music-user-avatar" src="" alt="用户头像">
    </div>
    
    <!-- ▼▼▼ 【核心修改】我们把这行文字移到了这里 ▼▼▼ -->
    <div id="music-time-counter">已经一起听了0.0小时</div>

    <!-- 2. 顶部操作按钮 -->
    <div class="music-player-top-actions">
        <div class="top-left-cluster">
            <button id="music-return-btn">‹</button>
            <button id="music-exit-btn">×</button>
        </div>
        <span id="music-playlist-btn">☰</span>
    </div>

    <!-- 3. 封面和歌词的切换容器 -->
    <div id="music-display-area">
        <img id="music-album-cover" src="https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png" alt="歌曲封面">
        <div id="music-lyrics-container">
            <div id="music-lyrics-list">
                <div class="lyric-line">♪ 暂无歌词 ♪</div>
            </div>
        </div>
    </div>

    <!-- 4. 歌曲信息 -->
    <div id="music-player-song-title">请添加歌曲</div>
    <div id="music-player-artist">...</div>
    
    <!-- 5. 播放控制区 (保持不变) -->
    <div class="music-player-controls-wrapper">
        <div class="music-progress-bar-container">
            <div id="music-current-time" class="time-display">0:00</div>
            <div class="progress-bar">
                <div id="music-progress-fill" class="progress-bar-fill"></div>
            </div>
            <div id="music-total-time" class="time-display">0:00</div>
        </div>
        <div class="music-controls">
            <button id="music-prev-btn">◀</button>
            <button id="music-play-pause-btn" class="play-pause-btn">▶</button>
            <button id="music-next-btn">▶</button>
            <button id="music-mode-btn">顺序</button>
            <button id="toggle-lyrics-bar-btn" title="桌面歌词">悬浮</button>
        </div>
    </div>
</div>

    </div>
</div>
    
<!-- ▼▼▼ 请用这【一整块】全新的代码，替换掉你旧的 id="music-playlist-panel" 及其所有内部内容 ▼▼▼ -->
<div id="music-playlist-panel">
<!-- ▼▼▼ 用这整块代码替换 ▼▼▼ -->
<div class="playlist-header">
    <span class="panel-btn" id="close-playlist-btn">返回</span>
    <span>播放列表</span>
    <div>
        <!-- ▼▼▼ 我们把垃圾桶图标移到了'本地'的左边 ▼▼▼ -->
        <span class="panel-btn" id="delete-expired-songs-btn" title="清理失效的搜索歌曲">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M3 6H5H21" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M8 6V4C8 3.46957 8.21071 2.96086 8.58579 2.58579C8.96086 2.21071 9.46957 2 10 2H14C14.5304 2 15.0391 2.21071 15.4142 2.58579C15.7893 2.96086 16 3.46957 16 4V6M19 6V20C19 20.5304 18.7893 21.0391 18.4142 21.4142C18.0391 21.7893 17.5304 22 17 22H7C6.46957 22 5.96086 21.7893 5.58579 21.4142C5.21071 21.0391 5 20.5304 5 20V6H19Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
        </span>
        <span class="panel-btn" id="add-song-local-btn">本地</span>
        <span class="panel-btn" id="add-song-url-btn">URL</span>
        <span class="panel-btn" id="add-song-search-btn">搜索</span>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->


        <div class="playlist-body" id="playlist-body"></div>
    </div>
    <input type="file" id="local-song-upload-input" accept="audio/*" multiple style="display: none;">
<input type="file" id="lrc-upload-input" accept=".lrc" style="display: none;">
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->

<!-- ▼▼▼ 用这整块代码替换你原来的 id="wallpaper-screen" ▼▼▼ -->
<div id="wallpaper-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <!-- 【核心修改1】标题改为“外观设置”，更通用 -->
        <span>外观设置</span>
        <span style="width: 30px;"></span>
    </div>
    <div class="form-container">
        <!-- 锁屏壁纸设置 (全新) -->
        <div style="width:100%; text-align: left; margin-bottom: 5px;">
            <label style="font-weight: 500; color: var(--text-secondary);">锁屏设置</label>
        </div>
        <div id="lockscreen-wallpaper-preview" class="wallpaper-preview">点击下方上传</div>
        <button class="form-button" onclick="document.getElementById('lockscreen-wallpaper-upload-input').click();">上传锁屏壁纸</button>
        <input type="file" id="lockscreen-wallpaper-upload-input" accept="image/*" hidden>
        
        <div class="form-group" style="width: 100%; margin-top: 15px;">
            <label for="password-set-input">锁屏密码 (留空则无密码)</label>
            <input type="text" id="password-set-input" placeholder="设置你的解锁密码">
        </div>
        
        <hr style="width: 80%; opacity: 0.3; margin: 20px 0;">

        <!-- 主屏幕壁纸设置 (原有) -->
        <div style="width:100%; text-align: left; margin-bottom: 5px;">
            <label style="font-weight: 500; color: var(--text-secondary);">主屏幕设置</label>
        </div>
        <div id="wallpaper-preview">点击下方上传</div>
<!-- ▼▼▼ 请将这段新代码粘贴到 wallpaper-preview 的 div 之后 ▼▼▼ -->
<div class="form-group">
    <label for="enable-lock-screen-toggle" class="toggle-switch-label">
        <span class="toggle-switch-text">启用锁屏界面</span>
        <input type="checkbox" id="enable-lock-screen-toggle">
        <span class="toggle-switch-slider"></span>
    </label>
</div>
<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 在这里粘贴新的“显示状态栏”开关代码 ▼▼▼ -->
<div class="form-group">
    <label for="show-status-bar-toggle" class="toggle-switch-label">
        <span class="toggle-switch-text">显示状态栏</span>
        <input type="checkbox" id="show-status-bar-toggle">
        <span class="toggle-switch-slider"></span>
    </label>
</div>
<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->


        <button class="form-button" onclick="document.getElementById('wallpaper-upload-input').click();">上传壁纸</button>
        <input type="file" id="wallpaper-upload-input" accept="image/*">

<!-- ▼▼▼ 将【下面整块代码】，完整替换为下面这段【全新的代码】 ▼▼▼ -->
<div class="form-group" style="display: none;">
    <label for="theme-toggle-switch" style="margin-bottom: 0;">夜间模式</label>
    <label class="toggle-switch">
        <input type="checkbox" id="theme-toggle-switch">
        <span class="slider"></span>
    </label>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->

    <!-- === ▼▼▼ 以下是新增的美化功能UI ▼▼▼ === -->
    <div style="width:100%; text-align: left; margin-bottom: 15px;">
        <label style="font-weight: 500; color: var(--text-secondary);">手机美化 (CSS)</label>
    </div>

    <!-- 主题选择和管理 -->
    <div class="form-group">
        <label for="theme-selector">选择已存方案</label>
        <div style="display: flex; gap: 10px;">
            <select id="theme-selector" style="flex-grow: 1;"></select>
            <button id="rename-theme-btn" class="form-button-secondary" style="margin:0; padding: 0 10px;">重命名</button>
            <button id="delete-theme-btn" class="form-button-secondary" style="margin:0; padding: 0 10px; background-color: #ffdddd; color: #ff3b30;">删除</button>
        </div>
    </div>

    <!-- CSS 代码编辑区 -->
    <div class="form-group">
        <label for="theme-css-editor">美化代码编辑区</label>
        <textarea id="theme-css-editor" rows="10" style="font-family: monospace; font-size: 12px; resize: vertical;" placeholder="在这里粘贴或编辑美化代码..."></textarea>
    </div>
    
    <!-- 操作按钮 -->
    <button id="apply-theme-btn" class="form-button">应用当前代码</button>
    <div style="display: flex; gap: 10px; margin-top: 10px;">
        <button id="save-theme-btn" class="form-button-secondary" style="flex:1;">保存</button>
        <button id="save-as-new-theme-btn" class="form-button-secondary" style="flex:1;">另存</button>
    </div>
    <div style="display: flex; gap: 10px; margin-top: 10px;">
        <button id="export-theme-btn" class="form-button-secondary" style="flex:1;">导出方案</button>
        <button id="import-theme-btn" class="form-button-secondary" style="flex:1;">导入方案</button>
        <input type="file" id="import-theme-input" accept=".json" hidden>
    </div>
    <!-- === ▲▲▲ 新增UI结束 ▲▲▲ === -->
<!-- ▼▼▼ 【V3最终美化版】主屏幕美化预设功能UI ▼▼▼ -->
<div class="preset-manager-container">
    <div style="width:100%; text-align: left; margin-bottom: 15px;">
        <label style="font-weight: 500; color: var(--text-secondary);">主屏幕预设</label>
    </div>
    <div class="form-group">
        <select id="home-preset-selector" class="form-group select"></select>
        <div class="preset-manager-controls">
            <!-- 独占一行的应用按钮 -->
            <button id="apply-home-preset-btn" class="preset-btn-capsule preset-btn-apply" disabled>应用</button>
            
            <!-- 2x2 网格按钮 -->
            <button id="save-home-preset-btn" class="preset-btn-capsule preset-btn-save">保存</button>
            <!-- ▼▼▼ 就是在这里新增了“更新”按钮 ▼▼▼ -->
            <button id="update-home-preset-btn" class="preset-btn-capsule preset-btn-secondary" disabled>更新</button>
            <button id="rename-home-preset-btn" class="preset-btn-capsule preset-btn-secondary" disabled>重命名</button>
            <button id="import-home-preset-btn" class="preset-btn-capsule preset-btn-secondary">导入</button>
            <button id="export-home-preset-btn" class="preset-btn-capsule preset-btn-secondary" disabled>导出</button>
            <button id="delete-home-preset-btn" class="preset-btn-capsule preset-btn-delete" disabled>删除</button>
            
            <input type="file" id="import-home-preset-input" accept=".json" hidden>
        </div>
    </div>
</div>
<!-- ▲▲▲ UI替换结束 ▲▲▲ -->
<!-- ▼▼▼ 步骤2：用这段新代码替换旧的颜色选择器HTML ▼▼▼ -->
<hr style="width: 80%; opacity: 0.3; margin: 30px 0;">
<div style="width:100%; text-align: left; margin-bottom: 15px;">
    <label style="font-weight: 500; color: var(--text-secondary);">主屏幕图标及小组件字体颜色</label>
</div>
<div class="form-group">
    <label for="home-icon-widget-text-color-picker">自定义字体颜色</label>
    <input type="color" id="home-icon-widget-text-color-picker" value="#FFFFFF" style="width: 100%; height: 40px; padding: 0; border-radius: 8px;">
</div>
<!-- ▲▲▲ 步骤2 HTML代码替换结束 ▲▲▲ -->
 <!-- ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼ -->
<div class="form-group">
    <label for="remove-home-font-shadow-toggle" class="toggle-switch-label">
        <span class="toggle-switch-text">去除主屏幕字体阴影</span>
        <input type="checkbox" id="remove-home-font-shadow-toggle">
        <span class="toggle-switch-slider"></span>
    </label>
</div>
<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->

        <!-- 【核心修改2】新增图标设置区域 -->
        <hr style="width: 80%; opacity: 0.3; margin: 30px 0;">
        <div style="width:100%; text-align: left; margin-bottom: 15px;">
            <label style="font-weight: 500; color: var(--text-secondary);">App 图标设置</label>
        </div>
        <div id="icon-settings-grid">
            <!-- 图标设置项将由JS动态生成在这里 -->
        </div>
<!-- ▼▼▼ 把下面这整块全新的代码，粘贴到“App图标设置”的 div 之后 ▼▼▼ -->
<hr style="width: 80%; opacity: 0.3; margin: 30px 0;">
<div style="width:100%; text-align: left; margin-bottom: 15px;">
    <label style="font-weight: 500; color: var(--text-secondary);">主屏幕 App 名称</label>
</div>
<div id="icon-rename-grid" style="width: 100%; display: flex; flex-direction: column; gap: 15px;">
    <!-- App 名称输入框将由JS动态生成在这里 -->
</div>
<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 将这段新代码，粘贴到“保存所有外观设置”按钮的【上方】 ▼▼▼ -->
<hr style="width: 80%; opacity: 0.3; margin: 30px 0;">
<div style="width:100%; text-align: left; margin-bottom: 15px;">
    <label style="font-weight: 500; color: var(--text-secondary);">铃声设置</label>
</div>
<div class="form-group" style="width: 100%;">
    <label for="ringtone-url-input">来电铃声 URL (.mp3, .wav, etc.)</label>
    <input type="text" id="ringtone-url-input" placeholder="输入音频文件的网络链接...">
</div>
<!-- ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼ -->
<div class="form-group" style="width: 100%; margin-top: 15px;">
    <label for="notification-sound-url-input">消息提示音 URL (.mp3, .wav, etc.)</label>
    <input type="text" id="notification-sound-url-input" placeholder="输入音频文件的网络链接...">
</div>
<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->

<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 从这里开始，把下面这一整块全新的代码，粘贴到“保存所有外观设置”按钮的【上方】 ▼▼▼ -->
<hr style="width: 80%; opacity: 0.3; margin: 30px 0;">
<div style="width:100%; text-align: left; margin-bottom: 15px;">
    <label style="font-weight: 500; color: var(--text-secondary);">全局聊天背景</label>
</div>
<div id="global-bg-preview" class="wallpaper-preview">点击下方上传</div>
<button class="form-button" onclick="document.getElementById('global-bg-upload-input').click();">上传全局背景</button>
<input type="file" id="global-bg-upload-input" accept="image/*" hidden>
<button class="form-button form-button-secondary" id="remove-global-bg-btn" style="margin-top: 10px;">移除全局背景</button>
<button class="form-button form-button-secondary" id="clear-all-single-bgs-btn" style="margin-top: 10px; border-color: #ff3b30; color: #ff3b30;">一键清空所有单人聊天背景</button>
<!-- ▲▲▲ 粘贴到这里结束 ▲▲▲ -->
        
        <!-- 【核心修改3】按钮文字也改一下 -->
        <button class="form-button" id="save-wallpaper-btn" style="margin-top: 30px;">保存所有外观设置</button>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】分享链接功能 HTML ▼▼▼ -->
<div id="browser-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="browser-back-btn">‹</span>
        <span id="browser-title"></span>
        <span style="width: 30px;"></span>
    </div>
    <div id="browser-content" class="list-container">
        <!-- 文章内容将由JS动态生成在这里 -->
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<div id="font-settings-screen" class="screen">
    <div class="header">
    <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
    <span>字体预设</span>
    <span style="width: 30px;"></span> <!-- 保留这个占位符，让标题能完美居中 -->
</div>
    <div class="form-container" style="gap: 20px;">
        <!-- 字体预设卡槽的容器 -->
        <div id="font-preset-container">
            <!-- 5个卡槽将由JavaScript动态生成在这里 -->
        </div>

        <!-- 全局字体预览区 -->
        <div class="form-group" style="width:100%;">
            <label>当前全局字体预览</label>
            <div id="font-preview">
                <p style="font-size: 20px; margin: 0 0 10px 0;">你好世界 Hello World</p>
                <p style="margin: 0;">这是全局字体预览效果，12345。</p>
            </div>
        </div>

        <button class="form-button form-button-secondary" id="reset-font-btn">恢复默认字体</button>
    </div>
</div>

<!-- 这个是隐藏的文件选择器，用来处理本地上传 -->
<input type="file" id="font-preset-local-upload" accept=".ttf,.otf,.woff,.woff2" style="display: none;">


<!-- ▼▼▼ 【全新】“查角色手机”功能的所有HTML界面 (V3终极版) ▼▼▼ -->

<!-- 1. 角色选择屏幕 (保持不变) -->
<div id="character-selection-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <span>选择要查看的手机</span>
        <span style="width: 30px;"></span>
    </div>
    <div id="character-selection-list" class="list-container"></div>
</div>

<!-- ▼▼▼ 请用这【一整块】全新的代码，完整替换掉你旧的 id="character-phone-container" 及其所有内容 ▼▼▼ -->
<div id="character-phone-container" class="screen">
    <div class="character-phone-frame">
        <div class="character-phone-notch"></div>
        <div class="character-phone-inner-screen">
            
            <!-- 1. 角色手机的主界面 -->
            <div id="character-phone-screen" class="character-phone-page active">
                <div class="header character-phone-header">
                    <span class="back-btn" data-target-screen="character-selection-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span id="character-phone-owner-name"></span>
                    <div class="header-actions">
                        <span class="action-btn" id="clear-character-data-btn" title="清空全部数据">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>
                        </span>
                        <span class="action-btn" id="generate-character-data-btn" title="刷新全部数据">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 4v6h-6M1 20v-6h6"/><path d="M3.51 9a9 9 0 0114.85-3.36L20.5 10M3.5 14a9 9 0 0114.85 3.36L20.5 14"/></svg>
                        </span>
                    </div>
                </div>
                <!-- ▼▼▼ 在这里粘贴下面这段全新的HTML代码 ▼▼▼ -->
<!-- 这是左上角的小组件 -->
<div id="char-phone-widget-1" class="char-phone-widget">
    <img id="char-phone-widget-img-1" src="">
</div>
<!-- 这是右下角的小组件 -->
<div id="char-phone-widget-2" class="char-phone-widget">
    <img id="char-phone-widget-img-2" src="">
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
                <div id="character-app-grid" class="app-grid-standard" style="padding-top: 60px;"></div>
            </div>

            <!-- 2. 角色手机 - 聊天列表 -->
            <div id="character-chat-list-screen" class="character-phone-page">
                <div class="header character-phone-header">
                    <span class="back-btn" data-target-page="character-phone-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>消息</span>
                    <div class="header-actions">
                        <!-- ★ 新增：消息页的删除按钮 ★ -->
                        <span class="action-btn" id="clear-npc-chats-btn" title="清空所有NPC聊天">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>
                        </span>
                        <span class="action-btn" id="generate-chat-message-btn" title="生成新聊天">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/></svg>
                        </span>
                    </div>
                </div>
                <div id="character-chat-list" class="list-container" style="padding: 0;"></div>
            </div>

            <!-- 3. 角色手机 - 具体聊天记录 -->
            <div id="character-chat-history-screen" class="character-phone-page">
                <div class="header character-phone-header">
                     <span class="back-btn" data-target-page="character-chat-list-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span id="character-chat-with-name"></span>
                </div>
                <div id="character-chat-history-messages" class="list-container" style="padding: 15px; display: flex; flex-direction: column; gap: 15px; background-color: #e5ddd5;"></div>
            </div>

            <!-- 4. 角色手机 - 购物车 -->
            <div id="character-shopping-cart-screen" class="character-phone-page">
                <div class="header character-phone-header">
                    <span class="back-btn" data-target-page="character-phone-screen">
                         <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>购物车</span>
                    <div class="header-actions">
                        <!-- ★ 新增：购物车页的删除按钮 ★ -->
                        <span class="action-btn" id="clear-cart-items-btn" title="清空购物车">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>
                        </span>
                        <span class="action-btn" id="generate-cart-item-btn" title="添加新商品">
                            <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
                        </span>
                    </div>
                </div>
                <div id="character-shopping-cart-list" class="list-container"></div>
            </div>

            <!-- 5. 角色手机 - 备忘录 -->
            <div id="character-memos-screen" class="character-phone-page">
                 <div class="header character-phone-header">
                    <span class="back-btn" data-target-page="character-phone-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>备忘录</span>
                    <div class="header-actions">
                        <!-- ★ 新增：备忘录页的删除按钮 ★ -->
                        <span class="action-btn" id="clear-memos-btn" title="清空备忘录">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>
                        </span>
                        <span class="action-btn" id="generate-memo-btn" title="写新备忘录">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/></svg>
                        </span>
                    </div>
                </div>
                <div id="character-memos-list" class="list-container"></div>
            </div>

            <!-- 6. 角色手机 - 浏览器 -->
            <div id="character-browser-screen" class="character-phone-page">
                 <div class="header character-phone-header">
                    <span class="back-btn" data-target-page="character-phone-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>浏览器</span>
                    <div class="header-actions">
                        <!-- ★ 新增：浏览器页的删除按钮 ★ -->
                        <span class="action-btn" id="clear-browser-history-btn" title="清空历史记录">
                             <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>
                        </span>
                        <span class="action-btn" id="generate-browser-history-btn" title="生成新历史">
                             <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path></svg>
                        </span>
                    </div>
                </div>
                <div id="character-browser-list" class="list-container"></div>
            </div>

            <!-- 7. 角色手机 - 浏览器搜索结果详情 -->
            <div id="character-browser-detail-screen" class="character-phone-page">
                 <div class="header character-phone-header">
                    <span class="back-btn" data-target-page="character-browser-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span id="character-browser-detail-title">搜索结果</span>
                </div>
                <div id="character-browser-detail-content" class="list-container" style="padding: 15px; line-height: 1.7;"></div>
            </div>

            <!-- 8. 角色手机 - 相册 -->
            <div id="character-album-screen" class="character-phone-page">
                 <div class="header character-phone-header">
                    <span class="back-btn" data-target-page="character-phone-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>相册</span>
                    <div class="header-actions">
                        <!-- ★ 新增：相册页的删除按钮 ★ -->
                        <span class="action-btn" id="clear-album-photos-btn" title="清空相册">
                             <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>
                        </span>
                        <span class="action-btn" id="generate-album-photo-btn" title="生成新照片">
                             <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>
                        </span>
                    </div>
                </div>
                <div id="character-album-grid" class="list-container"></div>
            </div>

            <!-- 9. 角色手机 - 银行 -->
            <div id="character-bank-screen" class="character-phone-page">
                 <div class="header character-phone-header">
                    <span class="back-btn" data-target-page="character-phone-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>钱包</span>
                    <div class="header-actions">
                        <!-- ★ 新增：钱包页的删除按钮 ★ -->
                        <span class="action-btn" id="clear-bank-transactions-btn" title="清空交易记录">
                             <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>
                        </span>
                        <span class="action-btn" id="generate-bank-transaction-btn" title="生成新交易">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="1" x2="12" y2="23"></line><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path></svg>
                        </span>
                    </div>
                </div>
                <div id="character-bank-details" class="list-container"></div>
            </div>

            <!-- 10. 角色手机 - 行动轨迹 -->
            <div id="character-trajectory-screen" class="character-phone-page">
                 <div class="header character-phone-header">
                    <span class="back-btn" data-target-page="character-phone-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>足迹</span>
                    <div class="header-actions">
                        <!-- ★ 新增：足迹页的删除按钮 ★ -->
                        <span class="action-btn" id="clear-trajectory-btn" title="清空足迹">
                             <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>
                        </span>
                        <span class="action-btn" id="generate-trajectory-btn" title="生成新足迹">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>
                        </span>
                    </div>
                </div>
                <div id="character-trajectory-list" class="list-container"></div>
            </div>

            <!-- 11. 角色手机 - APP使用记录 -->
            <div id="character-app-usage-screen" class="character-phone-page">
                 <div class="header character-phone-header">
                    <span class="back-btn" data-target-page="character-phone-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>屏幕使用时间</span>
                    <div class="header-actions">
                        <!-- ★ 新增：使用记录页的删除按钮 ★ -->
                        <span class="action-btn" id="clear-app-usage-btn" title="清空记录">
                             <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>
                        </span>
                        <span class="action-btn" id="generate-app-usage-btn" title="生成新记录">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 8v4l3 3m6-3a9 9 0 1 1-18 0 9 9 0 0 1 18 0z"></path></svg>
                        </span>
                    </div>
                </div>
                <div id="character-app-usage-list" class="list-container"></div>
            </div>

            <!-- 12. 角色手机 - 日记 -->
            <div id="character-diary-screen" class="character-phone-page">
                 <div class="header character-phone-header">
                    <span class="back-btn" data-target-page="character-phone-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>日记</span>
                    <div class="header-actions">
                        <!-- ★ 新增：日记页的删除按钮 ★ -->
                        <span class="action-btn" id="clear-diary-entries-btn" title="清空日记">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>
                        </span>
                        <span class="action-btn" id="generate-diary-entry-btn" title="写新日记">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/></svg>
                        </span>
                    </div>
                </div>
                <div id="character-diary-list" class="list-container"></div>
            </div>
            <!-- ▼▼▼ 【全新】这是角色手机外观设置的HTML界面，请粘贴到指定位置 ▼▼▼ -->
<div id="character-phone-appearance-screen" class="character-phone-page">
    <div class="header character-phone-header">
        <span class="back-btn" data-target-page="character-phone-screen">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
        </span>
        <span>外观设置</span>
        <span style="width: 30px;"></span>
    </div>
    <!-- 复用你已有的.form-container样式，方便滚动和布局 -->
    <div class="form-container" style="padding: 15px; gap: 25px;">
        <!-- 壁纸设置区 -->
        <div>
            <label style="font-weight: 500; color: var(--text-secondary);">手机壁纸</label>
            <div id="char-phone-wallpaper-preview" class="wallpaper-preview" style="height: 240px; width: 135px; margin: 10px auto; border-radius: 12px;">点击下方上传</div>
            <button id="upload-char-phone-wallpaper-btn" class="form-button">上传壁纸</button>
            <button id="remove-char-phone-wallpaper-btn" class="form-button form-button-secondary" style="margin-top: 10px;">移除壁纸</button>
        </div>
        <!-- ▼▼▼ 在这里粘贴下面这一整块新代码 ▼▼▼ -->
<hr style="width: 100%; opacity: 0.2;">

<div>
    <label style="font-weight: 500; color: var(--text-secondary);">App 内壁纸</label>
    <div id="char-phone-app-wallpaper-preview" class="wallpaper-preview" style="height: 240px; width: 135px; margin: 10px auto; border-radius: 12px;">点击下方上传</div>
    <button id="upload-char-phone-app-wallpaper-btn" class="form-button">上传 App 内壁纸</button>
    <button id="remove-char-phone-app-wallpaper-btn" class="form-button form-button-secondary" style="margin-top: 10px;">移除 App 内壁纸</button>
</div>
<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->

        <hr style="width: 100%; opacity: 0.2;">

        <!-- App图标设置区 -->
        <div>
            <label style="font-weight: 500; color: var(--text-secondary);">App 图标</label>
            <div id="char-phone-icon-settings-grid" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin-top: 15px; text-align: center;">
                <!-- App图标设置将由JS动态生成在这里 -->
            </div>
        </div>

        <!-- ▼▼▼ 在这里粘贴下面这一整块新代码 ▼▼▼ -->
        <hr style="width: 100%; opacity: 0.2;">
        <!-- 桌面小组件设置区 -->
        <div>
            <label style="font-weight: 500; color: var(--text-secondary);">桌面小组件</label>
            <!-- 小组件1: 左上角 -->
            <div class="form-group" style="margin-top: 15px;">
                <label>左上角小组件</label>
                <div class="avatar-upload">
                    <img id="char-phone-widget-preview-1" class="wallpaper-preview" style="height: 100px; width: 100px; margin-bottom: 0;">
                    <div style="display:flex; flex-direction: column; gap: 8px;">
                        <button class="form-button-secondary" id="upload-widget-1-btn" style="margin-top:0;">上传图片</button>
                        <button class="form-button-secondary" id="remove-widget-1-btn" style="margin-top:0; border-color: #ff3b30; color: #ff3b30;">移除图片</button>
                    </div>
                </div>
            </div>
            <!-- 小组件2: 右下角 -->
            <div class="form-group" style="margin-top: 15px;">
                <label>右下角小组件</label>
                <div class="avatar-upload">
                    <img id="char-phone-widget-preview-2" class="wallpaper-preview" style="height: 100px; width: 100px; margin-bottom: 0;">
                     <div style="display:flex; flex-direction: column; gap: 8px;">
                        <button class="form-button-secondary" id="upload-widget-2-btn" style="margin-top:0;">上传图片</button>
                        <button class="form-button-secondary" id="remove-widget-2-btn" style="margin-top:0; border-color: #ff3b30; color: #ff3b30;">移除图片</button>
                    </div>
                </div>
            </div>
        </div>
        <!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 把这一整块全新的代码，粘贴到角色手机外观设置页面的 .form-container 内部末尾 ▼▼▼ -->
<hr style="width: 100%; opacity: 0.2; margin-top: 25px;">
<div class="preset-manager-container">
    <div style="width:100%; text-align: left; margin-bottom: 15px;">
        <label style="font-weight: 500; color: var(--text-secondary);">外观预设</label>
    </div>
    <div class="form-group">
        <select id="char-phone-preset-selector" class="form-group select"></select>
        <div class="preset-manager-controls">
            <!-- 独占一行的应用按钮 -->
            <button id="apply-char-phone-preset-btn" class="preset-btn-capsule preset-btn-apply" disabled>应用</button>
            
            <!-- 2x2 网格按钮 -->
            <button id="save-char-phone-preset-btn" class="preset-btn-capsule preset-btn-save">保存</button>
            <button id="update-char-phone-preset-btn" class="preset-btn-capsule preset-btn-secondary" disabled>更新</button>
            <button id="rename-char-phone-preset-btn" class="preset-btn-capsule preset-btn-secondary" disabled>重命名</button>
            <button id="import-char-phone-preset-btn" class="preset-btn-capsule preset-btn-secondary">导入</button>
            <button id="export-char-phone-preset-btn" class="preset-btn-capsule preset-btn-secondary" disabled>导出</button>
            <button id="delete-char-phone-preset-btn" class="preset-btn-capsule preset-btn-delete" disabled>删除</button>
            
            <input type="file" id="import-char-phone-preset-input" accept=".json" hidden>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML代码结束 ▲▲▲ -->

    </div>
</div>
<!-- 隐藏的文件选择器，用于处理上传 -->
<input type="file" id="char-phone-wallpaper-upload-input" accept="image/*" hidden>
<input type="file" id="char-phone-icon-upload-input" accept="image/*" hidden>

<!-- ▼▼▼ 在这里粘贴下面这两行新的文件选择器 ▼▼▼ -->
<input type="file" id="char-phone-widget-1-upload-input" accept="image/*" hidden>
<input type="file" id="char-phone-widget-2-upload-input" accept="image/*" hidden>
<input type="file" id="char-phone-app-wallpaper-upload-input" accept="image/*" hidden>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
        </div>
    </div>
</div>
<!-- ▲▲▲ HTML 替换结束 ▲▲▲ -->


<!-- 加载动画遮罩层 (保持不变) -->
<div id="generation-overlay" class="modal" style="background-color: rgba(0,0,0,0.6); z-index: 2000;">
    <div style="text-align: center; color: white;">
        <div id="loading-spinner" style="width: 40px; height: 40px; border: 4px solid rgba(255,255,255,0.3); border-top-color: white; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 20px;"></div>
        <p>正在同步Ta的手机数据...</p>
        <p style="font-size: 12px; opacity: 0.7;">（这可能需要一些时间，并会消耗API额度）</p>
    </div>
</div>

<!-- ▲▲▲ “查角色手机”功能HTML结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】选择联系人以创建群聊的屏幕 ▼▼▼ -->
<div id="contact-picker-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="cancel-contact-picker-btn">取消</span>
        <span>选择联系人</span>
        <span class="save-btn" id="confirm-contact-picker-btn">完成(0)</span>
    </div>
    <div class="list-container" id="contact-picker-list">
        <!-- 联系人列表将由JS动态生成 -->
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】群成员管理屏幕 ▼▼▼ -->
<div id="member-management-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="back-from-member-management">‹</span>
        <span>群成员管理</span>
        <span style="width: 30px;"></span>
    </div>
    <div class="list-container" id="member-management-list">
        <!-- 现有成员列表会在这里动态生成 -->
    </div>
    <div id="member-management-actions">
        <button id="add-existing-contact-btn">从好友列表添加</button>
        <button id="create-new-member-btn">创建群内新成员</button>
        <button id="ai-generate-members-btn">✨ AI 生成成员</button>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】微博用户人设与职业设置模态框 ▼▼▼ -->
<div id="weibo-user-settings-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 80%;">
        <div class="modal-header">
            <span>我的微博设定</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label>预设方案</label>
                <div class="bubble-preset-manager"> <!-- 复用现有样式 -->
                    <select id="weibo-user-preset-select" class="form-group select"></select>
                    <button id="manage-weibo-user-presets-btn" class="action-btn">管理</button>
                </div>
            </div>
            <div class="form-group">
                <label for="weibo-user-profession-modal-input">职业 (显示在昵称下方)</label>
                <input type="text" id="weibo-user-profession-modal-input" placeholder="例如：职业电竞选手、美妆博主">
            </div>
            <div class="form-group">
                <label for="weibo-user-persona-modal-input">隐藏人设 (仅供AI生成评论时参考)</label>
                <textarea id="weibo-user-persona-modal-input" rows="4" placeholder="例如：性格高冷，少与粉丝互动，只回复赞助商的评论。"></textarea>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-weibo-user-settings-btn">取消</button>
            <button class="save" id="save-weibo-user-settings-btn">保存</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】这是微博手动操作的弹窗，粘贴到 </body> 前面 ▼▼▼ -->
<div id="weibo-action-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 80%;">
        <div class="modal-header">
            <span id="weibo-action-modal-title">执行操作</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="weibo-action-actor-select">选择操作者 (Actor)</label>
                <select id="weibo-action-actor-select" class="form-group select"></select>
            </div>
            <div class="form-group">
                <label>选择操作类型</label>
<!-- ▼▼▼ 用这块新代码替换 ▼▼▼ -->
<div id="weibo-action-type-select" style="text-align: left;">
    <label><input type="radio" name="weibo_action_type" value="post" checked> 发布一条新微博</label>
    <label><input type="radio" name="weibo_action_type" value="comment_plaza"> 评论广场最新微博</label>
    <!-- ▼▼▼ 这是我们新增的选项 ▼▼▼ -->
    <label><input type="radio" name="weibo_action_type" value="comment_user"> 评论用户最新微博</label>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
            </div>
             <div class="form-group">
                <label for="weibo-action-prompt-input">关于... (可选, 简要提示)</label>
                <textarea id="weibo-action-prompt-input" rows="2" placeholder="例如：今天比赛赢了很开心 or 回应最近的热搜"></textarea>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-weibo-action-btn">取消</button>
            <button class="save" id="confirm-weibo-action-btn">执行</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 第2步 第3处修改（新增HTML） ▼▼▼ -->
<!-- ▼▼▼ 用这块新代码替换旧的 #char-sticker-manager-screen ▼▼▼ -->
<div id="char-sticker-manager-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="back-from-sticker-manager">‹</span>
        <span id="sticker-manager-title">表情包管理</span>
        <!-- 【核心修改1】在这里添加“编辑/完成”按钮 -->
        <div class="header-actions">
            <span class="action-btn" id="edit-char-stickers-btn">编辑</span>
            <span class="action-btn" id="done-char-stickers-btn" style="display: none;">完成</span>
        </div>
    </div>
    <input type="file" id="char-sticker-upload-input" accept="image/*" style="display: none;" multiple>
    <div class="modal-body" style="padding: 0; display: flex; flex-direction: column; flex-grow: 1;">
        <!-- 页签切换 -->
        <div class="frame-tabs">
            <div id="sticker-tab-exclusive" class="frame-tab active">专属表情</div>
            <div id="sticker-tab-common" class="frame-tab">通用表情</div>
        </div>

        <!-- 专属表情内容区 -->
        <div id="sticker-content-exclusive" class="frame-content active">
            <div class="sticker-panel-header" style="justify-content: flex-end;">
                 <div style="display: flex; gap: 10px;">
                    <span class="panel-btn" id="add-exclusive-sticker-btn">批量添加</span>
                    <span class="panel-btn" id="upload-exclusive-sticker-btn">本地上传</span>
                </div>
            </div>
            <div id="exclusive-sticker-grid" class="sticker-grid"></div>
        </div>

        <!-- 通用表情内容区 -->
        <div id="sticker-content-common" class="frame-content">
             <div class="sticker-panel-header" style="justify-content: flex-end;">
                 <div style="display: flex; gap: 10px;">
                    <span class="panel-btn" id="add-common-sticker-btn">批量添加</span>
                    <span class="panel-btn" id="upload-common-sticker-btn">本地上传</span>
                </div>
            </div>
            <div id="common-sticker-grid" class="sticker-grid"></div>
        </div>
    </div>
    <!-- 【核心修改2】在底部新增一个用于批量删除的操作栏 -->
    <div id="char-sticker-footer" style="display: none;">
        <button id="delete-selected-char-stickers-btn">删除已选 (0)</button>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->


<!-- ▼▼▼ 【全新】来电请求模态框 ▼▼▼ -->
<div id="incoming-call-modal" class="modal">
    <div class="incoming-call-content">
        <img id="caller-avatar" class="caller-avatar" src="">
        <div id="caller-name" class="caller-name"></div>
        <div class="caller-text">邀请你视频通话</div>
        <div class="incoming-call-actions">
            <div class="action-button-wrapper">
                <button id="decline-call-btn" class="call-action-btn decline"></button>
                <span>拒绝</span>
            </div>
            <div class="action-button-wrapper">
                <button id="accept-call-btn" class="call-action-btn accept"></button>
                <span>接听</span>
            </div>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】这是BGM搜索结果的弹窗，请粘贴到body末尾 ▼▼▼ -->
<div id="music-search-results-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span>搜索结果</span>
        </div>
        <div class="modal-body" id="search-results-list" style="padding: 0;">
            <!-- 搜索结果将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-music-search-btn" style="width: 100%;">取消</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->

<!-- ▼▼▼ 请用这段【全新群聊兼容结构】的代码，完整替换你旧的 #video-call-screen ▼▼▼ -->
<!-- ▼▼▼ 用下面这【一整块】全新的代码，替换掉你文件中旧的 #video-call-screen 及其所有内容 ▼▼▼ -->
<div id="video-call-screen" class="screen">
    <!-- 这个 screen 同时为两种模式服务 -->

    <!-- ======================================================= -->
    <!-- 模式一：全新的【可视化】视频通话界面 -->
    <!-- ======================================================= -->
    <div id="visual-call-interface" style="display: none;"> <!-- 默认隐藏 -->
        <!-- 1. 视频背景层 (大图和小图都在这里) -->
        <div class="video-background">
            <!-- 大图容器 -->
            <div id="video-main-view" class="video-container">
                <img src="" alt="主视频画面">
            </div>
            <!-- 小图容器 (画中画) -->
            <div id="video-pip-view" class="video-container pip">
                <img src="" alt="小窗视频画面">
            </div>
        </div>

        <!-- 2. 顶部状态栏 -->
        <div class="video-call-top-bar">
            <span id="visual-call-timer">00:00</span>
        </div>

        <!-- 3. 聊天气泡显示区域 -->
        <div id="video-call-messages-visual" class="video-call-main">
            <!-- 聊天气泡会由JS动态生成在这里 -->
        </div>
<!-- ▼▼▼ 用下面这【一整块】代码，替换掉 id="visual-call-interface" 里面那个旧的 video-call-controls 的 div ▼▼▼ -->
<div class="video-call-controls">
    <!-- 重-roll按钮 -->
    <button id="reroll-call-btn" class="control-btn reroll-btn" title="重新生成"></button>
    <!-- 【核心新增】发言按钮 -->
    <button id="user-speak-btn-visual" class="control-btn speak-btn" title="发言"></button>
    <!-- 切换镜头按钮 -->
    <button id="switch-camera-btn" class="control-btn switch-camera-btn" title="切换镜头"></button>
    <!-- 挂断按钮 -->
    <button id="hang-up-btn-visual" class="control-btn hangup-btn"></button>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->

    </div>

    <!-- ======================================================= -->
    <!-- 模式二：你原来的【纯文字】语音通话界面 (我们把它保留下来作为默认选项) -->
    <!-- ======================================================= -->
    <div id="text-call-interface" style="display: none;"> <!-- 默认隐藏 -->
        <div class="video-call-top-bar">
            <span id="call-timer">00:00</span>
        </div>
        <div class="video-call-avatar-area">
            <div id="participant-avatars-grid">
                <!-- JS会在这里动态生成头像 -->
            </div>
        </div>
        <div id="video-call-main" class="video-call-main">
            <!-- 对话内容会动态生成在这里 -->
        </div>
        <div class="video-call-controls">
            <!-- 【新增】为旧模式也加上重roll按钮 -->
            <button id="reroll-call-btn-text" class="control-btn reroll-btn" title="重新生成"></button>
            <button id="user-speak-btn" class="control-btn speak-btn"></button>
            <button id="hang-up-btn" class="control-btn hangup-btn"></button>
            <button id="join-call-btn" class="control-btn join-btn" style="display: none;"></button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->


<!-- ▼▼▼ 【全新添加】正在呼叫界面 ▼▼▼ -->
<div id="outgoing-call-screen" class="screen">
    <div class="outgoing-call-content">
        <img id="outgoing-call-avatar" class="caller-avatar" src="">
        <div id="outgoing-call-name" class="caller-name"></div>
        <div class="caller-text">正在呼叫...</div>
        <div class="outgoing-call-actions">
            <button id="cancel-call-btn" class="call-action-btn decline"></button>
            <span>取消</span>
        </div>
    </div>
</div>
<!-- ▲▲▲ 添加结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】通话记录页面 ▼▼▼ -->
<div id="call-history-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="call-history-back-btn">‹</span>
        <span id="call-history-title">通话记录</span>
        <span style="width: 30px;"></span> <!-- 占位符，保持标题居中 -->
    </div>
    <div id="call-history-list" class="list-container" style="padding: 15px; display: flex; flex-direction: column; gap: 15px;">
        <!-- 通话记录卡片将由JS动态生成在这里 -->
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】这是聊天记录搜索界面，请粘贴到 call-history-screen 的 div 之后 ▼▼▼ -->
<div id="chat-search-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="search-back-btn">‹</span>
        <span>查找聊天记录</span>
        <span style="width: 30px;"></span> <!-- 占位符 -->
    </div>
    <div class="form-container" style="padding-bottom: 0;">
        <!-- 搜索条件输入区 -->
        <div class="form-group">
            <label for="keyword-search-input">关键词</label>
            <input type="text" id="keyword-search-input" placeholder="输入要查找的关键词...">
        </div>
        <div class="form-group">
            <label for="sender-search-select">人物</label>
            <select id="sender-search-select">
                <!-- 选项将由JS动态生成 -->
            </select>
        </div>
        <div class="form-group">
            <label for="date-search-input">日期</label>
            <input type="date" id="date-search-input">
        </div>
        <button class="form-button" id="perform-search-btn">开始查找</button>
        
        <!-- 搜索结果显示区 -->
        <div id="chat-search-results-list" class="list-container" style="margin-top: 15px; padding: 0;">
            <!-- 搜索结果将由JS动态生成在这里 -->
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->


            <!-- ▼▼▼ 请将下面这整块【全新的HTML代码】粘贴到这里 ▼▼▼ -->
            <div id="lock-screen" class="screen">
                <div id="lock-clock-container">
                    <div id="lock-main-time">12:00</div>
                    <div id="lock-main-date">星期一, 1月1日</div>
                </div>
                <div id="unlock-hint">向上轻扫以解锁</div>
            </div>

            <div id="password-modal-overlay" class="modal">
                <div class="password-modal-content">
                    <p>请输入密码</p>
                    <input type="password" id="password-input-field" maxlength="20">
                    <div class="password-actions">
                        <button id="password-cancel-btn">取消</button>
                        <button id="password-confirm-btn">进入</button>
                    </div>
                </div>
            </div>
            <!-- ▲▲▲ 新HTML代码粘贴结束 ▲▲▲ -->

        </div>
    </div>
  <!-- ▼▼▼ 用这整块代码替换 ▼▼▼ -->
<div id="lovers-space-screen" class="screen">
    <!-- 头部 -->
    <div id="ls-header">
        <div class="ls-header-overlay"></div>
        <div class="ls-header-top-bar">
            <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
            <span id="ls-char-name"></span>
            <div class="header-actions">
                <span class="action-btn" id="ls-settings-btn" title="空间设置">
                    <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>
                </span>
                <span class="action-btn" id="ls-change-bg-btn" title="更换背景">
                    <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>
                </span>
                <span class="action-btn" id="ls-switch-char-btn">切换</span>
            </div>
        </div>
        <div class="ls-avatar-and-counter-wrapper">
            <div class="ls-header-avatars">
                <img id="ls-user-avatar" src="">
                <span class="heart-icon">❤</span>
                <img id="ls-char-avatar" src="">
            </div>
            <div id="ls-days-counter"></div>
        </div>
    </div>
<!-- ▼▼▼ 用这整块【SVG图标版】代码，替换你旧的 ls-tab-bar ▼▼▼ -->
<div id="ls-tab-bar">
    <div class="ls-tab-item active" data-view="ls-moments-view" title="说说">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>
    </div>
    <div class="ls-tab-item" data-view="ls-album-view" title="相册">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>
    </div>
    <div class="ls-tab-item" data-view="ls-letters-view" title="情书">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline></svg>
    </div>
    <div class="ls-tab-item" data-view="ls-shares-view" title="分享">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line></svg>
    </div>
    <div class="ls-tab-item" data-view="ls-questions-view" title="提问">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>
    </div>
    <div class="ls-tab-item" data-view="ls-diary-view" title="日记">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path></svg>
    </div>
    <div class="ls-tab-item" data-view="ls-pomodoro-view" title="番茄钟">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>
    </div>
</div>
<!-- ▲▲▲ HTML替换结束 ▲▲▲ -->
    <!-- 内容显示区域 -->
    <div id="ls-content-area">
        <div id="ls-moments-view" class="ls-view active"><div id="ls-moments-list"></div><button id="ls-add-moment-btn" class="ls-fab-btn">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <line x1="12" y1="5" x2="12" y2="19" stroke="currentColor" stroke-width="3" stroke-linecap="round"/>
        <line x1="5" y1="12" x2="19" y2="12" stroke="currentColor" stroke-width="3" stroke-linecap="round"/>
    </svg>
</button>
</div>
        <div id="ls-album-view" class="ls-view">
    <div id="ls-album-list"></div>
    <button id="ls-add-album-btn" class="ls-fab-btn">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <line x1="12" y1="5" x2="12" y2="19" stroke="currentColor" stroke-width="3" stroke-linecap="round"/>
            <line x1="5" y1="12" x2="19" y2="12" stroke="currentColor" stroke-width="3" stroke-linecap="round"/>
        </svg>
    </button>
</div>

        <div id="ls-letters-view" class="ls-view">
    <div id="ls-letters-list"></div>
    <button id="ls-add-letter-btn" class="ls-fab-btn">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <line x1="12" y1="5" x2="12" y2="19" stroke="currentColor" stroke-width="3" stroke-linecap="round"/>
            <line x1="5" y1="12" x2="19" y2="12" stroke="currentColor" stroke-width="3" stroke-linecap="round"/>
        </svg>
    </button>
</div>

        <div id="ls-shares-view" class="ls-view"><div id="ls-shares-list"></div></div>
     <div id="ls-questions-view" class="ls-view">
    <div id="ls-questions-list"></div>
    <button id="ls-add-question-btn" class="ls-fab-btn">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <line x1="12" y1="5" x2="12" y2="19" stroke="currentColor" stroke-width="3" stroke-linecap="round"/>
            <line x1="5" y1="12" x2="19" y2="12" stroke="currentColor" stroke-width="3" stroke-linecap="round"/>
        </svg>
    </button>
</div>

        <!-- ▼▼▼ 在 id="ls-questions-view" 的 div 之后，粘贴下面这整块新代码 ▼▼▼ -->
<div id="ls-diary-view" class="ls-view">
    <!-- 日历和心情罐子的内容将由JS动态生成在这里 -->
</div>
<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->
        <!-- ★★★ 这就是我们为番茄钟准备的全新界面 ★★★ -->
        <div id="ls-pomodoro-view" class="ls-view">
            <!-- 番茄钟主页，显示历史记录和开始按钮 -->
            <div id="ls-pomodoro-home">
                <div id="ls-pomodoro-start-btn-container">
                    <div id="ls-pomodoro-start-icon">＋</div>
                    <p>开启新的专注时光</p>
                </div>
                <div id="ls-pomodoro-history-list">
                    <!-- 历史记录会由JS生成在这里 -->
                </div>
            </div>
            <!-- 正在计时的界面，默认隐藏 -->
            <div id="ls-pomodoro-timer-active" style="display: none;">
                <div class="pomodoro-char-avatar-container">
                    <img id="pomodoro-char-avatar" src="">
                    <div id="pomodoro-char-log"></div>
                </div>
                <div class="pomodoro-timer-display">
                    <div id="pomodoro-current-task"></div>
                    <div id="pomodoro-time">25:00</div>
                </div>
                <button id="pomodoro-end-btn">结束专注</button>
            </div>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
    <div id="chat-settings-modal" class="modal"><div class="modal-content"><div class="modal-header"><span>聊天设置</span></div><div class="modal-body"><div class="form-group" id="chat-name-group"><label for="chat-name-input">备注名 / 群名</label><input type="text" id="chat-name-input"></div>

    <!-- ▼▼▼ 请将这段新代码粘贴到“备注名”输入框的 form-group 之后 ▼▼▼ -->
    <div class="form-group" id="assign-group-section" style="display: none;"> <!-- 默认隐藏，只对单聊显示 -->
        <label for="assign-group-select">好友分组</label>
        <div style="display: flex; align-items: center; gap: 10px;">
            <select id="assign-group-select" style="flex-grow: 1;">
                <!-- 分组选项将由JS动态生成 -->
            </select>
            <button id="manage-groups-btn" class="form-button-secondary" style="margin-top: 0; padding: 12px;">管理分组</button>
        </div>
    </div>
    <!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->

<div class="form-group" id="my-group-nickname-group"><label for="my-group-nickname-input">我的群昵称</label><input type="text" id="my-group-nickname-input"></div><div class="form-group" id="group-avatar-group"><label>群头像</label><div class="avatar-upload"><img id="group-avatar-preview"><button onclick="document.getElementById('group-avatar-input').click()">上传群头像</button><input type="file" id="group-avatar-input" accept="image/*"></div></div>
            <div class="form-group" id="world-book-link-group">
                <label>关联世界书 (可多选)</label>
                <div class="custom-multiselect">
                    <div class="select-box">
                        <span class="selected-options-text">-- 点击选择 --</span>
                        <span class="arrow-down">▼</span>
                    </div>
                    <div id="world-book-checkboxes-container" class="checkboxes-container">
                    </div>
                </div>
            </div>
            <!-- ▼▼▼ 【全新】记忆互通设置 (持久化链接版) ▼▼▼ -->
<div class="form-group" id="memory-link-group">
    <label>记忆互通 (选择要链接的聊天)</label>
    
    <!-- 复用世界书的多选框样式 -->
    <div class="custom-multiselect" id="memory-link-multiselect">
        <div class="select-box">
            <span class="selected-options-text">-- 点击选择 --</span>
            <span class="arrow-down">▼</span>
        </div>
        <div id="memory-link-checkboxes-container" class="checkboxes-container">
            <!-- 聊天选项将由JS动态生成在这里 -->
        </div>
    </div>
    
    <!-- 新增：记忆条数设置 -->
    <div class="form-group" style="margin-top: 10px;">
        <label for="link-memory-depth-input" style="font-weight: normal; color: var(--text-secondary); font-size: 13px;">互通记忆条数 (AI会看到对方最近的几条消息)</label>
        <input type="number" id="link-memory-depth-input" value="5" min="1" max="20" style="padding: 8px;">
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
 <!-- ▼▼▼ 把这一整块全新的HTML代码，粘贴到 <div id="chat-settings-modal"> 的 <div class="modal-body"> 内部，例如“聊天背景”设置的上方 ▼▼▼ -->

<hr style="opacity: 0.2; margin: 20px 0;">

<!-- 1. 线下模式总开关 -->
<div class="form-group" id="offline-mode-section">
    <label for="offline-mode-toggle" class="toggle-switch-label">
        <span class="toggle-switch-text">
            开启线下模式
            <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                开启后，AI将默认你们在线下见面，并以大段叙事的方式进行回应。
            </p>
        </span>
        <input type="checkbox" id="offline-mode-toggle">
        <span class="toggle-switch-slider"></span>
    </label>
</div>

<!-- 2. 线下模式的详细设置 (默认隐藏) -->
<div id="offline-mode-details" style="display: none; padding-left: 10px; border-left: 3px solid var(--accent-color); margin-top: 15px;">
    
    <!-- 2.1 预设管理 -->
    <div class="form-group">
        <label>线下模式预设</label>
        <div class="bubble-preset-manager">
            <select id="offline-preset-select" class="form-group select"></select>
            <button id="manage-offline-presets-btn" class="action-btn">管理</button>
        </div>
    </div>
    
    <!-- 2.2 提示词输入 -->
    <div class="form-group">
        <label for="offline-prompt-input">自定义提示词 (Prompt)</label>
        <textarea id="offline-prompt-input" rows="4" placeholder="例如：你正在一家安静的咖啡馆里和用户约会..."></textarea>
    </div>
    
    <!-- 2.3 文风输入 -->
    <div class="form-group">
        <label for="offline-style-input">自定义文风 (Style)</label>
        <textarea id="offline-style-input" rows="3" placeholder="例如：请使用第三人称，详细描写角色的动作、神态和心理活动..."></textarea>
    </div>

    <!-- 2.4 字数设置 -->
    <div class="form-group">
        <label for="offline-word-count-input">期望回复字数</label>
        <input type="number" id="offline-word-count-input" value="300" min="50" step="50">
    </div>

</div>
<!-- ▼▼▼ 【全新】聊天总结设置区域 ▼▼▼ -->
<hr style="opacity: 0.2; margin: 20px 0;">

<div class="form-group">
    <label for="summary-toggle" class="toggle-switch-label">
        <span class="toggle-switch-text">
            开启聊天总结
            <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                开启后，AI会在对话达到一定长度时自动或手动进行总结，作为长期记忆。
            </p>
        </span>
        <input type="checkbox" id="summary-toggle">
        <span class="toggle-switch-slider"></span>
    </label>
</div>

<div id="summary-details-container" style="display: none; padding-left: 10px; border-left: 3px solid var(--accent-color); margin-top: 15px;">
    <div class="form-group">
        <label>总结模式</label>
        <div style="display: flex; gap: 20px;">
            <label><input type="radio" name="summary-mode" value="auto" checked> 自动总结</label>
            <label><input type="radio" name="summary-mode" value="manual"> 手动总结</label>
        </div>
    </div>
    <div class="form-group">
        <label for="summary-count-input">触发消息条数</label>
        <input type="number" id="summary-count-input" value="20" min="5">
    </div>
    <div class="form-group">
        <label for="summary-prompt-input">总结提示词 (Prompt)</label>
        <textarea id="summary-prompt-input" rows="4"></textarea>
    </div>
    <button id="view-summaries-btn" class="form-button form-button-secondary" style="margin-top: 10px;">查看和管理总结</button>
        <!-- ▼▼▼ 在这里粘贴下面的新按钮 ▼▼▼ -->
    <button id="manual-summary-btn" class="form-button form-button-secondary" style="margin-top: 10px;">立即手动总结</button>
    <!-- ▲▲▲ 新按钮粘贴结束 ▲▲▲ -->
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 在 id="summary-details-container" 的 </div> 之后粘贴 ▼▼▼ -->
<div class="form-group" style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
    <label style="margin-bottom: 0;">当前总聊天条数</label>
    <span id="total-message-count-display" style="color: var(--text-secondary); font-weight: 500;">--</span>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
 <!-- ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼ -->
<div class="form-group" style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
    <label style="margin-bottom: 0;">
        上下文Token数
        <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
            (提示词 + 上下文记忆)
        </p>
    </label>
    <span id="context-token-count-display" style="color: var(--text-secondary); font-weight: 500;">--</span>
</div>
<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->
<!-- ▲▲▲ 新增HTML代码粘贴结束 ▲▲▲ -->

            <div class="form-group" id="ai-persona-group"><label for="ai-persona">对方人设 (AI Persona)</label><textarea id="ai-persona" rows="3"></textarea></div>
              <!-- ▼▼▼ 第2步 第2处修改（新增HTML） ▼▼▼ -->
            <div class="form-group" id="char-sticker-group">
                <button id="manage-char-stickers-btn" class="form-button form-button-secondary" style="width: 100%; margin-top: 5px;">
                    管理角色表情包
                </button>
            </div>
            <!-- ▲▲▲ 新增结束 ▲▲▲ -->
            <!-- ▼▼▼ 在这里粘贴新代码 ▼▼▼ -->
<div class="form-group" id="npc-library-group">
    <button id="manage-npcs-btn" class="form-button form-button-secondary" style="width: 100%; margin-top: 5px;">管理NPC库</button>
</div>
<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->
 <!-- ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼ -->
<div class="form-group" id="minimax-voice-id-group">
    <label for="minimax-voice-id-input">Minimax 语音ID</label>
    <input type="text" id="minimax-voice-id-input" placeholder="例如：male-01">
</div>
<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->
 <!-- 【全新】微博人设与职业设置 -->
<div id="weibo-settings-for-user" style="display: none;">
    <hr style="opacity: 0.2; margin: 20px 0;">
    <div class="form-group">
        <label>我的微博设定</label>
        <div class="bubble-preset-manager">
            <select id="weibo-persona-preset-select" class="form-group select"></select>
            <button id="manage-weibo-presets-btn" class="action-btn">管理</button>
        </div>
    </div>
    <div class="form-group">
        <label for="weibo-user-profession-input">职业 (显示在昵称下方)</label>
        <input type="text" id="weibo-user-profession-input" placeholder="例如：职业电竞选手、美妆博主">
    </div>
    <div class="form-group">
        <label for="weibo-user-persona-input">隐藏人设 (仅供AI参考)</label>
        <textarea id="weibo-user-persona-input" rows="3" placeholder="例如：性格高冷，少与粉丝互动，只回复赞助商的评论。"></textarea>
    </div>
</div>
<!-- 【全新】微博设置结束 -->
 <!-- ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼ -->
<div class="form-group" id="weibo-profession-group">
    <label for="weibo-profession-input">微博职业</label>
    <input type="text" id="weibo-profession-input" placeholder="例如：职业电竞选手、美妆博主、演员...">
</div>
<div class="form-group" id="weibo-instruction-group">
    <label for="weibo-instruction-input">微博指令 (AI发微博/评论时将严格遵守)</label>
    <textarea id="weibo-instruction-input" rows="3" placeholder="例如：多发日常训练和比赛的内容，性格高冷，少与粉丝互动，只回复赞助商的评论。"></textarea>
</div>
<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->
 <!-- ▼▼▼ 把这一整块全新的代码，粘贴到“管理NPC库”按钮的 div 之后 ▼▼▼ -->
<hr style="opacity: 0.2; margin: 20px 0;">
<div class="form-group">
    <label for="time-perception-toggle" class="toggle-switch-label">
        <span class="toggle-switch-text">启用实时时间感知</span>
        <input type="checkbox" id="time-perception-toggle" checked>
        <span class="toggle-switch-slider"></span>
    </label>
</div>
<div id="custom-time-container" class="form-group" style="display: none;">
    <label for="custom-time-input">自定义时间</label>
    <input type="datetime-local" id="custom-time-input" style="width: 95%; padding: 8px; border-radius: 8px; border: 1px solid var(--border-color);">
</div>
<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->
<div class="form-group" id="ai-avatar-group"><label>对方头像</label>
  <!-- ▼▼▼ 把下面这【一整块】代码，粘贴到 id="ai-avatar-group" 的那个 div 之后 ▼▼▼ -->
<div class="form-group" id="video-call-settings-group">
    <hr style="opacity: 0.2; margin: 20px 0;">
    <label>视频通话界面设置</label>
    
    <!-- 1. 功能开关 -->
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
        <span>启用可视化界面</span>
        <label class="toggle-switch">
            <input type="checkbox" id="visual-video-call-switch">
            <span class="slider"></span>
        </label>
    </div>

    <!-- 2. 图片上传区 (默认隐藏) -->
    <div id="video-call-image-uploads" style="display: none;">
        <div class="form-group">
            <label>对方的视频画面</label>
            <div class="avatar-upload">
                <img id="char-video-image-preview" style="border-radius: 8px; width: 80px; height: 142px;">
                <button onclick="document.getElementById('char-video-image-input').click()">上传图片</button>
                <input type="file" id="char-video-image-input" accept="image/*" hidden>
            </div>
        </div>
        <div class="form-group">
            <label>我的视频画面</label>
            <div class="avatar-upload">
                <img id="user-video-image-preview" style="border-radius: 8px; width: 80px; height: 142px;">
                <button onclick="document.getElementById('user-video-image-input').click()">上传图片</button>
                <input type="file" id="user-video-image-input" accept="image/*" hidden>
            </div>
        </div>
    </div>
</div>
<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->

  <div class="avatar-upload">
    <img id="ai-avatar-preview">
    <button onclick="document.getElementById('ai-avatar-input').click()">上传对方头像</button>
    <button class="change-frame-btn" data-type="ai">更换头像框</button>
    <button id="manage-ai-avatar-library-btn">管理头像库</button>
    <input type="file" id="ai-avatar-input" accept="image/*">
</div>
</div>
<!-- ▼▼▼ 步骤1：在这里粘贴情侣头像功能的新HTML代码 ▼▼▼ -->
<div class="form-group" id="couple-avatar-group">
    <label for="couple-avatar-toggle" class="toggle-switch-label">
        <span class="toggle-switch-text">情侣头像开关</span>
        <input type="checkbox" id="couple-avatar-toggle">
        <span class="toggle-switch-slider"></span>
    </label>
    <div id="couple-avatar-desc-container" style="display: none; margin-top: 10px;">
         <label for="couple-avatar-description" style="font-size: 13px; color: var(--text-secondary);">情侣头像描述 (可选)</label>
         <input type="text" id="couple-avatar-description" placeholder="例如：一只小猫在看月亮">
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
<div class="form-group" id="my-persona-group"><label for="my-persona">我的人设 (My Persona)</label><textarea id="my-persona" rows="3"></textarea></div><div class="form-group" id="my-avatar-group"><label>我的头像</label><div class="avatar-upload"><img id="my-avatar-preview"><button onclick="document.getElementById('my-avatar-input').click()">上传我的头像</button>
<button class="change-frame-btn" data-type="my">更换头像框</button> <!-- ← 加回这一行 -->
<button id="open-persona-library-btn">预设</button><input type="file" id="my-avatar-input" accept="image/*"></div></div><div class="form-group" id="group-members-group"><label>群成员人设</label><div id="group-members-settings"></div>


    <!-- 【新增】管理成员按钮 -->
    <button id="manage-members-btn" class="form-button form-button-secondary" style="margin-top: 15px;">管理群成员</button></div>
    <!-- ▼▼▼ 【全新】群聊后台活动设置 ▼▼▼ -->
<div class="form-group" id="group-background-activity-group" style="display: none;">
    <hr style="opacity: 0.2; margin: 20px 0;">
    <label class="toggle-switch-label">
        <span class="toggle-switch-text">
            群聊后台实时活动
            <p style="font-size: 12px; font-weight: normal; color: #ff6b6b; margin-top: 5px;">
                警告：开启后会增加API调用和费用！
            </p>
        </span>
        <input type="checkbox" id="group-background-activity-switch">
        <span class="toggle-switch-slider"></span>
    </label>

    <div id="group-background-interval-settings" style="display: none; margin-top: 15px;">
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <label for="group-background-interval-input" style="margin-bottom: 0;">
                活动间隔期 (秒)
                <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                    建议值 120-600。值越大，费用越低，但群内互动越慢。
                </p>
            </label>
            <input type="number" id="group-background-interval-input" min="60" value="120" style="width: 80px; text-align: center;">
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 用这块【功能增强版】代码，替换旧的续火花设置区 ▼▼▼ -->
<div class="form-group" id="streak-settings-section">
    <!-- 火花总开关 -->
    <label for="streak-enabled-toggle" class="toggle-switch-label">
        <span class="toggle-switch-text">
            开启续火花
            <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                开启后，每天和Ta互动即可延续火花。
            </p>
        </span>
        <input type="checkbox" id="streak-enabled-toggle">
        <span class="toggle-switch-slider"></span>
    </label>

    <!-- 火花详细设置 (默认隐藏) -->
    <div id="streak-details-container" style="display: none; margin-top: 15px; padding-left: 10px; border-left: 3px solid var(--accent-color);">
        <!-- 【全新】初始天数输入框 -->
        <div class="form-group">
            <label for="streak-initial-days-input">初始火花天数</label>
            <input type="number" id="streak-initial-days-input" value="0" min="0">
        </div>

        <!-- 【已修改】熄灭规则选择器 -->
        <div class="form-group">
            <label for="streak-extinguish-threshold-select">火花熄灭规则</label>
            <select id="streak-extinguish-threshold-select">
                <option value="1">1天不联系则熄灭</option>
                <option value="3">3天不联系则熄灭</option>
                <option value="7">7天不联系则熄灭</option>
                <option value="-1">永不熄灭 🔥</option>
            </select>
        </div>
        <!-- ▼▼▼ 在 id="streak-details-container" 的 </div> 闭合标签前，粘贴下面这行 ▼▼▼ -->
<!-- ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼ -->
<!-- 【全新】自定义火花图标和颜色 -->
<div class="form-group">
    <label for="streak-lit-icon-url">点亮的火花图片 URL (可选)</label>
    <input type="text" id="streak-lit-icon-url" placeholder="留空则默认显示🔥">
</div>
<div class="form-group">
    <label for="streak-extinguished-icon-url">熄灭的火花图片 URL (可选)</label>
    <input type="text" id="streak-extinguished-icon-url" placeholder="留空则默认显示🧊">
</div>
<div class="form-group">
    <label for="streak-font-color-picker">天数字体颜色 (可选)</label>
    <input type="color" id="streak-font-color-picker" value="#ff6f00" style="width: 100%; height: 40px;">
</div>
<!-- ▲▲▲ 新增代码粘贴结束 ▲▲▲ -->
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->


<div class="form-group"><label for="max-memory">上下文记忆条数</label><input type="number" id="max-memory" value="10"></div><div class="form-group"><label>聊天气泡主题 <button id="reset-theme-btn" type="button">重置</button></label><div class="theme-selector"><label><input type="radio" name="theme-select" value="default" id="theme-default"> 默认</label><label><input type="radio" name="theme-select" value="pink_blue"> 粉蓝</label><label><input type="radio" name="theme-select" value="blue_white"> 蓝白</label><label><input type="radio" name="theme-select" value="purple_yellow"> 紫黄</label><label><input type="radio" name="theme-select" value="black_white"> 黑白</label><label><input type="radio" name="theme-select" value="yellow_white"> 黄白</label><label><input type="radio" name="theme-select" value="red_black"> 红黑</label><label><input type="radio" name="theme-select" value="blue_yellow"> 蓝黄</label><label><input type="radio" name="theme-select" value="pink_yellow"> 粉黄</label><label><input type="radio" name="theme-select" value="pink_purple"> 粉紫</label><label><input type="radio" name="theme-select" value="gray_white"> 灰白</label><label><input type="radio" name="theme-select" value="blue_green"> 蓝绿</label><label><input type="radio" name="theme-select" value="pink_white"> 粉白</label><label><input type="radio" name="theme-select" value="pink_black"> 粉黑</label><label><input type="radio" name="theme-select" value="pink_green"> 粉绿</label><label><input type="radio" name="theme-select" value="green_black"> 绿黑</label></div></div>

<!-- ▼▼▼ 请将这段新代码粘贴到“聊天气泡主题”的 form-group 之后 ▼▼▼ -->
<div class="form-group">
    <label for="font-size-slider">聊天字体大小 <span id="font-size-value">13px</span></label>
    <input type="range" id="font-size-slider" min="12" max="20" step="1" value="13" style="width: 100%; margin-top: 8px;">
</div>
<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】气泡样式预设选择器 (已添加导入导出功能) ▼▼▼ -->
<div class="form-group">
    <label>气泡样式预设</label>
    <div class="bubble-preset-manager">
        <select id="bubble-style-preset-select" class="form-group select"></select>
        <button id="manage-bubble-presets-btn" class="action-btn">管理</button>
    </div>
    <!-- ▼▼▼ 这是我们新加的导入和导出按钮 ▼▼▼ -->
    <div style="display: flex; gap: 10px; margin-top: 10px;">
        <button id="export-bubble-preset-btn" class="form-button form-button-secondary" style="flex:1; margin:0;">导出气泡</button>
        <button id="import-bubble-preset-btn" class="form-button form-button-secondary" style="flex:1; margin:0;">导入气泡</button>
    </div>
    <input type="file" id="import-bubble-preset-input" accept=".json" style="display: none;">
    <!-- ▲▲▲ 添加结束 ▲▲▲ -->
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->


<!-- ▼▼▼ 请将这段新代码粘贴到“聊天字体大小”的 form-group 之后 ▼▼▼ -->
<div class="form-group">
    <label for="custom-css-input">
        自定义气泡样式 (CSS)
        <button id="reset-custom-css-btn" type="button" style="background: none; border: 1px solid #ccc; color: #555; font-size: 12px; padding: 2px 8px; border-radius: 5px; cursor: pointer; margin-left: 10px;">重置</button>
    </label>
    <textarea id="custom-css-input" rows="5" style="width: 100%; margin-top: 8px; font-family: monospace; font-size: 12px; resize: vertical;" placeholder="/* 示例：为“我”的气泡添加渐变背景和阴影 */
.message-bubble.user .content {
  background: linear-gradient(135deg, #a1c4fd, #c2e9fb);
  box-shadow: 0 4px 10px rgba(0,0,0,0.1);
  border-radius: 15px 4px 15px 15px;
}"></textarea>
</div>
<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 请将这段新代码粘贴到自定义CSS输入框的 form-group 之后 ▼▼▼ -->
<div class="form-group">
    <label>实时预览</label>
    <div id="settings-preview-area">
        <!-- JS会在这里生成预览内容 -->
    </div>
</div>
<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->

            <div class="form-group">
                <label>聊天背景</label>
                <div class="bg-upload-container">
                    <button type="button" class="form-button-secondary" style="width: auto; padding: 8px 12px; margin-top: 0;" onclick="document.getElementById('bg-input').click()">上传背景图</button>
                    <button type="button" id="remove-bg-btn">移除背景</button>
                </div>
                <img id="bg-preview" class="bg-preview-img">
                <input type="file" id="bg-input" accept="image/*" style="display: none;">
            </div>
<!-- ▼▼▼ 把这一整块全新的代码，粘贴到你刚刚删除代码的位置 ▼▼▼ -->

<!-- 记录管理区 -->
<div class="form-group" style="display: flex; gap: 10px;">
    <button class="form-button form-button-secondary" id="import-chat-history-btn" style="flex: 1; margin: 0;">导入聊天记录</button>
    <button class="form-button form-button-secondary" id="export-chat-history-btn" style="flex: 1; margin: 0;">导出聊天记录</button>
</div>
<input type="file" id="import-chat-history-input" accept="application/json" style="display: none;">
<button class="form-button form-button-secondary" id="search-chat-btn">查找聊天记录</button>
<button class="form-button form-button-secondary" id="clear-chat-btn">清空聊天记录</button>
<button class="form-button form-button-secondary" id="block-chat-btn" style="background-color: #ff3b30; color: white; border-color: #ff3b30;">拉黑对方</button>

<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->

</div><div class="modal-footer"><button class="cancel" id="cancel-chat-settings-btn">取消</button><button class="save" id="save-chat-settings-btn">保存</button></div></div></div>
    
    <div id="persona-library-modal" class="modal"><div class="modal-content"><div class="modal-header"><span>我的人设库</span><button id="add-persona-preset-btn" class="action-button">添加</button></div><div class="modal-body"><div id="persona-library-grid"></div></div><div class="modal-footer"><button class="cancel" id="close-persona-library-btn">关闭</button></div></div></div>
    
<!-- ▼▼▼ 从这里开始替换 ▼▼▼ -->
<div id="persona-editor-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <span id="persona-editor-title">添加人设预设</span>
        </div>
        <div class="modal-body">
            <!-- 【新增】NPC名字输入框 -->
            <div class="form-group" id="npc-editor-name-group">
                <label for="npc-editor-name-input">NPC 名字</label>
                <input type="text" id="npc-editor-name-input">
            </div>
            <div class="form-group">
                <label>头像</label>
                <div class="avatar-upload">
                    <img id="preset-avatar-preview">
                    <button onclick="document.getElementById('preset-avatar-input').click()">上传头像</button>
                    <!-- 【新增】给这个按钮一个ID，方便我们控制它 -->
                    <button id="persona-editor-change-frame-btn" class="change-frame-btn" data-type="member">更换头像框</button>
                    <input type="file" id="preset-avatar-input" accept="image/*">
                </div>
            </div>
            <div class="form-group">
                <label for="preset-persona-input">人设</label>
                <textarea id="preset-persona-input" rows="4" placeholder="在此输入这个人设的详细设定..."></textarea>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-persona-editor-btn">取消</button>
            <button class="save" id="save-persona-preset-btn">保存</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替换到这里结束 ▲▲▲ -->



    <div id="member-settings-modal" class="modal"><div class="modal-content"><div class="modal-header"><span>编辑群成员</span></div><div class="modal-body">
    <div class="form-group"><label for="member-name-input">名字</label><input type="text" id="member-name-input"></div>
    <div class="form-group"><label for="member-persona-input">人设</label><textarea id="member-persona-input" rows="4"></textarea></div>
<!-- ▼▼▼ 用下面这整块代码，替换旧的头像上传区域 ▼▼▼ -->
<div class="form-group">
    <label>头像</label>
    <div class="avatar-upload">
        <img id="member-avatar-preview">
        <button onclick="document.getElementById('member-avatar-input').click()">上传头像</button>
        <!-- ★★★ 我们在这里新增了一个更换头像框的按钮 ★★★ -->
        <button id="member-editor-change-frame-btn" class="change-frame-btn">更换头像框</button>
        <input type="file" id="member-avatar-input" accept="image/*" hidden>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
    </div><div class="modal-footer"><button class="cancel" id="cancel-member-settings-btn">取消</button><button class="save" id="save-member-settings-btn">保存</button></div></div></div>
    
    <div id="custom-modal-overlay">
        <div id="custom-modal">
            <div class="custom-modal-header" id="custom-modal-title"></div>
            <div class="custom-modal-body" id="custom-modal-body"></div>
            <div class="custom-modal-footer">
                <button id="custom-modal-cancel">取消</button>
                <button id="custom-modal-confirm" class="confirm-btn">确定</button>
            </div>
        </div>
    </div>


    <div id="preset-actions-modal" class="modal">
        <div id="custom-modal" style="width: 250px;">
            <div class="custom-modal-footer">
                <button id="preset-action-edit">编辑预设</button>
                <button id="preset-action-delete" class="btn-danger">删除预设</button>
                <button id="preset-action-cancel" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">取消</button>
            </div>
        </div>
    </div>

    <div id="transfer-modal">
        <div class="transfer-content">
            <div class="transfer-header">给Ta一个惊喜！</div>
            <div class="transfer-input-group">
                <label for="transfer-amount">转账金额</label>
                <input type="number" id="transfer-amount" placeholder="0.00" min="0" max="9999999999999" step="0.01">
            </div>
            <div class="transfer-input-group">
                <label for="transfer-note">备注 (可选)</label>
                <input type="text" id="transfer-note" placeholder="留下你的小心思~" maxlength="20">
            </div>
            <div class="transfer-actions">
                <button id="transfer-cancel-btn">取消</button>
                <button id="transfer-confirm-btn">确认转账</button>
            </div>
        </div>
    </div>

 <div id="battery-alert-modal">
    <div class="battery-alert-content">
        <img id="battery-alert-image" src="">
        <p id="battery-alert-text"></p>
    </div>
</div>

    <audio id="audio-player" style="display:none;"></audio>
<!-- ▼▼▼ 在这里添加下面这行新的音频元素 ▼▼▼ -->
<audio id="tts-audio-player" style="display:none;"></audio>
<!-- ▲▲▲ 添加结束 ▲▲▲ -->
<audio id="ringtone-player" loop></audio>
<audio id="notification-sound-player" preload="auto"></audio>
<!-- ▼▼▼ 用下面这【一整块完整代码】替换掉你旧的 id="create-post-modal" 的整个 div ▼▼▼ -->
<div id="create-post-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 90%;">
        <div class="modal-header">
            <span id="create-post-modal-title">发布动态</span> <!-- 使用ID方便JS修改标题 -->
        </div>
        <div class="modal-body">
            <!-- 公开文字输入区 -->
            <div class="form-group">
                <textarea id="post-public-text" rows="3" placeholder="分享新鲜事..."></textarea>
            </div>

            <!-- === 【新增】模式切换开关 === -->
            <div class="post-mode-switcher">
                <button id="switch-to-image-mode" class="mode-btn active">上传图片</button>
                <button id="switch-to-text-image-mode" class="mode-btn">使用文字图</button>
            </div>

            <!-- === 【新增】图片模式区域 === -->
            <div id="image-mode-content" class="post-mode-content active">
                <div class="form-group">
                    <div id="post-image-preview-container" class="post-image-preview-container">
                        <img id="post-image-preview" src="" alt="图片预览">
                        <button id="post-remove-image-btn">×</button>
                    </div>
                    <div class="post-image-upload-options">
                        <button id="post-upload-local-btn" class="form-button-secondary">本地上传</button>
                        <button id="post-use-url-btn" class="form-button-secondary">网络URL</button>
                        <input type="file" id="post-local-image-input" accept="image/*" hidden>
                    </div>
                </div>
                <!-- 这个是给AI看的图片描述，在微博模式下我们会用JS隐藏它 -->
                <div id="post-image-desc-group" class="form-group" style="display: none;">
                    <label>图片描述 (必填，给AI看)</label>
                    <input type="text" id="post-image-description" placeholder="简单描述图片内容，帮助AI理解">
                </div>
            </div>

            <!-- === 【新增】文字图模式区域 === -->
            <div id="text-image-mode-content" class="post-mode-content">
                <div class="form-group">
                    <label>文字图 (给AI理解用的描述，点击图片后可见)</label>
                    <textarea id="post-hidden-text" rows="4" placeholder="在这里写下图片描述..."></textarea>
                </div>
            </div>

<!-- ▼▼▼ 在这里粘贴下面这块新代码 ▼▼▼ -->
<div class="form-group" id="post-visibility-group">
    <label>可见范围</label>
    <div style="display: flex; gap: 20px; margin-bottom: 10px;">
        <label><input type="radio" name="visibility" value="all" checked> 所有人可见</label>
        <label><input type="radio" name="visibility" value="groups"> 仅分组可见</label>
    </div>
    <div id="post-visibility-groups" style="display: none; max-height: 120px; overflow-y: auto; background-color: #f0f2f5; padding: 10px; border-radius: 8px;">
        <!-- 分组的多选框会由JS动态生成在这里 -->
    </div>
</div>
<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->
            <!-- 这个是动态功能的评论开关，在微博模式下我们会用JS隐藏它 -->
            <div class="form-group" id="post-comments-toggle-group" style="margin-top: 15px;">
                <label for="post-comments-toggle" class="toggle-switch-label">
                    <span class="toggle-switch-text">允许角色看见评论区</span>
                    <input type="checkbox" id="post-comments-toggle" checked>
                    <span class="toggle-switch-slider"></span>
                </label>
            </div>
            
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-create-post-btn">取消</button>
            <button class="save" id="confirm-create-post-btn">发布</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->


<!-- ▼▼▼ 请将这个新的模态框HTML粘贴到所有其他模态框之后 ▼▼▼ -->
<div id="group-management-modal" class="modal">
    <div class="modal-content" style="height: 60%;">
        <div class="modal-header">
            <span>管理好友分组</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label>新建分组</label>
                <div style="display: flex; gap: 10px;">
                    <input type="text" id="new-group-name-input" placeholder="输入分组名..." style="flex-grow: 1;">
                    <button id="add-new-group-btn" class="form-button" style="width: auto; margin-top: 0; padding: 0 15px;">添加</button>
                </div>
            </div>
            <hr style="opacity: 0.2;">
            <div id="existing-groups-list" style="display: flex; flex-direction: column; gap: 10px;">
                <!-- 分组列表将由JS动态生成 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-group-manager-btn" style="width: 100%;">完成</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新代码粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 请将这段新HTML粘贴到所有模态框的末尾 ▼▼▼ -->
<div id="message-actions-modal" class="modal">
    <div id="custom-modal" style="width: 250px;">
        <div class="custom-modal-footer">
            <!-- 新的操作按钮 -->
            <button id="edit-message-btn">编辑消息</button>
            <button id="copy-message-btn">复制文本</button>
            <button id="recall-message-btn">撤回</button>
<button id="quote-message-btn">引用</button>
            <button id="select-message-btn">进入多选</button>
            <!-- 取消按钮 -->
            <button id="cancel-message-action-btn" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">取消</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 请将这段新HTML粘贴到所有模态框的末尾 ▼▼▼ -->
<div id="post-actions-modal" class="modal">
    <div id="custom-modal" style="width: 250px;">
        <div class="custom-modal-footer">
            <button id="edit-post-btn">编辑动态</button>
            <button id="copy-post-btn">复制内容</button>           
            <button id="cancel-post-action-btn">取消</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】可视化消息编辑器模态框 ▼▼▼ -->
<div id="message-editor-modal" class="modal">
    <div class="modal-content" style="height: 75%;">
        <div class="modal-header">
            <span>编辑与拆分消息</span>
        </div>
        <div class="modal-body" id="message-editor-body">
            <!-- 编辑器容器，JS会在这里动态生成文本框 -->
            <div id="message-editor-container"></div>
            <!-- 添加新消息的按钮 -->
            <button id="add-message-editor-block-btn" class="form-button form-button-secondary" style="margin-top: 15px;">
                [+] 添加下一条消息
            </button>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-advanced-editor-btn">取消</button>
            <button class="save" id="save-advanced-editor-btn">保存更改</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】外卖请求模态框 ▼▼▼ -->
<div id="waimai-request-modal" class="modal">
    <div class="modal-content" style="width: 290px;">
        <div class="modal-header">
            <span>发起外卖代付</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="waimai-product-info">商品信息</label>
                <input type="text" id="waimai-product-info" placeholder="例如：一杯杨枝甘露">
            </div>
            <div class="form-group">
                <label for="waimai-amount">代付金额 (元)</label>
                <input type="number" id="waimai-amount" placeholder="例如：21" min="0" step="0.01">
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="waimai-cancel-btn">取消</button>
            <button class="save" id="waimai-confirm-btn">发起请求</button>
        </div>
    </div>
</div>

<!-- ▼▼▼ 【全新】新建约定/倒计时模态框 ▼▼▼ -->
<div id="create-countdown-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span>新建约定</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="countdown-title-input">约定标题</label>
                <input type="text" id="countdown-title-input" placeholder="例如：我的生日">
            </div>
            <div class="form-group">
                <label for="countdown-date-input">约定日期与时间</label>
                <input type="datetime-local" id="countdown-date-input"style="width: 95%; padding: 8px; border-radius: 8px; border: 1px solid var(--border-color);">
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-create-countdown-btn">取消</button>
            <button class="save" id="confirm-create-countdown-btn">保存约定</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】发红包模态框 ▼▼▼ -->
<div id="red-packet-modal" class="modal">
    <div class="modal-content" style="width: 300px; height: auto;">
        <div class="modal-header">
            <span>发红包</span>
        </div>
        <div class="modal-body" style="padding: 0;">
<!-- 1. 页签切换 -->
<div class="frame-tabs">
    <div id="rp-tab-group" class="frame-tab active">拼手气红包</div>
    <div id="rp-tab-direct" class="frame-tab">专属红包</div>
</div>

            <!-- 2. 拼手气红包内容区 -->
            <div id="rp-content-group" class="frame-content" style="padding: 20px 15px;">
                <div class="form-group">
                    <label>总金额 (元)</label>
                    <input type="number" id="rp-group-amount" placeholder="0.00">
                </div>
                <div class="form-group">
                    <label>红包个数</label>
                    <input type="number" id="rp-group-count" placeholder="填写红包个数">
                </div>
                <div class="form-group">
                    <label>祝福语</label>
                    <input type="text" id="rp-group-greeting" placeholder="恭喜发财，大吉大利！">
                </div>
                <p id="rp-group-total" style="text-align: center; font-size: 24px; font-weight: bold; margin: 10px 0;">¥ 0.00</p>
                <button id="send-group-packet-btn" class="form-button">塞钱进红包</button>
            </div>

            <!-- 3. 专属红包内容区 -->
            <div id="rp-content-direct" class="frame-content" style="display: none; padding: 20px 15px;">
                <div class="form-group">
                    <label>发送给</label>
                    <select id="rp-direct-receiver"></select>
                </div>
                <div class="form-group">
                    <label>金额 (元)</label>
                    <input type="number" id="rp-direct-amount" placeholder="0.00">
                </div>
                <div class="form-group">
                    <label>祝福语</label>
                    <input type="text" id="rp-direct-greeting" placeholder="恭喜发财，大吉大利！">
                </div>
                 <p id="rp-direct-total" style="text-align: center; font-size: 24px; font-weight: bold; margin: 10px 0;">¥ 0.00</p>
                <button id="send-direct-packet-btn" class="form-button">塞钱进红包</button>
            </div>
        </div>
        <div class="modal-footer" style="justify-content: center;">
             <button class="cancel" id="cancel-red-packet-btn" style="width: 100%;">取消</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】红包详情模态框 ▼▼▼ -->
<div id="red-packet-details-modal" class="modal">
    <div class="modal-content" style="width: 280px; height: auto; background-color: #f7f7f7;">
        <div class="modal-header" style="background-color: #F96259; color: white; border-bottom: none; padding-bottom: 5px;">
            <div style="text-align: center; width: 100%;">
                <div id="rp-details-sender" style="font-size: 16px;"></div>
                <div style="font-size: 13px; opacity: 0.8;">的红包</div>
            </div>
        </div>
        <div class="modal-body" style="padding: 15px;">
            <p id="rp-details-greeting" style="text-align: center; font-size: 20px; color: #333; margin: 0 0 20px 0;"></p>
            <div id="rp-details-my-amount" style="text-align: center; display: none; margin-bottom: 20px;">
                <span style="font-size: 40px; font-weight: bold; color: #E44D44;">0.00</span>
                <span style="font-size: 18px; color: #E44D44;">元</span>
            </div>
            <div id="rp-details-summary" style="font-size: 13px; color: #8a8a8a; border-top: 1px solid #e0e0e0; padding-top: 10px;"></div>
            <div id="rp-details-list" style="max-height: 150px; overflow-y: auto; margin-top: 10px;">
                <!-- 领取详情将由JS动态生成在这里 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-rp-details-btn" style="width: 100%;">关闭</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】创建投票模态框 ▼▼▼ -->
<div id="create-poll-modal" class="modal">
    <div class="modal-content" style="width: 300px; height: auto;">
        <div class="modal-header">
            <span>发起投票</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="poll-question-input">投票问题</label>
                <textarea id="poll-question-input" rows="2" placeholder="例如：今晚我们看什么电影？"></textarea>
            </div>
            <div class="form-group">
                <label>投票选项 (至少2项)</label>
                <div id="poll-options-container" style="display: flex; flex-direction: column; gap: 8px;">
                    <!-- 投票选项将由JS动态生成在这里 -->
                </div>
                <button id="add-poll-option-btn" class="form-button form-button-secondary" style="margin-top: 12px;">+ 添加选项</button>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-create-poll-btn">取消</button>
            <button class="save" id="confirm-create-poll-btn">发起投票</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】AI头像库管理模态框 ▼▼▼ -->
<div id="ai-avatar-library-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span id="ai-avatar-library-title">对方的头像库</span>
            <button id="add-ai-avatar-btn" class="action-button">添加</button>
        </div>
        <div class="modal-body" style="padding: 15px;">
            <div id="ai-avatar-library-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 15px;">
                <!-- 头像库内容将由JS动态生成 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-ai-avatar-library-btn" style="width: 100%;">关闭</button>
        </div>
    </div>
</div>

<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】用户分享链接模态框 ▼▼▼ -->
<div id="share-link-modal" class="modal">
    <div class="modal-content" style="width: 300px; height: auto;">
        <div class="modal-header">
            <span>分享链接</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="link-title-input">标题</label>
                <input type="text" id="link-title-input" placeholder="输入文章或链接的标题">
            </div>
            <div class="form-group">
                <label for="link-description-input">摘要 (可选)</label>
                <textarea id="link-description-input" rows="2" placeholder="简单描述一下链接内容"></textarea>
            </div>
            <div class="form-group">
                <label for="link-source-input">来源名称 (可选)</label>
                <input type="text" id="link-source-input" placeholder="例如：知乎日报、B站">
            </div>
            <div class="form-group">
                <label for="link-content-input">完整内容 (可选，用于浏览器内显示)</label>
                <textarea id="link-content-input" rows="4" placeholder="粘贴或输入完整的文章内容"></textarea>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-share-link-btn">取消</button>
            <button class="save" id="confirm-share-link-btn">分享</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】精致版转账操作弹窗 ▼▼▼ -->
<div id="transfer-actions-modal" class="modal">
    <div class="transfer-actions-content">
        <div class="transfer-actions-header">请选择操作</div>
        <div class="transfer-actions-body">
            <p>你收到了来自 <strong id="transfer-sender-name"></strong> 的一笔转账。</p>
        </div>
        <div class="transfer-actions-footer">
            <button id="transfer-action-decline" class="action-btn decline">残忍拒绝</button>
            <button id="transfer-action-accept" class="action-btn accept">开心收下</button>
        </div>
        <button id="transfer-action-cancel" class="cancel-btn">×</button>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】通话记录详情模态框 ▼▼▼ -->
<div id="call-transcript-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span id="transcript-modal-title">通话详情</span>
        </div>
        <div class="modal-body" id="transcript-modal-body" style="background-color: #f0f2f5;">
            <!-- 通话文字记录将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="delete-transcript-btn" style="background-color: #ff3b30; color: white; border-color: #ff3b30;">删除记录</button>
            <button class="save" id="close-transcript-modal-btn" style="width: 100%;">关闭</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】分享目标选择器模态框 ▼▼▼ -->
<div id="share-target-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
<div class="modal-header">
    <span id="share-target-modal-title">分享到...</span>
</div>
        <div class="modal-body" id="share-target-list" style="padding: 0;">
            <!-- 聊天列表将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-share-target-btn">取消</button>
            <button class="save" id="confirm-share-target-btn">确认分享</button>
        </div>
    </div>
</div>

<!-- ▼▼▼ 【全新】分享记录查看器模态框 ▼▼▼ -->
<div id="shared-history-viewer-modal" class="modal">
    <div class="modal-content" style="height: 80%;">
        <div class="modal-header">
            <span id="shared-history-viewer-title">聊天记录</span>
        </div>
        <div class="modal-body" id="shared-history-viewer-content" style="background-color: #f0f2f5;">
            <!-- 分享的聊天记录气泡将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button class="save" id="close-shared-history-viewer-btn" style="width:100%;">关闭</button>
        </div>
    </div>
</div>

<!-- ▼▼▼ 【全新】世界书分类管理模态框 ▼▼▼ -->
<div id="world-book-category-manager-modal" class="modal">
    <div class="modal-content" style="height: 60%;">
        <div class="modal-header">
            <span>管理世界书分类</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label>新建分类</label>
                <div style="display: flex; gap: 10px;">
                    <input type="text" id="new-category-name-input" placeholder="输入分类名..." style="flex-grow: 1;">
                    <button id="add-new-category-btn" class="form-button" style="width: auto; margin-top: 0; padding: 0 15px;">添加</button>
                </div>
            </div>
            <hr style="opacity: 0.2;">
            <div id="existing-categories-list" style="display: flex; flex-direction: column; gap: 10px;">
                <!-- 分类列表将由JS动态生成 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-category-manager-btn" style="width: 100%;">完成</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】角色专属NPC库管理界面 ▼▼▼ -->
<div id="npc-management-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="back-from-npc-management">‹</span>
        <span id="npc-management-title">NPC 库管理</span>
        <span class="action-btn" id="add-new-npc-btn">+</span>
    </div>
    <div class="list-container" id="npc-management-list">
        <!-- NPC列表将由JS动态生成在这里 -->
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】在这里粘贴所有论坛相关的HTML代码 ▼▼▼ -->

<!-- 1. 论坛主屏幕 (显示所有小组) -->
<div id="forum-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <span>圈子</span>
        <div class="header-actions">
                  <!-- ▼▼▼ 在这里添加筛选图标 ▼▼▼ -->
        <span class="action-btn filter-btn" id="forum-filter-btn" title="筛选">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon></svg>
        </span>
        <!-- ▲▲▲ 添加结束 ▲▲▲ -->
            <span class="action-btn" id="create-group-btn" style="font-size: 28px; font-weight: 300;">+</span>
        </div>
    </div>
    <div id="forum-group-list" class="list-container" style="padding: 15px; display: grid; grid-template-columns: 1fr 1fr; gap: 15px; align-content: start;">
        <!-- 小组列表将由JS动态生成在这里 -->
    </div>
</div>

<!-- ▼▼▼ 用这整块代码替换旧的 id="group-screen" ▼▼▼ -->
<div id="group-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="back-to-forum-list">‹</span>
        <span id="group-screen-title">小组名称</span>
        <div class="header-actions">
                  <!-- ▼▼▼ 在这里添加筛选图标 ▼▼▼ -->
        <span class="action-btn filter-btn" id="group-filter-btn" title="筛选">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon></svg>
        </span>
        <!-- ▲▲▲ 添加结束 ▲▲▲ -->
            <!-- 【核心修改】我们在这里新增了一个通用的“生成内容”按钮 -->
            <span class="action-btn" id="generate-group-content-btn" title="生成内容">
                <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></svg>
            </span>
            <span class="action-btn" id="create-forum-post-btn" style="font-size: 28px; font-weight: 300;">+</span>
        </div>
    </div>
<!-- ▼▼▼ 用这块新代码替换 ▼▼▼ -->
<div id="fanfic-preference-bar" style="display: none; padding: 10px 15px; background-color: #f0f2f5; border-bottom: 1px solid var(--border-color); flex-shrink: 0;">
    <div class="form-group" style="margin: 0;">
        <label style="font-size: 14px; margin-bottom: 5px;">选择CP偏好</label>
        <div style="display: flex; align-items: center; gap: 10px;">
            <select id="fanfic-char1-select" style="flex: 1;"></select>
            <span>&</span>
            <select id="fanfic-char2-select" style="flex: 1;"></select>
            <button id="trigger-fanfic-generation-btn" class="form-button" style="margin: 0; padding: 10px 15px; width: auto;">生成</button>
        </div>
    </div>
    <!-- 这是我们新加的世界观输入框 -->
    <div class="form-group" style="margin-top: 10px; margin-bottom: 0;">
        <label for="fanfic-worldview-input" style="font-size: 14px; margin-bottom: 5px;">世界观偏好 (可选)</label>
        <input type="text" id="fanfic-worldview-input" placeholder="例如：ABO、哨向、现代大学AU...">
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->

    <div id="group-post-list" class="list-container" style="padding-top: 0;">
        <!-- 帖子列表将由JS动态生成在这里 -->
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->


<!-- 3. 单个帖子页面 (显示帖子内容和评论) -->
<div id="post-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="back-to-group-screen">‹</span>
        <span>帖子详情</span>
        <div class="header-actions">
            <span class="action-btn" id="repost-to-chat-btn">转载</span>
        </div>
    </div>
    <div id="post-detail-content" class="list-container" style="padding: 20px;">
        <!-- 帖子和评论将由JS动态生成在这里 -->
    </div>
    <!-- 帖子页的评论输入框 -->
    <div id="post-comment-input-area" class="chat-input-area" style="visibility: visible;">
         <div class="chat-input-main-row">
            <textarea id="post-comment-input" rows="1" placeholder="发布你的评论..."></textarea>
            <button id="send-post-comment-btn" class="action-button">发送</button>
        </div>
    </div>
</div>
<!-- ▼▼▼ 【全新】这是为圈子分类筛选新增的弹窗 ▼▼▼ -->
<div id="forum-filter-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 60%;">
        <div class="modal-header">
            <span>按分类筛选</span>
        </div>
        <div class="modal-body">
            <div id="forum-filter-category-list">
                <!-- 分类标签将由JS动态生成在这里 -->
            </div>
        </div>
        <div class="modal-footer" style="justify-content: space-between;">
            <button class="cancel" id="reset-forum-filter-btn" style="width: 30%;">重置</button>
            <button class="cancel" id="cancel-forum-filter-btn" style="width: 30%;">取消</button>
            <button class="save" id="apply-forum-filter-btn" style="width: 30%;">应用</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->


<!-- ▲▲▲ 论坛相关HTML代码粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】自定义头像框管理模态框 ▼▼▼ -->
<div id="custom-frame-manager-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span>管理我的头像框</span>
            <button id="upload-custom-frame-btn" class="action-button">上传</button>
        </div>
        <div class="modal-body" style="padding: 15px;">
            <div id="custom-frame-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 15px;">
                <!-- 自定义头像框将由JS动态生成在这里 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-frame-manager-btn" style="width: 100%;">关闭</button>
        </div>
    </div>
</div>
<input type="file" id="custom-frame-upload-input" accept="image/png, image/gif" hidden multiple>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->

<!-- ▼▼▼ 【已修改】头像框选择模态框 ▼▼▼ -->
<div id="avatar-frame-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span>选择头像框</span>
            <!-- 【核心修改】我们在这里加一个“管理”按钮 -->
            <button id="manage-custom-frames-btn" class="action-button">管理</button>
        </div>
        <div class="modal-body" style="padding: 15px;">
            <!-- 【核心修改】不再需要Tabs，只有一个Grid -->
            <div id="avatar-frame-grid" class="frame-grid">
                <!-- 头像框选项（包括“无”和自定义的）会在这里生成 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-frame-settings-btn">取消</button>
            <button class="save" id="save-frame-settings-btn">保存</button>
        </div>
    </div>
</div>

<!-- ▼▼▼ 用这整块【全新设计】的代码，替换旧的 id="send-location-modal" ▼▼▼ -->
<div id="send-location-modal" class="modal">
    <div class="modal-content" style="width: 300px; height: auto; max-height: 80%;">
        <div class="modal-header">
            <span>发送定位与轨迹</span>
        </div>
        <div class="modal-body" style="padding-bottom: 5px;">
            <!-- 核心信息 -->
            <div class="form-group">
                <label for="user-location-input">我的位置 (起点)</label>
                <input type="text" id="user-location-input" placeholder="例如：市中心的咖啡馆">
            </div>
            <div class="form-group">
                <label for="ai-location-input">Ta的位置 (终点)</label>
                <input type="text" id="ai-location-input" placeholder="例如：海边的灯塔">
            </div>
            <div class="form-group">
                <label for="distance-input">相距</label>
                <input type="text" id="distance-input" placeholder="例如：约5公里 (必填)">
            </div>
            
            <hr style="opacity: 0.2;">

            <!-- 【全新】行动轨迹输入区 -->
            <div class="form-group">
                <label>行动轨迹 (可选，按顺序填写)</label>
                <div id="trajectory-points-container" style="display: flex; flex-direction: column; gap: 8px;">
                    <!-- JS会在这里动态添加输入框 -->
                </div>
                <button id="add-trajectory-point-btn" class="form-button form-button-secondary" style="margin-top: 12px;">+ 添加途经点</button>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="location-cancel-btn">取消</button>
            <button class="save" id="location-confirm-btn">发送</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】粘贴悬浮歌词栏设置模态框 ▼▼▼ -->
<div id="lyrics-settings-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span>悬浮歌词设置</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="lyrics-font-size-slider">字体大小: <span id="lyrics-font-size-value">14px</span></label>
                <input type="range" id="lyrics-font-size-slider" min="12" max="24" value="14" style="width: 100%;">
            </div>
            <div class="form-group">
                <label for="lyrics-bg-opacity-slider">背景不透明度: <span id="lyrics-bg-opacity-value">0%</span></label>
                <input type="range" id="lyrics-bg-opacity-slider" min="0" max="100" value="0" style="width: 100%;">
            </div>
            <div class="form-group">
                <label for="lyrics-font-color-picker">字体颜色</label>
                <input type="color" id="lyrics-font-color-picker" value="#FFFFFF" style="width: 100%; height: 40px;">
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="reset-lyrics-settings-btn">恢复默认</button>
            <button class="save" id="close-lyrics-settings-btn">完成</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】这是“选择搜索源”的弹窗，请粘贴到body末尾 ▼▼▼ -->
<div id="music-source-selector-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span>选择搜索源</span>
        </div>
        <div class="modal-body" style="text-align: left; padding: 20px;">
            <label style="display: block; margin-bottom: 15px; cursor: pointer;">
                <input type="radio" name="search-source" value="all" checked> 全部来源 (网易云 + QQ音乐)
            </label>
            <label style="display: block; margin-bottom: 15px; cursor: pointer;">
                <input type="radio" name="search-source" value="netease"> 仅网易云音乐
            </label>
            <label style="display: block; cursor: pointer;">
                <input type="radio" name="search-source" value="tencent"> 仅QQ音乐
            </label>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-source-select-btn">取消</button>
            <button class="save" id="confirm-source-select-btn">开始搜索</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
 <!-- ▼▼▼ 【全新】这是微博关注列表的弹窗，粘贴到 </body> 前面 ▼▼▼ -->
<div id="weibo-following-modal" class="modal">
    <div class="modal-content" style="height: 60%;">
        <div class="modal-header">
            <span>关注列表</span>
        </div>
        <div class="modal-body" style="padding: 0;">
            <!-- 【核心】这个容器将带滚动条 -->
            <div id="weibo-following-list-container">
                <!-- 关注列表将由JS动态生成在这里 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-following-list-btn" style="width: 100%;">关闭</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->
<!-- 塔罗牌占卜主模态框 -->
<div id="tarot-divination-modal" class="modal">
    <div class="modal-content" style="height: 85%; width: 95%;">
        
        <!-- 1. 占卜设置界面 -->
        <div id="tarot-setup-view">
            <div class="modal-header">
                <span>塔罗牌占卜</span>
                <div>
                    <span id="tarot-history-btn" class="action-btn" style="font-size: 16px;">历史</span>
                    <span id="close-tarot-modal-btn" class="action-btn" style="font-size: 16px;">关闭</span>
                </div>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="tarot-question-input">您的问题或关注点</label>
                    <textarea id="tarot-question-input" rows="2" placeholder="例如：我近期的桃花运如何？"></textarea>
                </div>
                <div class="form-group">
                    <label for="tarot-spread-select">选择牌阵</label>
                    <select id="tarot-spread-select">
                        <option value="single">单张牌 - 快速指引</option>
                        <option value="three_past_present_future">三张牌 - 过去/现在/未来</option>
                        <option value="three_situation_challenge_advice">三张牌 - 情境/挑战/建议</option>
                        <option value="celtic_cross">凯尔特十字 - 深度分析 (10张牌)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>牌面方向</label>
                    <div style="display: flex; gap: 20px;">
                        <label><input type="radio" name="tarot-orientation" value="upright" checked> 仅正位</label>
                        <label><input type="radio" name="tarot-orientation" value="reversed"> 包含逆位</label>
                    </div>
                </div>
                <button id="draw-tarot-cards-btn" class="form-button" style="margin-top: 20px;">洗牌并抽牌</button>
            </div>
        </div>

        <!-- 2. 占卜结果界面 (默认隐藏) -->
        <div id="tarot-result-view" style="display: none; height: 100%; display: flex; flex-direction: column;">
            <div class="modal-header">
                <span id="back-to-tarot-setup-btn" class="action-btn" style="font-size: 16px;">返回</span>
                <span>占卜结果</span>
            </div>
            <div class="modal-body" id="tarot-result-display">
                <!-- 结果将由JS动态生成在这里 -->
            </div>
            <div class="modal-footer">
                <button id="send-tarot-result-btn" class="save" style="width: 100%;">发给塔罗师解读</button>
            </div>
        </div>

        <!-- 3. 历史记录界面 (默认隐藏) -->
        <div id="tarot-history-view" style="display: none; height: 100%; display: flex; flex-direction: column;">
            <div class="modal-header">
                <span id="back-to-tarot-main-btn" class="action-btn" style="font-size: 16px;">返回</span>
                <span>占卜历史</span>
            </div>
            <div class="modal-body" id="tarot-history-list">
                <!-- 历史记录将由JS动态生成在这里 -->
            </div>
        </div>
    </div>
</div>
<!-- ▼▼▼ 【全新】这里是整个情侣空间功能的HTML代码 ▼▼▼ -->
<!-- 2. 切换角色的弹窗 -->
<div id="ls-char-selector-modal" class="modal">
    <div class="modal-content" style="height: 60%;">
        <div class="modal-header">
            <span>选择空间</span>
        </div>
        <div class="modal-body" id="ls-char-selector-list" style="padding: 0;">
            <!-- 角色列表会由JS动态生成 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="ls-cancel-switch-char-btn" style="width:100%;">取消</button>
        </div>
    </div>
</div>

<!-- 3. 发布说说的弹窗 -->
<div id="ls-create-moment-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span>想对Ta说...</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <textarea id="ls-moment-content-input" rows="5" placeholder="在这里写下你们的私密话语..."></textarea>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="ls-cancel-moment-btn">取消</button>
            <button class="save" id="ls-confirm-moment-btn">发布</button>
        </div>
    </div>
</div>

<!-- ▼▼▼ 用这整块新代码，替换掉你旧的 ls-create-album-modal ▼▼▼ -->
<!-- 4. 创建相册/上传照片的弹窗 (这是修改后的版本) -->
<div id="ls-create-album-modal" class="modal">
     <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <!-- 标题已修改 -->
            <span id="ls-album-modal-title">上传照片</span>
        </div>
        <div class="modal-body">
            <!-- 新增：模式切换开关 (复用动态的样式) -->
            <div class="post-mode-switcher">
                <button id="ls-switch-to-image-mode" class="mode-btn active">上传图片</button>
                <button id="ls-switch-to-text-image-mode" class="mode-btn">使用文字图</button>
            </div>

            <!-- 模式1: 上传图片 -->
            <div id="ls-image-mode-content" class="post-mode-content active">
                <div class="form-group">
                    <label>选择照片 (仅限单张)</label>
                    <div id="ls-photo-preview-container"></div>
                    <button class="form-button form-button-secondary" id="ls-select-photos-btn">选择照片</button>
                    <!-- 关键：这里的 input 移除了 multiple 属性，现在只能单选 -->
                    <input type="file" id="ls-photo-input" accept="image/*" hidden>
                </div>
                 <div class="form-group">
                    <label>图片描述 (必填)</label>
                    <textarea id="ls-photo-desc-input" rows="3" placeholder="为这张照片写下注脚..."></textarea>
                </div>
            </div>

            <!-- 模式2: 使用文字图 -->
            <div id="ls-text-image-mode-content" class="post-mode-content" style="display: none;">
                <div class="form-group">
                    <label>文字图描述 (必填)</label>
                    <textarea id="ls-text-image-desc-input" rows="5" placeholder="在这里写下你的心情或故事..."></textarea>
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="ls-cancel-album-btn">取消</button>
            <button class="save" id="ls-confirm-album-btn">确认上传</button>
        </div>
    </div>
</div><!-- ▼▼▼ 把这一整块全新的HTML代码，粘贴到 </body> 标签的正上方 ▼▼▼ -->

<!-- 【全新】情侣空间-写情书/回信的弹窗 -->
<div id="ls-create-letter-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span id="ls-letter-modal-title">给Ta写一封信</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="ls-letter-recipient-input">收信人</label>
                <!-- 收信人通常是固定的，所以我们禁用这个输入框 -->
                <input type="text" id="ls-letter-recipient-input" disabled>
            </div>
            <div class="form-group">
                <label for="ls-letter-content-input">情书内容</label>
                <textarea id="ls-letter-content-input" rows="8" placeholder="在这里写下你的心意..."></textarea>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="ls-cancel-letter-btn">取消</button>
            <button class="save" id="ls-confirm-letter-btn">寄出</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 把这一整块全新的HTML代码，粘贴到 </body> 标签的正上方 ▼▼▼ -->

<!-- 【全新美化版】情侣空间-情书查看器 -->
<div id="ls-letter-viewer-modal" class="modal">
    <div class="ls-letter-viewer-content">
        <!-- 头部：收信人信息 -->
        <div class="letter-viewer-header">
            <img id="ls-viewer-recipient-avatar" class="meta-avatar">
            <div class="recipient-info">
                <div class="label">To my dear:</div>
                <div id="ls-viewer-recipient-name" class="name"></div>
            </div>
        </div>
        <!-- 中间：信件正文 -->
        <div id="ls-viewer-body" class="letter-viewer-body">
            <!-- JS会在这里填充信件内容 -->
        </div>
        <!-- 底部：发信人信息和操作按钮 -->
        <div class="letter-viewer-footer">
            <div class="sender-info">
                <div id="ls-viewer-sender-name"></div>
                <div id="ls-viewer-timestamp" class="timestamp"></div>
            </div>
            <div class="letter-actions">
                <button id="ls-close-letter-viewer-btn">关闭</button>
                <button id="ls-reply-letter-btn" class="primary">回信</button>
            </div>
        </div>
    </div>
</div>

<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->

<!-- ▲▲▲ 替换结束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】情侣空间设置弹窗 ▼▼▼ -->
<div id="ls-settings-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span>情侣空间设置</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="ls-start-date-input">我们在一起的第一天</label>
                <input type="date" id="ls-start-date-input" style="width: 100%; padding: 10px; box-sizing: border-box;">
            </div>
            
            <!-- ▼▼▼ 你新加的代码会出现在这里 ▼▼▼ -->
            <hr style="opacity: 0.2; margin: 20px 0;">
            <div class="form-group">
                <label>危险操作</label>
                <div style="display: flex; gap: 10px;">
                    <button id="ls-cancel-space-btn" class="form-button form-button-secondary" style="background-color: #ffe5e5; color: #ff3b30; border-color: #ffc2d1; flex: 1; margin:0;">取消空间</button>
                    <button id="ls-disconnect-space-btn" class="form-button form-button-secondary" style="background-color: #ff3b30; color: white; border-color: #ff3b30; flex: 1; margin:0;">解除关系</button>
                </div>
                 <p style="font-size: 12px; color: #8a8a8a; margin-top: 8px;">
                    <strong>取消空间</strong>: 将空间变为未启用状态，但保留所有数据。不会通知对方。<br>
                    <strong>解除关系</strong>: 同样会取消空间，但会通知对方关系已解除，对方会对此发表意见。
                </p>
            </div>
            <!-- ▲▲▲ 新代码结束 ▲▲▲ -->

        </div>
        <div class="modal-footer">
            <button class="cancel" id="ls-settings-cancel-btn">取消</button>
            <button class="save" id="ls-settings-save-btn">保存</button>
        </div>
    </div>
</div>

<!-- ▼▼▼ 把这一整块全新的HTML代码，粘贴到 </body> 标签的正上方 ▼▼▼ -->

<!-- 【全新】情侣空间-提问弹窗 -->
<div id="ls-ask-question-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span>发起一个提问</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <textarea id="ls-question-content-input" rows="5" placeholder="向Ta提个问题吧..."></textarea>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="ls-cancel-ask-btn">取消</button>
            <button class="save" id="ls-confirm-ask-btn">向Ta提问</button>
        </div>
    </div>
</div>

<!-- 【全新】情侣空间-回答弹窗 -->
<div id="ls-answer-question-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span>回答Ta的问题</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label>问题：</label>
                <p id="ls-answer-question-text" style="background-color: #f0f2f5; padding: 10px; border-radius: 8px;"></p>
            </div>
            <div class="form-group">
                <label for="ls-answer-content-input">你的回答：</label>
                <textarea id="ls-answer-content-input" rows="5" placeholder="认真回答哦..."></textarea>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="ls-cancel-answer-btn">取消</button>
            <button class="save" id="ls-confirm-answer-btn">确认回答</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】这是情侣空间专属音乐播放器的HTML代码 ▼▼▼ -->

<!-- 1. 这是播放器专属的音频引擎 -->
<audio id="ls-audio-player" style="display:none;"></audio>

<!-- 2. 这是播放器的主窗口界面 -->
<div id="ls-music-player-overlay" class="modal">
    <div class="music-player-window">
<!-- 【全新】封面和歌词的切换容器 -->
<div id="ls-display-area" style="width: 192px; height: 192px; margin-bottom: 20px; cursor: pointer;">
    <!-- 歌曲封面 -->
    <img id="ls-album-cover" src="https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png" alt="歌曲封面" style="width: 100%; height: 100%; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.2);">
    
    <!-- 歌词容器 -->
    <div id="ls-lyrics-container" style="display: none; width: 100%; height: 100%; overflow: hidden; text-align: center; color: #333; font-weight: 500;">
        <div id="ls-lyrics-list" style="transition: transform 0.5s ease;">
             <!-- 歌词会显示在这里 -->
        </div>
    </div>
</div>

        <!-- 歌曲信息 -->
        <div id="ls-song-title" style="font-size: 18px; font-weight: 600;">暂无歌曲</div>
        <div id="ls-artist" style="font-size: 14px; color: #666; margin-bottom: 15px;">...</div>
        
        <!-- 进度条 -->
        <div class="music-progress-bar-container" style="width: 100%;">
            <div id="ls-current-time" class="time-display">0:00</div>
            <div class="progress-bar" id="ls-progress-bar">
                <div id="ls-progress-fill" class="progress-bar-fill"></div>
            </div>
            <div id="ls-total-time" class="time-display">0:00</div>
        </div>
        
        <!-- 控制按钮 -->
        <div class="music-controls" style="margin-bottom: 15px;">
            <button id="ls-prev-btn">◀</button>
            <button id="ls-play-pause-btn" class="play-pause-btn">▶</button>
            <button id="ls-next-btn">▶</button>
        </div>
        
        <!-- 底部操作按钮 -->
        <div class="music-bottom-actions" style="width: 100%;">
            <button id="ls-playlist-btn" style="background-color: rgba(0, 123, 255, 0.1); color: var(--accent-color); margin-right: 5px;">播放列表</button>
            <button id="ls-close-player-btn" style="background-color: rgba(0,0,0,0.05); color: #333; margin-left: 5px;">关闭</button>
        </div>
    </div>
</div>

<!-- 3. 这是播放列表的侧滑面板 -->
<div id="ls-music-playlist-panel" class="music-playlist-panel">
    <div class="playlist-header">
        <span class="panel-btn" id="ls-close-playlist-btn">返回</span>
        <span>播放列表</span>
        <span class="panel-btn" id="ls-clear-playlist-btn" style="color: #ff3b30;">清空</span>
    </div>
    <div class="playlist-body" id="ls-playlist-body">
        <!-- 播放列表内容会在这里生成 -->
    </div>
</div>

<!-- ▲▲▲ HTML代码粘贴结束 ▲▲▲ -->
<!-- ▼▼▼ 把这一整块全新的HTML代码，粘贴到 </body> 标签的正上方 ▼▼▼ -->

<!-- 【全新】情侣番茄钟-设置弹窗 -->
<div id="ls-pomodoro-setup-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span>新的专注时光</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="pomodoro-task-input">专注任务</label>
                <input type="text" id="pomodoro-task-input" placeholder="例如：学习JS、完成工作报告">
            </div>
            <div class="form-group">
                <label for="pomodoro-duration-input">专注时长 (分钟)</label>
                <input type="number" id="pomodoro-duration-input" value="25" min="1">
            </div>
<div class="form-group">
    <label>计时模式</label>
    <div style="display: flex; gap: 20px;">
        <label><input type="radio" name="pomodoro-mode" value="countdown" checked> 倒计时</label>
        <label><input type="radio" name="pomodoro-mode" value="countup"> 正计时</label>
    </div>
</div>
            <div class="form-group">
                <label for="pomodoro-talk-interval-input">角色鼓励间隔 (分钟, 0为不自动鼓励)</label>
                <input type="number" id="pomodoro-talk-interval-input" value="5" min="0">
            </div>
<!-- ▼▼▼ 这是修改后的番茄钟背景设置 ▼▼▼ -->
<div class="form-group">
    <label>自定义背景 (可选)</label>
    <div style="display: flex; gap: 10px; align-items: center;">
        <input type="text" id="pomodoro-bg-url-input" placeholder="粘贴图片URL" style="flex-grow: 1;">
        <button id="pomodoro-bg-local-upload-btn" class="form-button-secondary" style="margin: 0; padding: 12px; width: auto;">本地上传</button>
    </div>
    <input type="file" id="pomodoro-bg-file-input" accept="image/*" hidden>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="pomodoro-cancel-setup-btn">取消</button>
            <button class="save" id="pomodoro-confirm-setup-btn">开始专注</button>
        </div>
    </div>
</div>

<!-- 【全新】情侣番茄钟-历史详情弹窗 -->
<div id="ls-pomodoro-history-viewer-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span id="pomodoro-history-viewer-title">专注记录</span>
        </div>
        <div class="modal-body" id="pomodoro-history-viewer-content">
            <!-- 聊天记录会由JS生成在这里 -->
        </div>
        <div class="modal-footer">
            <button class="save" id="pomodoro-close-history-viewer-btn" style="width:100%;">关闭</button>
        </div>
    </div>
</div>

<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->

<!-- ▲▲▲ 情侣空间HTML代码结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】这是为“圈子”功能新增的所有弹窗 ▼▼▼ -->

<!-- 1. 小组编辑器弹窗 (用于修改小组信息和世界观) -->
<div id="forum-group-editor-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 80%;">
        <div class="modal-header">
            <span>编辑小组信息</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="group-editor-name-input">小组名称</label>
                <input type="text" id="group-editor-name-input">
            </div>
            <div class="form-group">
                <label for="group-editor-desc-input">小组简介</label>
                <input type="text" id="group-editor-desc-input">
            </div>
            <div class="form-group">
                <label for="group-editor-icon-input">小组图标 (Emoji)</label>
                <input type="text" id="group-editor-icon-input" maxlength="2">
            </div>
            <div class="form-group">
                <label for="group-editor-categories-input">小组分类 (用#号分隔, 例如: #科幻 #未来)</label>
                <input type="text" id="group-editor-categories-input" placeholder="例如: #科幻 #未来">
            </div>
            <div class="form-group">
                <label for="group-editor-worldview-input">小组世界观 (供AI生成内容时参考)</label>
                <textarea id="group-editor-worldview-input" rows="5" placeholder="详细描述这个小组独特的背景设定..."></textarea>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-group-editor-btn">取消</button>
            <button class="save" id="save-group-editor-btn">保存</button>
        </div>
    </div>
</div>

<!-- 2. 分类管理弹窗 -->
<div id="forum-category-manager-modal" class="modal">
    <div class="modal-content" style="height: 60%;">
        <div class="modal-header">
            <span>管理圈子分类</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label>新建分类</label>
                <div style="display: flex; gap: 10px;">
                    <input type="text" id="new-forum-category-name-input" placeholder="输入分类名，无需带'#'..." style="flex-grow: 1;">
                    <button id="add-new-forum-category-btn" class="form-button" style="width: auto; margin-top: 0; padding: 0 15px;">添加</button>
                </div>
            </div>
            <hr style="opacity: 0.2;">
            <div id="existing-forum-categories-list" style="display: flex; flex-direction: column; gap: 10px;">
                <!-- 分类列表将由JS动态生成 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-forum-category-manager-btn" style="width: 100%;">完成</button>
        </div>
    </div>
</div>

<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】这是游戏大厅的主界面，粘贴到所有 modal 的 div 之后、<script> 标签之前 ▼▼▼ -->
<div id="game-hall-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <span>游戏大厅</span>
        <span style="width: 30px;"></span> <!-- 占位符 -->
    </div>
    <div class="list-container" style="padding: 20px;">
        <p style="text-align: center; color: var(--text-secondary);">选择一个游戏开始吧！</p>
        <div id="game-hall-grid">
            <!-- 游戏列表将显示在这里 -->
            <div class="game-card" data-game="werewolf">
                <div class="game-icon">🐺</div>
                <div class="game-info">
                    <div class="game-title">狼人杀</div>
                    <div class="game-desc">逻辑与谎言的对决</div>
                </div>
            </div>
            <div class="game-card" data-game="sea-turtle-soup">
                <div class="game-icon">🐢</div>
                <div class="game-info">
                    <div class="game-title">海龟汤</div>
                    <div class="game-desc">揭开情景的真相</div>
                </div>
            </div>
             <div class="game-card" data-game="script-kill">
                <div class="game-icon">📜</div>
                <div class="game-info">
                    <div class="game-title">剧本杀</div>
                    <div class="game-desc">扮演角色，探寻谜案</div>
                </div>
            </div>
            <div class="game-card" data-game="guess-what">
                <div class="game-icon">🗣️</div>
                <div class="game-info">
                    <div class="game-title">你说我猜</div>
                    <div class="game-desc">考验默契的时候到了</div>
                </div>
            </div>
<div class="game-card" data-game="ludo">
    <div class="game-icon">🎲</div>
    <div class="game-info">
        <div class="game-title">心动飞行棋</div>
        <div class="game-desc">和Ta来一场只属于你们的冒险</div>
    </div>
</div>
<!-- ▲▲▲ 新增代码结束 ▲▲▲ -->
 <!-- ▼▼▼ 在这里粘贴新的游戏卡片 ▼▼▼ -->
<div class="game-card" data-game="undercover">
    <div class="game-icon">🕵️</div>
    <div class="game-info">
        <div class="game-title">谁是卧底</div>
        <div class="game-desc">语言的伪装，逻辑的陷阱</div>
    </div>
</div>
<!-- ▲▲▲ 新增代码结束 ▲▲▲ -->
             <p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); font-size: 14px; margin-top: 20px;">更多游戏正在火速开发中...</p>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】这是整个狼人杀功能的HTML，粘贴到 game-hall-screen 的 div 之后 ▼▼▼ -->

<!-- 1. 狼人杀游戏设置屏幕 -->
<div id="werewolf-setup-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('game-hall-screen')">‹</span>
        <span>狼人杀 - 游戏设置</span>
    </div>
    <div class="form-container">
        <div class="form-group">
            <label for="werewolf-player-count">选择游戏人数</label>
            <select id="werewolf-player-count">
                <option value="6">6人局 (2狼, 2民, 预言家, 守卫)</option>
                <option value="9">9人局 (3狼, 3民, 预言家, 女巫, 猎人)</option>
                <option value="12">12人局 (4狼, 4民, 预言家, 女巫, 猎人, 白痴)</option>
            </select>
        </div>
        <div class="form-group">
            <label>邀请玩家 (你已自动加入)</label>
            <div id="werewolf-player-selection" class="list-container" style="height: 300px; border: 1px solid var(--border-color); border-radius: 8px;">
                <!-- 玩家选择列表将由JS动态生成 -->
            </div>
        </div>
        <button id="start-werewolf-game-btn" class="form-button">开始游戏</button>
    </div>
</div>

<!-- 2. 狼人杀游戏主界面 -->
<div id="werewolf-game-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="exit-werewolf-game-btn">‹ 退出</span>
        <span id="werewolf-game-title">狼人杀</span>
        <span class="action-btn" id="werewolf-my-role-btn">我的身份</span>
    </div>
    <!-- 游戏主内容区 -->
    <div id="werewolf-game-content">
        <!-- 玩家座位区 -->
        <div id="werewolf-players-grid">
            <!-- 玩家头像和状态将由JS动态生成 -->
        </div>
        <!-- 游戏日志/信息区 -->
        <div id="werewolf-log-container">
            <div id="werewolf-game-log">
                <!-- 游戏过程信息会显示在这里 -->
            </div>
        </div>
        <!-- 玩家操作区 -->
        <div id="werewolf-action-area">
            <!-- 玩家的按钮会根据游戏阶段显示在这里 -->
        </div>
    </div>
</div>

<!-- ▲▲▲ 狼人杀功能HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】狼人杀游戏结算卡片 ▼▼▼ -->
<div id="werewolf-summary-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 80%;">
        <div class="modal-header">
            <span>游戏结算</span>
        </div>
        <div class="modal-body" id="werewolf-summary-content" style="white-space: pre-wrap; line-height: 1.7;">
            <!-- 结算内容将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="repost-summary-btn">发送复盘到聊天</button>
            <button class="save" id="back-to-hall-btn">返回大厅</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】狼人杀复盘发送目标选择器 ▼▼▼ -->
<div id="werewolf-target-picker-modal" class="modal">
    <div class="modal-content" style="height: 60%;">
        <div class="modal-header">
            <span>选择要发送的玩家</span>
        </div>
        <div class="modal-body" id="werewolf-target-list" style="padding: 0;">
            <!-- 玩家列表将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button id="wt-select-all-btn" class="form-button-secondary" style="width: 45%; margin: 0;">全选</button>
            <button id="wt-deselect-all-btn" class="form-button-secondary" style="width: 45%; margin: 0;">全不选</button>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="wt-cancel-btn">取消</button>
            <button class="save" id="wt-confirm-btn">确认发送</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】这是整个海龟汤功能的HTML，请粘贴到 </body> 标签前 ▼▼▼ -->

<!-- 1. 海龟汤游戏主界面 -->
<div id="sea-turtle-soup-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="exit-sts-game-btn">‹ 退出</span>
        <span>海龟汤</span>
        <span class="action-btn" id="reveal-sts-answer-btn">揭晓答案</span>
    </div>
    <div id="sts-game-content" style="display: flex; flex-direction: column; height: 100%; overflow: hidden; padding: 10px; box-sizing: border-box;">
        <!-- 玩家座位区 -->
        <div id="sts-players-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(60px, 1fr)); gap: 10px; padding: 10px; flex-shrink: 0;">
            <!-- 玩家头像和状态将由JS动态生成 -->
        </div>
        <!-- 游戏日志/信息区 -->
        <div id="sts-log-container" style="flex-grow: 1; background-color: rgba(0,0,0,0.05); border-radius: 10px; padding: 10px; overflow-y: auto; margin: 10px 0; min-height: 0;">
            <div id="sts-game-log">
                <!-- 游戏过程信息会显示在这里 -->
            </div>
        </div>
<!-- ▼▼▼ 用这块新代码替换旧的 id="sts-action-area" ▼▼▼ -->
<div id="sts-action-area" class="chat-input-area" style="visibility: visible;">
     <div class="chat-input-main-row">
        <textarea id="sts-question-input" rows="1" placeholder="输入问题或答案..."></textarea>
        <!-- 【核心修改】新增“猜答案”按钮 -->
        <button id="guess-sts-answer-btn" class="action-button" style="background-color: #ff9800;">猜答案</button>
        <button id="send-sts-question-btn" class="action-button">提问</button>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
    </div>
</div>

<!-- 2. 海龟汤游戏设置模态框 -->
<div id="sea-turtle-soup-setup-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 85%;">
        <div class="modal-header">
            <span>海龟汤 - 游戏设置</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label>邀请玩家 (你已自动加入)</label>
                <div id="sts-player-selection" class="list-container" style="height: 200px; border: 1px solid var(--border-color); border-radius: 8px;">
                    <!-- 玩家选择列表将由JS动态生成 -->
                </div>
            </div>
            <div class="form-group">
                <label>谁来出题？</label>
                <select id="sts-riddle-provider-select">
                    <option value="user">我来出题</option>
                    <option value="random_ai">随机一位AI</option>
                </select>
            </div>
            <!-- 用户出题的输入区 (默认隐藏) -->
            <div id="sts-user-riddle-input-area" style="display: none;">
                <div class="form-group">
                    <label for="sts-user-riddle-surface">谜面</label>
                    <textarea id="sts-user-riddle-surface" rows="2" placeholder="例如：一个男人走进酒吧，要了一杯水..."></textarea>
                </div>
                <div class="form-group">
                    <label for="sts-user-riddle-answer">谜底 (完整故事)</label>
                    <textarea id="sts-user-riddle-answer" rows="4" placeholder="例如：男人在打嗝，他想喝水止嗝..."></textarea>
                </div>
            </div>
            <!-- AI出题的输入区 (默认隐藏) -->
            <div id="sts-ai-riddle-input-area" style="display: none;">
                <div class="form-group">
                    <label for="sts-ai-riddle-type">谜题类型 (可选)</label>
                    <input type="text" id="sts-ai-riddle-type" placeholder="例如：恐怖、温情、脑洞、经典">
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-sts-setup-btn">取消</button>
            <button class="save" id="start-sts-game-btn">开始游戏</button>
        </div>
    </div>
</div>
<!-- ▼▼▼ 【全新】请将这两块代码粘贴到 </body> 标签前 ▼▼▼ -->

<!-- 1. 海龟汤游戏结算卡片 -->
<div id="sts-summary-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 80%;">
        <div class="modal-header">
            <span>游戏结算</span>
        </div>
        <div class="modal-body" id="sts-summary-content" style="white-space: pre-wrap; line-height: 1.7;">
            <!-- 结算内容将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="share-sts-summary-btn">分享复盘</button>
            <button class="save" id="back-to-hall-from-sts-btn">返回大厅</button>
        </div>
    </div>
</div>

<!-- 2. 海龟汤复盘发送目标选择器 -->
<div id="sts-share-target-modal" class="modal">
    <div class="modal-content" style="height: 60%;">
        <div class="modal-header">
            <span>选择要分享的玩家</span>
        </div>
        <div class="modal-body" id="sts-share-target-list" style="padding: 0;">
            <!-- 玩家列表将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button id="sts-select-all-btn" class="form-button-secondary" style="width: 45%; margin: 0;">全选</button>
            <button id="sts-deselect-all-btn" class="form-button-secondary" style="width: 45%; margin: 0;">全不选</button>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="sts-cancel-share-btn">取消</button>
            <button class="save" id="sts-confirm-share-btn">确认分享</button>
        </div>
    </div>
</div>

<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】这是整个剧本杀功能的HTML，请粘贴到 </body> 标签前 ▼▼▼ -->

<!-- 1. 剧本杀游戏设置屏幕 -->
<div id="script-kill-setup-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('game-hall-screen')">‹</span>
        <span>剧本杀 - 游戏设置</span>
    </div>
    <div class="form-container">
        <div class="form-group">
            <label>选择剧本</label>
            <div style="display: flex; gap: 10px;">
                <select id="script-kill-script-select" style="flex-grow: 1;"></select>
                <button id="manage-custom-scripts-btn" class="form-button-secondary" style="margin-top: 0; padding: 0 15px;">管理</button>
            </div>
        </div>
        <div class="form-group">
            <label>邀请玩家 (你已自动加入)</label>
            <div id="script-kill-player-selection" class="list-container" style="height: 300px; border: 1px solid var(--border-color); border-radius: 8px;">
                <!-- 玩家选择列表将由JS动态生成 -->
            </div>
        </div>
        <div class="form-group">
            <label class="toggle-switch-label">
                <span class="toggle-switch-text">自由选择角色 (关闭则随机分配)</span>
                <input type="checkbox" id="script-kill-free-choice-toggle">
                <span class="toggle-switch-slider"></span>
            </label>
        </div>
        <button id="start-script-kill-game-btn" class="form-button">开始游戏</button>
    </div>
</div>

<!-- 2. 剧本杀游戏主界面 -->
<div id="script-kill-game-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="exit-script-kill-game-btn">‹ 退出</span>
        <span id="script-kill-game-title">剧本杀</span>
        <div class="header-actions">
            <span class="action-btn" id="script-kill-my-role-btn">我的角色</span>
            <span class="action-btn" id="script-kill-all-evidence-btn">公共线索</span>
        </div>
    </div>
    <div id="script-kill-game-content">
        <div id="script-kill-players-grid">
            <!-- 玩家头像和状态将由JS动态生成 -->
        </div>
        <div id="script-kill-log-container">
            <div id="script-kill-game-log">
                <!-- 游戏过程信息会显示在这里 -->
            </div>
        </div>
        <div id="script-kill-action-area">
            <!-- 玩家的按钮会根据游戏阶段显示在这里 -->
        </div>
    </div>
</div>
<!-- ▼▼▼ 把这一整块全新的HTML代码，粘贴到 </body> 标签的正上方 ▼▼▼ -->

<!-- 【全新】剧本杀自定义剧本管理模态框 -->
<div id="script-kill-manager-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
<div class="modal-header">
    <span>管理自定义剧本</span>
    <div class="header-actions">
        <!-- ▼▼▼ 在这里添加一个新按钮 ▼▼▼ -->
        <button id="open-sk-ai-generator-btn" class="action-button" style="font-size: 14px;">AI生成</button>
        <!-- ▲▲▲ 添加结束 ▲▲▲ -->
        <button id="add-new-script-btn" class="action-button">添加</button>
    </div>
</div>

        <div class="modal-body" id="custom-scripts-list" style="padding: 0;">
            <!-- 自定义剧本列表将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button class="save" id="close-script-manager-btn" style="width: 100%;">完成</button>
        </div>
    </div>
</div>

<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->

<!-- ▼▼▼ 用下面这【一整块】全新的代码，替换掉你旧的 id="script-kill-editor-modal" ▼▼▼ -->

<!-- 1. 剧本编辑器主弹窗 (可视化版) -->
<div id="script-kill-editor-modal" class="modal">
    <div class="modal-content" style="height: 90%;">
        <div class="modal-header">
            <span id="script-editor-title">剧本编辑器</span>
        </div>
        <div class="modal-body" style="display: flex; flex-direction: column; gap: 15px;">
            
            <!-- 基础信息 -->
            <div class="form-group">
                <label for="script-name-input">剧本名称</label>
                <input type="text" id="script-name-input">
            </div>
            <div class="form-group">
                <label for="script-background-input">故事背景</label>
                <textarea id="script-background-input" rows="3"></textarea>
            </div>
            
            <hr style="opacity: 0.2;">

            <!-- 角色设定区 -->
            <div>
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <label style="margin: 0; font-weight: 600;">角色设定</label>
                    <button id="sk-add-role-btn" class="form-button-secondary" style="margin: 0; padding: 5px 15px;">+ 添加角色</button>
                </div>
                <div id="sk-roles-container" class="sk-item-container">
                    <!-- 角色卡片将由JS动态生成在这里 -->
                </div>
            </div>

            <!-- 线索卡区 -->
            <div>
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <label style="margin: 0; font-weight: 600;">线索卡</label>
                    <button id="sk-add-clue-btn" class="form-button-secondary" style="margin: 0; padding: 5px 15px;">+ 添加线索</button>
                </div>
                <div id="sk-clues-container" class="sk-item-container">
                    <!-- 线索卡片将由JS动态生成在这里 -->
                </div>
            </div>

            <!-- 最终真相互动 -->
            <div class="form-group">
                <label for="sk-truth-input">最终真相</label>
                <textarea id="sk-truth-input" rows="3"></textarea>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-script-editor-btn">取消</button>
            <button class="save" id="save-script-btn">保存剧本</button>
        </div>
    </div>
</div>

<!-- 2. 【全新】用于编辑单个角色/线索的子弹窗 -->
<div id="sk-item-editor-modal" class="modal" style="z-index: 1003;">
    <div class="modal-content" style="height: auto; max-height: 85%;">
        <div class="modal-header">
            <span id="sk-item-editor-title"></span>
        </div>
        <div class="modal-body">
            <!-- 角色编辑字段 (默认隐藏) -->
            <div id="sk-role-editor-fields" style="display: none;">
                <div class="form-group">
                    <label for="sk-role-name-input">角色名称</label>
                    <input type="text" id="sk-role-name-input">
                </div>
                <div class="form-group">
                    <label for="sk-role-desc-input">角色介绍</label>
                    <textarea id="sk-role-desc-input" rows="3"></textarea>
                </div>
<div class="form-group">
    <label for="sk-role-storyline-input">故事线 (案发时间段的详细行动轨迹)</label>
    <textarea id="sk-role-storyline-input" rows="5"></textarea>
</div>
                <div class="form-group">
                    <label for="sk-role-tasks-input">秘密任务</label>
                    <textarea id="sk-role-tasks-input" rows="2"></textarea>
                </div>
                <div class="form-group">
                    <label class="toggle-switch-label">
                        <span class="toggle-switch-text">是凶手</span>
                        <input type="checkbox" id="sk-role-killer-toggle">
                        <span class="toggle-switch-slider"></span>
                    </label>
                </div>
            </div>
            <!-- 线索编辑字段 (默认隐藏) -->
            <div id="sk-clue-editor-fields" style="display: none;">
                <div class="form-group">
                    <label for="sk-clue-owner-select">线索归属</label>
                    <select id="sk-clue-owner-select">
                        <!-- 选项将由JS动态生成 -->
                    </select>
                </div>
                <div class="form-group">
                    <label for="sk-clue-desc-input">线索描述</label>
                    <textarea id="sk-clue-desc-input" rows="4"></textarea>
                </div>
                 <div class="form-group">
                    <label class="toggle-switch-label">
                        <span class="toggle-switch-text">是关键线索</span>
                        <input type="checkbox" id="sk-clue-key-toggle">
                        <span class="toggle-switch-slider"></span>
                    </label>
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="sk-item-editor-cancel-btn">取消</button>
            <button class="save" id="sk-item-editor-save-btn">保存</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->

<!-- 4. 角色身份卡模态框 -->
<div id="script-kill-role-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span id="sk-role-name">你的角色</span>
        </div>
        <div class="modal-body" id="sk-role-details" style="white-space: pre-wrap; line-height: 1.7;">
            <!-- 角色介绍、任务等将显示在这里 -->
        </div>
        <div class="modal-footer">
            <button class="save" id="close-sk-role-modal-btn" style="width:100%;">我已了解</button>
        </div>
    </div>
</div>

<!-- 5. 个人线索板模态框 -->
<div id="script-kill-evidence-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span>我的线索板</span>
        </div>
        <div class="modal-body" id="sk-evidence-list" style="padding: 10px; display: flex; flex-direction: column; gap: 10px;">
            <!-- 搜到的线索卡片会显示在这里 -->
        </div>
        <div class="modal-footer">
            <button class="save" id="close-sk-evidence-modal-btn" style="width:100%;">关闭</button>
        </div>
    </div>
</div>

<!-- 6. 投票模态框 -->
<div id="script-kill-vote-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 70%;">
        <div class="modal-header">
            <span id="sk-vote-title">最终投票</span>
        </div>
        <div class="modal-body" id="sk-vote-options-list" style="text-align: left; padding: 20px;">
            <!-- 投票选项将由JS动态生成 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-sk-vote-btn">取消</button>
            <button class="save" id="confirm-sk-vote-btn">确认投票</button>
        </div>
    </div>
</div>
<!-- ▼▼▼ 【全新】剧本杀游戏结算卡片 ▼▼▼ -->
<div id="script-kill-summary-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 80%;">
        <div class="modal-header">
            <span>游戏结算</span>
        </div>
        <div class="modal-body" id="script-kill-summary-content" style="white-space: pre-wrap; line-height: 1.7;">
            <!-- 结算内容将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="repost-sk-summary-btn">转发复盘到单聊</button>
            <button class="save" id="back-to-hall-from-sk-btn">返回大厅</button>
        </div>
    </div>
</div>

<!-- ▼▼▼ 【全新】剧本杀复盘发送目标选择器 ▼▼▼ -->
<div id="script-kill-target-picker-modal" class="modal">
    <div class="modal-content" style="height: 60%;">
        <div class="modal-header">
            <span>选择要转发的玩家</span>
        </div>
        <div class="modal-body" id="script-kill-target-list" style="padding: 0;">
            <!-- 玩家列表将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button id="sk-select-all-btn" class="form-button-secondary" style="width: 45%; margin: 0;">全选</button>
            <button id="sk-deselect-all-btn" class="form-button-secondary" style="width: 45%; margin: 0;">全不选</button>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="sk-cancel-share-btn">取消</button>
            <button class="save" id="sk-confirm-share-btn">确认转发</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】这是AI剧本生成器的弹窗，粘贴到</body>前 ▼▼▼ -->
<div id="sk-ai-generator-modal" class="modal">
    <div class="modal-content" style="height: 90%;">
        <div class="modal-header">
            <span>AI 剧本生成器</span>
        </div>
<div class="modal-body" style="display: flex; flex-direction: column; gap: 15px;">
            
    <div class="form-group">
        <label for="sk-ai-elements-input">核心要素 (用逗号分隔)</label>
        <input type="text" id="sk-ai-elements-input" placeholder="例如：现代, 谋杀, 暴风雪山庄, 遗产">
    </div>

    <!-- ▼▼▼ 【这是你要求新增的HTML】请把它粘贴到这里 ▼▼▼ -->
    <div class="form-group">
        <label for="sk-ai-player-count-input">玩家人数 (包含凶手, 建议4-8人)</label>
        <input type="number" id="sk-ai-player-count-input" value="5" min="3" max="12" style="width: 100%; box-sizing: border-box; padding: 10px; border-radius: 6px; border: 1px solid var(--border-color);">
    </div>
    <!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->

    <div class="form-group">
        <label for="sk-ai-summary-input">剧情梗概 (可选)</label>
        <textarea id="sk-ai-summary-input" rows="4" placeholder="可以写一个简单的故事大纲，帮助AI更好地理解你的想法..."></textarea>
    </div>
    <button id="sk-trigger-ai-generation-btn" class="form-button">开始生成</button>
          
            <hr style="opacity: 0.2; margin: 5px 0;">

            <div class="form-group" style="flex-grow: 1; min-height: 0; display: flex; flex-direction: column;">
                <label>AI 生成结果预览</label>
                <div id="sk-ai-result-preview" style="flex-grow: 1; overflow-y: auto; background: #f0f2f5; padding: 10px; border-radius: 8px; white-space: pre-wrap; line-height: 1.6; color: #555;">
                    点击“开始生成”后，结果将显示在这里...
                </div>
            </div>

        </div>
        <div class="modal-footer">
            <button class="cancel" id="sk-ai-generator-cancel-btn">关闭</button>
            <!-- 这个保存按钮初始是禁用的，生成成功后才会激活 -->
            <button class="save" id="sk-ai-generator-save-btn" disabled>保存剧本</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->

<!-- ▲▲▲ 剧本杀功能HTML结束 ▲▲▲ -->

<!-- ▲▲▲ 海龟汤功能HTML结束 ▲▲▲ -->
 <!-- ▼▼▼ 【全新】这是“你说我猜”游戏的所有HTML代码 ▼▼▼ -->

<!-- 1. “你说我猜”游戏设置屏幕 -->
<div id="guess-what-setup-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('game-hall-screen')">‹</span>
        <span>你说我猜 - 游戏设置</span>
    </div>
    <div class="form-container">
        <div class="form-group">
            <label>邀请一位玩伴</label>
            <div id="guess-what-player-selection" class="list-container" style="height: 200px; border: 1px solid var(--border-color); border-radius: 8px;">
                <!-- 玩家选择列表将由JS动态生成 -->
            </div>
        </div>
        <div class="form-group">
            <label>选择游戏模式</label>
            <div style="display: flex; gap: 20px;">
                <label><input type="radio" name="guess_what_mode" value="ai_guesses" checked> 我出题，AI猜</label>
                <label><input type="radio" name="guess_what_mode" value="user_guesses"> AI出题，我猜</label>
            </div>
        </div>
        <!-- "我出题"模式下的输入框 -->
        <div class="form-group" id="user-word-input-container">
            <label for="guess-what-user-word">请输入你要出的词</label>
            <input type="text" id="guess-what-user-word" placeholder="例如：苹果、流浪地球...">
        </div>
        <button id="start-guess-what-game-btn" class="form-button">开始游戏</button>
    </div>
</div>

<!-- 2. “你说我猜”游戏主界面 -->
<div id="guess-what-game-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="exit-guess-what-game-btn">‹ 退出</span>
        <span id="guess-what-game-title">你说我猜</span>
        <span class="action-btn" id="give-up-guess-what-btn">放弃</span>
    </div>
    <!-- 游戏主内容区 -->
    <div id="guess-what-game-content" style="display: flex; flex-direction: column; height: 100%; overflow: hidden; padding: 10px; box-sizing: border-box;">
        <!-- 游戏日志/信息区 -->
        <div id="guess-what-log-container" style="flex-grow: 1; background-color: rgba(0,0,0,0.05); border-radius: 10px; padding: 10px; overflow-y: auto; margin: 10px 0; min-height: 0;">
            <div id="guess-what-game-log">
                <!-- 游戏过程信息会显示在这里 -->
            </div>
        </div>
        <!-- 玩家操作区 -->
        <div id="guess-what-action-area" class="chat-input-area" style="visibility: visible;">
             <div class="chat-input-main-row">
                <textarea id="guess-what-user-input" rows="1" placeholder="输入提示或猜测..."></textarea>
                <button id="send-guess-what-input-btn" class="action-button">发送</button>
            </div>
        </div>
    </div>
</div>

<!-- ▲▲▲ “你说我猜”HTML代码结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】“你说我猜”游戏结算卡片 ▼▼▼ -->
<div id="guess-what-summary-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 80%;">
        <div class="modal-header">
            <span>游戏结算</span>
        </div>
        <div class="modal-body" id="guess-what-summary-content" style="white-space: pre-wrap; line-height: 1.7;">
            <!-- 结算内容将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="forward-guess-what-summary-btn">转发给Ta</button>
            <button class="save" id="close-guess-what-summary-btn">返回大厅</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
 <!-- ▼▼▼ 【全新】这是“心动飞行棋”的所有新HTML代码 ▼▼▼ -->

<!-- 1. 飞行棋游戏设置屏幕 -->
<div id="ludo-setup-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('game-hall-screen')">‹</span>
        <span>心动飞行棋 - 游戏设置</span>
    </div>
    <div class="form-container">
        <div class="form-group">
            <label>选择一位玩伴</label>
            <!-- 邀请列表，我们会用JS来填充 -->
            <div id="ludo-player-selection" class="list-container" style="height: 200px; border: 1px solid var(--border-color); border-radius: 8px;">
            </div>
        </div>
        <!-- ▼▼▼ 在 #ludo-setup-screen 的 "form-container" 内，粘贴这段新代码 ▼▼▼ -->
<div class="form-group">
    <label>选择问题库</label>
    <div style="display: flex; align-items: center; gap: 10px;">
        <select id="ludo-question-bank-select" style="flex-grow: 1;"></select>
        <button id="manage-ludo-question-banks-btn" class="form-button-secondary" style="margin-top: 0; padding: 12px; width: auto;">管理题库</button>
    </div>
</div>
<!-- ▲▲▲ 粘贴结束 ▲▲▲ -->

        <button id="start-ludo-game-btn" class="form-button">开始游戏</button>
    </div>
</div>

<!-- 2. 飞行棋游戏主界面 -->
<div id="ludo-game-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="exit-ludo-game-btn">‹ 退出</span>
        <span>心动飞行棋</span>
        <!-- 这里可以放一个重置游戏的按钮 -->
        <span class="action-btn" id="restart-ludo-game-btn" title="重新开始">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg>
        </span>
    </div>
    <!-- 游戏主内容区 -->
    <div id="ludo-game-content">
        <!-- 棋盘区域 -->
        <div id="ludo-board-container">
            <div id="ludo-board">
                <!-- 棋盘格子将由JS动态生成 -->
            </div>
            <!-- 玩家棋子 -->
            <div id="ludo-user-piece" class="ludo-piece user"></div>
            <div id="ludo-char-piece" class="ludo-piece char"></div>
        </div>

        <!-- 游戏日志区域 -->
        <div id="ludo-log-container">
            <div id="ludo-game-log">
                <!-- 游戏过程信息会显示在这里 -->
            </div>
        </div>
        
        <!-- 玩家操作区 -->
        <div id="ludo-action-area">
            <!-- 用户的按钮会根据游戏阶段显示在这里 -->
        </div>
    </div>
</div>

<!-- ▲▲▲ “心动飞行棋”HTML代码结束 ▲▲▲ -->

<!-- ▼▼▼ 在这里找到你的微博私信列表页面 ▼▼▼ -->
<div id="weibo-dm-list-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="back-from-dm-list">‹</span>
        <span id="weibo-dm-list-title">粉丝私信</span>
        <!-- 这是你要求的“继续生成”按钮 -->
        <div class="header-actions">
            <span class="action-btn" id="generate-more-dms-btn" title="继续生成私信">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></svg>
            </span>
            
            <!-- ▼▼▼ 在这里粘贴下面这个全新的“清空全部”按钮 ▼▼▼ -->
            <span class="action-btn" id="clear-all-dms-btn" title="清空全部私信">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/>
                </svg>
            </span>
            <!-- ▲▲▲ 粘贴结束 ▲▲▲ -->
            
        </div>
    </div>
    <div id="weibo-dm-list" class="list-container" style="padding: 0;">
        <!-- 私信列表将由JS动态生成 -->
    </div>
</div>


<!-- ▼▼▼ 【全新】这是微博私信详情页面，请粘贴到 #phone-screen 的末尾 ▼▼▼ -->
<div id="weibo-dm-detail-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="back-from-dm-detail">‹</span>
        <span id="weibo-dm-detail-title"></span>
        <span style="width: 30px;"></span> <!-- 占位符 -->
    </div>
    <div id="weibo-dm-messages" class="list-container" style="display: flex; flex-direction: column; gap: 15px; padding: 15px; background-color: #f0f2f5;">
        <!-- 聊天气泡将由JS动态生成 -->
    </div>
</div>
<!-- ▼▼▼ 把下面这一整块全新的HTML代码，粘贴到 </body> 标签的正上方 ▼▼▼ -->

<!-- ▼▼▼ 用这整块代码替换旧的 id="taobao-screen" 的 div ▼▼▼ -->
<div id="taobao-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <span>桃宝</span>
        <div class="header-actions">
            <!-- ▼▼▼ 在这里添加新按钮 ▼▼▼ -->
            <span class="action-btn" id="clear-taobao-products-btn" style="font-size: 16px; font-weight: 500;">清空</span>
            <!-- ▲▲▲ 添加结束 ▲▲▲ -->
            <span class="action-btn" id="add-product-btn" title="添加商品">+</span>
        </div>
    </div>

    
    <!-- 1. 顶部页签导航 -->
    <div class="taobao-tabs">
        <button class="taobao-tab active" data-view="products-view">首页</button>
        <!-- ★★★ 在这里新增了“购物车”按钮 ★★★ -->
        <button class="taobao-tab" data-view="cart-view">
            购物车<span id="cart-item-count-badge" style="display: none;">0</span>
        </button>
        <button class="taobao-tab" data-view="orders-view">我的订单</button>
        <button class="taobao-tab" data-view="my-view">我的</button>
    </div>

    <!-- 2. 页面内容容器 -->
    <div class="taobao-content">
        <!-- “首页”视图 (保持不变) -->
        <div id="products-view" class="taobao-view active">
          <div class="taobao-search-bar">
            <input type="search" id="product-search-input" placeholder="搜一搜，让AI为你创造好物！">
            <button id="product-search-btn">搜索</button>
          </div>
            <div id="product-category-tabs"></div>
            <div id="product-grid" class="product-grid"></div>
        </div>

        <!-- ★★★ “购物车”视图 (全新添加) ★★★ -->
        <div id="cart-view" class="taobao-view">
            <div id="cart-item-list">
                <!-- 购物车商品会显示在这里 -->
            </div>
<!-- ▼▼▼ 用这块新代码替换旧的 cart-checkout-bar ▼▼▼ -->
<div id="cart-checkout-bar" style="display: none;">
    <div class="total-price">
        合计: <span id="cart-total-price">¥ 0.00</span>
    </div>
    <div style="display: flex; gap: 10px;">
        <button id="share-cart-to-char-btn">分享给Ta代付</button>
        <button id="buy-for-char-btn">为Ta购买</button> <!-- 这是我们新增的按钮 -->
        <button id="checkout-btn">结算(0)</button>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
        </div>

        <!-- “我的订单”视图 (保持不变) -->
        <div id="orders-view" class="taobao-view">
            <div id="order-list" class="order-list"></div>
        </div>

        <!-- “我的”视图 (保持不变) -->
        <div id="my-view" class="taobao-view">
            <div id="user-balance-container">
                <p>我的余额</p>
                <h2 id="user-balance-display">¥ 0.00</h2>
                <button id="top-up-btn" class="form-button">给钱包充点钱</button>
            </div>
            <div id="balance-details-list" class="order-list" style="padding: 0 15px;"></div>
        </div>
    </div>
</div>

<!-- ▼▼▼ 用这块【已添加评价区】的代码，替换旧的 id="product-detail-modal" ▼▼▼ -->
<div id="product-detail-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <span>商品详情</span>
        </div>
        <div class="modal-body" id="product-detail-body">
            <!-- 详情内容将由JS动态生成 -->
        </div>
        <!-- ★★★ 这是我们新增的评价区域 ★★★ -->
        <div id="product-reviews-section">
            <h3>宝贝评价</h3>
            <div id="product-reviews-list">
                <!-- 评价内容会由JS动态生成在这里 -->
            </div>
            <button id="generate-reviews-btn" class="form-button form-button-secondary">✨ AI生成评价</button>
        </div>
        <!-- ▲▲▲ 新增结束 ▲▲▲ -->
        <div class="modal-footer">
            <button class="cancel" id="close-product-detail-btn">关闭</button>
            <button class="save" id="detail-add-to-cart-btn">加入购物车</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->


<!-- 2. 添加商品的方式选择弹窗 -->
<div id="add-product-choice-modal" class="modal">
    <div id="custom-modal" style="width: 250px;">
        <div class="custom-modal-header">选择添加方式</div>
        <div class="custom-modal-footer">
            <button id="add-product-manual-btn">手动添加</button>
            <button id="add-product-link-btn">识别链接</button>
            <button id="add-product-ai-btn">AI生成</button>
            <button id="cancel-add-choice-btn" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">取消</button>
        </div>
    </div>
</div>

<!-- 3. 手动添加/编辑商品弹窗 -->
<div id="product-editor-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span id="product-editor-title">添加新商品</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="product-name-input">商品名称</label>
                <input type="text" id="product-name-input">
            </div>
            <div class="form-group">
                <label for="product-price-input">价格 (元)</label>
                <input type="number" id="product-price-input">
            </div>
            <div class="form-group">
                <label for="product-image-input">图片 URL</label>
                <input type="text" id="product-image-input">
            </div>
            <div class="form-group">
                <label for="product-category-input">分类 (选填)</label>
                <input type="text" id="product-category-input" placeholder="例如：衣服, 零食...">
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-product-editor-btn">取消</button>
            <button class="save" id="save-product-btn">保存</button>
        </div>
    </div>
</div>

<!-- 4. 识别链接弹窗 -->
<div id="add-from-link-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span>粘贴分享文案</span>
        </div>
        <div class="modal-body">
            <textarea id="link-paste-area" rows="6" placeholder="请在这里粘贴完整的淘宝或拼多多分享文案..."></textarea>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-link-paste-btn">取消</button>
            <button class="save" id="confirm-link-paste-btn">识别</button>
        </div>
    </div>
</div>

<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 把这一整块全新的HTML代码，粘贴到 </body> 标签的正上方 ▼▼▼ -->

<!-- 【全新】物流详情页面 -->
<div id="logistics-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="logistics-back-btn">‹</span>
        <span>物流详情</span>
        <span style="width: 30px;"></span> <!-- 占位符，让标题居中 -->
    </div>
    <div id="logistics-content-area" class="list-container">
        <!-- 物流信息将由JS动态生成在这里 -->
    </div>
</div>

<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 把这一整块全新的HTML，粘贴到 </body> 标签的正上方 ▼▼▼ -->
<!-- ▼▼▼ 【全新】这是“谁是卧底”游戏的全部HTML界面，请粘贴到 </body> 标签前 ▼▼▼ -->

<!-- 1. “谁是卧底”游戏设置屏幕 -->
<div id="undercover-setup-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('game-hall-screen')">‹</span>
        <span>谁是卧底 - 游戏设置</span>
    </div>
<div class="form-container">
    <div class="form-group">
        <label>邀请模式</label>
        <div style="display: flex; gap: 20px;">
            <label style="cursor: pointer;"><input type="radio" name="undercover_invite_mode" value="manual" checked> 手动邀请</label>
            <label style="cursor: pointer;"><input type="radio" name="undercover_invite_mode" value="random"> 随机邀请</label>
        </div>
    </div>

    <!-- 随机邀请的选项 -->
    <div id="undercover-random-invite-options" style="display: none;">
        <div class="form-group">
            <label for="undercover-random-player-count">你想邀请几位AI/NPC？ (不含你自己)</label>
            <input type="number" id="undercover-random-player-count" min="2" max="15" value="5" style="width: 100%; box-sizing: border-box; padding: 10px;">
        </div>
    </div>

    <!-- 手动邀请的选项 -->
    <div id="undercover-manual-invite-options">
        <div class="form-group">
            <label>请勾选要邀请的玩家</label>
            <div id="undercover-player-selection" class="list-container" style="height: 350px; border: 1px solid var(--border-color); border-radius: 8px;">
                <!-- 玩家选择列表将由JS动态生成 -->
            </div>
        </div>
    </div>
    
    <button id="start-undercover-game-btn" class="form-button">开始游戏</button>
    <p style="text-align: center; color: var(--text-secondary); font-size: 13px; margin-top: 15px;">
        游戏最少需要3人。<br>
        3-5人局：1卧底<br>
        6-8人局：1卧底, 1白板<br>
        9人及以上：2卧底, 1白板
    </p>
</div>
</div>

<!-- 2. “谁是卧底”游戏主界面 -->
<div id="undercover-game-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="exit-undercover-game-btn">‹ 退出</span>
        <span id="undercover-game-title">谁是卧底</span>
        <span class="action-btn" id="undercover-my-word-btn">我的词语</span>
    </div>
    <!-- 游戏主内容区 -->
    <div id="undercover-game-content" style="display: flex; flex-direction: column; height: 100%; overflow: hidden; padding: 10px; box-sizing: border-box;">
        <!-- 玩家座位区 -->
        <div id="undercover-players-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(70px, 1fr)); gap: 15px; padding: 10px; flex-shrink: 0;">
            <!-- 玩家头像和状态将由JS动态生成 -->
        </div>
        <!-- 游戏日志/信息区 -->
        <div id="undercover-log-container" style="flex-grow: 1; background-color: rgba(0,0,0,0.05); border-radius: 10px; padding: 10px; overflow-y: auto; margin: 10px 0; min-height: 0;">
            <div id="undercover-game-log">
                <!-- 游戏过程信息会显示在这里 -->
            </div>
        </div>
        <!-- 玩家操作区 -->
        <div id="undercover-action-area" style="flex-shrink: 0; padding: 10px; display: flex; justify-content: center; align-items: center; gap: 15px; min-height: 50px;">
            <!-- 玩家的按钮会根据游戏阶段显示在这里 -->
        </div>
    </div>
</div>

<!-- ▼▼▼ 用这整块【已修改】的代码，替换掉你旧的 undercover-summary-modal ▼▼▼ -->
<div id="undercover-summary-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 80%;">
        <div class="modal-header">
            <span>游戏结算</span>
        </div>
        <div class="modal-body" id="undercover-summary-content" style="white-space: pre-wrap; line-height: 1.7;">
            <!-- 结算内容将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <!-- ★★★ 核心修改：我们在这里新增了一个“分享复盘”按钮 ★★★ -->
            <button class="cancel" id="repost-undercover-summary-btn">分享复盘到单聊</button>
            <button class="save" id="back-to-hall-from-undercover-btn">返回大厅</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】这是User自己的私信功能，请粘贴到 <div id="weibo-screen">...</div> 之后 ▼▼▼ -->

<!-- 1. User私信列表页面 -->
<div id="user-dm-list-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="back-from-user-dm-list">‹</span>
        <span>我的私信</span>
        <div class="header-actions">
            <!-- 这个按钮用于让AI生成新的粉丝私信 -->
            <span class="action-btn" id="generate-new-user-dms-btn" title="生成新私信">
                <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></svg>
            </span>
            <!-- 这个按钮用于清空所有私信 -->
            <span class="action-btn" id="clear-all-user-dms-btn" title="清空所有私信">
                 <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>
            </span>
        </div>
    </div>
    <div id="user-dm-list-container" class="list-container" style="padding: 0;">
        <!-- 私信列表将由JS动态生成在这里 -->
    </div>
</div>

<!-- 2. User私信详情页面 (与粉丝聊天) -->
<div id="user-dm-detail-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="back-from-user-dm-detail">‹</span>
        <span id="user-dm-detail-title"></span> <!-- 粉丝名字 -->
        <span style="width: 30px;"></span> <!-- 占位符 -->
    </div>
    <div id="user-dm-messages-container" class="list-container" style="display: flex; flex-direction: column; gap: 15px; padding: 15px; background-color: #f0f2f5;">
        <!-- 聊天气泡将由JS动态生成在这里 -->
    </div>
    <!-- 聊天输入框 -->
<!-- ▼▼▼ 【V2版】聊天输入框 (已添加新按钮) ▼▼▼ -->
<div id="user-dm-input-area" class="chat-input-area">
    <div class="chat-input-main-row">
        <textarea id="user-dm-input" rows="1" placeholder="和粉丝聊点什么..."></textarea>
        <!-- 我们用一个新的容器把所有操作按钮包起来 -->
        <div id="input-actions-wrapper">
            <!-- 这是新加的“触发AI回应”按钮 -->
            <button id="user-dm-trigger-ai-btn" class="action-button chat-action-icon-btn" title="让对方先说">
                <svg width="22" height="22" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                </svg>
            </button>
            <!-- 这是新加的“重Roll”按钮 -->
            <button id="user-dm-reroll-btn" class="action-button chat-action-icon-btn" title="重新生成回复">
                <svg width="22" height="22" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="23 4 23 10 17 10"></polyline>
                    <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
                </svg>
            </button>
            <!-- 这是你原来的发送按钮 -->
            <button id="user-dm-send-btn" class="action-button">发送</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
</div>

<!-- ▲▲▲ 全新的 User 私信功能 HTML 结构结束 ▲▲▲ -->


<!-- 【全新】角色微博主页屏幕 -->
<div id="weibo-char-profile-screen" class="screen">
    <!-- 头部，包含返回按钮和角色名字 -->
    <div class="header">
        <span class="back-btn" id="back-from-char-profile">‹</span>
        <span id="weibo-char-profile-title">角色主页</span>
        <div class="header-actions">
            <!-- 为角色主页也添加一个编辑按钮 -->
            <span class="action-btn" id="edit-char-weibo-profile-btn" title="编辑角色资料">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M12 20h9"></path>
                    <path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>
                </svg>
            </span>
        </div>
    </div>
    <!-- 角色主页的内容区 -->
    <div id="weibo-char-profile-page" class="weibo-profile-page"> <!-- 复用个人主页的滚动样式 -->
        <div class="weibo-profile-header">
            <img id="weibo-char-background-img" src="https://i.postimg.cc/mk93Y3j1/weibo-bg-default.jpg" class="weibo-background">
            <div class="weibo-avatar-container">
                <img id="weibo-char-avatar-img" src="https://files.catbox.moe/q6z5fc.jpeg" class="weibo-avatar">
                <img id="weibo-char-avatar-frame" class="weibo-avatar-frame" src="" style="display: none;">
            </div>
            <div class="weibo-nickname" id="weibo-char-nickname">角色昵称</div>
            <div id="weibo-char-profession-display">角色职业</div>
<!-- ▼▼▼ 用这整块代码，替换掉 id="weibo-char-profile-page" 里面那个旧的、只有注释的 <div class="weibo-stats"> ▼▼▼ -->
<div class="weibo-stats">
    <div id="weibo-char-following-item" class="weibo-stat-item" style="cursor: pointer;">
        <span id="weibo-char-following-count" class="weibo-stat-number">0</span>
        <span class="weibo-stat-label">关注</span>
    </div>
    <div id="weibo-char-posts-item" class="weibo-stat-item">
        <span id="weibo-char-posts-count" class="weibo-stat-number">0</span>
        <span class="weibo-stat-label">微博</span>
    </div>
    <div id="weibo-char-fans-item" class="weibo-stat-item" style="cursor: pointer;">
        <span id="weibo-char-fans-count" class="weibo-stat-number">0</span>
        <span class="weibo-stat-label">粉丝</span>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
        </div>
        <div id="char-weibo-feed-list" style="padding: 15px; display: flex; flex-direction: column; gap: 15px;">
            <!-- 角色的微博列表将由JS动态生成在这里 -->
        </div>
    </div>
</div>

<!-- 【全新】角色微博资料编辑弹窗 -->
<div id="char-weibo-editor-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span>编辑角色微博资料</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label>微博头像</label>
                <div class="avatar-upload">
                    <img id="char-weibo-editor-avatar-preview">
                    <button onclick="document.getElementById('char-weibo-editor-avatar-input').click()">上传头像</button>
                    <button class="change-frame-btn" data-type="char-weibo">更换头像框</button>
                    <input type="file" id="char-weibo-editor-avatar-input" accept="image/*" hidden>
                </div>
            </div>
            <div class="form-group">
                <label for="char-weibo-editor-nickname-input">微博昵称</label>
                <input type="text" id="char-weibo-editor-nickname-input">
            </div>
            <div class="form-group">
                <label>微博背景</label>
                <div class="avatar-upload">
                    <img id="char-weibo-editor-bg-preview" style="width: 120px; height: 67.5px; border-radius: 8px;">
                    <button onclick="document.getElementById('char-weibo-editor-bg-input').click()">上传背景</button>
                    <input type="file" id="char-weibo-editor-bg-input" accept="image/*" hidden>
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-char-weibo-editor-btn">取消</button>
            <button class="save" id="save-char-weibo-editor-btn">保存</button>
        </div>
    </div>
</div>

<!-- ▼▼▼ 用这整块【已添加新按钮】的代码，替换你旧的 id="date-a-live-screen" ▼▼▼ -->
<div id="date-a-live-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <span>约会大作战</span>
        <div class="header-actions">

            <!-- ★★★★★ 这就是我们为你新增的“+”号按钮 ★★★★★ -->
            <span class="action-btn" id="create-dating-scene-btn" title="创建新场景">
                 <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
            </span>
            <!-- ★★★★★ 新增结束 ★★★★★ -->

            <span class="action-btn" id="dating-history-btn" title="历史约会">
                 <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
                    <polyline points="3 3 3 8 8 8"/>
                    <path d="M12 6V12L16 14"/>
                 </svg>
            </span>
            <span class="action-btn" id="refresh-dating-scene-btn" title="刷新场景">
                 <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg>
            </span>
        </div>
    </div>
    <div id="dating-scene-content" class="list-container">
        <!-- 约会场景卡片将由JS动态生成在这里 -->
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->




<!-- ▼▼▼ 【增强版】宠物功能模态框 ▼▼▼ -->
<div id="pet-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 85%;">
        <div class="modal-header">
            <span id="pet-modal-title">我的宠物</span>
        </div>
        <div class="modal-body">
            <!-- 宠物信息预览区 -->
            <div id="pet-preview-area" style="text-align: center; margin-bottom: 20px;">
                <div id="pet-preview-display" style="font-size: 60px; line-height: 1; margin-bottom: 10px; cursor: pointer;" title="点击更换图片"></div>
                <strong id="pet-preview-name" style="font-size: 18px;"></strong>
                <p id="pet-preview-type" style="font-size: 14px; color: var(--text-secondary); margin: 5px 0;"></p>
            </div>

            <!-- 宠物数值显示区 -->
            <div id="pet-stats-area" style="display: none;">
                <div id="pet-hunger-bar" class="stat-bar-container">
                    <span class="stat-label">饱食度</span>
                    <div class="stat-bar"><div class="stat-bar-fill">100%</div></div>
                </div>
                <div id="pet-happiness-bar" class="stat-bar-container">
                    <span class="stat-label">心情值</span>
                    <div class="stat-bar"><div class="stat-bar-fill">100%</div></div>
                </div>
                <div id="pet-intimacy-user-bar" class="stat-bar-container">
                    <span class="stat-label">对你的亲密度</span>
                    <div class="stat-bar"><div class="stat-bar-fill">50%</div></div>
                </div>
                <div id="pet-intimacy-char-bar" class="stat-bar-container">
                    <span class="stat-label">对Ta的亲密度</span>
                    <div class="stat-bar"><div class="stat-bar-fill">50%</div></div>
                </div>
            </div>

            <!-- 互动按钮区 (已新增“对话”按钮) -->
            <div id="pet-interaction-area" style="display: flex; justify-content: center; gap: 15px; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid var(--border-color);">
                <button class="form-button-secondary" data-action="feed">喂食</button>
                <button class="form-button-secondary" data-action="play">玩耍</button>
                <button class="form-button-secondary" data-action="touch">抚摸</button>
                <button class="form-button-secondary" data-action="chat">对话</button>
            </div>
            
            <!-- 设置区 -->
            <div class="form-group">
                <label for="pet-type-input">种类 (自由填写)</label>
                <input type="text" id="pet-type-input" placeholder="例如: 小猫, 仓鼠, 太阳花...">
            </div>
             <div class="form-group">
                <label for="pet-name-input">昵称</label>
                <input type="text" id="pet-name-input" placeholder="给它起个名字吧">
            </div>
             <div class="form-group">
                <label for="pet-image-input">初始样子 (Emoji 或 图片URL)</label>
                <input type="text" id="pet-image-input" placeholder="输入一个 Emoji 比如 🐈 或图片链接">
            </div>
            <!-- 【全新】人设输入框 -->
            <div class="form-group">
                <label for="pet-persona-input">宠物人设与背景</label>
                <textarea id="pet-persona-input" rows="3" placeholder="描述一下它的性格和故事，AI会根据这个来扮演它。"></textarea>
            </div>
            <div class="form-group">
                <label class="toggle-switch-label">
                    <span>在聊天界面显示</span>
                    <input type="checkbox" id="pet-display-toggle">
                    <span class="toggle-switch-slider"></span>
                </label>
            </div>
            <div id="pet-position-controls" style="display:none;">
                <div class="form-group">
                    <label for="pet-size-slider">大小: <span id="pet-size-value">100px</span></label>
                    <input type="range" id="pet-size-slider" min="30" max="200" value="100" style="width: 100%;">
                </div>
            </div>

        </div>
        <div class="modal-footer">
            <!-- ▼▼▼ 在这里添加新按钮 ▼▼▼ -->
            <button class="cancel" id="pet-abandon-btn" style="background-color: #ffdde5; color: #ff3b30; border-color: #ffc2d1;">放生宠物</button>
            <!-- ▲▲▲ 添加结束 ▲▲▲ -->
            <button class="cancel" id="pet-modal-cancel-btn">取消</button>
            <button class="save" id="pet-modal-save-btn">保存</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
<input type="file" id="pet-custom-image-input" accept="image/*" style="display: none;">
<!-- ▼▼▼ 【全新】宠物聊天模态框 ▼▼▼ -->
<div id="pet-chat-modal" class="modal">
    <div class="modal-content" style="height: 80%;">
        <div class="modal-header">
            <span id="pet-chat-title">和宠物的对话</span>
        </div>
        <div id="pet-chat-messages" class="modal-body" style="background-color: #f0f2f5; display: flex; flex-direction: column; gap: 15px;">
            <!-- 宠物聊天记录将显示在这里 -->
        </div>
        <!-- 复用主聊天输入框的样式 -->
        <div id="pet-chat-input-area" class="chat-input-area" style="border-top: 1px solid var(--border-color);">
            <div class="chat-input-main-row">
                <textarea id="pet-chat-input" rows="1" placeholder="和它说点什么..."></textarea>
                <button id="send-to-pet-btn" class="action-button">发送</button>
            </div>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->

<!-- ▲▲▲ 宠物功能模态框结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】这是微博专用的、支持多选和滚动的角色选择弹窗 ▼▼▼ -->
<div id="weibo-char-selector-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span>选择生成内容的主角</span>
        </div>
        <div class="modal-body" id="weibo-char-selector-list" style="padding: 0; overflow-y: auto;">
            <!-- 角色列表将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer" style="justify-content: space-between;">
            <button id="weibo-select-all-btn" class="form-button-secondary" style="width: 45%; margin: 0;">全选</button>
            <button id="weibo-deselect-all-btn" class="form-button-secondary" style="width: 45%; margin: 0;">全不选</button>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="weibo-cancel-char-select-btn">取消</button>
            <button class="save" id="weibo-confirm-char-select-btn">确认</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 把这一整块全新的HTML代码，粘贴到 </body> 标签的正上方 ▼▼▼ -->

<!-- 【全新】情侣空间-情绪日记编辑弹窗 -->
<div id="ls-diary-editor-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 80%;">
        <div class="modal-header">
            <span id="ls-diary-editor-title">记录今天的心情</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label>选择一个表情代表今天的心情</label>
                <div id="ls-emoji-selector" style="display: flex; flex-wrap: wrap; gap: 10px; font-size: 24px; cursor: pointer; justify-content: center; padding: 10px 0;">
                    <!-- Emoji将由JS生成 -->
                </div>
            </div>
            <div class="form-group">
                <label for="ls-diary-content-input">写下你的日记</label>
                <textarea id="ls-diary-content-input" rows="6" placeholder="今天发生了什么特别的事吗..."></textarea>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="ls-cancel-diary-btn">取消</button>
            <button class="save" id="ls-save-diary-btn">保存日记</button>
        </div>
    </div>
</div>

<!-- 【全新】情侣空间-日记查看弹窗 -->
<div id="ls-diary-viewer-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 80%;">
        <div class="modal-header">
            <span id="ls-diary-viewer-title">查看日记</span>
        </div>
        <div id="ls-diary-viewer-body" class="modal-body" style="display: flex; flex-direction: column; gap: 20px;">
            <!-- 日记内容将由JS动态生成 -->
        </div>
        <div class="modal-footer">
            <button class="save" id="ls-close-diary-viewer-btn" style="width: 100%;">关闭</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 用这整块代码替换旧的 summary-viewer-modal ▼▼▼ -->
<div id="summary-viewer-modal" class="modal">
    <div class="modal-content" style="height: 80%;">
        <div class="modal-header">
            <span id="summary-viewer-title">聊天总结</span>
        </div>
        <div class="modal-body" id="summary-list" style="padding: 15px;">
            <!-- 总结列表将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer" style="display: flex; gap: 10px;">
            <!-- 【核心修改】我们在这里新增了“全部精简”按钮 -->
            <button class="form-button-secondary" id="concise-all-summaries-btn" style="flex: 1; margin: 0;">全部精简</button>
            <button class="save" id="close-summary-viewer-btn" style="flex: 1; margin: 0;">关闭</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
<!-- ▼▼▼ 把这一整块全新的HTML代码，粘贴到 </body> 标签的正上方 ▼▼▼ -->

<!-- 【全新】AI生成商品结果/选择弹窗 -->
<div id="ai-generated-products-modal" class="modal">
    <div class="modal-content" style="height: 80%;">
        <div class="modal-header">
            <span id="ai-products-modal-title">AI为你生成了以下宝贝</span>
        </div>
        <div class="modal-body" style="padding: 15px;">
            <div id="ai-product-results-grid" class="product-grid">
                <!-- AI生成的商品会显示在这里 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-ai-products-modal-btn" style="width: 100%;">完成</button>
        </div>
    </div>
</div>

<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 在 </body> 标签的正上方，粘贴下面这一整块新代码 ▼▼▼ -->

<!-- 【全新】飞行棋问题库管理模态框 (已修改) -->
<div id="ludo-qbank-manager-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span>管理问题库</span>
            <!-- ▼▼▼ 核心修改在这里 ▼▼▼ -->
            <div class="header-actions">
                <span class="action-btn" id="import-ludo-qbank-btn" title="导入题库">
                    <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="17 8 12 3 7 8"></polyline>
                        <line x1="12" y1="3" x2="12" y2="15"></line>
                    </svg>
                </span>
                <span class="action-btn" id="add-ludo-qbank-btn" style="font-size: 16px;">新建</span>
            </div>
            <!-- ▲▲▲ 修改结束 ▲▲▲ -->
        </div>
        <div class="modal-body" id="ludo-qbank-list" style="padding: 0;">
            <!-- 问题库列表将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button class="save" id="close-qbank-manager-btn" style="width: 100%;">完成</button>
        </div>
    </div>
</div>


<!-- 【全新】飞行棋问题编辑器模态框 -->
<div id="ludo-question-editor-modal" class="modal">
    <div class="modal-content" style="height: 80%;">
        <div class="modal-header">
            <span class="back-btn" id="back-to-qbank-manager-btn">‹</span>
            <span id="ludo-question-editor-title">编辑问题</span>
            <span class="action-btn" id="add-ludo-question-btn" style="font-size: 28px; font-weight: 300;">+</span>
        </div>
        <div class="modal-body" id="ludo-question-list" style="padding: 10px;">
            <!-- 问题列表将由JS动态生成在这里 -->
        </div>
    </div>
</div>

<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 在 </body> 标签的正上方，粘贴下面这一整块新代码 ▼▼▼ -->
<!-- 【全新】飞行棋单个问题编辑器模态框 -->
<div id="ludo-single-question-editor-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span id="ludo-single-question-title">编辑问题</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="ludo-question-text-input">问题内容</label>
                <textarea id="ludo-question-text-input" rows="4"></textarea>
            </div>
            <div class="form-group">
                <label>问题类型</label>
                <div style="display: flex; gap: 20px;">
                    <label><input type="radio" name="ludo_question_type" value="both_answer" checked> 共同回答</label>
                    <label><input type="radio" name="ludo_question_type" value="single_answer"> 一人回答,一人评价</label>
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-single-question-btn">取消</button>
            <button class="save" id="save-single-question-btn">保存</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】这是飞行棋游戏结算卡片，请粘贴到 </body> 标签前 ▼▼▼ -->
<div id="ludo-summary-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 80%;">
        <div class="modal-header">
            <span>游戏结算</span>
        </div>
        <div class="modal-body" id="ludo-summary-content" style="text-align: left; line-height: 1.7;">
            <!-- 结算内容将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="share-ludo-summary-btn">分享给Ta</button>
            <button class="save" id="back-to-hall-from-ludo-btn">返回大厅</button>
        </div>
    </div>
</div>
<!-- ▼▼▼ 【全新】“谁是卧底”游戏结算卡片 ▼▼▼ -->
<div id="undercover-summary-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 80%;">
        <div class="modal-header">
            <span>游戏结算</span>
        </div>
        <div class="modal-body" id="undercover-summary-content" style="white-space: pre-wrap; line-height: 1.7;">
            <!-- 结算内容将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <!-- 这是我们新增的“分享复盘”按钮 -->
            <button class="cancel" id="repost-undercover-summary-btn">分享复盘到单聊</button>
            <button class="save" id="back-to-hall-from-undercover-btn">返回大厅</button>
        </div>
    </div>
</div>
<!-- ▼▼▼ 在 </body> 标签前，粘贴下面这整块【全新的】HTML代码 ▼▼▼ -->
<!-- “谁是卧底”复盘发送目标选择器 -->
<div id="undercover-target-picker-modal" class="modal">
    <div class="modal-content" style="height: 60%;">
        <div class="modal-header">
            <span>选择要发送的玩家</span>
        </div>
        <div class="modal-body" id="undercover-target-list" style="padding: 0;">
            <!-- 玩家列表将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button id="uc-select-all-btn" class="form-button-secondary" style="width: 45%; margin: 0;">全选</button>
            <button id="uc-deselect-all-btn" class="form-button-secondary" style="width: 45%; margin: 0;">全不选</button>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="uc-cancel-share-btn">取消</button>
            <button class="save" id="uc-confirm-share-btn">确认发送</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】群公告模态框 ▼▼▼ -->
<div id="group-announcement-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <span>群公告</span>
        </div>
        <div class="modal-body" id="announcement-content-area">
            <!-- 公告内容将显示在这里 -->
        </div>
        <div class="modal-footer" id="announcement-footer">
            <!-- 按钮将由JS动态生成 -->
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】这是心声面板的样式编辑器弹窗 ▼▼▼ -->
<div id="inner-voice-editor-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span>编辑心声面板样式</span>
        </div>
        <div class="modal-body">
            <!-- 卡片背景颜色 -->
            <div class="form-group">
                <label for="iv-card-bg-color">卡片背景颜色</label>
                <input type="color" id="iv-card-bg-color" value="#FFFFFF" style="width: 100%; height: 40px;">
            </div>
            <!-- 卡片透明度 -->
            <div class="form-group">
                <label for="iv-opacity-slider">卡片背景透明度: <span id="iv-opacity-value">70%</span></label>
                <input type="range" id="iv-opacity-slider" min="0" max="1" step="0.05" value="0.7" style="width: 100%;">
            </div>
            <hr style="opacity: 0.2;">
            <!-- 四个标签的背景色 -->
            <div class="form-group">
                <label for="iv-color-clothing">“服装”标签背景色</label>
                <input type="color" id="iv-color-clothing" value="#f0a1a8" style="width: 100%; height: 40px;">
            </div>
            <div class="form-group">
                <label for="iv-color-behavior">“行为”标签背景色</label>
                <input type="color" id="iv-color-behavior" value="#81c784" style="width: 100%; height: 40px;">
            </div>
            <div class="form-group">
                <label for="iv-color-thoughts">“心声”标签背景色</label>
                <input type="color" id="iv-color-thoughts" value="#64b5f6" style="width: 100%; height: 40px;">
            </div>
            <div class="form-group">
                <label for="iv-color-naughty">“坏心思”标签背景色</label>
                <input type="color" id="iv-color-naughty" value="#ba68c8" style="width: 100%; height: 40px;">
            </div>
            <!-- ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼ -->
<hr style="opacity: 0.2; margin: 20px 0;">
<div class="form-group">
    <label for="iv-icon-color">图标颜色</label>
    <input type="color" id="iv-icon-color" value="#ff8a80" style="width: 100%; height: 40px;">
</div>
<!-- ▲▲▲ 新增代码粘贴结束 ▲▲▲ -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="iv-editor-cancel-btn">取消</button>
            <button class="save" id="iv-editor-save-btn">保存</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 把这一整块全新的HTML代码，粘贴到 </body> 标签的正上方 ▼▼▼ -->

<!-- 【全新】AI生成群成员模态框 -->
<div id="ai-generate-members-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span>AI 生成群成员</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="ai-member-count-input">生成人数 (1-20)</label>
                <input type="number" id="ai-member-count-input" value="3" min="1" max="20">
            </div>
            <div class="form-group">
                <label for="ai-member-prompt-input">要求 (可选，AI会参考)</label>
                <textarea id="ai-member-prompt-input" rows="4" placeholder="例如：一群喜欢户外探险的大学生，性格各异..."></textarea>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-ai-generate-members-btn">取消</button>
            <button class="save" id="confirm-ai-generate-members-btn">开始生成</button>
        </div>
    </div>
</div>

<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】约会邀请与支付模态框 ▼▼▼ -->
<div id="dating-payment-modal" class="modal">
    <div class="modal-content" style="width: 300px; height: auto;">
        <div class="modal-header">
            <span id="dating-modal-title">发起约会邀请</span>
        </div>
        <div class="modal-body" style="text-align: center;">
            <p>你选择的约会是：</p>
            <h3 id="dating-modal-scene-name" style="color: var(--accent-color); margin: 10px 0;"></h3>
            <p id="dating-modal-scene-cost" style="font-weight: bold;"></p>
            <hr style="opacity: 0.2; margin: 20px 0;">
            <p>由谁来买单呢？</p>
            <div id="dating-payment-options" style="display: flex; flex-direction: column; gap: 10px;">
                <!-- 支付选项按钮将由JS动态生成 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="dating-cancel-btn" style="width:100%;">下次再说</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】约会角色选择弹窗 ▼▼▼ -->
<div id="dating-char-selector-modal" class="modal">
    <div class="modal-content" style="height: 60%;">
        <div class="modal-header">
            <span>选择约会对象</span>
        </div>
        <div class="modal-body" id="dating-char-selector-list" style="padding: 0;">
            <!-- 角色列表将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="dating-cancel-char-select-btn" style="width: 100%;">取消</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 用这整块【最终修复版】的代码，替换你旧的 id="dating-game-screen" 的 div ▼▼▼ -->
<div id="dating-game-screen" class="screen">
    <!-- 1. 动态背景图 (最底层) -->
    <div id="dating-game-background"></div>

    <!-- 2. 角色立绘容器 (中间层) -->
    <div id="dating-game-sprite-container">
        <img id="dating-game-sprite" src="">
    </div>

    <!-- 3. UI覆盖层 (最顶层, 包含头部/文本框/选项) -->
    <div class="dating-game-ui-overlay">
<!-- ▼▼▼ 请用这块【已添加心形UI】的代码，完整替换掉你旧的 id="dating-game-screen" 里的那个 .header ▼▼▼ -->
<div class="header">
    <span class="back-btn" id="end-date-btn">结束约会</span>
    <span id="dating-game-char-name"></span>
    <div class="header-actions">

        <!-- ★★★★★ 这就是我们新加的心形数值条 ★★★★★ -->
        <div id="dating-values-container">
            <div id="romance-value" class="value-display">
                <!-- 我们会用JS在这里生成5个粉色心形 -->
            </div>
            <div id="lust-value" class="value-display">
                <!-- 我们会用JS在这里生成5个黄色心形 -->
            </div>
        </div>
        <!-- ★★★★★ 新增HTML结束 ★★★★★ -->

        <span class="action-btn" id="dating-game-settings-btn" title="场景设置">
            <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>
        </span>
        <span class="action-btn" id="dating-game-reroll-btn" title="重Roll回应">
            <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg>
        </span>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->


        <!-- 3b. 底部文本框 -->
        <div class="dating-game-textbox">
            <p id="dating-game-text-content">约会即将开始...</p>
        </div>

        <!-- 3c. 玩家操作区 -->
        <div id="dating-game-choices" class="dating-game-choices">
            <!-- 选项按钮将由JS动态生成在这里 -->
        </div>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
    <div id="dating-completion-bar-container">
        <div id="dating-completion-bar-fill"></div>
        <span id="dating-completion-text">0%</span>
    </div>


<!-- ▼▼▼ 【全新】借钱对象选择弹窗（带滚动和头像）▼▼▼ -->
<div id="borrow-money-modal" class="modal">
    <div class="modal-content" style="height: 60%;">
        <div class="modal-header">
            <span>向谁借钱？</span>
        </div>
        <div class="modal-body" id="borrow-money-char-list" style="padding: 0; overflow-y: auto;">
            <!-- 借钱对象列表将由JS动态生成在这里 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="borrow-money-cancel-btn" style="width: 100%;">取消</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 用这块【立绘功能增强版】代码，完整替换旧的 id="dating-game-settings-modal" ▼▼▼ -->
<div id="dating-game-settings-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <span>约会场景设置</span>
        </div>
        <div class="modal-body">
            <!-- 预设管理 (保持不变) -->
            <div class="form-group">
                <label>预设方案</label>
                <div class="bubble-preset-manager">
                    <select id="dating-preset-select" class="form-group select"></select>
                    <button id="manage-dating-presets-btn" class="action-btn">管理</button>
                </div>
            </div>

            <hr style="opacity: 0.2;">
            
            <!-- ★★★ 核心新增：立绘组选择器 ★★★ -->
            <div class="form-group">
                <label>选择角色立绘组</label>
                <div class="bubble-preset-manager">
                    <select id="dating-sprite-group-select" class="form-group select">
                        <option value="">-- 不使用立绘 --</option>
                        <!-- 立绘组将由JS动态填充 -->
                    </select>
                    <button id="manage-sprite-groups-btn" class="action-btn">管理立绘组</button>
                </div>
            </div>
            <!-- ★★★ 新增结束 ★★★ -->

            <hr style="opacity: 0.2;">

            <!-- 核心设置 (保持不变) -->
            <div class="form-group">
                <label for="dating-prompt-input">场景/角色提示词 (Prompt)</label>
                <textarea id="dating-prompt-input" rows="4" placeholder="例如：你是一个傲娇但内心温柔的少女，在海边对用户的表白感到不知所措..."></textarea>
            </div>
            <div class="form-group">
                <label for="dating-style-input">文风 (Style)</label>
                <textarea id="dating-style-input" rows="3" placeholder="例如：请使用细腻的心理描写和优美的风景描写..."></textarea>
            </div>
            <div class="form-group">
                <label>约会背景图</label>
                <div class="bg-upload-container">
                    <button class="form-button-secondary" onclick="document.getElementById('dating-bg-upload-input').click()" style="margin-top:0;">上传图片</button>
                    <input type="text" id="dating-bg-url-input" placeholder="或粘贴网络图片URL" style="flex-grow:1;">
                </div>
                 <input type="file" id="dating-bg-upload-input" accept="image/*" hidden>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-dating-settings-btn">取消</button>
            <button class="save" id="save-dating-settings-btn">应用并保存</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->
<!-- ▼▼▼ 在 </body> 前，粘贴下面这两块全新的弹窗HTML ▼▼▼ -->

<!-- 1. 【全新】立绘组管理弹窗 -->
<div id="sprite-group-manager-modal" class="modal">
    <div class="modal-content" style="height: 60%;">
        <div class="modal-header">
            <span>管理立绘组</span>
            <span class="action-btn" id="create-new-sprite-group-btn" style="font-size: 16px;">新建</span>
        </div>
        <div class="modal-body" id="sprite-group-list-container" style="padding: 0;">
            <!-- 立绘组列表将由JS动态生成 -->
        </div>
        <div class="modal-footer">
            <button class="save" id="close-sprite-group-manager-btn" style="width: 100%;">完成</button>
        </div>
    </div>
</div>

<!-- 2. 【全新】立绘组编辑器弹窗 -->
<div id="sprite-editor-modal" class="modal">
    <div class="modal-content" style="height: 90%;">
        <div class="modal-header">
            <span id="sprite-editor-title">编辑立绘组</span>
        </div>
        <div class="modal-body" id="sprite-editor-body">
            <div class="form-group">
                <label for="sprite-group-name-input">立绘组名称</label>
                <input type="text" id="sprite-group-name-input" placeholder="例如：日常、战斗、害羞...">
            </div>
            <hr style="opacity: 0.2;">
            <label>立绘列表</label>
            <div id="sprite-list-editor" style="display: flex; flex-direction: column; gap: 15px; margin-top: 10px;">
                <!-- 单个立绘的编辑卡片将由JS动态生成 -->
            </div>
            <button id="add-new-sprite-btn" class="form-button form-button-secondary" style="margin-top: 20px;">+ 添加一个新立绘</button>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-sprite-editor-btn">取消</button>
            <button class="save" id="save-sprite-editor-btn">保存立绘组</button>
        </div>
    </div>
</div>

<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 约会结算卡片 ▼▼▼ -->
<div id="dating-summary-overlay" class="modal">
    <div class="dating-summary-card">
        <div class="dating-summary-card-inner">
            <!-- 卡片正面 -->
            <div class="card-front">
                <img id="summary-card-avatar" src="" alt="角色头像">
                <h2 id="summary-card-rating"></h2>
                <p class="summary-card-tip">点击卡片查看完整约会记录</p>
                <div class="summary-card-actions">
                    <button id="summary-share-btn">分享给Ta</button>
                    <button id="summary-close-btn">关闭</button>
                </div>
            </div>
            <!-- 卡片背面 -->
            <div class="card-back">
                <div class="card-back-header">
                    <span>完整约会记录</span>
                    <button id="summary-flip-back-btn">返回</button>
                </div>
                <div id="summary-card-history" class="card-back-content">
                    <!-- 约会历史记录将由JS动态生成在这里 -->
                </div>
            </div>
        </div>
    </div>
</div>


<!-- ▼▼▼ 【全新】这是为约会结算卡片分享功能新增的HTML ▼▼▼ -->
<input type="file" id="dating-summary-image-upload" accept="image/*" hidden>
<!-- ▲▲▲ 新增HTML结束 ▲▲▲ -->
<!-- ▼▼▼ 把这一整块全新的代码，粘贴到 </body> 标签的正上方 ▼▼▼ -->

<!-- 【全新】约会历史记录界面 -->
<div id="dating-history-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="dating-history-back-btn">‹</span>
        <span>历史约会</span>
        <span style="width: 30px;"></span> <!-- 占位符，保持标题居中 -->
    </div>
    <div id="dating-history-list" class="list-container">
        <!-- 历史约会卡片将由JS动态生成在这里 -->
    </div>
</div>

<!-- ▲▲▲ 新增HTML代码结束 ▲▲▲ -->
<!-- ▼▼▼ 用这块【已优化提示】的代码，替换旧的创建场景弹窗 ▼▼▼ -->
<div id="create-dating-scene-modal" class="modal">
    <div class="modal-content" style="width: 300px; height: auto;">
        <div class="modal-header">
            <span>创建约会场景</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="scene-name-input">场景名称</label>
                <input type="text" id="scene-name-input" placeholder="例如：月光下的海滩漫步">
            </div>
            <div class="form-group">
                <label for="scene-image-url-input">图片 URL (可选)</label>
                <!-- ★★★ 核心修改：更新了 placeholder 提示文字 ★★★ -->
                <input type="text" id="scene-image-url-input" placeholder="留空则由AI根据场景名生成图片...">
            </div>
            <div class="form-group">
                <label for="scene-cost-input">花费 (金币)</label>
                <input type="number" id="scene-cost-input" placeholder="例如：520">
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-create-scene-btn">取消</button>
            <button class="save" id="save-custom-scene-btn">保存</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->



<!-- ▼▼▼ 用这整块代码替换旧的 inner-voice-modal ▼▼▼ -->
<div id="inner-voice-modal" class="modal">
    <!-- 心声主面板 -->
    <div id="inner-voice-main-panel" class="modal-content" style="width: 90%; max-width: 340px; height: auto; max-height: 80%; background-color: #fffafb; border: 1px solid #ffe4e1;">
<!-- ▼▼▼ 用这块新代码替换旧的 <div class="modal-header">...</div> ▼▼▼ -->
<div class="modal-header" style="border-bottom: 1px solid #ffe4e1; padding: 12px 15px; display: flex; justify-content: space-between; align-items: center;">
    <span id="close-inner-voice-modal" style="cursor: pointer; font-size: 24px;">×</span>
    
    <div style="display: flex; align-items: center; gap: 15px;">
        <span id="inner-voice-edit-btn" style="cursor: pointer;" title="编辑心声面板">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M12 20h9"></path>
                <path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>
            </svg>
        </span>
        <span id="change-inner-voice-bg-btn" style="cursor: pointer;" title="更换背景">
            <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                <circle cx="8.5" cy="8.5" r="1.5"></circle>
                <polyline points="21 15 16 10 5 21"></polyline>
            </svg>
        </span>
        <span id="inner-voice-history-btn" style="cursor: pointer;">
            <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
            </svg>
        </span>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->



        <div class="modal-body" style="padding: 15px;">
            <!-- 头像和名字信息现在是独立的、可定位的元素 -->
            <!-- 角色头像 -->
            <div id="inner-voice-avatar-wrapper">
                <img id="inner-voice-avatar" src="">
                <!-- 【全新】这是为头像框预留的位置 -->
                <img id="inner-voice-avatar-frame" src="" style="display: none;">
            </div>

            
            <!-- 角色名字 -->
            <div id="inner-voice-char-info">
                <div id="inner-voice-char-name"></div>
            </div>

            <!-- 【全新】领养人信息（头像+名字）-->
            <div id="inner-voice-adopter-info">
                <img id="inner-voice-adopter-avatar" src="">
                <span id="inner-voice-adopter-name"></span>
            </div>
            
            <!-- 心声内容 -->
            <div id="inner-voice-content-area" style="display: flex; flex-direction: column; gap: 15px;">
                <div>
                    <strong style="color: #e57373;">服装:</strong>
                    <p id="inner-voice-clothing" style="margin: 5px 0 0 0; line-height: 1.6; color: #555;"></p>
                </div>
                <div>
                    <strong style="color: #81c784;">行为:</strong>
                    <p id="inner-voice-behavior" style="margin: 5px 0 0 0; line-height: 1.6; color: #555;"></p>
                </div>
                <div>
                    <strong style="color: #64b5f6;">心声:</strong>
                    <p id="inner-voice-thoughts" style="margin: 5px 0 0 0; line-height: 1.6; color: #555;"></p>
                </div>
                <div>
                    <strong style="color: #ba68c8;">坏心思:</strong>
                    <p id="inner-voice-naughty-thoughts" style="margin: 5px 0 0 0; line-height: 1.6; color: #555;"></p>
                </div>
            </div>
        </div>
    </div>

    <!-- 历史记录面板 (保持不变) -->
    <div id="inner-voice-history-panel" class="modal-content" style="width: 90%; max-width: 340px; height: 80%; background-color: #f5f5f5; display: none; flex-direction: column;">
        <div class="modal-header" style="border-bottom: 1px solid #ddd; justify-content: space-between;">
            <span id="back-from-history-btn" style="cursor: pointer; font-size: 16px; font-weight: 600; color: var(--accent-color);">返回</span>
            <span>历史心声</span>
            <span id="clear-all-history-btn" style="cursor: pointer; font-size: 14px; color: #ff3b30;">全部清空</span>
        </div>
        <div class="modal-body" id="inner-voice-history-list" style="padding: 0;">
            <!-- 历史记录会由JS动态生成在这里 -->
        </div>
    </div>
</div>
<!-- ▲▲▲ 替换结束 ▲▲▲ -->


<script>
// ▼▼▼ 把这一整块超长的塔罗牌数据，粘贴到 const GEMINI_API_URL 的正上方 ▼▼▼

const TAROT_DECK = [
    { name: "愚人", upright: "开始, 天真, 自发性, 自由精神", reversed: "天真, 鲁莽, 承担风险" },
    { name: "魔术师", upright: "显化, 足智多谋, 力量, 灵感行动", reversed: "操纵, 计划不周, 未被利用的天赋" },
    { name: "女祭司", upright: "直觉, 神圣女性, 潜意识, 神秘", reversed: "秘密, 脱离直觉, 压抑的感情" },
    { name: "皇后", upright: "生育, 女性气质, 美丽, 自然, 丰富", reversed: "创造力受阻, 依赖他人" },
    { name: "皇帝", upright: "权威, 父亲形象, 结构, 稳固控制", reversed: "控制欲, 僵化, 缺乏纪律" },
    { name: "教皇", upright: "精神智慧, 宗教信仰, 传统, 制度", reversed: "个人信仰, 挑战传统, 墨守成规" },
    { name: "恋人", upright: "爱, 和谐, 关系, 价值观对齐, 选择", reversed: "不和谐, 失衡, 价值观错位" },
    { name: "战车", upright: "控制, 意志力, 胜利, 断言, 决心", reversed: "缺乏控制和方向, 侵略性" },
    { name: "力量", upright: "力量, 勇气, 同情, 专注, 耐心", reversed: "内在力量, 自我怀疑, 精力不足" },
    { name: "隐士", upright: "灵魂探索, 内省, 孤独, 内在引导", reversed: "孤立, 孤独, 退缩" },
    { name: "命运之轮", upright: "好运, 因果报应, 生命周期, 转折点", reversed: "坏运气, 抵抗改变, 打破循环" },
    { name: "正义", upright: "正义, 公平, 真理, 因果, 法律", reversed: "不公平, 缺乏责任感, 不诚实" },
    { name: "倒吊人", upright: "暂停, 限制, 放手, 牺牲, 新视角", reversed: "拖延, 毫无意义的牺牲, 停滞" },
    { name: "死神", upright: "结束, 改变, 转变, 过渡", reversed: "抵抗改变, 无法前进, 停滞" },
    { name: "节制", upright: "平衡, 适度, 耐心, 目标", reversed: "失衡, 过度, 重新调整" },
    { name: "恶魔", upright: "束缚, 成瘾, 消极, 唯物主义", reversed: "挣脱束缚, 释放, 恢复控制" },
    { name: "高塔", upright: "突变, 剧变, 混乱, 启示, 觉醒", reversed: "避免灾难, 害怕改变" },
    { name: "星星", upright: "希望, 信念, 目标, 更新, 灵性", reversed: "缺乏信念, 绝望, 不专注" },
    { name: "月亮", upright: "幻觉, 恐惧, 焦虑, 潜意识, 直觉", reversed: "释放恐惧, 压抑的情感, 内心困惑" },
    { name: "太阳", upright: "积极, 乐趣, 温暖, 成功, 活力", reversed: "内心幼稚, 过于乐观, 沮丧" },
    { name: "审判", upright: "审判, 重生, 内心召唤, 赦免", reversed: "自我怀疑, 无视召唤" },
    { name: "世界", upright: "完成, 整合, 成就, 旅行", reversed: "寻求个人结束, 走捷径, 拖延" },
    { name: "权杖ACE", upright: "灵感, 新机会, 成长, 潜力", reversed: "缺乏动力, 错过机会, 拖延" },
    { name: "权杖二", upright: "未来规划, 进步, 决策, 离开家", reversed: "恐惧未知, 缺乏规划, 害怕改变" },
    { name: "权杖三", upright: "扩张, 成长, 远见, 海外机会", reversed: "计划受挫, 缺乏远见, 延误" },
    { name: "权杖四", upright: "庆祝, 和谐, 婚姻, 回家, 稳定", reversed: "不和谐, 过渡, 缺乏支持" },
    { name: "权杖五", upright: "冲突, 分歧, 竞争, 紧张", reversed: "冲突避免, 尊重差异" },
    { name: "权杖六", upright: "成功, 公众认可, 胜利, 进步", reversed: "自负, 缺乏认可, 惩罚" },
    { name: "权杖七", upright: "挑战, 竞争, 保护, 坚持", reversed: "放弃, 不知所措, 过度保护" },
    { name: "权杖八", upright: "速度, 行动, 空中旅行, 运动, 快速决策", reversed: "延误, 挫折, 抵制改变" },
    { name: "权杖九", upright: "韧性, 勇气, 坚持, 界限", reversed: "内心挣扎, 偏执, 防御性" },
    { name: "权杖十", upright: "负担, 责任, 努力工作, 压力", reversed: "卸下负担, 委派, 释放" },
    { name: "权杖侍从", upright: "灵感, 想法, 发现, 自由精神", reversed: "不切实际的想法, 拖延, 创造力受阻" },
    { name: "权杖骑士", upright: "能量, 激情, 欲望, 行动, 冒险", reversed: "愤怒, 冲动, 鲁莽" },
    { name: "权杖王后", upright: "勇气, 自信, 独立, 社交蝴蝶", reversed: "自我尊重, 自信, 内向" },
    { name: "权杖国王", upright: "天生的领袖, 远见, 企业家, 荣誉", reversed: "冲动, 仓促, 无情的" },
    { name: "圣杯ACE", upright: "爱, 新关系, 同情, 创造力", reversed: "自我爱, 直觉, 压抑的情感" },
    { name: "圣杯二", upright: "统一的爱, 伙伴关系, 相互吸引", reversed: "分手, 不和谐, 不信任" },
    { name: "圣杯三", upright: "庆祝, 友谊, 创造力, 合作", reversed: "独立, 独处, '三人行'" },
    { name: "圣杯四", upright: "沉思, 断开连接, 冷漠, 重新评估", reversed: "退缩, 孤僻, 错过机会" },
    { name: "圣杯五", upright: "遗憾, 失败, 失望, 悲观主义", reversed: "个人挫折, 自我宽恕, 前进" },
    { name: "圣杯六", upright: "重温过去, 童年记忆, 天真, 喜悦", reversed: "活在过去, 不愿原谅, 缺乏玩乐" },
    { name: "圣杯七", upright: "机会, 选择, 幻想, 幻觉", reversed: "一致性, 幻想, 过多选择" },
    { name: "圣杯八", upright: "失望, 放弃, 退缩, 逃避主义", reversed: "尝试新事物, 冷漠, 恐惧改变" },
    { name: "圣杯九", upright: "满足, 满意, 感激, 愿望成真", reversed: "不满足, 唯物主义, 不满" },
    { name: "圣杯十", upright: "神圣的爱, 和谐关系, 家庭, 一致性", reversed: "脱节, 对齐错误, 挣扎的关系" },
    { name: "圣杯侍从", upright: "创意机会, 直觉信息, 好奇心", reversed: "新的想法, 怀疑, 创造力受阻" },
    { name: "圣杯骑士", upright: "创造力, 浪漫, 魅力, 想象力", reversed: "不切实际, 嫉妒, 情绪波动" },
    { name: "圣杯王后", upright: "富有同情心, 关怀, 直觉, 平静", reversed: "内在感受, 自我照顾, 自爱, 共情" },
    { name: "圣杯国王", upright: "情绪平衡, 同情, 外交", reversed: "自我同情, 内在真理, 情绪不稳定" },
    { name: "宝剑ACE", upright: "突破, 新想法, 头脑清晰, 成功", reversed: "内心清晰, 重新思考一个想法, 混乱" },
    { name: "宝剑二", upright: "艰难的选择, 未知的后果, 僵局", reversed: "优柔寡断, 困惑, 信息过载" },
    { name: "宝剑三", upright: "心碎, 悲伤, 拒绝, 分离", reversed: "释放痛苦, 乐观, 宽恕" },
    { name: "宝剑四", upright: "休息, 放松, 沉思, 恢复", reversed: "精疲力尽, 倦怠, 停滞" },
    { name: "宝剑五", upright: "冲突, 分歧, 竞争, 失败", reversed: "和解, 过去的原谅" },
    { name: "宝剑六", upright: "过渡, 改变, 仪式, 放下", reversed: "个人过渡, 抵抗改变, 未完成的事" },
    { name: "宝剑七", upright: "背叛, 欺骗, 走捷径, 鬼祟", reversed: "冒名顶替综合症, 欺骗, 守秘" },
    { name: "宝剑八", upright: "负面想法, 自我强加的限制, 监禁", reversed: "自我限制的信念, 释放, 思想开放" },
    { name: "宝剑九", upright: "焦虑, 担忧, 恐惧, 抑郁, 噩梦", reversed: "内心挣扎, 深度恐惧, 释放忧虑" },
    { name: "宝剑十", upright: "痛苦的结局, 深度创伤, 背叛, 损失", reversed: "恢复, 抵抗结局, 无法放手" },
    { name: "宝剑侍从", upright: "新想法, 好奇心, 追求真理", reversed: "自言自语, 全能选手, 仓促" },
    { name: "宝剑骑士", upright: "雄心勃勃, 行动导向, 追求目标", reversed: "不安, 冲动, 倦怠" },
    { name: "宝剑王后", upright: "独立的, 无偏见的判断, 清晰的界限", reversed: "过于情绪化, 轻易受影响, 刻薄" },
    { name: "宝剑国王", upright: "精神清晰, 智慧, 权威, 真理", reversed: "安静的力量, 内在真理, 滥用权力" },
    { name: "星币ACE", upright: "显化, 新的财务机会, 繁荣", reversed: "机会丧失, 缺乏规划和远见" },
    { name: "星币二", upright: "多任务, 适应性, 时间管理", reversed: "重新调整优先级, 过度投入" },
    { name: "星币三", upright: "团队合作, 合作, 学习, 实施", reversed: "不和谐, 团队内部冲突, 计划不周" },
    { name: "星币四", upright: "节约, 安全, 保守, 稀缺心态", reversed: "过度消费, 贪婪, 自我保护" },
    { name: "星币五", upright: "财务损失, 贫困, 孤立, 忧虑", reversed: "从财务损失中恢复, 精神贫困" },
    { name: "星币六", upright: "给予, 接受, 分享财富, 慷慨", reversed: "自私, 债务, 单方面给予" },
    { name: "星币七", upright: "长期眼光, 可持续的结果, 投资", reversed: "缺乏长期眼光, 成功受限" },
    { name: "星币八", upright: "学徒, 重复, 掌握, 技能发展", reversed: "自我发展, 完美主义, 部署不当" },
    { name: "星币九", upright: "丰富, 奢华, 自给自足, 财务独立", reversed: "自我价值, 过度投资于工作" },
    { name: "星币十", upright: "财富, 财务安全, 家庭, 遗产", reversed: "财务失败, 负担, 遗产丧失" },
    { name: "星币侍从", upright: "显化, 财务机会, 技能发展", reversed: "缺乏进步, 拖延, 学会新技能" },
    { name: "星币骑士", upright: "努力工作, 生产力, 日常, 保守", reversed: "自我纪律, 无聊, 感觉'卡住'" },
    { name: "星币王后", upright: "养育, 务实, 财务安全, 工作与家庭的平衡", reversed: "财务独立, 自我照顾, 工作与家庭的不平衡" },
    { name: "星币国王", upright: "财富, 商业, 领导力, 安全, 纪律", reversed: "财务不称职, 过时, 固执" }
];

// ▲▲▲ 塔罗牌数据粘贴结束 ▲▲▲
// ▼▼▼ 把这一整块全新的代码，粘贴到 const GEMINI_API_URL 的正上方 ▼▼▼

const BUILT_IN_SCRIPTS = [
    {
        id: 'built_in_1',
        name: '办公室疑云',
        storyBackground: '深夜，顶级互联网公司“比特无限”灯火通明。以苛刻闻名的项目总监王强，被发现死在自己的座位上，死因为药物中毒。警方初步锁定了当晚还在公司的五位嫌疑人，每个人似乎都与死者有着千丝万缕的联系。在这座欲望与代码交织的钢铁森林里，谁的秘密被永远埋葬，谁的双手沾染了罪恶？',
        roles: [
            {
                name: '李思',
                description: '公司新晋的天才程序员，技术过硬，但性格内向，不善言辞。',
                storyline: `今天是项目上线的最后期限，我被王总监逼着加班到深夜。\n**晚上8:00**：王总监把我叫进他办公室，因为一个微不足道的bug对我破口大骂，甚至撕掉了我的绩效评估报告，说我“不合格”。我气得浑身发抖，和他大吵了一架，然后摔门而出。\n**晚上8:30**：我回到工位，越想越气，打开电脑写了一封辞职信，但还没发送。\n**晚上9:00**：我起身去茶水间倒水，路过总监办公室时，看到人事主管陈静端着一杯咖啡走了进去。我当时没太在意。\n**晚上9:30**：我有点饿，点了一份外卖。等外卖的时候，我看到设计师孙伟鬼鬼祟祟地从茶水间的方向走出来，手里好像攥着什么东西。\n**晚上10:00**：外卖到了，我吃完外卖继续改bug，直到被发现尸体的惊叫声打断。`,
                tasks: '1. 隐藏你与王强总监发生过激烈争吵，并被他评为“不合格”的事实。\n2. 你的首要目标是自保，找到证据证明你离开后另有其人进入过办公室。\n3. 你怀疑陈静和孙伟，尝试找出他们的可疑之处。',
                isKiller: false
            },
            {
                name: '赵娜',
                description: '公司的市场部经理，能力出众，是典型的职场女强人，野心勃勃。',
                storyline: `今晚本不需要我加班，但我为了准备一个重要的竞标方案，主动留了下来。\n**晚上7:30**：我在自己的办公室整理资料，无意中发现了王强挪用项目公款的证据。我立刻起草了一封匿名举报邮件，准备发给总部。\n**晚上8:10**：我听到隔壁总监办公室传来激烈的争吵声，好像是李思在和王强吵架。\n**晚上8:45**：我需要一些数据，就去找王强签字。进他办公室时，他正在喝咖啡，脸色很差。我把文件给他，他很不耐烦地签了字。我注意到他桌上放着一瓶没贴标签的药瓶。\n**晚上9:15**：我回到自己办公室，思考着举报邮件的事情。我担心这会影响公司声誉，最终还是没有发送。\n**晚上10:15**：我准备下班，路过总监办公室时，发现门虚掩着，里面很安静。我没有进去看，直接离开了公司。`,
                tasks: '1. 你的首要任务是找出真凶，洗清自己的嫌疑，确保公司丑闻不被曝光，以免影响你的职业前途。\n2. 隐藏你发现王强挪用公款并准备举报他的事实。\n3. 你看到他桌上的药瓶，这是一个重要线索，你需要引导大家注意到这一点。',
                isKiller: false
            },
            {
                name: '孙伟',
                description: '公司的资深UI设计师，也是王强的老部下，表面对他毕恭毕敬。',
                storyline: `我恨透了王强！他克扣了我们团队辛辛苦苦做完的项目奖金，自己却拿了大头。\n**晚上9:00**：我借口加班，实际上是想潜入王强的办公室，找到他克扣奖金的证据。我看到陈静端着咖啡进去后不久就出来了。\n**晚上9:20**：我确认王强办公室没人注意，就偷偷溜了进去。我看到他趴在桌上睡着了，旁边是那杯几乎没喝的咖啡。我在他抽屉里翻找，果然找到了一份内部奖金分配表，证实了他中饱私囊。我用手机拍了下来。\n**晚上9:30**：我拿着证据悄悄离开办公室，准备去茶水间处理一下。这时迎面撞上了去倒水的李思，我吓了一跳，赶紧把手机藏进口袋里。\n**晚上10:00后**：我一直在自己的工位上，盘算着怎么利用这个证据让他身败名裂。`,
                tasks: '1. 隐藏你曾潜入总监办公室并偷拍证据的事实。\n2. 王强死了对你有利，你需要引导大家怀疑其他有动机的人，比如与他争吵的李思。\n3. 保护好你手机里的照片证据，这是你的护身符。',
                isKiller: false
            },
            {
                name: '陈静',
                description: '公司的人事主管，外表温柔体贴，善于处理人际关系。',
                storyline: `我曾是王强秘密的情人，他承诺过会和妻子离婚娶我。但最近，我发现他为了攀附一个富家女，准备抛弃我。更让我恐惧的是，他手机里存着我们大量的私密照片和视频，如果曝光，我的职业生涯就全毁了。\n**晚上8:45**：我知道王强有喝咖啡的习惯。我提前准备了强效安眠药，磨成粉末，藏在身上。\n**晚上9:00**：我以关心他为由，为他冲了一杯咖啡，并将安眠药全部倒了进去，然后端进了他的办公室。他当时正在处理文件，没有怀疑，喝了一大口。\n**晚上9:10**：我借口离开，在外面观察。不一会儿，就看到他趴在桌上睡着了。\n**晚上9:20**：我返回办公室，想找到他的手机删除资料。但我怎么也找不到他的手机。此时我发现他已经没了呼吸，我吓坏了，慌乱中，我不小心将他桌上的一条项链（他准备送给那个富家女的）碰掉，掉进了我的手提包里。\n**晚上9:40**：我惊慌失措地逃离了办公室，回到自己的工位假装加班，心乱如麻。`,
                tasks: `【你的核心任务】\n请隐藏你为了销毁证据而失手用安眠药毒杀王强的事实。你是本案的唯一真凶。\n\n【你的行动指南】\n1. 嫁祸他人。你可以利用你看到的、听到的信息，将嫌疑引向李思或孙伟。\n2. 你包里的项链是定时炸弹，想办法合理解释它的来历，或者神不知鬼不觉地处理掉它。\n3. 你的目标是误导所有人，让他们投出错误的凶手。`,
                isKiller: true
            },
            {
                name: '周毅',
                description: '公司大楼的夜班保安，看起来忠厚老实，但观察力敏锐。',
                storyline: `作为保安，我负责大楼夜间的安全巡逻。\n**晚上8:10**：我巡逻到18楼，听到总监办公室里有激烈的争吵声，好像是那个叫李思的程序员，我没敢靠近。\n**晚上9:00**：我看到人事主管陈静端着杯咖啡进了总监办公室，几分钟后就出来了，看起来有点紧张。\n**晚上9:20**：我看到UI设计师孙伟，像做贼一样溜进了总监办公室。\n**晚上9:40**：我又看到陈静从总监办公室出来，这次她脸色惨白，脚步匆忙，好像丢了魂一样。我觉得很奇怪，但没敢多问。\n**晚上10:30**：我进行例行检查，发现总监办公室的门没关，进去一看，发现王总监已经……我立刻报了警。`,
                tasks: '1. 你是本案最重要的目击证人，你的任务是诚实、准确地向大家提供你看到的时间线索。\n2. 你觉得陈静的行为最可疑，你需要重点观察她，并向大家说明你的怀疑。\n3. 找出对公司最有利的真相，避免事件扩大化。',
                isKiller: false
            }
        ],
        clues: [
            { owner: '李思', description: '一张被揉成一团、丢在垃圾桶里的绩效评估报告，上面有王强龙飞凤舞的签名和“不合格，建议辞退”的批注。' },
            { owner: '赵娜', description: '你的电脑里有一封未发送的邮件，收件人是集团总部纪检委，标题是“关于比特无限项目总监王强涉嫌严重职务侵占的实名举报”。' },
            { owner: '孙伟', description: '你的手机相册里有一张照片，内容是一份内部奖金分配表，表格显示项目总奖金的70%都流向了王强的个人账户。' },
            { owner: '陈静', description: '在你的手提包夹层里，发现了一条价值不菲的钻石项链，包装盒还在，但没有贺卡。', isKey: true },
            { owner: '周毅', description: '一份保安巡逻日志，清晰地记录了你在不同时间点看到不同人进出总监办公室的情况。' },
            { owner: '公共', description: '在茶水间垃圾桶里发现一个空的安眠药药瓶，上面的标签被撕掉了。' },
            { owner: '公共', description: '在死者办公桌下发现一部手机，但不是死者常用的那部，手机已经没电了。' }
        ],
        truth: '凶手是人事主管陈静。她与总监王强有私情，但王强近期为了利益想和她分手并娶一位富家女。当晚，陈静在王强的咖啡里下了过量安眠药，想让他睡着后偷走他手机里存有的两人亲密照片。但由于药量过大，王强意外死亡。陈静在慌乱中没找到手机，反而不小心将王强准备送给富家女的项链碰进了自己的包里。'
    },
    // --- 【全新剧本1：深海遗书】 ---
    {
        id: 'built_in_2',
        name: '深海遗书',
        storyBackground: '在与世隔绝的“回响岛”上，著名的海洋学家李博士被发现死在自己反锁的书房中，桌上放着一封打印的遗书，死因为氰化物中毒。一场突如其来的风暴切断了岛上与外界的所有联系，将剩下的四个人困在了这座孤岛上：李博士的得意门生、一位竞争对手、一位沉默寡言的技术员，以及一位不请自来的记者。',
        roles: [
            {
                name: '高远',
                description: '李博士的学生，才华横溢但野心勃勃。',
                storyline: `我一直觉得老师窃取了我的研究成果。今晚，我本想和他摊牌。\n**晚上7:00**：我和老师在实验室大吵一架，他承认参考了我的数据，但拒绝公开承认。我愤怒地离开。\n**晚上8:00**：我回到宿舍，越想越气。我利用权限，远程删除了部分对他有利、对我不利的核心实验数据，想让他无法发布论文。\n**晚上9:00**：我去食堂吃饭，看到技术员陈默在调试监控设备，他看起来心事重重。\n**晚上9:45**：我看到记者张莱在李博士书房门口徘徊，似乎想进去但又不敢。`,
                tasks: '1. 隐藏你和老师的学术纠纷以及你删除数据的行为。\n2. 你认为自己的前途受到了威胁，必须找到真凶来洗清嫌疑。\n3. 引导大家怀疑其他有动机的人。',
                isKiller: false
            },
            {
                name: '林雪',
                description: '另一位海洋学家，与李博士是长期的竞争对手。',
                storyline: `我和李博士在竞争一个重要的国际科研基金。我知道他这次的研究有重大突破。\n**晚上7:30**：我去找李博士，希望他能分享一些数据，被他无情拒绝了。我们不欢而散。\n**晚上8:30**：我在自己的房间里整理资料，听到外面有奇怪的电流声，好像是停电了一瞬间又恢复了。\n**晚上9:10**：我口渴去厨房倒水，看到高远神色慌张地从机房的方向出来。\n**晚上10:00**：我经过书房时，闻到一股淡淡的杏仁味（氰化物的典型气味），但我当时以为是实验室的化学品味道，没有在意。`,
                tasks: '1. 李博士的死对你的基金申请有利，这是你的嫌疑点，你需要撇清关系。\n2. 隐藏你曾私下找他索要数据被拒的事实。\n3. 你闻到的杏仁味是关键线索，需要让大家知道。',
                isKiller: false
            },
            {
                name: '陈默',
                description: '研究站的技术员，性格内向，暗恋着李博士。',
                storyline: `我深爱着李博士，但她似乎对我毫不在意。我掌管着整个研究站的设备和监控。\n**晚上8:30**：我接到高远的请求，他让我“不小心”让监控系统断电一分钟。我虽然觉得奇怪，但因为他答应帮我向李博士说好话，我还是照做了。\n**晚上9:00**：我看到李博士把自己锁在书房里，神情悲伤。我很难过，但不敢打扰。\n**晚上9:20**：我看到记者张莱试图撬书房的门锁，被我发现后他慌忙走开了。\n**晚上10:30**：我越想越不对劲，用备用钥匙打开了书房的门，发现了博士的尸体。`,
                tasks: '1. 隐藏你曾受高远指使，人为制造监控断电的事实。\n2. 你有备用钥匙，这让你有重大嫌疑，你需要找到合理的解释。\n3. 你怀疑记者张莱有不轨行为。',
                isKiller: false
            },
            {
                name: '张莱',
                description: '一位追踪学术丑闻的记者，秘密登岛。',
                storyline: `我收到线报，称李博士的研究涉嫌造假，我是来调查真相的。今晚是最好的机会。\n**晚上9:00**：我绕到李博士书房的窗外，看到她正在电脑前打字，似乎在写着什么重要的东西。我用长焦相机拍下了几张模糊的照片。\n**晚上9:20**：我尝试从正门进入书房，想找她当面对质，但门被反锁了。我试图用铁丝开锁，结果被技术员陈默撞见了，我只好假装路过离开。\n**晚上9:50**：我回到自己的住处，放大相机里的照片，发现她打字的内容似乎是一封遗书，但内容很奇怪，好像在暗示什么。我还拍到她桌上有一个遥控器一样的东西。`,
                tasks: '1. 隐藏你记者的身份和你登岛的真实目的。\n2. 你拍到的照片是关键证据，但直接拿出来会暴露你自己。你需要巧妙地引导大家发现遗书和遥控器的问题。\n3. 你是外来者，嫌疑最大，必须尽快找到凶手。',
                isKiller: true
            }
        ],
        clues: [
            { owner: '高远', description: '你的电脑回收站里有一份未发送的邮件，内容是向竞争对手的公司投递简历，并附言可以提供“比特无限”的核心代码。' },
            { owner: '林雪', description: '在你的抽屉里，发现了一瓶标签被撕掉的化学试剂，经过检验，是无毒的营养液。' },
            { owner: '陈默', description: '一张工作日志，上面写着“20:30-20:31，18楼东区服务器意外重启，原因排查中”。'},
            { owner: '张莱', description: '你的相机里有多张照片，其中一张清晰地拍到死者电脑屏幕上的遗书内容，另一张模糊地拍到了桌上的一个小型遥控装置。', isKey: true },
            { owner: '公共', description: '死者手边的咖啡杯里检测出高浓度的氰化物，但奇怪的是，咖啡基本没喝。' },
            { owner: '公共', description: '书房的通风口内侧，发现一个被改装过的、连接着小型雾化喷嘴的遥控香薰机，里面残留有氰化物液体。' },
            { owner: '公共', description: '死者的电脑浏览器历史显示，她在死前最后一个访问的页面是她已故丈夫的纪念网站。' }
        ],
        truth: '凶手是记者张莱。他并非想杀死李博士，而是想制造混乱以窃取学术造假的证据。他提前在书房的通风口安装了遥控毒气装置，计划在采访时如果李博士不配合，就少量释放让她昏迷。但他没想到，当晚李博士因为思念亡夫而情绪低落，正在写一封真的遗书。张莱在窗外看到遗书，误以为时机已到，便按下了遥控器，导致李博士吸入过量毒气身亡。他之后尝试进入房间取回装置未果。'
    },
    // --- 【全新剧本2：古堡魅影】 ---
    {
        id: 'built_in_3',
        name: '古堡魅影',
        storyBackground: '在浓雾笼罩的偏远古堡里，富有而古怪的伯爵被发现死在反锁的书房中，胸口插着一把古董拆信刀。猛烈的暴风雨切断了城堡与外界的唯一桥梁，所有人都被困于此：伯爵年轻貌美的妻子、与他素有嫌隙的侄子、负债累累的私人医生，以及一位被请来进行降神会的女巫。',
        roles: [
            {
                name: '安娜',
                description: '伯爵的年轻妻子，被外界传言是为了财产才嫁给年迈的伯爵。',
                storyline: `我受够了这段没有爱情的婚姻。我爱上了侄子爱德华，我们计划私奔。\n**晚上8:00**：我和爱德华在花园秘密会面，商量私奔的细节。我告诉他，我找到了一条可以通往书房的密道。\n**晚上9:00**：伯爵把我叫到书房，再次因为我购买奢侈品的事与我争吵，并威胁要修改遗嘱，剥夺我的继承权。我愤怒地离开。\n**晚上9:30**：我回到房间，收拾好我的珠宝准备离开。此时我听到楼下传来一声女人的尖叫，但很快就消失了。\n**晚上10:00**：我从房间的密道入口进入，想去书房偷走遗嘱。当我从书房的壁炉后走出来时，发现伯爵已经倒在血泊里。我吓坏了，立刻原路返回，不敢声张。`,
                tasks: '1. 隐藏你和爱德华的私情以及私奔计划。\n2. 隐藏你曾通过密道进入案发现场的事实。\n3. 你认为凶手是其他人，需要尽快找到证据洗脱嫌疑。',
                isKiller: false
            },
            {
                name: '爱德华',
                description: '伯爵的侄子，放荡不羁，是城堡的法定继承人，但与伯爵关系恶劣。',
                storyline: `我急需用钱，但老家伙一分钱都不肯给我。我今晚准备偷点东西去卖。\n**晚上8:00**：我和安娜在花园见面，她告诉我一条通往书房的密道，这正合我意。\n**晚上8:30**：我看到医生马丁行色匆匆地进了伯爵的书房。\n**晚上9:10**：我准备通过安娜告诉我的密道进入书房，但在密道口听到了里面有奇怪的响动，我害怕被发现，就退了回来。\n**晚上9:40**：我在走廊里遇到了女巫罗兰女士，她警告我今晚城堡会有血光之灾，让我不要乱走动。她的眼神很奇怪，让我不寒而栗。`,
                tasks: '1. 隐藏你计划偷窃以及知道密道的事实。\n2. 伯爵死了，你是最大受益人，你的嫌疑最大。你需要将嫌疑转移到他人身上，比如医生或行为诡异的女巫。\n3. 你需要找到对你有利的证据。',
                isKiller: false
            },
            {
                name: '马丁医生',
                description: '伯爵的私人医生，医术高明，但深陷赌博债务。',
                storyline: `我欠了伯爵一大笔钱，他拿走了我的行医执照作为抵押，并威胁如果我还不上钱，就让我身败名裂。\n**晚上8:30**：我去找伯爵，恳求他再宽限我一段时间。他不仅拒绝了，还羞辱了我一番。我绝望地离开。\n**晚上9:00**：我回到我的房间，准备了一些强效镇定剂，我计划让他睡着，然后偷回我的行医执照。\n**晚上9:20**：我再次来到书房门口，却听到里面安娜和伯爵在激烈争吵。我只好暂时放弃计划，躲在附近观察。\n**晚上9:40后**：我看到安娜气冲冲地离开后，就再也没人进出过书房。我因为害怕一直没敢动手，直到尸体被发现。`,
                tasks: '1. 隐藏你欠下巨额赌债并被伯爵威胁的事实。\n2. 隐藏你准备了镇定剂并计划偷东西的意图。\n3. 你是最后一个见到伯爵的人之一，你需要证明你离开后还有作案时间。',
                isKiller: false
            },
            {
                name: '罗兰女士',
                description: '著名的灵媒、女巫，被伯爵请来进行降神会，与城堡的“幽灵”对话。',
                storyline: `我是个骗子。伯爵发现了我的秘密，并以此敲诈我，让我免费为他“服务”。\n**晚上9:10**：伯爵把我叫到书房，再次威胁我，说如果今晚的降神会不能让他满意，就要揭穿我的一切。我感到前所未有的恐惧。\n**晚上9:30**：我借口准备仪式，独自留在书房。伯爵背对着我，在欣赏一幅画。我看到桌上有一把锋利的拆信刀，一时冲动，拿起刀从背后刺向了他。他当场倒下。我发出一声短促的尖叫，但立刻捂住了嘴。\n**晚上9:35**：我慌乱地将书房门从内反锁，然后从墙角的书架后面启动了密道（这是我之前偷偷发现的），逃离了现场。在密道中，我的一片蕾丝袖口被挂掉了。\n**晚上9:40**：我从密道出来，遇到了爱德华，我故作神秘地警告他有血光之灾，以掩饰我的慌张。`,
                tasks: '1. 你是真凶！你的任务是隐藏一切，将罪行嫁祸给他人。\n2. 利用你“女巫”的身份，编造一些鬼神之说来混淆视听。\n3. 爱德华和安娜都知道密道，这是嫁祸他们的好机会。马丁医生有强烈的动机，也可以加以利用。',
                isKiller: true
            }
        ],
        clues: [
            { owner: '安娜', description: '你的珠宝盒里有一张单程的火车票，目的地是巴黎，时间是明天一早。' },
            { owner: '爱德华', description: '你的口袋里有一张当票，上面是一枚属于伯爵家族的古董怀表。' },
            { owner: '马丁医生', description: '你的药箱里有一瓶几乎满装的强效镇定剂，以及一张伯爵写的、要求你一周内还清10万英镑欠款的字条。' },
            { owner: '罗兰女士', description: '你的长裙袖口处有一块明显的撕裂痕迹，似乎是被什么东西挂坏的。', isKey: true },
            { owner: '公共', description: '在书房壁炉后面发现一个隐蔽的按钮，按下后，旁边的一整面书架会旋转打开，露出一条通往楼上走廊的密道。' },
            { owner: '公共', description: '在密道的地板上，发现了一小片黑色的蕾丝布料。' },
            { owner: '公共', description: '伯爵的书桌上摊开着一本关于“灵媒与欺诈”的书，其中一页用红笔圈出了“罗兰女士”的名字。' }
        ],
        truth: '凶手是女巫罗兰女士。伯爵发现了她是个骗子并以此敲诈她。当晚，伯爵再次威胁她，罗兰在恐惧和愤怒之下，用拆信刀从背后杀害了伯主。她知道城堡的密道，于是反锁房门，通过密道逃离，伪造了密室杀人案。但慌乱中，她的一片蕾f丝袖口挂在了密道里，成为了关键证据。'
    }
];

// ▲▲▲ 剧本库粘贴结束 ▲▲▲
// ▼▼▼ 在这里粘贴下面这一整块新代码 ▼▼▼

/**
 * 【全新】从一个已领完的红包中找出“手气王”
 * @param {object} packet - 已领完的红包消息对象
 * @returns {object|null} - 返回手气王的信息 { name, amount }，或 null
 */
function findLuckyKing(packet) {
    const claimedBy = packet.claimedBy || {};
    const claimedEntries = Object.entries(claimedBy);
    
    // 如果红包是“拼手气”类型，并且有超过1个人领取
    if (packet.packetType === 'lucky' && claimedEntries.length > 1) {
        let luckyKing = { name: '', amount: -1 };
        claimedEntries.forEach(([name, amount]) => {
            if (amount > luckyKing.amount) {
                luckyKing = { name, amount };
            }
        });
        return luckyKing;
    }
    return null; // 如果不满足条件，则没有手气王
}

// ▲▲▲ 新代码粘贴结束 ▲▲▲
let state = { chats: {}, activeChatId: null, globalSettings: {}, apiConfig: {}, userStickers: [], worldBooks: [], personaPresets: [], qzoneSettings: {}, activeAlbumId: null };
let datingGameState = {
    isActive: false,
    scene: null,
    characterId: null,
    storyHistory: [],
    romance: 0,
    lust: 0,
    currentStoryText: "",
    currentSentenceIndex: -1,
    sentences: [],
    isSwitchingSentence: false,
    isNsfwMode: false,
    completion: 0
};
// ▼▼▼ 在这里粘贴下面这一行新代码 ▼▼▼
let currentDatingSummary = null; // 用于暂存当前结算卡片的数据
// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▲▲▲ 新代码粘贴结束 ▲▲▲
        const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models'
        // gemini如果是多个密钥, 那么随机获取一个
    function getRandomValue(str) {
        // 检查字符串是否包含逗号
        if (str.includes(',')) {
            // 用逗号分隔字符串并移除多余空格
            const arr = str.split(',').map(item => item.trim());
            // 生成随机索引 (0 到 arr.length-1)
            const randomIndex = Math.floor(Math.random() * arr.length);
            // 返回随机元素
            return arr[randomIndex];
        }
        // 没有逗号则直接返回原字符串
        return str;
    }
    function isImage(text,content) {
        let currentImageData = content.image_url.url
        // 提取Base64数据（去掉前缀）
        const base64Data = currentImageData.split(',')[1];
        // 根据图片类型获取MIME类型
        const mimeType = currentImageData.match(/^data:(.*);base64/)[1];
        return [
            {text: `${text.text}用户向你发送了一张图片`},
            {
                inline_data: {
                    mime_type: mimeType,
                    data: base64Data
                }
            }
        ]
    }

   function extractArray(text) {
        // 正则表达式模式：匹配开头的时间戳部分和后续的JSON数组
        const pattern = /^\(Timestamp: (\d+)\)(.*)$/s;
        const match = text.match(pattern);

        if (match) {
            const timestampPart = `(Timestamp: ${match[1]}) `;
            const jsonPart = match[2].trim();

            try {
                // 尝试解析JSON部分
                const parsedJson = JSON.parse(jsonPart);
                // 验证解析结果是否为数组
                if (Array.isArray(parsedJson)) {
                    return [timestampPart, parsedJson[0]];
                }
            } catch (error) {
                // 解析失败，返回原始文本
            }
        }

        // 不匹配格式或解析失败时返回原值
        return text;
    }
    function transformChatData(item) {
        let type = {
            send_and_recall:'撤回了消息',
            update_status:'更新了状态',
            change_music:'切换了歌曲',
            create_memory:'记录了回忆',
            create_countdown:'创建了约定/倒计时',
            text:'发送了文本',
            sticker:'发送了表情',
            ai_image:'发送了图片',
            voice_message:'发送了语音',
            transfer:'发起了转账',
            waimai_request:'发起了外卖请求',
            waimai_response:{
                paid:'回应了外卖-同意',
                rejected:'回应了外卖-拒绝'
            },
            video_call_request:'发起了视频通话',
            video_call_response:{
                accept:'回应了视频通话-接受',
                reject:'回应了视频通话-拒绝'
            },
            qzone_post:{
                shuoshuo:'发布了说说',
                text_image:'发布了文字图'
            },
            qzone_comment:'评论了动态',
            qzone_like:'点赞了动态',
            pat_user:'拍一拍了用户',
            block_user:'拉黑了用户',
            friend_request_response:'回应了好友申请',
            change_avatar:'更换了头像',
            share_link:'分享了链接',
            accept_transfer:'回应了转账-接受',
            decline_transfer:'回应了转账-拒绝/退款',
            quote_reply:'引用了回复',
            text:'',
        }
        let res = extractArray(item.content)

        if(Array.isArray(res)){
            let obj = res[1]
            let itemType = obj.type;
            let time = res[0]
            let text = type[itemType];
            if(text){
                if(itemType === 'sticker'){
                    return [{text:`${time}[${text}] 含义是:${obj.meaning}`}]
                }else if(itemType === 'send_and_recall'){
                    return [{text:`${time}[${text}] ${obj.content}`}]
                }else if(itemType === 'update_status'){
                    return [{text:`${time}[${text}] ${obj.status_text}(${obj.is_busy ? '忙碌/离开' : '空闲'})`}]
                }else if(itemType === 'change_music'){
                    return [{text:`${time}[${text}] ${obj.change_music}, 歌名是:${obj.song_name}`}]
                }else if(itemType === 'create_memory'){
                    return [{text:`${time}[${text}] ${obj.description}`}]
                }else if(itemType === 'create_countdown'){
                    return [{text:`${time}[${text}] ${obj.title}(${obj.date})`}]
                }else if(itemType === 'ai_image'){
                    return [{text:`${time}[${text}] 图片描述是:${obj.description}`}]
                }else if(itemType === 'voice_message'){
                    return [{text:`${time}[${text}] ${obj.content}`}]
                }else if(itemType === 'transfer'){
                    return [{text:`${time}[${text}] 金额是:${obj.amount} 备注是:${obj.amount}`}]
                }else if(itemType === 'waimai_request'){
                    return [{text:`${time}[${text}] 金额是:${obj.amount} 商品是:${obj.productInfo}`}]
                }else if(itemType === 'waimai_response'){
                    return [{text:`${time}[${text[obj.status]}] ${obj.status === 'paid' ? '同意' : '拒绝'}`}]
                }else if(itemType === 'video_call_request'){
                    return [{text:`${time}[${text}]`}]
                }}else if(itemType === 'video_call_request'){
                    return [{text:`${time}[${text[obj.decision]}] ${obj.decision === 'accept' ? '同意' : '拒绝'}`}]
                }else if(itemType === 'qzone_post'){
                    return [{text:`${time}[${text[obj.postType]}] ${obj.postType === 'shuoshuo' ? `${obj.content}` : `图片描述是:${obj.hiddenContent} ${obj.publicText ? `文案是: ${obj.publicText}` : ''}`}`}]
                }else if(itemType === 'qzone_comment'){
                    return [{text:`${time}[${text}] 评论的id是: ${obj.postId} 评论的内容是: ${obj.commentText}`}]
                }else if(itemType === 'qzone_like'){
                    return [{text:`${time}[${text}] 点赞的id是: ${obj.postId}`}]
                }else if(itemType === 'pat_user'){
                    return [{text:`${time}[${text}] ${obj.suffix ? obj.suffix  : ''}`}]
                }else if(itemType === 'block_user'){
                    return [{text:`${time}[${text}]`}]
                }else if(itemType === 'friend_request_response'){
                    return [{text:`${time}[${text}] 结果是:${obj.decision === 'accept' ? '同意' : '拒绝'}`}]
                }else if(itemType === 'change_avatar'){
                    return [{text:`${time}[${text}] 头像名是:${obj.name}`}]
                }else if(itemType === 'share_link'){
                    return [{text:`${time}[${text}] 文章标题是:${obj.title}  文章摘要是:${obj.description} 来源网站名是:${obj.source_name} 文章正文是:${obj.content}`}]
                }else if(itemType === 'accept_transfer'){
                    return [{text:`${time}[${text}]`}]
                }else if(itemType === 'accept_transfer'){
                    return [{text:`${time}[${text}]`}]
                }else if(itemType === 'quote_reply'){
                    return [{text:`${time}[${text}] 引用的内容是:${obj.reply_content}`}]
                }else if(itemType === 'text'){
                    return [{text:`${time}${obj.content}`}]
                }
            }

    // (例如，它是一个数组，或者一个AI返回的、我们不认识的JSON对象)
    if (typeof res !== 'string') {
        // 我们就强制使用最原始、最安全的 item.content 字符串
        res = item.content;
    }

    return [{text: res}];
}

    function toGeminiRequestData(model, apiKey, systemInstruction, messagesForDecision, isGemini, temperature) {

	if(!isGemini){
		return undefined
	}

        // 【核心修正】在这里，我们将 'system' 角色也映射为 'user'

        let roleType = {
            user: 'user',
            assistant: 'model',
            system: 'user' // <--- 新增这一行
        }
        return {
            url: `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${getRandomValue(apiKey)}`,
            data: {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    contents: messagesForDecision.map((item) => {
                        let  includesImages = false;
                        if(Array.isArray(item.content) && item.content.length === 2){
                              includesImages =  item.content.some((sub)=>{
                                return sub.type === 'image_url' && sub.image_url.url
                            })
                        }
                        return {
                            role: roleType[item.role], // 现在 'system' 会被正确转换为 'user'
                            parts: includesImages ? isImage(item.content[0],item.content[1]) : transformChatData(item)
                        }
                    }),
                    generationConfig: {
                        temperature: parseFloat(temperature) || 0.8,
                    },
                    "systemInstruction": {
                        "parts": [{
                            "text": systemInstruction
                        }]
                    }
                })
            }
        }
    }
    document.addEventListener('DOMContentLoaded', () => {

        // ===================================================================
        // 1. 所有变量和常量定义
        // ===================================================================
        // ▼▼▼ 【全新】宠物数值衰减相关的全局变量和常量 ▼▼▼
const PET_DECAY_INTERVAL = 60 * 60 * 1000; // 每60分钟衰减一次
const PET_DECAY_AMOUNT = { // 每次衰减的数值
    hunger: 5,
    happiness: 3
};
let petDecayTimer = null; // 用于管理衰减计时器的全局变量
// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 【全新】这是角色手机的App列表，请粘贴到JS顶部 ▼▼▼
const CHAR_PHONE_APPS = [
    { id: 'chat', name: '微信', screen: 'character-chat-list-screen', svg: `<svg viewBox="0 0 24 24" fill="#4CAF50"><path d="M12 2C6.48 2 2 6.48 2 12c0 2.94 1.28 5.58 3.34 7.42c-.22 1.4-.89 3.1-1.25 3.82c-.36.72.48 1.39 1.05.94c.82-.67 2.43-1.88 3.3-2.58C9.44 21.78 10.68 22 12 22c5.52 0 10-4.48 10-10S17.52 2 12 2zm3.5 10.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5s1.5.67 1.5 1.5s-.67 1.5-1.5 1.5zm-7 0c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5s1.5.67 1.5 1.5s-.67 1.5-1.5 1.5z"/></svg>` },
    { id: 'cart', name: '购物车', screen: 'character-shopping-cart-screen', svg: `<svg viewBox="0 0 24 24" fill="#F44336"><path d="M7 18c-1.1 0-1.99.9-1.99 2S5.9 22 7 22s2-.9 2-2s-.9-2-2-2zm10 0c-1.1 0-1.99.9-1.99 2s.89 2 1.99 2s2-.9 2-2s-.9-2-2-2zm-15-14h3.27l.94 2H20c.69 0 1.25.56 1.25 1.25c0 .09-.02.18-.04.27l-3.58 6.49c-.25.44-.73.74-1.26.74H8.52l-.94-2H4.27V4H2V2h3.27z"/></svg>` },
    { id: 'memos', name: '备忘录', screen: 'character-memos-screen', svg: `<svg viewBox="0 0 24 24" fill="#FFC107"><path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z"/></svg>` },
    { id: 'browser', name: '浏览器', screen: 'character-browser-screen', svg: `<svg viewBox="0 0 24 24" fill="#2196F3"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1.5-12.5l3 7.5 7.5-3-7.5-3z"/></svg>` },
    { id: 'album', name: '相册', screen: 'character-album-screen', svg: `<svg viewBox="0 0 24 24" fill="#8BC34A"><path d="M22 16V4c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2zm-11-4l2.03 2.71L16 11l4 5H8l3-4zM2 6v14c0 1.1.9 2 2 2h14v-2H4V6H2z"/></svg>` },
    { id: 'bank', name: '钱包', screen: 'character-bank-screen', svg: `<svg viewBox="0 0 24 24" fill="#E91E63"><path d="M21 18v1c0 1.1-.9 2-2 2H5c-1.11 0-2-.9-2-2V5c0-1.1.89-2 2-2h14c1.1 0 2 .9 2 2v1h-9c-1.11 0-2 .9-2 2v8c0 1.1.89 2 2 2h9zm-9-2h10V8H12v8zm4-2.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"/></svg>` },
    { id: 'trajectory', name: '足迹', screen: 'character-trajectory-screen', svg: `<svg viewBox="0 0 24 24" fill="#795548"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/></svg>` },
    { id: 'app_usage', name: '使用记录', screen: 'character-app-usage-screen', svg: `<svg viewBox="0 0 24 24" fill="#607D8B"><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8s8 3.58 8 8s-3.58 8-8 8zm.5-13H11v6l5.25 3.15l.75-1.23l-4.5-2.67z"/></svg>` },
    { id: 'diary', name: '日记', screen: 'character-diary-screen', svg: `<svg viewBox="0 0 24 24" fill="#009688"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83l3.75 3.75 1.83-1.83z"/></svg>` },
    // 这就是我们新加的App
    { id: 'appearance', name: '外观设置', screen: 'character-phone-appearance-screen', svg: `<svg viewBox="0 0 24 24" fill="#9C27B0"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1.17 14.34c-.21.21-.46.32-.71.32s-.5-.11-.71-.32l-1.41-1.41c-.2-.2-.31-.45-.31-.71 0-.26.11-.51.31-.71l1.41-1.41c.2-.2.45-.31.71-.31s.51.11.71.31l1.41 1.41c.4.4.4 1.04 0 1.41l-1.41 1.41zm3.34-5.34c-.21.21-.46.32-.71.32s-.5-.11-.71-.32L11.41 8.5c-.2-.2-.31-.45-.31-.71 0-.26.11-.51.31-.71l1.41-1.41c.2-.2.45-.31.71-.31s.51.11.71.31l1.41 1.41c.4.4.4 1.04 0 1.41l-1.41 1.41zm3.34 5.34c-.21.21-.46.32-.71.32s-.5-.11-.71-.32l-1.41-1.41c-.4-.4-.4-1.04 0-1.41l1.41-1.41c.2-.2.45-.31.71-.31s.51.11.71.31l1.41 1.41c.2.2.31.45.31.71 0 .26-.11.51-.31.71l-1.41 1.41z"/></svg>` }
];
// ▼▼▼ 在这里粘贴下面这一整块新代码 ▼▼▼

// ▼▼▼ 在这里粘贴下面这一整块新代码 ▼▼▼

// ▼▼▼ 在这里粘贴下面这一整块新代码 ▼▼▼

/* --- 【全新 | AI生成版 V4】约会大作战App核心功能 --- */

// 1. 全局变量，用于存储所有已生成的约会场景
let currentDatingScenes = []; 
let isGeneratingScenes = false;
let currentDatingUISettings = null; 
/* --- 【全新 | V5 - 永久保存修复版】约会大作战App核心功能 --- */

/**
 * 【总入口 V6】打开“约会大作战”App，快速显示已保存数据
 */
async function openDatingApp() {
    showScreen('date-a-live-screen');
    // 从数据库加载所有已保存的场景
    currentDatingScenes = await db.datingScenes.toArray();
    console.log(`从数据库加载了 ${currentDatingScenes.length} 个约会场景。`);
    // 渲染这些场景（只会先显示文字和加载动画）
    renderDatingScenes();
}

/**
 * 【AI核心 V6】调用AI生成【新的一批】约会场景，并【只保存场景数据】
 */
async function refreshDatingScenes() {
    if (isGeneratingScenes) {
        alert("正在加载中，请不要着急哦~");
        return;
    }
    isGeneratingScenes = true;

    const contentEl = document.getElementById('dating-scene-content');
    const loadingIndicator = document.createElement('p');
    loadingIndicator.textContent = "AI正在构思新的约会方案...";
    loadingIndicator.style.textAlign = 'center';
    loadingIndicator.style.color = 'var(--text-secondary)';
    contentEl.innerHTML = ''; // 先清空旧场景
    contentEl.appendChild(loadingIndicator);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        loadingIndicator.textContent = 'API未配置，无法生成场景！';
        loadingIndicator.style.color = 'red';
        isGeneratingScenes = false;
        return;
    }
    
    // Prompt保持不变
    const prompt = `
# 任务
你是一位顶级约会策划师，尤其擅长营造浪漫氛围。请为我策划 3-5 个适合情侣的、日常且极具浪漫情调的约会场景。

# 核心规则
1.  **场景风格**: 场景必须是现实生活中可以实现的，但要富有想象力和浪漫气息。**绝对禁止**任何黑暗、恐怖或令人不适的元素。
2.  **场景多样性**: 请包含多种类型的地点，例如：
    -   **户外**: 公园、海边、路边小吃摊。
    -   **室内**: 温馨的咖啡馆、艺术展、书店。
    -   **住宿**: 普通的温馨酒店、电竞酒店、甚至可以来点新奇的情趣酒店。
3.  **格式铁律**: 你的回复【必须且只能】是一个严格的JSON数组，直接以'['开头, 以']'结尾。
4.  **内容要求**: 每个场景对象【必须】包含以下三个字段:
    -   \`"name"\`: (字符串) 一个充满浪漫想象的日常约会场景名称 (例如: "星空下的电竞双排夜", "微醺路边摊的夏日晚风", "私语书店的角落")。
    -   \`"cost"\`: (数字) 一个代表浪漫程度的虚拟花费 (例如: 288, 520, 999)。
    -   \`"imagePrompt"\`: (字符串) 一个用于文生图的、纯英文的、详细的【纯风景或静物】描述，用于生成场景图片。【绝对不能包含人物、情侣或任何人】。图片风格必须是【浪漫唯美的 (romantic, beautiful, aesthetic)】，可以使用 anime style, vibrant colors, soft lighting, masterpiece 等词汇来增强艺术感。

# JSON输出格式示例:
[
  {
    "name": "雨后公园的七彩霓虹",
    "cost": 188,
    "imagePrompt": "a peaceful park after rain, wet cobblestone path reflecting neon city lights, rainbow puddle, glowing lanterns on trees, beautiful, aesthetic, anime style, masterpiece, vibrant colors"
  }
]
`;

    try {
        const messagesForApi = [{ role: 'user', content: prompt }];
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, prompt, messagesForApi, isGemini);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({ model: model, messages: messagesForApi, temperature: 1.1, response_format: { type: "json_object" } })
            });

        if (!response.ok) throw new Error(`API请求失败: ${await response.text()}`);
        
        const data = await response.json();
        const rawContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content);
        const cleanedContent = rawContent.replace(/^```json\s*|```$/g, '').trim();
        const newScenes = JSON.parse(cleanedContent);

        if (Array.isArray(newScenes)) {
            // ★★★ 核心修改：只添加uid和空的imageUrl，不再立即生成图片 ★★★
            const scenesWithId = newScenes.map((scene, index) => ({
                ...scene,
                uid: 'scene_' + Date.now() + index,
                imageUrl: '' // 初始化时图片链接为空
            }));

            await db.datingScenes.bulkAdd(scenesWithId);

            // 更新内存数据，并重新渲染（此时图片还是加载中状态）
            currentDatingScenes.push(...scenesWithId); 
            renderDatingScenes(); 
            
        } else {
            throw new Error("AI返回的数据不是有效的数组。");
        }
    } catch (error) {
        console.error("生成约会场景失败:", error);
        contentEl.innerHTML = `<p style="text-align:center; color:red;">生成失败: ${error.message}</p>`;
    } finally {
        isGeneratingScenes = false;
    }
}

/**
 * 【渲染函数 - 已改造】渲染所有约会场景卡片，并【异步】加载图片
 */
function renderDatingScenes() {
    const contentEl = document.getElementById('dating-scene-content');
    contentEl.innerHTML = ''; // 每次都清空再渲染

    if (currentDatingScenes.length === 0) {
        // 如果数据库是空的，显示提示并触发一次生成
        if (!isGeneratingScenes) {
            contentEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding: 50px 0;">正在为你构思浪漫的约会方案...</p>';
            refreshDatingScenes(); 
        }
        return;
    }
    
    // ★★★ 核心修改：使用 forEach 立即渲染所有卡片 ★★★
    currentDatingScenes.forEach(scene => {
        const card = createDatingSceneCard(scene);
        contentEl.appendChild(card);
        // ★★★ 核心修改：调用新的异步函数去处理图片 ★★★
        loadAndDisplaySceneImage(scene);
    });
}
/**
 * 【全新辅助函数】为单个场景加载或生成图片，并更新其卡片
 * @param {object} scene - 约会场景对象
 */
async function loadAndDisplaySceneImage(scene) {
    const card = document.querySelector(`.dating-scene-card[data-uid="${scene.uid}"]`);
    if (!card) return;
    const imageContainer = card.querySelector('.dating-scene-image-container');

    // 1. 如果数据库里已经有图片URL，直接使用它
    if (scene.imageUrl) {
        imageContainer.innerHTML = `<img src="${scene.imageUrl}" alt="${scene.name}">`;
        return;
    }

    // 2. 如果没有URL，说明需要生成
    try {
        const imageUrl = await generateAndLoadImage(scene.imagePrompt);
        // 生成成功后，更新UI
        if (document.body.contains(imageContainer)) {
             imageContainer.innerHTML = `<img src="${imageUrl}" alt="${scene.name}">`;
        }
       
        // ★★★ 关键：将新生成的URL保存回数据库！★★★
        scene.imageUrl = imageUrl;
        await db.datingScenes.update(scene.uid, { imageUrl: imageUrl });
        console.log(`为场景 "${scene.name}" 生成并保存了新图片。`);

    } catch (error) {
        console.error(`场景 "${scene.name}" 图片渲染失败:`, error);
        if (document.body.contains(imageContainer)) {
            imageContainer.innerHTML = `<span>图片加载失败</span>`;
        }
    }
}

/**
 * 【全新】根据唯一ID删除一个约会场景 (已添加数据库操作)
 * @param {string} sceneUid - 场景的唯一ID
 */
async function deleteDatingScene(sceneUid) {
    const cardToRemove = document.querySelector(`.dating-scene-card[data-uid="${sceneUid}"]`);
    if (cardToRemove) {
        cardToRemove.style.transition = 'transform 0.3s, opacity 0.3s';
        cardToRemove.style.transform = 'scale(0.9)';
        cardToRemove.style.opacity = '0';
        setTimeout(async () => {
            await db.datingScenes.delete(sceneUid);
            currentDatingScenes = currentDatingScenes.filter(scene => scene.uid !== sceneUid);
            cardToRemove.remove();
        }, 300);
    }
}


// (你原来的其他辅助函数 processSceneImages, createDatingSceneCard, generateAndLoadImage 保持不变，我已经帮你整合好了)
async function processSceneImages(newScenes) {
    const contentEl = document.getElementById('dating-scene-content');

    for (const scene of newScenes) {
        const card = createDatingSceneCard(scene);
        contentEl.appendChild(card);
        
        try {
            const imageUrl = await generateAndLoadImage(scene.imagePrompt);
            const imageContainer = card.querySelector('.dating-scene-image-container');
            if (imageContainer) {
                imageContainer.innerHTML = `<img src="${imageUrl}" alt="${scene.name}">`;
            }
        } catch (error) {
            console.error(`场景 "${scene.name}" 图片生成失败:`, error);
            const imageContainer = card.querySelector('.dating-scene-image-container');
            if (imageContainer) {
                imageContainer.innerHTML = `<span>图片生成失败</span>`;
            }
        }
    }
}

function createDatingSceneCard(scene) {
    const card = document.createElement('div');
    card.className = 'dating-scene-card';
    card.dataset.uid = scene.uid;

    card.innerHTML = `
        <button class="dating-scene-delete-btn" title="删除此场景">×</button>
        <div class="dating-scene-image-container">
            <div class="loading-spinner"></div>
        </div>
        <div class="dating-scene-info">
            <div class="name">${scene.name}</div>
            <div class="cost">花费: ${scene.cost}金币</div>
        </div>
    `;
    return card;
}

function generateAndLoadImage(prompt) {
    return new Promise((resolve, reject) => {
        const encodedPrompt = encodeURIComponent(prompt);
        const seed = Math.floor(Math.random() * 100000);
        const imageUrl = `https://image.pollinations.ai/prompt/${encodedPrompt}?width=1024&height=640&seed=${seed}`;
        
        const img = new Image();
        img.src = imageUrl;

        img.onload = () => resolve(imageUrl);
        img.onerror = () => {
            console.warn(`主URL加载失败，尝试备用URL for: ${prompt}`);
            const fallbackUrl = `https://pollinations.ai/p/${encodedPrompt}?width=1024&height=640&seed=${seed}`;
            img.src = fallbackUrl;
            img.onload = () => resolve(fallbackUrl);
            img.onerror = () => reject(new Error('主域名和备用域名均加载失败'));
        };
    });
}
/* --- 约会大作战功能结束 --- */

// ▲▲▲ 新增代码结束 ▲▲▲


// ▲▲▲ 新增代码结束 ▲▲▲

// ▲▲▲ 新增代码结束 ▲▲▲

// ▲▲▲ 代码粘贴结束 ▲▲▲
const db = new Dexie('GeminiChatDB');
// ▼▼▼ 在这里粘贴下面这一整块新代码 ▼▼▼

// ▲▲▲ 新增代码结束 ▲▲▲

        // ▼▼▼ 把下面这一整块全新的微博功能代码，粘贴到这里 ▼▼▼

/**
 * 【微博】总入口：根据当前激活的视图，渲染对应的微博Feed
 */
async function renderWeiboFeeds(viewId) {
    if (viewId === 'weibo-my-profile-view') {
        await renderMyWeiboFeed();
    } else if (viewId === 'weibo-following-view') {
        await renderFollowingWeiboFeed();
    }
}

// ▼▼▼ 用这【两块新代码】分别替换旧的 renderMyWeiboFeed 和 renderFollowingWeiboFeed 函数 ▼▼▼

/**
 * 【微博】渲染“我的主页”上的微博列表
 */
async function renderMyWeiboFeed() {
    const feedEl = document.getElementById('my-weibo-feed-list');
    const posts = await db.weiboPosts.where('authorId').equals('user').reverse().toArray();
    feedEl.innerHTML = '';
    if (posts.length === 0) {
        feedEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">你还没有发过微博哦，点击右上角“+”试试吧！</p>';
        return;
    }
    posts.forEach(post => {
        // 【核心修改】调用我们新的专属函数！
        feedEl.appendChild(createWeiboPostElement(post));
    });
}

// ▼▼▼ 用这块【已修复】的代码，完整替换掉你旧的 renderFollowingWeiboFeed 函数 ▼▼▼
/**
 * 【微博】渲染“关注的人”的微博Feed (已修复卡顿问题)
 */
async function renderFollowingWeiboFeed() {
    const feedEl = document.getElementById('weibo-following-feed-list');
    
    // 【核心优化】我们不再一次性读取所有帖子，而是直接让数据库帮我们筛选和排序，速度会快很多！
    const posts = await db.weiboPosts
        .where('authorId').notEqual('user') // 1. 直接在数据库层面，找出作者不是'user'的帖子
        .reverse()                          // 2. 让结果按倒序排列
        .sortBy('timestamp');               // 3. 根据时间戳排序

    // 后续的渲染逻辑保持不变
    feedEl.innerHTML = '';
    if (posts.length === 0) {
        feedEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">你关注的人还没有发布任何动态哦。</p>';
        return;
    }
    posts.forEach(post => {
        feedEl.appendChild(createWeiboPostElement(post));
    });
}


// ▼▼▼ 请用这【一整块】全新的代码，完整替换掉你旧的 createWeiboPostElement 函数 ▼▼▼

function createWeiboPostElement(post) {
    const postEl = document.createElement('div');
    postEl.className = 'weibo-post-item'; 

    let contentHtml = '';
    if (post.content) {
        contentHtml += `<div class="weibo-post-content">${post.content.replace(/\n/g, '<br>')}</div>`;
    }
    
    if (post.imageUrl) {
        if (post.postType === 'text_image') {
            contentHtml += `<img src="${post.imageUrl}" class="weibo-post-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent || ''}">`;
        } else {
            contentHtml += `<img src="${post.imageUrl}" class="weibo-post-image">`;
        }
    }

    let commentsHtml = '';
    if (post.comments && Array.isArray(post.comments) && post.comments.length > 0) {
        commentsHtml += '<div class="weibo-comments-container">';
        post.comments.forEach(comment => {
            if (typeof comment !== 'object' || comment === null) return;
            let replyHtml = '';
            
            // ★ 修改1：为被回复者添加专属的 class 和 data 属性，方便我们精确点击
            if (comment.replyToNickname) {
                replyHtml = `<span class="weibo-comment-reply-tag">回复</span><span class="reply-target-name" data-reply-to-name="${comment.replyToNickname}">${comment.replyToNickname}</span>`;
            }

            commentsHtml += `
                <div class="weibo-comment-item" data-comment-id="${comment.commentId}" data-commenter-name="${comment.authorNickname}">
                    <span class="weibo-commenter-name">${comment.authorNickname}</span>
                    ${replyHtml}:
                    <span class="weibo-comment-text">${comment.commentText}</span>
                    <button class="comment-delete-btn" title="删除此条评论">×</button>
                </div>`;
        });
        commentsHtml += '</div>';
    }

    const myNickname = state.qzoneSettings.weiboNickname || state.qzoneSettings.nickname || '我';
    const isLiked = post.likes && post.likes.includes(myNickname);
    
    let finalAuthorAvatar, finalAuthorNickname, finalAuthorAvatarFrame;
    if (post.authorId === 'user') {
        finalAuthorAvatar = state.qzoneSettings.weiboAvatar || state.qzoneSettings.avatar || defaultAvatar;
        finalAuthorNickname = state.qzoneSettings.weiboNickname || state.qzoneSettings.nickname || '我';
        finalAuthorAvatarFrame = state.qzoneSettings.weiboAvatarFrame || '';
    } else if (state.chats[post.authorId]) {
        const authorChat = state.chats[post.authorId];
        finalAuthorNickname = authorChat.settings.weiboNickname || authorChat.name;
        finalAuthorAvatar = authorChat.settings.weiboAvatar || authorChat.settings.aiAvatar || defaultAvatar;
        finalAuthorAvatarFrame = authorChat.settings.weiboAvatarFrame || authorChat.settings.aiAvatarFrame || '';
    } else {
        finalAuthorAvatar = defaultAvatar;
        finalAuthorNickname = post.authorNickname || '未知用户';
        finalAuthorAvatarFrame = '';
    }

    let avatarHtml = '';
    if (finalAuthorAvatarFrame) {
        avatarHtml = `
            <div class="avatar-with-frame">
                <img src="${finalAuthorAvatar}" class="avatar-img weibo-post-avatar">
                <img src="${finalAuthorAvatarFrame}" class="avatar-frame">
            </div>`;
    } else {
        avatarHtml = `<img src="${finalAuthorAvatar}" class="weibo-post-avatar">`;
    }
    
    const clickableAvatarWrapper = `
        <div class="weibo-post-avatar-clickable" data-char-id="${post.authorId}">
            ${avatarHtml}
        </div>
    `;

    postEl.innerHTML = `
        <div class="weibo-post-header">
            ${clickableAvatarWrapper} 
            <div class="weibo-post-info">
                <span class="weibo-post-nickname">${finalAuthorNickname}</span>
                <span class="weibo-post-timestamp">${formatPostTimestamp(post.timestamp)}</span>
            </div>
            <div class="post-actions-btn" data-post-id="${post.id}" data-author-id="${post.authorId}">…</div>
        </div>
        ${contentHtml}
        <div class="weibo-post-footer">
            <div class="weibo-post-actions">
                <span class="weibo-action-btn like-btn ${isLiked ? 'liked' : ''}">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3"></path></svg>
                    <span>${(post.baseLikesCount || 0) + (post.likes || []).length}</span>
                </span>
                <span class="weibo-action-btn comment-btn">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path></svg>           
                    <span>${(post.comments || []).length}</span>
                </span>
                <span class="weibo-action-btn generate-comments-btn" title="AI生成评论">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path>
                    </svg>
                    <span>生成评论</span>
                </span>
            </div>
            ${commentsHtml}
            <div class="weibo-comment-input-area">
                <input type="text" class="weibo-comment-input" placeholder="留下你的精彩评论吧...">
                <button class="weibo-comment-send-btn">发送</button>
            </div>
        </div>
    `;

    // 绑定发送评论按钮
    const sendBtn = postEl.querySelector('.weibo-comment-send-btn');
    if (sendBtn) {
        sendBtn.addEventListener('click', () => {
            const input = postEl.querySelector('.weibo-comment-input');
            handleWeiboComment(post.id, input);
        });
    }

    // 绑定AI生成评论按钮
    const generateBtn = postEl.querySelector('.generate-comments-btn');
    if (generateBtn) {
        generateBtn.addEventListener('click', () => generateWeiboComments(post.id));
    }
    
    // 绑定点赞按钮
    const likeBtn = postEl.querySelector('.like-btn');
    if (likeBtn) {
        likeBtn.addEventListener('click', () => handleWeiboLike(post.id));
    }

    // ★ 修改2：为评论区绑定一个全新的、功能更强大的点击事件监听器
    const commentSection = postEl.querySelector('.weibo-comments-container');
    if (commentSection) {
        commentSection.addEventListener('click', (e) => {
            // 阻止事件冒泡，这是解决点击无效的核心！
            e.stopPropagation();

            const target = e.target;
            const commentItem = target.closest('.weibo-comment-item');
            if (!commentItem) return; // 如果点击的不是评论区，就什么也不做
            
            const input = postEl.querySelector('.weibo-comment-input');

            // 检查点击的是否是删除按钮
            if (target.closest('.comment-delete-btn')) {
                deleteWeiboComment(post.id, commentItem.dataset.commentId);
                return; // 删除后结束
            }
            
            let replyToName = '';
            const replyToId = commentItem.dataset.commentId;

            // ★ 修改3：新增逻辑，判断你点击的是谁
            if (target.classList.contains('reply-target-name')) {
                // 如果点击了“被回复者”的名字
                replyToName = target.dataset.replyToName;
            } else {
                // 否则，默认回复这条评论的作者
                replyToName = commentItem.dataset.commenterName;
            }

            // ★ 修改4：优化回复逻辑
            // 如果正在回复同一个人，则取消回复
            if (input.dataset.replyToId === replyToId && input.placeholder.includes(`@${replyToName}`)) {
                input.placeholder = '留下你的精彩评论吧...';
                delete input.dataset.replyToId;
                delete input.dataset.replyToNickname;
            } else {
                // 否则，设置为新的回复目标
                input.placeholder = `回复 @${replyToName}:`;
                input.dataset.replyToId = replyToId;
                input.dataset.replyToNickname = replyToName;
                input.focus();
            }
        });
    }

    return postEl;
}
// ▲▲▲ 替换结束 ▲▲▲





/**
 * 【微博】打开微博发布/编辑模态框
 */
async function openWeiboPublisher() {
    const modal = document.getElementById('create-post-modal');
    
    modal.dataset.mode = 'weibo'; // 关键！标记为微博模式
    
    document.getElementById('create-post-modal-title').textContent = '发微博';
    document.getElementById('post-public-text').placeholder = '有什么新鲜事想分享给大家？';
    
    // 隐藏动态专属的控件
    document.getElementById('post-image-desc-group').style.display = 'none';
    document.getElementById('post-comments-toggle-group').style.display = 'none';
    
    document.getElementById('post-mode-switcher').style.display = 'flex'; // 微博也需要模式切换
    
    resetCreatePostModal();
    modal.classList.add('visible');
}
/**
 * 【全新】智能解析带“万”或“亿”的数字字符串
 * @param {string} str - 包含数字的字符串，例如 "30000", "3万", "1.5万"
 * @returns {number} - 解析后的纯数字
 */
function parseChineseNumber(str) {
    if (!str) return 0; // 安全检查

    str = String(str).trim().toLowerCase(); // 转换为小写字符串并去除空格

    let num = parseFloat(str); // 先尝试直接解析数字部分

    if (str.includes('万') || str.includes('w')) {
        // 如果包含“万”或“w”，则将数字部分乘以10000
        num = parseFloat(str) * 10000;
    } else if (str.includes('亿')) {
        // 如果包含“亿”，则乘以100000000
        num = parseFloat(str) * 100000000;
    }

    // 如果解析失败 (比如输入了纯文字)，返回0
    return isNaN(num) ? 0 : Math.floor(num); // 返回整数，确保结果干净
}

// ▼▼▼ 请用这【一整块功能增强版】的代码，完整替换掉你旧的 handlePublishWeibo 函数 ▼▼▼
/**
 * 【微博 V3 - 粉丝数计算版】处理发布微博的核心函数
 */
async function handlePublishWeibo() {
    const modal = document.getElementById('create-post-modal');
    
// ▼▼▼ 从这里开始，是你要粘贴的新代码 ▼▼▼
const mainContent = document.getElementById('post-public-text').value.trim();
let imageUrl = '', hiddenContent = '', postType = 'text_only', imageDescription = '';

const isImageModeActive = document.getElementById('image-mode-content').classList.contains('active');

if (isImageModeActive) {
    // 【核心修复】我们现在通过检查预览容器是否可见，来判断用户是否真的上传了图片
    const hasImage = document.getElementById('post-image-preview-container').classList.contains('visible');
    
    if (hasImage) {
        imageUrl = document.getElementById('post-image-preview').src;
        postType = 'image';
        imageDescription = document.getElementById('post-image-description').value.trim();
        // 图片描述的检查逻辑保持不变
        if (!imageDescription) {
            alert("为了让AI能看懂图片，请务必填写图片描述哦！");
            return;
        }
    }
    // 如果 hasImage 是 false (即用户只想发纯文字)，这段代码就会被跳过，imageUrl 保持为空，postType 保持为 text_only
    
} else { // 文字图模式的逻辑保持不变
    hiddenContent = document.getElementById('post-hidden-text').value.trim();
    if (hiddenContent) {
        imageUrl = 'https://i.postimg.cc/KYr2qRCK/1.jpg'; 
        postType = 'text_image';
    }
}
// ▲▲▲ 到这里为止，是你要粘贴的新代码 ▲▲▲

    if (!mainContent && !imageUrl) {
        alert('微博内容不能为空哦！');
        return;
    }

    const fansCount = parseChineseNumber(state.qzoneSettings.weiboFansCount) || 0;
    const baseLikes = Math.floor(fansCount * (Math.random() * 0.1 + 0.1));
    const baseComments = Math.floor(baseLikes * (Math.random() * 0.1 + 0.05));

    const newPost = {
        authorId: 'user',
        authorType: 'user',
        authorNickname: state.qzoneSettings.weiboNickname || state.qzoneSettings.nickname || '我',
        authorAvatar: state.qzoneSettings.weiboAvatar || state.qzoneSettings.avatar || defaultAvatar,
        content: mainContent,
        imageUrl: imageUrl,
        // ▼▼▼ 在这里添加下面这行新代码 ▼▼▼
        authorAvatarFrame: state.qzoneSettings.weiboAvatarFrame || '',
        // ▲▲▲ 添加结束 ▲▲▲
        // ▼▼▼ 这是新增的核心代码 ▼▼▼
        imageDescription: imageDescription, // 3. 把获取到的描述保存到新字段里！
        // ▲▲▲ 新增结束 ▲▲▲

        hiddenContent: hiddenContent,
        postType: postType,
        timestamp: Date.now(),
        likes: [],
        comments: [],
        baseLikesCount: baseLikes,
        baseCommentsCount: baseComments
    };

    await db.weiboPosts.add(newPost);
    await renderMyWeiboFeed(); 
    await renderWeiboProfile();
    
    modal.classList.remove('visible');
    alert('微博发布成功！');
}
// ▲▲▲ 替换结束 ▲▲▲


/**
 * 【微博】处理点赞/取消点赞
 * @param {number} postId - 帖子ID
 */
async function handleWeiboLike(postId) {
    const post = await db.weiboPosts.get(postId);
    if (!post) return;

    const myNickname = state.qzoneSettings.nickname || '我';
    if (!post.likes) post.likes = [];
    
    const likeIndex = post.likes.indexOf(myNickname);
    if (likeIndex > -1) {
        post.likes.splice(likeIndex, 1); // 取消点赞
    } else {
        post.likes.push(myNickname); // 点赞
    }

    await db.weiboPosts.put(post);
    // 重新渲染两个Feed，确保数据同步
    await renderMyWeiboFeed();
    await renderFollowingWeiboFeed();
}

/**
 * 【微博】处理发布评论或回复
 * @param {number} postId - 帖子ID
 * @param {HTMLInputElement} inputElement - 评论输入框元素
 */
async function handleWeiboComment(postId, inputElement) {
    const commentText = inputElement.value.trim();
    if (!commentText) {
        alert("评论内容不能为空！");
        return;
    }

    const post = await db.weiboPosts.get(postId);
    if (!post) return;

    if (!post.comments) post.comments = [];

    const newComment = {
        commentId: 'comment_' + Date.now(),
        authorId: 'user',
        authorNickname: state.qzoneSettings.weiboNickname || state.qzoneSettings.nickname || '我',
        commentText: commentText,
        timestamp: Date.now()
    };
    
    // 检查是否是回复
    if (inputElement.dataset.replyToId) {
        newComment.replyToId = inputElement.dataset.replyToId;
        newComment.replyToNickname = inputElement.dataset.replyToNickname;
    }

    post.comments.push(newComment);
    await db.weiboPosts.put(post);
    
    // 清空输入框并重置状态
    inputElement.value = '';
    inputElement.placeholder = '留下你的精彩评论吧...';
    delete inputElement.dataset.replyToId;
    delete inputElement.dataset.replyToNickname;
    
    // 重新渲染两个Feed
    await renderMyWeiboFeed();
    await renderFollowingWeiboFeed();
}


// ▲▲▲ 全新的微博功能代码粘贴结束 ▲▲▲
// ▼▼▼ 在这里添加您的 API 站点黑名单 ▼▼▼
const BLOCKED_API_SITES = [
    'api.pisces.ink',
    'aiapi.qzz.io'
];
// ▲▲▲ 黑名单定义结束 ▲▲▲
        // --- 已修正 ---

        // --- 修正结束 ---
    let isUserStickerSelectionMode = false;
    // ▼▼▼ 在 isUserStickerSelectionMode 变量后添加 ▼▼▼
let isCharStickerSelectionMode = false;
let selectedCharStickers = new Set();
// ▲▲▲ 添加结束 ▲▲▲
let selectedUserStickers = new Set();
let currentViewingDmsFor = null; // 用于追踪正在查看哪个角色的私信
let currentUserDmFanIndex = null; // 用于追踪正在查看哪个粉丝的私信
        let isLocked = false; // <-- 在这里添加这行新代码
        let newLockscreenWallpaperBase64 = null; // <-- 在这里添加这行新代码
let newGlobalBgBase64 = null; // 用于暂存新的全局聊天背景
let newAppWallpaperBase64 = null;
let musicState = { 
    isActive: false, 
    activeChatId: null, 
    isPlaying: false, 
    playlist: [], 
    currentIndex: -1, 
    playMode: 'order', 
    totalElapsedTime: 0, 
    timerId: null,
    // 【新增】歌词相关状态
    parsedLyrics: [],      // 当前歌曲解析后的歌词数组
    currentLyricIndex: -1  // 当前高亮的歌词行索引
};
// ▼▼▼ 【全新】这是情侣空间专属音乐播放器的状态管理器 ▼▼▼
let lsMusicState = {
    playlist: [],      // 播放列表
    currentIndex: -1,  // 当前播放歌曲的索引
    isPlaying: false   // 是否正在播放
};
// ▲▲▲ 新增状态管理器结束 ▲▲▲
let lyricsBarSettings = {
    fontSize: 14,
    bgOpacity: 0,
    fontColor: '#FFFFFF',
    showOnClose: true // 【问题4需要】默认开启
};

        const audioPlayer = document.getElementById('audio-player');
        let newWallpaperBase64 = null;
        let isSelectionMode = false;
        let isInnerVoiceHistoryOpen = false; // 用于跟踪历史面板是否打开
        let pomodoroState = {
    isActive: false,            // 专注是否正在进行
    timerId: null,              // 倒计时计时器
    periodicTalkTimerId: null,  // 角色定时说话的计时器
    currentSession: null        // 当前专注会话的数据
};
        let selectedMessages = new Set();
        let editingMemberId = null;
        let editingWorldBookId = null;
        let editingPersonaPresetId = null;
let activeCharPhonePresetId = null; // 用于追踪角色手机外观预设的选择
let activeCharacterPhoneId = null;
let activeLoversSpaceCharId = null; // 用于追踪当前情侣空间的角色ID
let waimaiTimers = {}; // 用于存储外卖倒计时
let editingSpriteGroupId = null;
let activeMessageTimestamp = null;


const LUDO_BOARD_SIZE = 42; // 总格子数，可以根据你的棋盘布局调整


let currentReplyContext = null; // <--- 新增这行，用来存储当前正在引用的消息信息
let currentSearchKeyword = ''; // 用于在搜索结果中高亮关键词
let activePostId = null; // <-- 新增：用于存储当前操作的动态ID
// ▼▼▼ 【全新】BGM 搜索功能核心代码 ▼▼▼

// 一个简单的网络请求函数
if (typeof Http_Get_External === 'undefined') {
    window.Http_Get_External = function(url) {
        return new Promise((resolve) => {
            fetch(url).then(res => res.json().catch(() => res.text())).then(resolve).catch(() => resolve(null));
        });
    }
}
async function Http_Get(url) { return await Http_Get_External(url); }

// 检查音频链接是否真的可以播放
function checkAudioAvailability(url) {
    return new Promise(resolve => {
        const tester = new Audio();
        tester.addEventListener('loadedmetadata', () => resolve(true), { once: true });
        tester.addEventListener('error', () => resolve(false), { once: true });
        tester.src = url;
    });
}

// ▼▼▼ 【V9.0 | 终极纯净版 - 移除代理】请用这块代码，完整替换旧的 searchNeteaseMusic 函数 ▼▼▼
/**
 * 移除所有代理，直接请求你找到的 vkeys.cn API
 */
async function searchNeteaseMusic(name, singer) {
    try {
        let searchTerm = name.replace(/\s/g, "");
        if (singer) { searchTerm += ` ${singer.replace(/\s/g, "")}`; }

        // 【核心修改】我们不再需要任何代理，直接把目标API作为最终请求地址！
        const apiUrl = `https://api.vkeys.cn/v2/music/netease?word=${encodeURIComponent(searchTerm)}`;
        
        console.log("正在尝试直接请求:", apiUrl); // 添加一条日志，方便我们调试
        
        const response = await fetch(apiUrl);

        if (!response.ok) {
            throw new Error(`API request failed with status ${response.status}: ${response.statusText}`);
        }
        
        const result = await response.json();

        if (result.code !== 200 || !result.data || result.data.length === 0) {
            console.log("vkeys API返回无结果:", result);
            return [];
        }
        
        return result.data.map(song => ({
            name: song.song,
            artist: song.singer,
            id: song.id,
            cover: song.cover || 'https://i.postimg.cc/pT2xKzP-album-cover-placeholder.png',
            source: 'netease'
        })).slice(0, 15);

    } catch (e) {
        // 如果这次还失败，请把浏览器F12控制台里的红色错误信息完整地截图给我
        console.error("【vkeys API 直连】搜索失败:", e);
        await showCustomAlert("网易云接口直连失败", `如果浏览器控制台(F12)提示CORS错误，说明此API禁止直接访问。错误: ${e.message}`);
        return [];
    }
}
// ▲▲▲ 替换结束 ▲▲▲


/**
 * 从QQ音乐搜索歌曲列表
 */
async function searchTencentMusic(name) {
    try {
        name = name.replace(/\s/g, "");
        const result = await Http_Get(`https://api.vkeys.cn/v2/music/tencent?word=${encodeURIComponent(name)}`);
        if (!result?.data?.length) return [];
        return result.data.map(song => ({
            name: song.song,
            artist: song.singer,
            id: song.id,
            cover: song.cover || 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png',
            source: 'tencent' // 标记来源
        })).slice(0, 5); // 只取前5条结果
    } catch (e) {
        console.error("QQ音乐搜索API失败:", e);
        return [];
    }
}
// ▼▼▼ 【V2.0 | 支持源选择】请用这个全新的函数，完整替换旧的 addSongFromSearch ▼▼▼
/**
 * 【总入口 V2.0】当用户点击“搜索”按钮时触发
 */
async function addSongFromSearch() {
    // 步骤 1: 首先弹出选择框，让用户选择搜索源
    const source = await showSearchSourceSelector();
    // 如果用户点了取消，source会是null，我们直接退出函数
    if (!source) return;

    // 步骤 2: 弹出输入框让用户输入关键词 (这部分逻辑不变)
    const searchTerm = await showCustomPrompt("搜索歌曲", "请输入 歌名 或 歌名-歌手");
    if (!searchTerm || !searchTerm.trim()) return;

    await showCustomAlert("请稍候...", "正在搜索歌曲资源...");

    let musicName = searchTerm.trim();
    let singerName = "";
    if (searchTerm.includes('-') || searchTerm.includes('–')) {
        const parts = searchTerm.split(/[-–]/);
        musicName = parts[0].trim();
        singerName = parts.slice(1).join(' ').trim();
    }

    // 步骤 3: 【核心修改】根据用户的选择，执行不同的搜索
    let combinedResults = [];

    if (source === 'all') {
        // 如果选择“全部”，则并行搜索两个平台
        const [neteaseResults, tencentResults] = await Promise.all([
            searchNeteaseMusic(musicName, singerName),
            searchTencentMusic(musicName)
        ]);
        combinedResults = [...neteaseResults, ...tencentResults];
    } else if (source === 'netease') {
        // 如果只选“网易云”，就只调用网易云的搜索
        combinedResults = await searchNeteaseMusic(musicName, singerName);
    } else if (source === 'tencent') {
        // 如果只选“QQ音乐”，就只调用QQ音乐的搜索
        combinedResults = await searchTencentMusic(musicName);
    }

    // 步骤 4: 后续的显示逻辑保持不变
    if (combinedResults.length === 0) {
        await showCustomAlert("无结果", "抱歉，在所选来源中未能找到相关歌曲。");
        return;
    }

    const modal = document.getElementById('music-search-results-modal');
    const listEl = document.getElementById('search-results-list');
    listEl.innerHTML = '';

    combinedResults.forEach(song => {
        const item = document.createElement('div');
        item.className = 'search-result-item';
        item.dataset.songJson = JSON.stringify(song);
        item.innerHTML = `
            <div class="title">${song.name}</div>
            <div class="artist">${song.artist} <span class="source">${song.source === 'netease' ? '网易云' : 'QQ音乐'}</span></div>
        `;
        listEl.appendChild(item);
    });

    modal.classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 【核心升级】处理用户点击搜索结果，增加备用音源查找和是否永久保存的逻辑
 */
async function handleSearchResultClick(songData) {
    const modal = document.getElementById('music-search-results-modal');
    modal.classList.remove('visible');

    await showCustomAlert("请稍候...", `正在获取《${songData.name}》的播放链接...`);

    let playableResult = null;
    let finalSource = songData.source;

    // 1. 尝试主音源
    const primaryApiUrl = songData.source === 'netease' 
        ? `https://api.vkeys.cn/v2/music/netease?id=${songData.id}`
        : `https://api.vkeys.cn/v2/music/tencent?id=${songData.id}`;
    let primaryResult = await Http_Get(primaryApiUrl);
    if (primaryResult?.data?.url && await checkAudioAvailability(primaryResult.data.url)) {
        playableResult = { url: primaryResult.data.url, id: songData.id, source: songData.source };
    }

    // 2. 如果主音源失败，尝试备用音源
    if (!playableResult) {
        await showCustomAlert("请稍候...", "主音源获取失败，正在尝试备用音源...");
        const fallbackSource = songData.source === 'netease' ? 'tencent' : 'netease';
        const fallbackResults = fallbackSource === 'tencent' 
            ? await searchTencentMusic(songData.name)
            : await searchNeteaseMusic(songData.name, songData.artist);

        if (fallbackResults.length > 0) {
            const fallbackApiUrl = fallbackSource === 'netease'
                ? `https://api.vkeys.cn/v2/music/netease?id=${fallbackResults[0].id}`
                : `https://api.vkeys.cn/v2/music/tencent?id=${fallbackResults[0].id}`;
            const fallbackResult = await Http_Get(fallbackApiUrl);
            if (fallbackResult?.data?.url && await checkAudioAvailability(fallbackResult.data.url)) {
                playableResult = { url: fallbackResult.data.url, id: fallbackResults[0].id, source: fallbackSource };
                finalSource = fallbackSource;
            }
        }
    }

    if (!playableResult) {
        await showCustomAlert("获取失败", "无法获取该歌曲的有效播放链接，主音源和备用音源均已尝试。");
        return;
    }
    
// ▼▼▼ 从这里开始粘贴新代码 ▼▼▼
const confirmed = await showCustomConfirm(
    '温馨提示', // 这是弹窗的标题
    '搜索的歌曲24h后会过期，重要的歌曲记得用url或者本地上传哦🐇', // 这是你指定的提示内容
    { confirmText: '确定' } // 按钮会显示“确定”和“取消”，这里的“取消”就等同于“返回”
);

// 如果用户点击了“取消”（返回），就直接结束，不添加歌曲
if (!confirmed) {
    return;
}
// ▲▲▲ 粘贴结束 ▲▲▲   
    // 获取歌词
    const lrcContent = await getLyricsForSong(playableResult.id, finalSource) || "";

// ▼▼▼ 用这块新代码替换 ▼▼▼
const newSong = {
    name: songData.name,
    artist: songData.artist,
    src: playableResult.url,
    cover: songData.cover,
    isLocal: false,
    lrcContent: lrcContent,
    isTemporary: true,
    // 核心新增：记录这首歌被添加的精确时间
    addedTimestamp: Date.now() 
};
// ▲▲▲ 替换结束 ▲▲▲



musicState.playlist.push(newSong);

// 注意：我们已经删除了 saveGlobalPlaylist() 的调用，因为临时歌曲不需要被永久保存
// ▲▲▲ 替换结束 ▲▲▲

    
    updatePlaylistUI();

    if (musicState.currentIndex === -1) {
        musicState.currentIndex = musicState.playlist.length - 1;
        updatePlayerUI();
    }

    await showCustomAlert("添加成功", `《${songData.name}》已成功添加到播放列表！`);
    // ▼▼▼ 把这一整块全新的代码，粘贴到指定位置 ▼▼▼
try {
    // 1. 检查一下当前是不是正在和别人聊天
    if (state.activeChatId) {
        const chat = state.chats[state.activeChatId];
        if (chat) {
            // 2. 创建一条对用户隐藏，但对AI可见的系统消息
            const hiddenMessage = {
                role: 'system', // 告诉AI这是系统信息
                content: `[系统提示：用户刚刚通过搜索，将歌曲《${songData.name}》 - ${songData.artist} 添加到了“一起听”的播放列表中。你可以根据这个情景，自然地开启关于这首歌的话题。]`,
                timestamp: Date.now(),
                isHidden: true // 这个是关键！让这条消息在聊天界面上“隐形”
            };
            
            // 3. 把这条“隐形”消息加到聊天记录的末尾
            chat.history.push(hiddenMessage);
            
            // 4. 保存更新后的聊天记录到数据库
            await db.chats.put(chat);

            console.log(`已为歌曲《${songData.name}》成功注入AI上下文提示。`);
        }
    }
} catch (error) {
    console.error("注入歌曲上下文时出错:", error);
}
// ▲▲▲ 粘贴结束 ▲▲▲
}

/**
 * 【辅助】获取网络歌曲的歌词
 */
async function getLyricsForSong(songId, source) {
    const url = source === 'netease'
        ? `https://api.vkeys.cn/v2/music/netease/lyric?id=${songId}`
        : `https://api.vkeys.cn/v2/music/tencent/lyric?id=${songId}`;
    
    const response = await Http_Get(url);
    if (response?.data) {
        const lrc = response.data.lrc || response.data.lyric || "";
        const tlyric = response.data.trans || response.data.tlyric || "";
        return lrc + "\\n" + tlyric;
    }
    return "";
}
// ▼▼▼ 【全新】这个函数用来显示“选择搜索源”的弹窗 ▼▼▼
/**
 * 显示搜索源选择弹窗，并返回用户的选择
 * @returns {Promise<string|null>} 返回 'all', 'netease', 'tencent', 或 null
 */
function showSearchSourceSelector() {
    return new Promise(resolve => {
        const modal = document.getElementById('music-source-selector-modal');
        const confirmBtn = document.getElementById('confirm-source-select-btn');
        const cancelBtn = document.getElementById('cancel-source-select-btn');

        // 显示弹窗
        modal.classList.add('visible');

        // 定义确认按钮的点击事件
        const onConfirm = () => {
            const selectedSource = document.querySelector('input[name="search-source"]:checked').value;
            cleanup();
            resolve(selectedSource); // 返回用户的选择
        };

        // 定义取消按钮的点击事件
        const onCancel = () => {
            cleanup();
            resolve(null); // 用户取消，返回 null
        };

        // 清理函数，用于移除事件监听并隐藏弹窗
        const cleanup = () => {
            modal.classList.remove('visible');
            confirmBtn.removeEventListener('click', onConfirm);
            cancelBtn.removeEventListener('click', onCancel);
        };

        // 绑定事件
        confirmBtn.addEventListener('click', onConfirm);
        cancelBtn.addEventListener('click', onCancel);
    });
}
// ▲▲▲ 新增函数结束 ▲▲▲
// ▼▼▼ 把这一整块全新的代码，粘贴到 getLyricsForSong 函数的后面 ▼▼▼

/**
 * 【全新】根据歌名和歌手自动搜索并播放歌曲
 * @param {string} name - 歌曲名
 * @param {string} artist - 歌手名
 */
async function searchAndPlaySong(name, artist) {
    // 弹出提示，告诉用户我们正在做什么
    await showCustomAlert("请稍候...", `AI为你分享了《${name}》，正在努力寻找播放资源...`);

    let songData = null;

    // 策略1：优先用网易云搜索 (通常结果更准)
    const neteaseResults = await searchNeteaseMusic(name, artist);
    if (neteaseResults.length > 0) {
        songData = neteaseResults[0]; // 如果找到了，就用第一个结果
    } 
    // 策略2：如果网易云找不到，再用QQ音乐搜一次
    else {
        const tencentResults = await searchTencentMusic(name);
        if (tencentResults.length > 0) {
            songData = tencentResults[0]; // 用QQ音乐的第一个结果
        }
    }

    // 如果两个平台都没找到，就告诉用户并退出
    if (!songData) {
        await showCustomAlert("找不到歌曲", `抱歉，在网易云和QQ音乐都没能找到《${name}》的可播放资源。`);
        return;
    }

    // 到这里，我们已经有了一首歌的基本信息 (id, source, name, artist)
    // 下面的逻辑就是调用API获取真实的播放链接
    
    const apiUrl = songData.source === 'netease' 
        ? `https://api.vkeys.cn/v2/music/netease?id=${songData.id}`
        : `https://api.vkeys.cn/v2/music/tencent?id=${songData.id}`;
    
    const result = await Http_Get(apiUrl);

    // 检查获取到的链接是否真的能播放
    if (!result?.data?.url || !(await checkAudioAvailability(result.data.url))) {
        await showCustomAlert("获取失败", `找到了《${name}》，但无法获取有效的播放链接。`);
        return;
    }

    // 获取歌词
    const lrcContent = await getLyricsForSong(songData.id, songData.source) || "";

    // 准备新的歌曲对象，准备添加到播放列表
    const newSong = {
        name: songData.name,
        artist: songData.artist,
        src: result.data.url, // 使用我们刚刚获取到的真实、可播放的URL！
        cover: songData.cover,
        isLocal: false,
        lrcContent: lrcContent,
        isTemporary: true, // 标记为临时歌曲，24小时后可能会失效
        addedTimestamp: Date.now()
    };

    // 检查播放列表里是不是已经有这首歌了
    const existingIndex = musicState.playlist.findIndex(t => t.name === newSong.name && t.artist === newSong.artist);
    if (existingIndex !== -1) {
        // 如果有，直接播放它
        playSong(existingIndex);
    } else {
        // 如果没有，就添加到列表末尾再播放
        musicState.playlist.push(newSong);
        updatePlaylistUI(); // 刷新播放列表界面
        playSong(musicState.playlist.length - 1);
    }
    
    // 如果“一起听”功能是关闭的，就自动打开它
    if (!musicState.isActive) {
         startListenTogetherSession(state.activeChatId);
    } else {
        // 如果已经是打开的，就直接显示播放器窗口
        document.getElementById('music-player-overlay').classList.add('visible');
    }
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▲▲▲ 新增函数粘贴结束 ▲▲▲
let activeForumFilters = { 
    global: [], // 用于主页小组列表的筛选
    group: {}   // 用于存储每个小组内部帖子的筛选, e.g., { 1: ['科幻'], 2: ['剧情'] }
};
let currentFilterContext = { type: 'global', id: null }; // 记录当前打开筛选的是哪个页面

        let photoViewerState = {
            isOpen: false,
            photos: [], // 存储当前相册的所有照片URL
            currentIndex: -1, // 当前正在查看的照片索引
        };

        let unreadPostsCount = 0;

        let isFavoritesSelectionMode = false;
        let selectedFavorites = new Set()

let simulationIntervalId = null;

let currentFrameSelection = { type: null, url: '', target: null }; 

        const defaultAvatar = 'https://i.postimg.cc/PxZrFFFL/o-o-1.jpg';
        const defaultMyGroupAvatar = 'https://i.postimg.cc/cLPP10Vm/4.jpg';
        const defaultGroupMemberAvatar = 'https://i.postimg.cc/VkQfgzGJ/1.jpg';
        const defaultGroupAvatar = 'https://i.postimg.cc/gc3QYCDy/1-NINE7-Five.jpg';
        let notificationTimeout;

const THEME_CSS_TEMPLATE = `
/* 
  EPhone 美化代码模板
  使用方法: 
  1. 修改下面的颜色代码或图片URL。
  2. 不需要修改的部分可以删除或保持不变。
  3. 颜色代码格式为 #RRGGBB (例如 #FFFFFF 是白色)。
  4. 图片URL需要是网络直链。
*/

/* === 1. 手机壳与刘海颜色 === */
#phone-frame {
  background-color: #f0f0f0; /* 手机壳颜色 */
}
.notch {
  background-color: #1a1a1a; /* 顶部“刘海”颜色 */
}
        #clock-container {  color: white;  }


/* === 1.5. 全局主题色 (重要！) === */
/* 这个颜色决定了大部分按钮、链接和高亮文本的颜色。*/
:root {
  --accent-color: #007bff; /* 默认是蓝色 */
}

/* === 2. 聊天界面顶部和底部的图片按钮替换 === */
/* “一起听”按钮 (正常状态) */
#listen-together-btn img[src*="8kYShvrJ/90-UI-2.png"] {
  content: url('在这里粘贴你的“正常状态”图片URL');
}
/* “一起听”按钮 (播放中状态) */
#listen-together-btn img[src*="D0pq6qS2/E30078-DC-8-B99-4-C01-AFDA-74728-DBF7-BEA.png"] {
  content: url('在这里粘贴你的“播放中”图片URL');
}
/* “聊天设置”按钮 */
#chat-settings-btn img {
  content: url('https://i.postimg.cc/bvPq64cv/CCA834-BA-5-A90-408-D-94-FA-7-EE156-B6-A765.png');
}
/* “触发API回复”按钮 */
#wait-reply-btn img {
  content: url('https://i.postimg.cc/q72zq80N/ECE92-BBC-BE57-48-E9-BB2-C-345-B6019-C4-B2.png');
}
/* “发送”按钮 (设为图片形式) */
#send-btn {
  background-image: url('在这里粘贴你的发送按钮图片URL');
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
  width: 50px; /* 根据你的图片调整宽度 */
}

/* “重新生成回复”按钮 */
#reroll-btn {
    background-color: rgba(255, 255, 255, 0.6);
    color: var(--text-primary); /* 使用全局主题的主文本颜色 */
}

/* === 3. 顶部栏与底部栏颜色 === */
.header, .qzone-header {
  background-color: rgba(240, 240, 240, 0.8); /* 顶部栏背景色 (带一点透明) */
  color: #333333; /* 顶部栏文字颜色 */
}
#chat-list-bottom-nav {
  background-color: rgba(245, 245, 245, 0.85); /* 底部导航栏背景色 */
}
.nav-item {
  color: #8a8a8a; /* 底部导航栏未选中项的颜色 */
}
.nav-item.active {
  color: #007bff; /* 底部导航栏选中项的颜色 */
}

/* === 4. 各界面背景色 === */
#chat-list-screen, #qzone-screen .qzone-content, #memories-view {
  background-color: #f0f2f5 !important; /* 列表页主背景色 */
}

/* === 5. 聊天输入区底部功能栏SVG图标替换 === */
/* 提示: 你需要将你的SVG代码转换为URL编码格式。
   可以使用在线工具搜索 "SVG to Data URI" 来完成转换。
   然后替换掉下面的 url('...') 部分。 */

.chat-action-icon-btn {
  background-color: rgba(255, 255, 255, 0.5); /* 图标按钮的背景色 */
  border: 1px solid rgba(0,0,0,0.05); /* 图标按钮的边框 */
}

/* 表情面板(+)按钮 */
#open-sticker-panel-btn svg { display: none; /* 隐藏原始SVG */ }
#open-sticker-panel-btn {
  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
}

/* 发送照片(旧)按钮 */
#send-photo-btn svg { display: none; /* 隐藏原始SVG */ }
#send-photo-btn {
  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/><circle cx="12" cy="13" r="4"/></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
}

/* 上传图片(新)按钮 */
#upload-image-btn svg { display: none; }
#upload-image-btn {
  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="color: black;"><path d="M21 3.5H3C2.44772 3.5 2 3.94772 2 4.5V19.5C2 20.0523 2.44772 20.5 3 20.5H21C21.5523 20.5 22 20.0523 22 19.5V4.5C22 3.94772 21.5523 3.5 21 3.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M16.5 13.5C17.6046 13.5 18.5 12.6046 18.5 11.5C18.5 10.3954 17.6046 9.5 16.5 9.5C15.3954 9.5 14.5 10.3954 14.5 11.5C14.5 12.6046 15.3954 13.5 16.5 13.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M22 14.5L18 10.5L10.3333 18.5M12.5 16L9 12.5L2 19.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
}

/* 转账(￥)按钮 */
#transfer-btn svg { display: none; }
#transfer-btn {
  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M7 4L12 12L17 4M12 12V20M8 10H16M8 13H16"></path></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
}

/* 语音按钮 */
#voice-message-btn svg { display: none; }
#voice-message-btn {
  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><path d="M12 19v4"/><path d="M8 23h8"/></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
}

/* 外卖按钮 */
#send-waimai-request-btn svg { display: none; }
#send-waimai-request-btn {
  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z"/><line x1="3" y1="6" x2="21" y2="6"/><path d="M16 10a4 4 0 0 1-8 0"/></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
}

/* 视频通话按钮 */
#video-call-btn svg { display: none; }
#video-call-btn {
  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="23 7 16 12 23 17 23 7"></polygon><rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
}

/* 群视频通话按钮 */
#group-video-call-btn svg { display: none; }
#group-video-call-btn {
  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
}

/* 投票按钮 */
#send-poll-btn svg { display: none; }
#send-poll-btn {
  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 6h10"/><path d="M6 6h.01"/><path d="M8 12h10"/><path d="M6 12h.01"/><path d="M8 18h10"/><path d="M6 18h.01"/></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
}

/* 分享链接按钮 */
#share-link-btn svg { display: none; }
#share-link-btn {
  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
}

/* 发送定位按钮 */
#send-location-btn { display: none; }
#send-location-btn {
  background-image: url('data:image/svg+xml;utf8,    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
}

/* === 6. 更多界面背景色 === */
/* 适用于所有设置、编辑、选择等二级页面 */
#api-settings-screen,
#font-settings-screen,
#wallpaper-screen,
#world-book-screen,
#world-book-editor-screen,
#contact-picker-screen,
#member-management-screen,
#album-screen,
#album-photos-screen,
#call-history-screen,
#chat-search-screen,
#browser-screen {
  /* 这里不再设置背景色，让它自然继承夜间模式的颜色 */
}


/* === 7. 回忆卡片美化 === */
.memory-card {
  background-color: #fffaf0 !important; /* 卡片主背景色 */
  border-left-color: #ffb74d !important; /* 左侧装饰条颜色 */
  box-shadow: 0 2px 6px rgba(0,0,0,0.07) !important;
}
.memory-card .header .author {
  color: #d98100 !important; /* 作者/标题文字颜色 */
}
.memory-card .header .date {
  color: #a1887f !important; /* 日期文字颜色 */
}
.memory-card .content {
  color: #5d4037 !important; /* 内容文字颜色 */
}
`;

// ▼▼▼ 在JS顶部，变量定义区，添加这个新常量 ▼▼▼
// ▼▼▼ 用下面这段【修改后】的代码，完整替换掉你旧的 DEFAULT_APP_ICONS ▼▼▼
const DEFAULT_APP_ICONS = {
    'world-book': 'https://i.postimg.cc/HWf1JKzn/IMG-6435.jpg',
    'qq': 'https://i.postimg.cc/MTC3Tkw8/IMG-6436.jpg',
    'api-settings': 'https://i.postimg.cc/MK8rJ8t7/IMG-6438.jpg',
    'wallpaper': 'https://i.postimg.cc/T1j03pQr/IMG-6440.jpg',
    'font': 'https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg',
    'check-phone': 'https://i.postimg.cc/RVwpwr0r/IMG-8348.jpg',
    'weibo': 'https://i.postimg.cc/PqBY5wBq/weibo-icon.png',
    'forum': 'https://i.postimg.cc/pr0T3WfC/douban-icon.png',
    'lovers-space': 'https://i.postimg.cc/d1wZ39xW/lovers-space-icon.png',
    'game-hall': 'https://i.postimg.cc/P5gL5z2g/game-controller-icon.png',
    'x-social': 'https://i.postimg.cc/8P1H0vQ8/x-logo.png',
    'taobao': 'https://i.postimg.cc/k47tXg1j/taologo.png',
    'date-a-live': 'https://i.postimg.cc/Kjdss1j9/1761142686734.png' 
};
// ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼
const DEFAULT_APP_LABELS = {
    'qq': 'QQ',
    'world-book': '世界书',
    'api-settings': 'API设置',
    'wallpaper': '外观设置',
    'font': '字体',
    'check-phone': '查手机',
    'weibo': '微博',
    'forum': '圈子',
    'lovers-space': '情侣空间',
    'game-hall': '游戏大厅',
    'x-social': 'X社交',
    'taobao': '桃宝',
    'date-a-live': '约会大作战'
};
// ▲▲▲ 新代码粘贴结束 ▲▲▲


// ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼
const addProductChoiceModal = document.getElementById('add-product-choice-modal');
const aiGeneratedProductsModal = document.getElementById('ai-generated-products-modal');
const productSearchInput = document.getElementById('product-search-input');
const productSearchBtn = document.getElementById('product-search-btn');
// ▲▲▲ 新增变量结束 ▲▲▲



        const STICKER_REGEX = /^(https:\/\/i\.postimg\.cc\/.+|https:\/\/i\.ibb\.co\/.+|https:\/\/files\.catbox\.moe\/.+|data:image)/;
        const MESSAGE_RENDER_WINDOW = 50;
        let currentRenderedCount = 0;
        let lastKnownBatteryLevel = 1;
        let alertFlags = { hasShown40: false, hasShown20: false, hasShown10: false };
        let batteryAlertTimeout;
        const dynamicFontStyle = document.createElement('style');
        dynamicFontStyle.id = 'dynamic-font-style';
        document.head.appendChild(dynamicFontStyle);

        const modalOverlay = document.getElementById('custom-modal-overlay');
        const modalTitle = document.getElementById('custom-modal-title');
        const modalBody = document.getElementById('custom-modal-body');
        const modalConfirmBtn = document.getElementById('custom-modal-confirm');
        const modalCancelBtn = document.getElementById('custom-modal-cancel');
        let modalResolve;

        function showCustomModal() { 
            modalOverlay.classList.add('visible'); 
        }

        function hideCustomModal() { 
            modalOverlay.classList.remove('visible'); 
            modalConfirmBtn.classList.remove('btn-danger'); 
            if (modalResolve) modalResolve(null); 
        }

        window.showCustomConfirm = function(title, message, options = {}) {

            return new Promise(resolve => {
                modalResolve = resolve;
                modalTitle.textContent = title;
                modalBody.innerHTML = `<p>${message}</p>`;
                modalCancelBtn.style.display = 'block';
                modalConfirmBtn.textContent = '确定';
                if (options.confirmButtonClass) modalConfirmBtn.classList.add(options.confirmButtonClass);
                modalConfirmBtn.onclick = () => { resolve(true); hideCustomModal(); };
                modalCancelBtn.onclick = () => { resolve(false); hideCustomModal(); };
                showCustomModal();
            });
        }

        window.showCustomAlert = function(title, message) {

            return new Promise(resolve => {
                modalResolve = resolve;
                modalTitle.textContent = title;
                modalBody.innerHTML = `<p style="text-align: left; white-space: pre-wrap;">${message}</p>`;
                modalCancelBtn.style.display = 'none';
                modalConfirmBtn.textContent = '好的';
                modalConfirmBtn.onclick = () => {
                    modalCancelBtn.style.display = 'block'; 
                    modalConfirmBtn.textContent = '确定';
                    resolve(true); 
                    hideCustomModal();
                };
                showCustomModal();
            });
        }
// ▼▼▼ 把这一整块全新的函数，粘贴到 <script> 标签的最开始 ▼▼▼
/**
 * 【全新】一个专门清除HTML标签和代码的函数
 * @param {string} text - 包含HTML或代码的原始文本
 * @returns {string} - 清理后的纯文本
 */
function stripHtmlAndCode(text) {
    if (!text || typeof text !== 'string') {
        return ''; // 如果输入为空或不是字符串，返回空字符串
    }
    // 1. 移除所有HTML标签 (例如 <b>, <div>)
    let cleanedText = text.replace(/<\/?[^>]+(>|$)/g, "");
    
    // 2. 移除所有Markdown代码块 (例如 ```code``` 或 `code`)
    cleanedText = cleanedText.replace(/```[\s\S]*?```/g, ''); // 移除多行代码块
    cleanedText = cleanedText.replace(/`[^`]*`/g, '');     // 移除行内代码
    
    // 3. 将HTML实体 (例如 &lt; &gt;) 转换回正常字符 (< >)
    const tempDiv = document.createElement("div");
    tempDiv.innerHTML = cleanedText;
    
    return tempDiv.textContent || tempDiv.innerText || "";
}
// ▲▲▲ 粘贴结束 ▲▲▲

// ▼▼▼ 请用这个【功能增强版】替换旧的 showCustomPrompt 函数 ▼▼▼
window.showCustomPrompt = function(title, placeholder, initialValue = '', type = 'text', extraHtml = '') {

    return new Promise(resolve => {
        modalResolve = resolve;
        modalTitle.textContent = title;
        const inputId = 'custom-prompt-input';
        
        const inputHtml = type === 'textarea' 
            ? `<textarea id="${inputId}" placeholder="${placeholder}" rows="4" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ccc; font-size: 14px; box-sizing: border-box; resize: vertical;">${initialValue}</textarea>`
            : `<input type="${type}" id="${inputId}" placeholder="${placeholder}" value="${initialValue}">`;
        
        // 【核心修改】将额外的HTML和输入框组合在一起
        modalBody.innerHTML = extraHtml + inputHtml;
        const input = document.getElementById(inputId);

        // 【核心修改】为格式助手按钮绑定事件
        modalBody.querySelectorAll('.format-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const templateStr = btn.dataset.template;
                if (templateStr) {
                    try {
                        const templateObj = JSON.parse(templateStr);
                        // 使用 null, 2 参数让JSON字符串格式化，带缩进，更易读
                        input.value = JSON.stringify(templateObj, null, 2);
                        input.focus();
                    } catch(e) {
                        console.error("解析格式模板失败:", e);
                    }
                }
            });
        });
        
        modalConfirmBtn.onclick = () => { resolve(input.value); hideCustomModal(); };
        modalCancelBtn.onclick = () => { resolve(null); hideCustomModal(); };
        showCustomModal();
        setTimeout(() => input.focus(), 100);
    });
}
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 把这一整块全新的函数，粘贴到你的JS功能函数定义区 ▼▼▼
// ▼▼▼ 把这一整块全新的函数，粘贴到你的JS功能函数定义区 ▼▼▼

/**
 * 【全新】从一个数组中随机获取一个元素
 * @param {Array} arr - 目标数组
 * @returns {*} - 数组中的一个随机元素
 */
function getRandomItem(arr) {
    // 安全检查，如果数组为空或不存在，返回空字符串
    if (!arr || arr.length === 0) return '';
    // 返回一个随机索引对应的元素
    return arr[Math.floor(Math.random() * arr.length)];
}

// ▲▲▲ 粘贴结束 ▲▲▲
// ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼

/**
 * 【全新】获取一张随机的淘宝宝贝默认图片
 * @returns {string} - 返回一张随机图片的URL
 */
function getRandomDefaultProductImage() {
    const defaultImages = [
        'https://i.postimg.cc/W4svy4Hm/Image-1760206134285.jpg',
        'https://i.postimg.cc/jjRb1jF7/Image-1760206125678.jpg'
    ];
    // 从数组中随机选择一个并返回
    return defaultImages[Math.floor(Math.random() * defaultImages.length)];
}

// ▲▲▲ 新增代码粘贴结束 ▲▲▲

/**
 * 【全新】从一个数组中随机获取一个元素
 * @param {Array} arr - 目标数组
 * @returns {*} - 数组中的一个随机元素
 */
function getRandomItem(arr) {
    // 安全检查，如果数组为空或不存在，返回空字符串
    if (!arr || arr.length === 0) return '';
    // 返回一个随机索引对应的元素
    return arr[Math.floor(Math.random() * arr.length)];
}

// ▲▲▲ 粘贴结束 ▲▲▲

        // ===================================================================
        // 2. 数据库结构定义
        // ===================================================================

// ▼▼▼ 【V47修复版】请用这块新代码替换旧的 db.version(...).stores(...) ▼▼▼
db.version(47).stores({ // 版本号 +1 = 47
    chats: '&id, isGroup, groupId, ownerId, isPinned, characterPhoneData, latestInnerVoice, innerVoiceHistory, loversSpaceData.emotionDiaries, settings.summary, settings.weiboNickname, settings.innerVoiceHideHeaderBorder, settings.innerVoiceAdopterLabelFormat', 
    apiConfig: '&id',
    globalSettings: '&id, activeThemeId', 
    userStickers: '&id, url, name', 
    charStickers: '&id, url, name', 
    worldBooks: '&id, name, categoryId', 
    worldBookCategories: '++id, name',
    musicLibrary: '&id', 
    personaPresets: '&id',
    qzoneSettings: '&id',
    qzonePosts: '++id, authorId, timestamp', 
    qzoneAlbums: '++id, name, createdAt',
    qzonePhotos: '++id, albumId',
    favorites: '++id, type, timestamp, originalTimestamp',
    qzoneGroups: '++id, name',
    memories: '++id, chatId, timestamp, type, targetDate' ,
    callRecords: '++id, chatId, timestamp, customName',
    customAvatarFrames: '&id, name, url',   
    themes: '++id, name, css',
    apiPresets: '++id, name, proxyUrl',
    bubbleStylePresets: '++id, name, css',
    fontPresets: '&id, name, url',
    homeScreenPresets: '++id, name',
    weiboPosts: '++id, authorId, timestamp',
    forumGroups: '++id, name, worldview, *categories',
    forumPosts: '++id, groupId, timestamp, *categories',
    forumComments: '++id, postId, timestamp',
    forumCategories: '++id, name',
    tarotReadings: '++id, timestamp',
    pomodoroSessions: '++id, chatId, startTime',
    scriptKillScripts: '++id, name, isBuiltIn',
    taobaoProducts: '++id, name, category', 
    taobaoOrders: '++id, productId, timestamp',
    taobaoCart: '++id, productId',
    userWalletTransactions: '++id, timestamp' ,
    charPhonePresets: '++id, name',
    ludoQuestionBanks: '++id, name',
    ludoQuestions: '++id, bankId, text, type',
    datingScenes: '&uid, imageUrl',
    datingPresets: '++id, name, settings.spriteGroupId',
    datingSpriteGroups: '++id, name',
    datingSprites: '++id, groupId, description, url',
    // ★★★ 在这里添加我们的新表格 ★★★
    datingHistory: '++id, characterId, timestamp'
});
// ▲▲▲ 替换结束 ▲▲▲



window.db = db;

// ===================================================================
// 3. 所有功能函数定义
// ===================================================================

// ▼▼▼ 请用这整块【修复版】代码，完整替换掉你旧的 toggleVoiceTranscript 函数 ▼▼▼

/**
 * 【V2 - 修复版】切换语音消息的文字显示/隐藏
 * @param {HTMLElement} bubble - 被点击的语音消息的 .message-bubble 元素
 */
function toggleVoiceTranscript(bubble) {
    if (!bubble) return;

    const transcriptEl = bubble.querySelector('.voice-transcript');
    if (!transcriptEl) return;

    // 核心逻辑：直接检查文字区域当前是不是显示状态
    const isCurrentlyExpanded = transcriptEl.style.display === 'block';

    if (isCurrentlyExpanded) {
        // 如果是展开的，就直接收起来
        transcriptEl.style.display = 'none';
    } else {
        // 如果是收起的，就执行展开流程
        
        // 1. 先显示一个“正在转写”的提示，给用户即时反馈
        transcriptEl.textContent = '正在转文字...';
        transcriptEl.style.display = 'block';

        // 2. 模拟一个短暂的“识别”过程
        setTimeout(() => {
            // 再次检查元素是否还在页面上，防止用户切换聊天导致错误
            if (document.body.contains(transcriptEl)) {
                // 获取并显示真正的转写文字
                const voiceText = bubble.dataset.voiceText || '(无法识别)';
                transcriptEl.textContent = voiceText;
            }
        }, 300); // 300毫秒的延迟，感觉更灵敏
    }
}

// ▲▲▲ 替换结束 ▲▲▲



// ▼▼▼ 把这一整块全新的微博功能函数，粘贴到 init() 函数的上方 ▼▼▼

/**
 * 【全新】微博用户人设与职业设置核心功能
 */
function openWeiboUserSettingsModal() {
    const modal = document.getElementById('weibo-user-settings-modal');
    const settings = state.qzoneSettings;

    // 加载当前数据到输入框
    document.getElementById('weibo-user-profession-modal-input').value = settings.weiboUserProfession === '点击设置职业' ? '' : settings.weiboUserProfession;
    document.getElementById('weibo-user-persona-modal-input').value = settings.weiboUserPersona;
    
    renderWeiboUserPresetSelector(); // 渲染预设下拉框
    modal.classList.add('visible');
}

async function saveWeiboUserSettings() {
    const profession = document.getElementById('weibo-user-profession-modal-input').value.trim();
    const persona = document.getElementById('weibo-user-persona-modal-input').value.trim();

    state.qzoneSettings.weiboUserProfession = profession || '点击设置职业';
    state.qzoneSettings.weiboUserPersona = persona || '一个普通的微博用户。';

    await saveQzoneSettings(); // 保存到数据库
    await renderWeiboProfile(); // 刷新主页显示
    document.getElementById('weibo-user-settings-modal').classList.remove('visible');
    alert('微博设定已保存！');
}

function renderWeiboUserPresetSelector() {
    const select = document.getElementById('weibo-user-preset-select');
    const presets = state.qzoneSettings.weiboUserPersonaPresets || [];
    select.innerHTML = '<option value="">-- 选择预设 --</option>';
    presets.forEach((preset, index) => {
        const option = document.createElement('option');
        option.value = index;
        option.textContent = preset.name;
        select.appendChild(option);
    });
}

function handleWeiboUserPresetSelection() {
    const select = document.getElementById('weibo-user-preset-select');
    const presets = state.qzoneSettings.weiboUserPersonaPresets || [];
    const selectedIndex = select.value;

    if (selectedIndex !== "") {
        const preset = presets[parseInt(selectedIndex)];
        document.getElementById('weibo-user-profession-modal-input').value = preset.profession;
        document.getElementById('weibo-user-persona-modal-input').value = preset.persona;
    }
}

async function openWeiboUserPresetManager() {
    const choice = await showChoiceModal("管理预设", [
        { text: '💾 保存当前为新预设', value: 'save' },
        { text: '🗑️ 删除已选预设', value: 'delete' }
    ]);

    if (choice === 'save') {
        const name = await showCustomPrompt("保存预设", "请输入预设名称");
        if (name && name.trim()) {
            const newPreset = {
                name: name.trim(),
                profession: document.getElementById('weibo-user-profession-modal-input').value.trim(),
                persona: document.getElementById('weibo-user-persona-modal-input').value.trim()
            };
            state.qzoneSettings.weiboUserPersonaPresets.push(newPreset);
            await saveQzoneSettings();
            renderWeiboUserPresetSelector();
            alert(`预设 "${name.trim()}" 已保存！`);
        }
    } else if (choice === 'delete') {
        const select = document.getElementById('weibo-user-preset-select');
        const selectedIndex = select.value;
        if (selectedIndex === "") {
            alert("请先从下拉框中选择一个要删除的预设。");
            return;
        }
        const presets = state.qzoneSettings.weiboUserPersonaPresets;
        const presetName = presets[parseInt(selectedIndex)].name;
        const confirmed = await showCustomConfirm("确认删除", `确定要删除预设 "${presetName}" 吗？`, { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            presets.splice(parseInt(selectedIndex), 1);
            await saveQzoneSettings();
            renderWeiboUserPresetSelector();
            alert("预设已删除。");
        }
    }
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 从这里开始，粘贴所有新代码 ▼▼▼
/**
 * 【V2智能版】应用指定的主题，并智能刷新当前打开的任何界面
 * @param {string} theme - 'light' 或 'dark'
 */
function applyTheme(theme) {
    const phoneScreen = document.getElementById('phone-screen');
    const toggleSwitch = document.getElementById('theme-toggle-switch');
    
    const isDark = theme === 'dark';
    
    // 核心操作：为手机屏幕添加或移除 .dark-mode 类
    phoneScreen.classList.toggle('dark-mode', isDark);
    
    // 同步开关的状态
    if (toggleSwitch) {
        toggleSwitch.checked = isDark;
    }
    
    // 保存用户的选择
    localStorage.setItem('ephone-theme', theme);

    // 【核心修复！】
    // 不再只关心聊天界面，而是找出当前究竟是哪个界面处于激活状态
    const activeScreen = document.querySelector('.screen.active');
    if (!activeScreen) return; // 如果找不到，就退出

    // 根据当前激活的界面ID，调用它专属的刷新函数
    switch (activeScreen.id) {
        case 'chat-interface-screen':
            if (state.activeChatId) {
                renderChatInterface(state.activeChatId);
            }
            break;
        case 'wallpaper-screen':
            // 外观设置页也需要重新渲染来应用新主题
            renderWallpaperScreen();
            break;
        case 'font-settings-screen':
            // 字体预设页同样需要
            renderFontPresets();
            break;
        // 如果未来还有其他页面需要适配，在这里添加 case 即可
    }
}


/**
 * 当用户点击开关时，切换当前的主题
 */
function toggleTheme() {
    const toggleSwitch = document.getElementById('theme-toggle-switch');
    // 直接根据开关的选中状态来决定新主题
    const newTheme = toggleSwitch.checked ? 'dark' : 'light';
    applyTheme(newTheme);
}
/**
 * 【全新】在应用启动时，预加载所有已保存的字体预设
 */
async function loadAllFontPresetsOnStartup() {
    console.log("正在预加载所有字体预设...");
    const presets = await db.fontPresets.toArray();
    if (presets && presets.length > 0) {
        presets.forEach(preset => {
            // 我们复用已有的 loadFontForPreview 函数来加载每个字体
            loadFontForPreview(preset);
        });
        console.log(`成功预加载了 ${presets.length} 个字体。`);
    }
}

// ▼▼▼ 【全新】字体预设功能核心函数 ▼▼▼

/**
 * 渲染字体预设的5个卡槽
 */
async function renderFontPresets() {
    const container = document.getElementById('font-preset-container');
    container.innerHTML = ''; // 清空旧内容

    // 从数据库读取所有已保存的预设
    const presets = await db.fontPresets.toArray();

    // 循环5次，创建5个卡槽的HTML
    for (let i = 0; i < 5; i++) {
        const slot = document.createElement('div');
        slot.className = 'font-preset-slot';
        
        const preset = presets[i];

        if (preset) {
            // 如果这个卡槽有数据
            slot.innerHTML = `
                <div class="font-preview-text" data-preset-id="${preset.id}">Abc 你好</div>
                <div class="font-preset-info">名称: ${preset.name}</div>
                <div class="font-preset-actions">
                    <button class="preset-btn apply-btn" data-preset-id="${preset.id}">应用</button>
                    <button class="preset-btn delete-btn delete" data-preset-id="${preset.id}">删除</button>
                </div>
            `;
        } else {
            // 如果这个卡槽是空的
            slot.classList.add('empty');
            slot.innerHTML = `
                <div class="font-preset-info">卡槽 ${i + 1} 为空</div>
                <div class="font-preset-actions">
                    <button class="preset-btn secondary upload-url-btn" data-slot-index="${i}">URL上传</button>
                    <button class="preset-btn secondary upload-local-btn" data-slot-index="${i}">本地上传</button>
                </div>
            `;
        }
        container.appendChild(slot);
    }
    
    // ▼▼▼ 【核心修复】在这里，我们等所有HTML都创建好后，再统一加载预览字体 ▼▼▼
    presets.forEach(preset => {
        if (preset) {
            // 为每一个有数据的预设，调用加载预览函数
            loadFontForPreview(preset);
        }
    });
    // ▲▲▲ 修复结束 ▲▲▲

    // 为所有新生成的按钮绑定事件
    addFontPresetButtonListeners();
}


/**
 * 【终极修复版】为单个预设加载字体以供预览
 * @param {object} preset - 字体预设对象 {id, name, url}
 */
function loadFontForPreview(preset) {
    const styleId = `font-style-${preset.id}`;
    if (document.getElementById(styleId)) return;

    const style = document.createElement('style');
    style.id = styleId;
    
    // 【核心修改】我们不再手动操作元素的style属性，
    // 而是直接创建一条高优先级的CSS规则来应用字体，这更可靠。
    style.innerHTML = `
        @font-face {
            font-family: 'preset-${preset.id}';
            src: url('${preset.url}');
            font-display: swap;
        }

        .font-preview-text[data-preset-id="${preset.id}"] {
            font-family: 'preset-${preset.id}', sans-serif !important;
        }
    `;
    
    document.head.appendChild(style);
}




/**
 * 为预设卡槽中的所有按钮统一添加事件监听器
 */
function addFontPresetButtonListeners() {
    document.querySelectorAll('.upload-url-btn').forEach(btn => {
        btn.onclick = () => handleUploadFontUrl(parseInt(btn.dataset.slotIndex));
    });
    document.querySelectorAll('.upload-local-btn').forEach(btn => {
        btn.onclick = () => handleUploadFontLocal(parseInt(btn.dataset.slotIndex));
    });
    document.querySelectorAll('.apply-btn').forEach(btn => {
        btn.onclick = () => applyFontPreset(btn.dataset.presetId);
    });
    document.querySelectorAll('.delete-btn').forEach(btn => {
        btn.onclick = () => deleteFontPreset(btn.dataset.presetId);
    });
}

/**
 * 处理通过URL上传字体
 * @param {number} slotIndex - 卡槽的索引 (0-4)
 */
async function handleUploadFontUrl(slotIndex) {
    const url = await showCustomPrompt("字体URL", "请输入字体的网络链接(.ttf, .otf等)");
    if (!url || !url.trim().startsWith('http')) {
        if (url !== null) alert("请输入一个有效的URL！");
        return;
    }
    const name = await showCustomPrompt("字体命名", "请为这个字体起个名字");
    if (!name || !name.trim()) {
        if (name !== null) alert("名字不能为空！");
        return;
    }
    await saveFontPreset(slotIndex, name.trim(), url.trim());
}

/**
 * 处理通过本地文件上传字体
 * @param {number} slotIndex - 卡槽的索引 (0-4)
 */
function handleUploadFontLocal(slotIndex) {
    const input = document.getElementById('font-preset-local-upload');
    input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const name = await showCustomPrompt("字体命名", "请为这个字体起个名字", file.name.replace(/\.[^/.]+$/, ""));
        if (!name || !name.trim()) {
            if (name !== null) alert("名字不能为空！");
            return;
        }

        // 使用FileReader将字体文件转为Base64 Data URL
        const reader = new FileReader();
        reader.onload = async (event) => {
            // 核心修改：event.target.result 现在就是我们需要的 data:font/ttf;base64,... 格式的完整文本
            await saveFontPreset(slotIndex, name.trim(), event.target.result);
        };
        // 核心修改：使用 readAsDataURL 来读取文件
        reader.readAsDataURL(file);
    };
    input.click(); // 触发文件选择框
}


/**
 * 将新的字体预设保存到数据库
 * @param {number} slotIndex - 卡槽索引
 * @param {string} name - 字体名称
 * @param {string} url - 字体URL (网络或Base64)
 */
// ▼▼▼ 用下面这整块代码，替换掉你旧的 saveFontPreset 函数 ▼▼▼
async function saveFontPreset(slotIndex, name, url) {
    try {
        const presets = await db.fontPresets.toArray();
        const newPreset = { id: 'font_' + Date.now(), name, url };
        presets.splice(slotIndex, 0, newPreset);
        const presetsToSave = presets.slice(0, 5);

        // 【核心修改】使用数据库事务来保证操作的原子性
        await db.transaction('rw', db.fontPresets, async () => {
            await db.fontPresets.clear();
            await db.fontPresets.bulkPut(presetsToSave);
        });

        await renderFontPresets();
        alert(`字体 "${name}" 已成功保存到卡槽 ${slotIndex + 1}！`);
    } catch (error) {
        // 【核心修改】如果出错，会在这里捕获，并告知用户数据是安全的
        console.error("保存字体预设失败:", error);
        alert(`保存字体失败，数据已自动回滚，你之前的字体数据是安全的。错误: ${error.message}`);
        await renderFontPresets(); // 失败后重新渲染，恢复到旧的列表状态
    }
}
// ▲▲▲ 替换结束 ▲▲▲


/**
 * 删除一个字体预设
 * @param {string} presetId - 要删除的预设的ID
 */
async function deleteFontPreset(presetId) {
    const preset = await db.fontPresets.get(presetId);
    if (!preset) return;
    const confirmed = await showCustomConfirm("确认删除", `确定要删除字体 "${preset.name}" 吗？`, { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        await db.fontPresets.delete(presetId);
        
        // 从DOM中移除对应的预览样式
        const styleTag = document.getElementById(`font-style-${presetId}`);
        if (styleTag) styleTag.remove();

        await renderFontPresets();
    }
}

/**
 * 应用一个字体预设为全局字体
 * @param {string} presetId - 要应用的预设的ID
 */
async function applyFontPreset(presetId) {
    const preset = await db.fontPresets.get(presetId);
    if (preset) {
        // 调用你已有的全局字体应用函数
        applyCustomFont(preset.url, false);
        // 保存到全局设置
        state.globalSettings.fontUrl = preset.url;
        await db.globalSettings.put(state.globalSettings);
        alert(`已将全局字体更换为 "${preset.name}"！`);
    }
}

// ▲▲▲ 新功能函数粘贴结束 ▲▲▲

/**
 * 【总入口】处理用户选择的角色卡文件
 * @param {File} file - 用户选择的文件对象
 */
async function handleCharacterImport(file) {
    if (!file) return;

    try {
        let characterData;
        let avatarBase64;

        if (file.name.toLowerCase().endsWith('.png')) {
            // 如果是PNG文件，调用PNG解析函数
            const result = await parseCharPng(file);
            characterData = result.characterData;
            avatarBase64 = result.avatarBase64;
        } else if (file.name.toLowerCase().endsWith('.json')) {
            // 如果是JSON文件，调用JSON解析函数
            characterData = await parseCharJson(file);
            // JSON卡通常不包含图片，我们给一个默认头像
            avatarBase64 = defaultAvatar;
        } else {
            alert('不支持的文件格式，请选择 .png 或 .json 文件。');
            return;
        }

        if (characterData) {
            // 成功解析出数据后，调用创建函数
            await createCharacterFromData(characterData, avatarBase64);
        }

    } catch (error) {
        console.error("导入角色卡失败:", error);
        alert(`导入失败: ${error.message}`);
    }
}

/**
 * 【V3 - 最终乱码修复版】
 * 解析SillyTavern的PNG角色卡，通过字节级操作彻底解决中文乱码问题。
 * @param {File} file - PNG文件
 * @returns {Promise<{characterData: object, avatarBase64: string}>}
 */
async function parseCharPng(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
            const arrayBuffer = e.target.result;
            const dataView = new DataView(arrayBuffer);

            if (dataView.getUint32(0) !== 0x89504E47 || dataView.getUint32(4) !== 0x0D0A1A0A) {
                return reject(new Error('文件不是一个有效的PNG图片。'));
            }

            let offset = 8;
            let characterJson = null;

            while (offset < dataView.byteLength) {
                const length = dataView.getUint32(offset);
                const type = String.fromCharCode(
                    dataView.getUint8(offset + 4),
                    dataView.getUint8(offset + 5),
                    dataView.getUint8(offset + 6),
                    dataView.getUint8(offset + 7)
                );

                if (type === 'tEXt') {
                    const chunkData = new Uint8Array(arrayBuffer, offset + 8, length);
                    
                    // ★★★★★【这是本次修复乱码的核心代码】★★★★★
                    // 1. 先用一个简单的编码将字节转为字符串，以便查找关键字 "chara"
                    let text = '';
                    for (let i = 0; i < chunkData.length; i++) {
                        text += String.fromCharCode(chunkData[i]);
                    }

                    // 2. 检查关键字是否存在
                    const keyword = 'chara' + String.fromCharCode(0);
                    if (text.startsWith(keyword)) {
                        // 3. 提取出关键字后面的 Base64 编码的字符串
                        const base64Data = text.substring(keyword.length);
                        try {
                            // 4. 使用 atob() 解码 Base64，得到一个“二进制字符串”
                            const binaryString = atob(base64Data);
                            
                            // 5. 将这个“二进制字符串”重新转换为原始的 UTF-8 字节数组
                            const bytes = new Uint8Array(binaryString.length);
                            for (let i = 0; i < binaryString.length; i++) {
                                bytes[i] = binaryString.charCodeAt(i);
                            }
                            
                            // 6. 使用 TextDecoder 将这个纯净的 UTF-8 字节数组解码为正确的字符串
                            const decodedJsonString = new TextDecoder('utf-8').decode(bytes);
                            
                            // 7. 解析最终的JSON字符串
                            characterJson = JSON.parse(decodedJsonString);
                            break;
                        } catch (e) {
                            return reject(new Error('解析图片内嵌的角色数据失败，可能是数据损坏。'));
                        }
                    }
                    // ★★★★★【核心代码结束】★★★★★
                }
                
                if (type === 'IEND') break;
                offset += 12 + length;
            }

            if (characterJson) {
                const imageReader = new FileReader();
                imageReader.onload = (imgEvent) => {
                    resolve({
                        characterData: characterJson,
                        avatarBase64: imgEvent.target.result
                    });
                };
                imageReader.onerror = () => reject(new Error('读取图片作为头像失败。'));
                imageReader.readAsDataURL(file);
            } else {
                reject(new Error('在这张PNG图片中没有找到SillyTavern角色数据。'));
            }
        };
        reader.onerror = () => reject(new Error('读取PNG文件失败。'));
        reader.readAsArrayBuffer(file);
    });
}


/**
 * 解析JSON角色卡
 * @param {File} file - JSON文件
 * @returns {Promise<object>}
 */
/**
 * 【修正版】解析JSON角色卡，强制使用UTF-8编码
 * @param {File} file - JSON文件
 * @returns {Promise<object>}
 */
async function parseCharJson(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                // 核心修正：先读取为ArrayBuffer，再用TextDecoder指定UTF-8解码
                const arrayBuffer = e.target.result;
                const textDecoder = new TextDecoder('utf-8');
                const jsonString = textDecoder.decode(arrayBuffer);
                const data = JSON.parse(jsonString);
                // 兼容两种可能的格式
                resolve(data.data || data);
            } catch (error) {
                reject(new Error('解析JSON文件失败，请检查文件格式或编码。'));
            }
        };
        reader.onerror = () => reject(new Error('读取JSON文件失败。'));
        // 核心修正：读取为ArrayBuffer而不是Text
        reader.readAsArrayBuffer(file);
    });
}

/**
 * 【V5 - 最终适配版 - 识别 character_book】
 * 根据解析出的数据创建新角色和世界书。
 * 这个版本将优先查找您提供的 character_book 标准格式。
 * @param {object} data - 从卡片解析出的最原始的JSON数据
 * @param {string} avatarBase64 - 角色的头像图片 (Base64)
 */
async function createCharacterFromData(data, avatarBase64) {
    // 步骤 1: 确定核心角色数据 (不变)
    const charData = data.data || data;
    const characterName = charData.name ? charData.name.trim() : '未命名角色';
    
    // 步骤 2: 创建新的聊天对象 (不变)
    const newChatId = 'chat_' + Date.now();
// ▼▼▼ 请用这块【终极完整版】代码，替换你旧的 const newChat = { ... }; 代码块 ▼▼▼

const newChat = {
    id: newChatId,
    name: characterName,
    isGroup: false,
    isPinned: false,
    history: [],
    unreadCount: 0,
    musicData: { totalTime: 0 },
    npcLibrary: [],
    relationship: { status: 'friend', blockedTimestamp: null, applicationReason: '' },
    status: { text: '在线', lastUpdate: Date.now(), isBusy: false },
    weiboDms: [],
    loversSpaceData: null,
    settings: {
        aiPersona: charData.description || '该角色没有描述。',
        myPersona: '我是谁呀。',
        maxMemory: 10,
        aiAvatar: avatarBase64,
        myAvatar: defaultAvatar,
        background: '',
        theme: 'default',
        fontSize: 13,
        customCss: '',
        linkedWorldBookIds: [],
        aiAvatarLibrary: [],
        stickerLibrary: [],
        summary: { 
            enabled: false, 
            mode: 'auto', 
            count: 20, 
            prompt: '请你以第三人称的视角，客观、冷静、不带任何感情色彩地总结以下对话的核心事件和信息。禁止进行任何角色扮演或添加主观评论。', 
            lastSummaryIndex: -1 
        },
        linkedMemories: [],
        offlineMode: { 
            enabled: false, 
            prompt: '', 
            style: '', 
            wordCount: 300, 
            presets: [] 
        },
        timePerceptionEnabled: true,
        customTime: '',
        isCoupleAvatar: false,
        coupleAvatarDescription: '',
        weiboProfession: '',
        weiboInstruction: '',
        visualVideoCallEnabled: false,
        charVideoImage: '',
        userVideoImage: '',
        petAdopted: false,
        pet: null,
    },
    characterPhoneData: {
        lastGenerated: null,
        chats: {},
        shoppingCart: [],
        memos: [],
        browserHistory: [],
        photoAlbum: [],
        bank: { balance: 0, transactions: [] },
        trajectory: [],
        appUsage: [],
        diary: []
    }
};

// ▲▲▲ 替换结束 ▲▲▲

    await db.chats.put(newChat);
    state.chats[newChatId] = newChat;
    
    // =================================================================
    // ▼▼▼ 核心修改：重构世界书查找逻辑 ▼▼▼
    // =================================================================
    
    console.log("开始检测世界书数据...");
    let worldBookFound = false;

    // 策略一：【最高优先级】查找您提供的 character_book 标准格式
    if (charData.character_book && charData.character_book.entries && Array.isArray(charData.character_book.entries) && charData.character_book.entries.length > 0) {
        console.log(`检测到最新的 character_book 格式 (${charData.character_book.entries.length}条)，开始导入...`);
        const newCategory = { name: characterName };
        const newCategoryId = await db.worldBookCategories.add(newCategory);
        // 我们将调用【修改后】的辅助函数来处理
        await saveWorldBookEntriesFromArray(charData.character_book.entries, newCategoryId);
        worldBookFound = true;
    }
    
    // 策略二：兼容旧的 world_entries 格式
    else if (charData.world_entries && Array.isArray(charData.world_entries) && charData.world_entries.length > 0) {
        console.log(`检测到旧版 world_entries 格式 (${charData.world_entries.length}条)，开始导入...`);
        const newCategory = { name: characterName };
        const newCategoryId = await db.worldBookCategories.add(newCategory);
        await saveWorldBookEntriesFromArray(charData.world_entries, newCategoryId);
        worldBookFound = true;
    }
    
    // 策略三：兼容更旧的 data.world 格式
    else if (data.world && typeof data.world === 'string' && data.world.trim()) {
        console.log("检测到外层 world 字段格式，开始导入...");
        const newCategory = { name: characterName };
        const newCategoryId = await db.worldBookCategories.add(newCategory);
        await parseAndSaveWorldBooks(data.world, newCategoryId);
        worldBookFound = true;
    }

    // 策略四：最后的兼容手段 world_info
    else if (charData.world_info && typeof charData.world_info === 'string' && charData.world_info.trim()) {
        console.log("检测到旧版 world_info 字段格式，开始导入...");
        const newCategory = { name: characterName };
        const newCategoryId = await db.worldBookCategories.add(newCategory);
        await parseAndSaveWorldBooks(charData.world_info, newCategoryId);
        worldBookFound = true;
    }

    if (!worldBookFound) {
        console.log("诊断：在此角色卡中未找到任何可识别的世界书字段。");
    }
    
    // =================================================================
    // ▲▲▲ 核心修改结束 ▲▲▲
    // =================================================================

    // 步骤 4: 刷新UI (不变)
    await renderChatList();
    await showCustomAlert('导入成功！', `角色“${characterName}”已成功创建！`);
}


/**
 * 【V2 - 适配 comment 字段】
 * 从SillyTavern的 world_entries 或 character_book.entries 数组直接创建世界书
 * @param {Array<object>} entriesArray - 包含世界书条目的数组
 * @param {number} categoryId - 这些世界书所属的分类ID
 */
async function saveWorldBookEntriesFromArray(entriesArray, categoryId) {
    const newBooks = [];

    for (const entry of entriesArray) {
        // ▼▼▼ 核心修改：智能获取条目名称 ▼▼▼
        // 优先使用 comment 字段作为标题，如果它存在且不为空。
        // 否则，再尝试使用 keys 数组。
        // 如果都没有，就给一个默认名字。
        const entryName = (entry.comment && entry.comment.trim()) 
                          ? entry.comment.trim() 
                          : (entry.keys && entry.keys.length > 0 ? entry.keys.join(', ') : '未命名条目');
        // ▲▲▲ 核心修改结束 ▲▲▲

        // 检查条目是否有效 (有名字、有内容，并且是启用的)
        // (typeof entry.enabled === 'undefined' || entry.enabled) 是为了兼容没有 enabled 字段的卡片
        if (entryName !== '未命名条目' && entry.content && (typeof entry.enabled === 'undefined' || entry.enabled)) {
            newBooks.push({
                id: 'wb_' + Date.now() + Math.random(),
                name: entryName, // 使用我们智能获取到的名字
                content: entry.content,
                categoryId: categoryId
            });
        }
    }

    if (newBooks.length > 0) {
        await db.worldBooks.bulkAdd(newBooks);
        // 确保 state.worldBooks 也被更新，以便UI能立即显示
        const allBooks = await db.worldBooks.toArray();
        state.worldBooks = allBooks;
        console.log(`成功导入 ${newBooks.length} 个世界书条目到分类ID: ${categoryId}`);
    }
}



// 【辅助函数】获取事件的坐标
function getEventCoords(e) {
    // 如果是触摸事件，就从 e.touches[0] 获取
    if (e.touches && e.touches[0]) {
        return { x: e.touches[0].pageX, y: e.touches[0].pageY };
    }
    // 否则，就是鼠标事件，直接从 e 获取
    return { x: e.pageX, y: e.pageY };
}


// ▼▼▼ 用这块【最终修复版】的代码，完整替换你旧的 showScreen 函数 ▼▼▼
function showScreen(screenId) {
    if (!document.getElementById('logistics-screen').classList.contains('active')) {
        logisticsUpdateTimers.forEach(timerId => clearTimeout(timerId));
        logisticsUpdateTimers = [];
    }

    // 【核心修改】我们现在直接调用真正的函数，不再需要 "Proxy"
    if (screenId === 'chat-list-screen') {
        renderChatList(); 
        switchToChatListView('messages-view');
    }
    if (screenId === 'api-settings-screen') {
        renderApiSettings();
    }
    if (screenId === 'wallpaper-screen') {
        renderWallpaperScreen();
    }
    if (screenId === 'world-book-screen') {
        renderWorldBookScreen();
    }

    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    const screenToShow = document.getElementById(screenId);
    if (screenToShow) {
        screenToShow.classList.add('active');
    }

    if (screenId === 'chat-interface-screen') {
        updateListenTogetherIcon(state.activeChatId);
    }
    
    if (screenId === 'font-settings-screen') {
        document.getElementById('font-preview').style.fontFamily = '';
        applyCustomFont(state.globalSettings.fontUrl || '', true);
        renderFontPresets();
    }
}
window.showScreen = showScreen; // 确保 showScreen 自己也是全局的
// ▲▲▲ 替换结束 ▲▲▲

        window.updateListenTogetherIconProxy = () => {};

        function switchToChatListView(viewId) {
            const chatListScreen = document.getElementById('chat-list-screen');
            const views = {
                'messages-view': document.getElementById('messages-view'),
                'qzone-screen': document.getElementById('qzone-screen'),
                'favorites-view': document.getElementById('favorites-view'),
        'memories-view': document.getElementById('memories-view') // <-- 新增这一行
    };
            const mainHeader = document.getElementById('main-chat-list-header');
            const mainBottomNav = document.getElementById('chat-list-bottom-nav'); // 获取主导航栏

            if (isFavoritesSelectionMode) {
                document.getElementById('favorites-edit-btn').click(); 
            }

            // 隐藏所有视图
            Object.values(views).forEach(v => v.classList.remove('active'));
            // 显示目标视图
            if (views[viewId]) {
                views[viewId].classList.add('active');
            }

            // 更新底部导航栏高亮
            document.querySelectorAll('#chat-list-bottom-nav .nav-item').forEach(item => {
                item.classList.toggle('active', item.dataset.view === viewId);
            });
            
            // ▼▼▼ 【核心修正】在这里统一管理所有UI元素的显隐 ▼▼▼
            if (viewId === 'messages-view') {
                mainHeader.style.display = 'flex';
                mainBottomNav.style.display = 'flex';
            } else {
                mainHeader.style.display = 'none';
                mainBottomNav.style.display = 'none';
            }
            // ▲▲▲ 修正结束 ▲▲▲

    if (viewId !== 'memories-view') {
        activeCountdownTimers.forEach(timerId => clearInterval(timerId));
        activeCountdownTimers = [];
    }

            // 根据视图ID执行特定的渲染/更新逻辑
            switch (viewId) {
                case 'qzone-screen':
                    views['qzone-screen'].style.backgroundColor = '#f0f2f5';
                    updateUnreadIndicator(0);
                    renderQzoneScreen();
                    renderQzonePosts();
                    break;
                case 'favorites-view':
                    views['favorites-view'].style.backgroundColor = '#f9f9f9';
                    renderFavoritesScreen();
                    break;
                case 'messages-view':
                    // 如果需要，可以在这里添加返回消息列表时要执行的逻辑
                    break;
            }
        }
        
        function renderQzoneScreen() {
            if (state && state.qzoneSettings) {
                const settings = state.qzoneSettings;
                document.getElementById('qzone-nickname').textContent = settings.nickname;
                document.getElementById('qzone-avatar-img').src = settings.avatar;
                document.getElementById('qzone-banner-img').src = settings.banner;
            }
        }
        window.renderQzoneScreenProxy = renderQzoneScreen;

        async function saveQzoneSettings() {
            if (db && state.qzoneSettings) {
                await db.qzoneSettings.put(state.qzoneSettings);
            }
        }

        function formatPostTimestamp(timestamp) {
            if (!timestamp) return '';
            const now = new Date();
            const date = new Date(timestamp);
            const diffSeconds = Math.floor((now - date) / 1000);
            const diffMinutes = Math.floor(diffSeconds / 60);
            const diffHours = Math.floor(diffMinutes / 60);
            if (diffMinutes < 1) return '刚刚';
            if (diffMinutes < 60) return `${diffMinutes}分钟前`;
            if (diffHours < 24) return `${diffHours}小时前`;
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            if (now.getFullYear() === year) {
                return `${month}-${day} ${hours}:${minutes}`;
            } else {
                return `${year}-${month}-${day} ${hours}:${minutes}`;
            }
        }

// ▼▼▼ 步骤3.1：用这整块【终极修复版】代码替换旧的 renderQzonePosts 函数 ▼▼▼
async function renderQzonePosts() {
    const postsListEl = document.getElementById('qzone-posts-list');
    if (!postsListEl) return;

    const [posts, favorites] = await Promise.all([
        db.qzonePosts.orderBy('timestamp').reverse().toArray(),
        db.favorites.where('type').equals('qzone_post').toArray()
    ]);

    const favoritedPostIds = new Set(favorites.map(fav => fav.content.id));
    
    postsListEl.innerHTML = '';

    if (posts.length === 0) {
        postsListEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 30px 0;">这里空空如也，快来发布第一条说说吧！</p>';
        return;
    }

    const userSettings = state.qzoneSettings;
    
// ▼▼▼ 从这里开始替换 ▼▼▼
// ★★★★★ 这就是我们这次修复的核心 ★★★★★
// 1. 在渲染所有帖子之前，我们先创建一个包含所有AI角色名字的集合(Set)，方便快速查找。
const allAiCharacterNames = new Set(Object.values(state.chats).filter(chat => !chat.isGroup).map(chat => chat.name));
// ★★★★★ 修复结束 ★★★★★

posts.forEach(post => {
    const postContainer = document.createElement('div');
    postContainer.className = 'qzone-post-container';
    postContainer.dataset.postId = post.id;

    const postEl = document.createElement('div');
    postEl.className = 'qzone-post-item';

    let authorAvatar = '', authorNickname = '', commentAvatar = userSettings.avatar; 

    if (post.authorId === 'user') {
        authorAvatar = userSettings.avatar;
        authorNickname = userSettings.nickname;
    } else if (state.chats[post.authorId]) {
        const authorChat = state.chats[post.authorId];
        authorAvatar = authorChat.settings.aiAvatar || defaultAvatar;
        authorNickname = authorChat.name;
    } else {
        authorAvatar = defaultAvatar;
        authorNickname = '{{char}}';
    }
    
    let contentHtml = '';
    const publicTextHtml = post.publicText ? `<div class="post-content">${post.publicText.replace(/\n/g, '<br>')}</div>` : '';

    if (post.type === 'shuoshuo') {
        contentHtml = `<div class="post-content" style="margin-bottom: 10px;">${post.content.replace(/\n/g, '<br>')}</div>`;
    } 
    else if (post.type === 'image_post' && post.imageUrl) {
        contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${post.imageUrl}" class="chat-image"></div>` : `<img src="${post.imageUrl}" class="chat-image">`;
    } 
    else if (post.type === 'text_image') {
        contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}"></div>` : `<img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}">`;
    }

    let likesHtml = '';
    if (post.likes && post.likes.length > 0) {
        likesHtml = `<div class="post-likes-section"><svg class="like-icon" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg><span>${post.likes.join('、')} 觉得很赞</span></div>`;
    }
    
    let commentsHtml = '';
    if (post.comments && post.comments.length > 0) {
        // ★★★★★ 这就是我们这次修复的核心 ★★★★★
        // 2. 修改这里的过滤逻辑
        const commentsToShow = post.areCommentsVisible === false 
            ? post.comments.filter(comment => 
                // 条件1: 评论者是你自己
                comment.commenterName === userSettings.nickname || 
                // 条件2: 评论者的名字在我们刚才创建的AI角色名字列表里
                allAiCharacterNames.has(comment.commenterName)
              )
            : post.comments; // 如果开关是开的，就显示所有评论
        // ★★★★★ 修复结束 ★★★★★

        if (commentsToShow.length > 0) {
// ▲▲▲ 替换到这里结束 ▲▲▲

                commentsHtml = '<div class="post-comments-container">';
                commentsToShow.forEach(comment => {
                    const originalIndex = post.comments.indexOf(comment);
                    let replyHtml = '';
                    if (comment.replyTo) {
                        replyHtml = `<span class="reply-text">回复</span> <span class="reply-target-name">${comment.replyTo}</span>`;
                    }
                    commentsHtml += `
                        <div class="comment-item" data-commenter-name="${comment.commenterName}">
                            <span class="commenter-name">${comment.commenterName}</span>${replyHtml}:
                            <span class="comment-text"> ${comment.text}</span>
                            <span class="comment-delete-btn" data-comment-index="${originalIndex}">×</span>
                        </div>`;
                });
                commentsHtml += '</div>';
            }
        }


        const commentsAndFooterHtml = `
            ${commentsHtml}
            <div class="post-footer">
                <div class="comment-section">
                    <img src="${commentAvatar}" class="comment-avatar">
                    <input type="text" class="comment-input" placeholder="友善的评论是交流的起点">
                    <div class="at-mention-popup"></div>
                </div>
                <button class="comment-send-btn">发送</button>
            </div>
        `;

        const userNickname = state.qzoneSettings.nickname;
        const isLikedByUser = post.likes && post.likes.includes(userNickname);
        const isFavoritedByUser = favoritedPostIds.has(post.id);

        postEl.innerHTML = `
            <div class="post-header"><img src="${authorAvatar}" class="post-avatar"><div class="post-info"><span class="post-nickname">${authorNickname}</span><span class="post-timestamp">${formatPostTimestamp(post.timestamp)}</span></div>
                <div class="post-actions-btn">…</div>
            </div>
            <div class="post-main-content">${contentHtml}</div>
            <div class="post-feedback-icons">
                <span class="action-icon like ${isLikedByUser ? 'active' : ''}"><svg viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg></span>
                <span class="action-icon favorite ${isFavoritedByUser ? 'active' : ''}"><svg viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path></svg></span>
                <span class="action-icon summon-npc" data-post-id="${post.id}" data-author-id="${post.authorId}" title="召唤NPC评论"><svg viewBox="0 0 24 24"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg></span>
                </div>
            ${likesHtml}
            ${commentsAndFooterHtml} 
        `;
        
        const deleteAction = document.createElement('div');
        deleteAction.className = 'qzone-post-delete-action';
        deleteAction.innerHTML = '<span>删除</span>';
        postContainer.appendChild(postEl);
        postContainer.appendChild(deleteAction);
        const commentSection = postContainer.querySelector('.comment-section');
        if (commentSection) {
            commentSection.addEventListener('touchstart', (e) => e.stopPropagation());
            commentSection.addEventListener('mousedown', (e) => e.stopPropagation());
        }
        postsListEl.appendChild(postContainer);
        const commentInput = postContainer.querySelector('.comment-input');
        if (commentInput) {
            const popup = postContainer.querySelector('.at-mention-popup');
            commentInput.addEventListener('input', () => {
                const value = commentInput.value;
                const atMatch = value.match(/@([\p{L}\w]*)$/u);
                if (atMatch) {
                    const namesToMention = new Set();
                    const authorNickname = postContainer.querySelector('.post-nickname')?.textContent;
                    if (authorNickname) namesToMention.add(authorNickname);
                    postContainer.querySelectorAll('.commenter-name').forEach(nameEl => {
                        namesToMention.add(nameEl.textContent.replace(':', ''));
                    });
                    namesToMention.delete(state.qzoneSettings.nickname);
                    popup.innerHTML = '';
                    if (namesToMention.size > 0) {
                        const searchTerm = atMatch[1];
                        namesToMention.forEach(name => {
                            if (name.toLowerCase().includes(searchTerm.toLowerCase())) {
                                const item = document.createElement('div');
                                item.className = 'at-mention-item';
                                item.textContent = name;
                                item.addEventListener('mousedown', (e) => {
                                    e.preventDefault();
                                    const newText = value.substring(0, atMatch.index) + `@${name} `;
                                    commentInput.value = newText;
                                    popup.style.display = 'none';
                                    commentInput.focus();
                                });
                                popup.appendChild(item);
                            }
                        });
                        popup.style.display = popup.children.length > 0 ? 'block' : 'none';
                    } else {
                        popup.style.display = 'none';
                    }
                } else {
                    popup.style.display = 'none';
                }
            });
            commentInput.addEventListener('blur', () => { setTimeout(() => { popup.style.display = 'none'; }, 200); });
        }
    });
}
// ▲▲▲ 步骤3.1替换结束 ▲▲▲
async function renderFollowingFeed() {
    const feedListEl = document.getElementById('weibo-following-feed-list');
    if (!feedListEl) return;

    // 1. 从数据库获取所有动态
    const allPosts = await db.qzonePosts.orderBy('timestamp').reverse().toArray();
    
    // 2. 【核心】筛选出作者不是 'user' 的动态
    const followingPosts = allPosts.filter(post => post.authorId !== 'user');

    feedListEl.innerHTML = ''; // 清空旧内容

    if (followingPosts.length === 0) {
        feedListEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 30px 0;">你关注的人还没有发布任何动态哦。</p>';
        return;
    }

    // 3. 遍历筛选后的动态，并渲染它们
    //    【提示】这里创建单个动态HTML的逻辑，可以完全复制 `renderQzonePosts` 函数里的 forEach 循环内部的代码。
    //    你只需要把目标容器从 `postsListEl` 改为 `feedListEl` 即可。
    followingPosts.forEach(post => {
        // ... 在这里粘贴 renderQzonePosts 函数中创建 postContainer、postEl 的那一大段代码 ...
        // ... 记得最后要把 postContainer append 到 feedListEl 中 ...
        // feedListEl.appendChild(postContainer);
    });
}

// ▼▼▼ 请用下面这个【更新后的】函数，完整替换掉你代码中旧的 displayFilteredFavorites 函数 ▼▼▼

function displayFilteredFavorites(items) {
    const listEl = document.getElementById('favorites-list');
    listEl.innerHTML = '';

    if (items.length === 0) {
        const searchTerm = document.getElementById('favorites-search-input').value;
        const message = searchTerm ? '未找到相关收藏' : '你的收藏夹是空的，<br>快去动态或聊天中收藏喜欢的内容吧！';
        listEl.innerHTML = `<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">${message}</p>`;
        return;
    }

    for (const item of items) {
        const card = document.createElement('div');
        card.className = 'favorite-item-card';
        card.dataset.favid = item.id;

        let headerHtml = '', contentHtml = '', sourceText = '', footerHtml = '';

        if (item.type === 'qzone_post') {
            const post = item.content;
            sourceText = '来自动态';
            let authorAvatar = defaultAvatar, authorNickname = '未知用户';

            if (post.authorId === 'user') {
                authorAvatar = state.qzoneSettings.avatar;
                authorNickname = state.qzoneSettings.nickname;
            } else if (state.chats[post.authorId]) {
                authorAvatar = state.chats[post.authorId].settings.aiAvatar;
                authorNickname = state.chats[post.authorId].name;
            }

            headerHtml = `<img src="${authorAvatar}" class="avatar"><div class="info"><div class="name">${authorNickname}</div></div>`;
            
            const publicTextHtml = post.publicText ? `<div class="post-content">${post.publicText.replace(/\n/g, '<br>')}</div>` : '';
            if (post.type === 'shuoshuo') {
                contentHtml = `<div class="post-content">${post.content.replace(/\n/g, '<br>')}</div>`;
            } else if (post.type === 'image_post' && post.imageUrl) {
                contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${post.imageUrl}" class="chat-image"></div>` : `<img src="${post.imageUrl}" class="chat-image">`;
            } else if (post.type === 'text_image') {
                contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}"></div>` : `<img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}">`;
            }

            // ▼▼▼ 新增/修改的代码开始 ▼▼▼
            
            // 1. 构造点赞区域的HTML
            let likesHtml = '';
            // 检查 post 对象中是否存在 likes 数组并且不为空
            if (post.likes && post.likes.length > 0) {
                // 如果存在，就创建点赞区域的 div
                likesHtml = `
                    <div class="post-likes-section">
                        <svg class="like-icon" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>
                        <span>${post.likes.join('、')} 觉得很赞</span>
                    </div>`;
            }

            // 2. 构造评论区域的HTML
            let commentsHtml = '';
            // 检查 post 对象中是否存在 comments 数组并且不为空
            if (post.comments && post.comments.length > 0) {
                // 如果存在，就创建评论容器，并遍历每一条评论
                commentsHtml = '<div class="post-comments-container">';
                post.comments.forEach(comment => {
                    commentsHtml += `
                        <div class="comment-item">
                            <span class="commenter-name">${comment.commenterName}:</span>
                            <span class="comment-text">${comment.text}</span>
                        </div>`;
                });
                commentsHtml += '</div>';
            }

            // 3. 将点赞和评论的HTML组合到 footerHtml 中
            footerHtml = `${likesHtml}${commentsHtml}`;
            
            // ▲▲▲ 新增/修改的代码结束 ▲▲▲

} else if (item.type === 'chat_message') {
    const msg = item.content;
    const chat = state.chats[item.chatId];
    if (!chat) continue; 

    sourceText = `来自与 ${chat.name} 的聊天`;
    const isUser = msg.role === 'user';
    let senderName, senderAvatar;

    if (isUser) {
        // 用户消息的逻辑保持不变
        senderName = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
        senderAvatar = chat.settings.myAvatar || (chat.isGroup ? defaultMyGroupAvatar : defaultAvatar);
    } else { // AI/成员消息

         if (chat.isGroup) {
            // ★★★★★ 这就是唯一的、核心的修改！ ★★★★★
            // 我们现在使用 originalName 去匹配，而不是旧的 name
            const member = chat.members.find(m => m.originalName === msg.senderName);
            // ★★★★★ 修改结束 ★★★★★
            
            senderName = msg.senderName;
            // 因为现在能正确找到 member 对象了，所以也能正确获取到他的头像
            senderAvatar = member ? member.avatar : defaultGroupMemberAvatar;
        } else {
            // 单聊的逻辑保持不变
            senderName = chat.name;
            senderAvatar = chat.settings.aiAvatar || defaultAvatar;
        }
    }

    // 后续拼接 headerHtml 和 contentHtml 的逻辑都保持不变
    headerHtml = `<img src="${senderAvatar}" class="avatar"><div class="info"><div class="name">${senderName}</div></div>`;
    
    if (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content)) {
        contentHtml = `<img src="${msg.content}" class="sticker-image" style="max-width: 80px; max-height: 80px;">`;
    } else if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
        contentHtml = `<img src="${msg.content[0].image_url.url}" class="chat-image">`;
// ▼▼▼ 请用这【一整块新代码】替换掉上面那段旧的 else { ... } 代码块 ▼▼▼
// ▼▼▼ 请用这【一整块新代码】再次替换掉 createMessageElement 函数里的 else { ... } 代码块 ▼▼▼
} else {
    const messageText = String(msg.content || '');
    // 侦测格式：[sticker:名字]
    const stickerMatch = messageText.match(/\[sticker:\s*(.+?)\s*\]/i);

    if (stickerMatch) {
        // 如果匹配成功，提取出名字
        const stickerName = stickerMatch[1].trim();
        // 【核心】在所有可能的表情库里查找（用户的、角色的专属、角色的通用）
        const allStickers = [...state.userStickers, ...state.charStickers, ...(chat.settings.stickerLibrary || [])];
        const foundSticker = allStickers.find(s => s.name === stickerName);
        
        if (foundSticker) {
            // 如果找到了，就显示图片！
            bubble.classList.add('is-sticker');
            contentHtml = `<img src="${foundSticker.url}" alt="${foundSticker.name}" class="sticker-image">`;
        } else {
            // 如果没找到（比如AI自己编了个名字），就还是按普通文字显示
            contentHtml = messageText.replace(/\n/g, '<br>');
        }
    } else {
        // 如果不匹配，就是普通的文本消息
        contentHtml = messageText.replace(/\n/g, '<br>');
    }
}
// ▲▲▲ 替换结束 ▲▲▲


}
        
        // ▼▼▼ 修改最终的HTML拼接，加入 footerHtml ▼▼▼
        card.innerHTML = `
            <div class="fav-card-header">${headerHtml}<div class="source">${sourceText}</div></div>
            <div class="fav-card-content">${contentHtml}</div>
            ${footerHtml}`; // <-- 把我们新创建的 footerHtml 放在这里
            
        listEl.appendChild(card);
    }
}

// ▲▲▲ 替换区域结束 ▲▲▲

        /**
         * 【重构后的函数】: 负责准备数据并触发渲染
         */
        async function renderFavoritesScreen() {
            // 1. 从数据库获取最新数据并缓存
            allFavoriteItems = await db.favorites.orderBy('timestamp').reverse().toArray();
            
            // 2. 清空搜索框并隐藏清除按钮
            const searchInput = document.getElementById('favorites-search-input');
            const clearBtn = document.getElementById('favorites-search-clear-btn');
            searchInput.value = '';
            clearBtn.style.display = 'none';

            // 3. 显示所有收藏项
            displayFilteredFavorites(allFavoriteItems);
        }

        // ▲▲▲ 粘贴结束 ▲▲▲

function resetCreatePostModal() {
    document.getElementById('post-public-text').value = '';
    document.getElementById('post-image-preview').src = '';
    document.getElementById('post-image-description').value = '';
    document.getElementById('post-image-preview-container').classList.remove('visible');
    document.getElementById('post-image-desc-group').style.display = 'none';
    document.getElementById('post-local-image-input').value = '';
    document.getElementById('post-hidden-text').value = '';

    // 【核心修复】我们不再模拟点击，而是直接、安全地设置状态
    const imageModeBtn = document.getElementById('switch-to-image-mode');
    const textImageModeBtn = document.getElementById('switch-to-text-image-mode');
    const imageModeContent = document.getElementById('image-mode-content');
    const textImageModeContent = document.getElementById('text-image-mode-content');
    
    imageModeBtn.classList.add('active');
    textImageModeBtn.classList.remove('active');
    imageModeContent.classList.add('active');
    textImageModeContent.classList.remove('active');
}

// ▼▼▼ 用这个【已修复】的版本，完整替换掉你旧的 exportBackup 函数 ▼▼▼
async function exportBackup() {
    try {
        const backupData = {
            version: 1, 
            timestamp: Date.now()
        };

        // --- 这部分数据库读取的代码保持不变 ---
        const [
            chats, worldBooks, userStickers, apiConfig, globalSettings,
            personaPresets, musicLibrary, qzoneSettings, qzonePosts,
            qzoneAlbums, qzonePhotos, favorites, qzoneGroups, memories,
            worldBookCategories, callRecords, customAvatarFrames, themes,
            apiPresets, bubbleStylePresets, fontPresets, homeScreenPresets
        ] = await Promise.all([
            db.chats.toArray(),
            db.worldBooks.toArray(),
            db.userStickers.toArray(),
            db.apiConfig.get('main'),
            db.globalSettings.get('main'),
            db.personaPresets.toArray(),
            db.musicLibrary.get('main'),
            db.qzoneSettings.get('main'),
            db.qzonePosts.toArray(),
            db.qzoneAlbums.toArray(),
            db.qzonePhotos.toArray(),
            db.favorites.toArray(),
            db.qzoneGroups.toArray(),
            db.memories.toArray(),
            db.worldBookCategories.toArray(),
            db.callRecords.toArray(),
            db.customAvatarFrames.toArray(),
            db.themes.toArray(),
            db.apiPresets.toArray(),
            db.bubbleStylePresets.toArray(),
            db.fontPresets.toArray(),
            db.homeScreenPresets.toArray()
        ]);

        Object.assign(backupData, {
            chats, worldBooks, userStickers, apiConfig, globalSettings,
            personaPresets, musicLibrary, qzoneSettings, qzonePosts,
            qzoneAlbums, qzonePhotos, favorites, qzoneGroups, memories,
            worldBookCategories, callRecords, customAvatarFrames, themes,
            apiPresets, bubbleStylePresets, fontPresets, homeScreenPresets
        });
        
        // --- ▼▼▼ 核心修改就在这里！▼▼▼ ---
        // 我们重构了 homeScreenState 对象，确保它能包含第一页的所有数据
        backupData.homeScreenState = {
            // --- 这是我们新增的第一页数据 ---
            'profile-banner-img': document.getElementById('profile-banner-img').src,
            'profile-avatar-img': document.getElementById('profile-avatar-img').src,
            'profile-username': document.getElementById('profile-username').textContent,
            'profile-sub-username': document.getElementById('profile-sub-username').textContent,
            'profile-bio': document.getElementById('profile-bio').textContent,
            'profile-location': document.getElementById('profile-location').innerHTML, // 使用innerHTML来保存SVG图标
            'widget-bubble-1': document.getElementById('widget-bubble-1').textContent,
            'widget-image-1': document.getElementById('widget-image-1').src, // 这是你特别提到的组件
            'widget-subtext-1': document.getElementById('widget-subtext-1').textContent,
            'widget-bubble-2': document.getElementById('widget-bubble-2').textContent,
            'widget-image-2': document.getElementById('widget-image-2').src,
            'widget-subtext-2': document.getElementById('widget-subtext-2').textContent,
            'widget-image-3': document.getElementById('widget-image-3').src,
            'second-page-bubble': document.getElementById('second-page-bubble').textContent,
            'flat-capsule-bubble': document.getElementById('flat-capsule-bubble').textContent,
            'circular-bubble': document.getElementById('circular-bubble').textContent,
            'widget-image-4': document.getElementById('widget-image-4').src,
            'avatar-subtitle': document.getElementById('avatar-subtitle').textContent,
            'bubble-top-left': document.getElementById('bubble-top-left').textContent,
            'bubble-top-right': document.getElementById('bubble-top-right').textContent,
            'bubble-bottom-left': document.getElementById('bubble-bottom-left').textContent,
            'bubble-bottom-right': document.getElementById('bubble-bottom-right').textContent,
            'new-widget-avatar': document.getElementById('new-widget-avatar').src,
            'new-widget-text-1': document.getElementById('new-widget-text-1').textContent,
            'new-widget-text-2': document.getElementById('new-widget-text-2').textContent,
            'new-widget-text-3': document.getElementById('new-widget-text-3').textContent,
            'widget-month-display': document.getElementById('widget-month-display').textContent,
            'appIcons': { ...state.globalSettings.appIcons },
            'lockscreenWallpaper': state.globalSettings.lockscreenWallpaper,
            'wallpaper': state.globalSettings.wallpaper
        };
        // --- ▲▲▲ 修改结束 ▲▲▲ ---

        // 后续的下载逻辑保持不变
        const blob = new Blob(
            [JSON.stringify(backupData, null, 2)], 
            { type: 'application/json' }
        );
        const url = URL.createObjectURL(blob);
        const link = Object.assign(document.createElement('a'), {
            href: url,
            download: `EPhone-Full-Backup-${new Date().toISOString().split('T')[0]}.json`
        });
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        
        await showCustomAlert('导出成功', '已成功导出所有数据！');

    } catch (error) {
        console.error("导出数据时出错:", error);
        await showCustomAlert('导出失败', `发生了一个错误: ${error.message}`);
    }
}




// ▼▼▼ 请用这【一整块终极修复版】的代码，完整替换掉你旧的 importBackup 函数 ▼▼▼
async function importBackup(file) {
    if (!file) return;

    const confirmed = await showCustomConfirm(
        '严重警告！',
        '导入备份将完全覆盖您当前的所有数据，包括聊天、设置等。此操作不可撤销！您确定要继续吗？',
        { confirmButtonClass: 'btn-danger' }
    );

    if (!confirmed) return;

    try {
        const text = await file.text();
        const data = JSON.parse(text);

        await db.transaction('rw', db.tables, async () => {
            // 1. 清空所有现有表格
            for (const table of db.tables) {
                await table.clear();
            }

            // 2. 【核心修复】智能、安全地导入数据
            // 我们会检查备份文件中的每一项数据，只有当当前代码的数据库里也存在对应的表格时，才进行导入
            
            // 导入数组类型的数据
            const arrayTables = [
                'chats', 'worldBooks', 'worldBookCategories', 'userStickers', 
                'personaPresets', 'qzonePosts', 'qzoneAlbums', 'qzonePhotos', 
                'favorites', 'qzoneGroups', 'memories', 'callRecords', 
                'customAvatarFrames', 'themes', 'apiPresets', 'bubbleStylePresets',
                // 就算备份文件里有下面这些新版才有的数据，这段代码也能安全跳过
                'fontPresets', 'homeScreenPresets' 
            ];

// ▼▼▼ 【全新】世界书格式兼容转换代码 ▼▼▼
for (const tableName of arrayTables) {
    if (Array.isArray(data[tableName]) && db[tableName]) {
        let itemsToPut = data[tableName];

        // 【核心逻辑】当处理世界书表格时，执行特别的转换操作
        if (tableName === 'worldBooks') {
            console.log("正在检查并转换世界书数据格式以兼容...");
            itemsToPut.forEach(book => {
                // 如果 content 是数组 (别人的格式)，则将其转换为字符串 (我的格式)
                if (Array.isArray(book.content)) {
                    console.log(`检测到数组格式的世界书: "${book.name}"，正在转换为字符串...`);
                    
                    // 将数组中的每个条目对象转换为格式化的字符串
                    const convertedEntries = book.content.map(entry => {
                        const stringParts = [];
                        if (entry.comment) {
                            stringParts.push(`[备注: ${entry.comment}]`);
                        }
                        if (entry.keys && entry.keys.length > 0) {
                            stringParts.push(`[关键词: ${entry.keys.join(', ')}]`);
                        }
                        stringParts.push(entry.content); // 条目主要内容
                        return stringParts.join('\n'); // 每个条目的内部用换行分隔
                    });
                    
                    // 将所有转换后的条目字符串用一个明显的分隔符连接起来
                    book.content = convertedEntries.join('\n\n---\n\n');
                }
            });
        }
        
        // 过滤并保存数据 (这部分逻辑保持不变)
        const validItems = itemsToPut.filter(item => item && (typeof item.id === 'undefined' || typeof item.id === 'string' || typeof item.id === 'number'));
        if (validItems.length > 0) {
            console.log(`正在导入 ${validItems.length} 条数据到表格: ${tableName}...`);
            await db[tableName].bulkPut(validItems);
        }

    } else {
        console.log(`跳过导入: ${tableName} (在备份文件或当前数据库中不存在)`);
    }
}
// ▲▲▲ 代码粘贴结束 ▲▲▲

            
            // 导入对象类型的数据（通常是设置）
            const objectTables = ['apiConfig', 'globalSettings', 'musicLibrary', 'qzoneSettings'];
            for (const tableName of objectTables) {
                if (data[tableName] && db[tableName]) {
                    console.log(`正在导入设置: ${tableName}...`);
                    await db[tableName].put(data[tableName]);
                }
            }
        });

        // 导入主屏幕样式的逻辑保持不变，因为它不直接操作数据库的多个表
        if (data.homeScreenState) {
            const settings = await db.globalSettings.get('main') || { id: 'main' };
            settings.widgetData = data.homeScreenState;
            if (data.homeScreenState.wallpaper) settings.wallpaper = data.homeScreenState.wallpaper;
            if (data.homeScreenState.lockscreenWallpaper) settings.lockscreenWallpaper = data.homeScreenState.lockscreenWallpaper;
            if (data.homeScreenState.appIcons) settings.appIcons = data.homeScreenState.appIcons;
            await db.globalSettings.put(settings);
            console.log("已成功导入主屏幕样式数据。");
        }


        await showCustomAlert('导入成功', '所有数据已成功恢复！应用即将刷新以应用所有更改。');
        
        setTimeout(() => {
            window.location.reload();
        }, 1500);

    } catch (error) {
        console.error("导入数据时出错:", error);
        await showCustomAlert('导入失败', `文件格式不正确或数据已损坏: ${error.message}`);
    }
}

function applyCustomFont(fontUrl, isPreviewOnly = false) {
    if (!fontUrl) {
        // 如果没有提供字体链接（比如恢复默认），就清空样式
        dynamicFontStyle.innerHTML = '';
        document.getElementById('font-preview').style.fontFamily = '';
        return;
    }

    // 这是一个统一的内部名字
    const fontName = 'custom-user-font';
    
    // 这是定义字体的样式规则
    const newStyle = `
        @font-face {
          font-family: '${fontName}';
          src: url('${fontUrl}');
          font-display: swap;
        }`;

    if (isPreviewOnly) {
        // 如果只是预览，这个逻辑保持不变
        const previewStyle = document.getElementById('preview-font-style') || document.createElement('style');
        previewStyle.id = 'preview-font-style';
        previewStyle.innerHTML = newStyle;
        if (!document.getElementById('preview-font-style')) document.head.appendChild(previewStyle);
        document.getElementById('font-preview').style.fontFamily = `'${fontName}', 'bulangni', sans-serif`;
    } else {
        // 【核心】如果是全局应用，就同时定义字体并告诉整个 body 去使用它
        dynamicFontStyle.innerHTML = `
            ${newStyle}
            body {
              font-family: '${fontName}', 'bulangni', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif !important;
            }`;
    }
}


        async function resetToDefaultFont() {
            // 1. 清除全局字体样式
            dynamicFontStyle.innerHTML = ''; 
            
            // 2. 更新并保存设置
            state.globalSettings.fontUrl = '';
            await db.globalSettings.put(state.globalSettings);
            
            // 3. 【核心修复】明确地将全局预览区的字体也恢复为默认
            const globalPreview = document.getElementById('font-preview');
            globalPreview.style.fontFamily = ''; // 移除内联样式
            
            // 4. 应用一下空的字体设置，确保所有地方都恢复
            applyCustomFont('', true);
            
            alert('已恢复默认字体。');
        }



async function loadAllDataFromDB() {
    // 【核心修改】我们把 Promise.all 的内容扩充了
    const [
        chatsArr,
        apiConfig,
        globalSettings,
        userStickers,
        charStickers,
        worldBooks,
        musicLib,
        personaPresets,
        qzoneSettings,
        initialFavorites,
        apiPresets,
        bubbleStylePresets,
        datingScenes // <--- 在这里新增
    ] = await Promise.all([
        db.chats.toArray(),
        db.apiConfig.get('main'),
        db.globalSettings.get('main'),
        db.userStickers.toArray(),
        db.charStickers.toArray(),
        db.worldBooks.toArray(),
        db.musicLibrary.get('main'),
        db.personaPresets.toArray(),
        db.qzoneSettings.get('main'),
        db.favorites.orderBy('timestamp').reverse().toArray(),
        db.apiPresets.toArray(),
        db.bubbleStylePresets.toArray(),
        db.datingScenes.toArray() // <--- 在这里新增
    ]);

    state.chats = chatsArr.reduce((acc, chat) => {
            // 【全新】为旧的群聊数据兼容专属表情库
        if (chat.isGroup && (!chat.settings || !chat.settings.stickerLibrary)) {
            if (!chat.settings) chat.settings = {}; // 以防万一连settings都没有
            chat.settings.stickerLibrary = [];
            console.log(`为旧群聊 "${chat.name}" 补全了专属表情库(stickerLibrary)属性。`);
        }
            // 兼容旧数据：为没有专属表情库的角色添加一个空的表情库
        if (!chat.isGroup && (!chat.settings || !chat.settings.stickerLibrary)) {
            if (!chat.settings) chat.settings = {}; // 以防万一连settings都没有
            chat.settings.stickerLibrary = [];
            console.log(`为旧角色 "${chat.name}" 补全了专属表情库(stickerLibrary)属性。`);
        }
        // ▲▲▲ 修改结束 ▲▲▲

    if (typeof chat.unreadCount === 'undefined') {
        chat.unreadCount = 0; // 如果这个聊天对象没有 unreadCount 属性，就给它初始化为 0
    }
    // ▼▼▼ 在这里粘贴下面的“数据迁移”代码 ▼▼▼
// ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼
// 兼容旧数据：为没有心声背景的角色添加一个空字符串
if (typeof chat.innerVoiceBackground === 'undefined') {
    chat.innerVoiceBackground = '';
}
// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ★★★ 这就是本次新增的兼容性代码！ ★★★
if (chat.settings && typeof chat.settings.innerVoiceAdopterLabelFormat === 'undefined') {
    chat.settings.innerVoiceAdopterLabelFormat = '领养人: {{user}}';
}
// ★★★ 新增结束 ★★★
        // ★★★【核心重构：数据迁移脚本】★★★
        // 检查是否是群聊，并且其成员对象使用的是旧的 `name` 结构
        if (chat.isGroup && chat.members && chat.members.length > 0 && chat.members[0].name) {
            console.log(`检测到旧版群聊数据 for "${chat.name}"，正在执行迁移...`);
            chat.members.forEach(member => {
                // 如果这个成员对象没有 originalName，说明是旧数据
                if (typeof member.originalName === 'undefined') {
                    member.originalName = member.name; // 将旧的 name 作为 originalName
                    member.groupNickname = member.name; // 同时创建一个初始的 groupNickname
                    delete member.name; // 删除旧的、有歧义的 name 字段
                    needsUpdate = true; // 标记需要存回数据库
                }
            });
             console.log(`迁移完成 for "${chat.name}"`);
        }

        // --- ▼▼▼ 核心修复就在这里 ▼▼▼ ---
        // 检查1：如果是一个单聊，并且没有 status 属性
        if (!chat.isGroup && !chat.status) {
            // 就为它补上一个默认的 status 对象
            chat.status = {
                text: '在线',
                lastUpdate: Date.now(),
                isBusy: false
            };
            console.log(`为旧角色 "${chat.name}" 补全了status属性。`);
        }
        // --- ▲▲▲ 修复结束 ▲▲▲

        // --- ▼▼▼ 核心修复就在这里 ▼▼▼ ---
        // 检查2：兼容最新的“关系”功能
        if (!chat.isGroup && !chat.relationship) {
            // 如果是单聊，且没有 relationship 对象，就补上一个默认的
            chat.relationship = {
                status: 'friend',
                blockedTimestamp: null,
                applicationReason: ''
            };
            console.log(`为旧角色 "${chat.name}" 补全了 relationship 属性。`);
        }
        // --- ▲▲▲ 修复结束 ▲▲▲

    // ▼▼▼ 在这里添加 ▼▼▼
    if (!chat.isGroup && (!chat.settings || !chat.settings.aiAvatarLibrary)) {
        if (!chat.settings) chat.settings = {}; // 以防万一连settings都没有
        chat.settings.aiAvatarLibrary = [];
        console.log(`为旧角色 "${chat.name}" 补全了aiAvatarLibrary属性。`);
    }
    // ▲▲▲ 添加结束 ▲▲▲
    // ▼▼▼ 在这里粘贴新代码 ▼▼▼
// 兼容旧数据：为没有总结设置的聊天添加默认值
if (!chat.settings.summary) {
    chat.settings.summary = {
        enabled: false,
        mode: 'auto',
        count: 20,
        prompt: '请你以第三人称的视角，客观、冷静、不带任何感情色彩地总结以下对话的核心事件和信息。禁止进行任何角色扮演或添加主观评论。',
        lastSummaryIndex: -1 // -1表示从未总结过
    };
}
// ▲▲▲ 新代码粘贴结束 ▲▲▲

    // 兼容旧数据：为没有NPC库的单聊角色添加空的NPC库
    if (!chat.isGroup && !chat.npcLibrary) {
        chat.npcLibrary = [];
        console.log(`为旧角色 "${chat.name}" 补全了 npcLibrary 属性。`);
    }
    // ▲▲▲ 粘贴结束 ▲▲▲
// ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼
// 兼容旧数据：为没有微博设置的单聊角色添加空的微博设置
if (!chat.isGroup && (!chat.settings.weiboProfession || typeof chat.settings.weiboInstruction === 'undefined')) {
    chat.settings.weiboProfession = '';
    chat.settings.weiboInstruction = '';
    console.log(`为旧角色 "${chat.name}" 补全了微博设置属性。`);
}
// ▲▲▲ 粘贴结束 ▲▲▲

        if (!chat.musicData) chat.musicData = { totalTime: 0 };
        if (chat.settings && chat.settings.linkedWorldBookId && !chat.settings.linkedWorldBookIds) {
            chat.settings.linkedWorldBookIds = [chat.settings.linkedWorldBookId];
            delete chat.settings.linkedWorldBookId;
        }

    // 兼容旧数据，为没有 isPinned 属性的聊天添加默认值
    if (typeof chat.isPinned === 'undefined') {
        chat.isPinned = false;
    }

// ▼▼▼ 【V2最终修复版】统一修复并初始化所有角色的手机数据 ▼▼▼
if (!chat.isGroup) {
    // 第一步：确保最外层的 characterPhoneData 对象存在
    if (!chat.characterPhoneData) {
        chat.characterPhoneData = {}; // 如果不存在，就创建一个空的
    }

    // 第二步：逐一检查并补全所有APP的数据结构
    // 这样无论角色多老，都能确保所有字段都存在
    if (!chat.characterPhoneData.widgets) chat.characterPhoneData.widgets = {};
    if (!chat.characterPhoneData.lastGenerated) chat.characterPhoneData.lastGenerated = null;
    if (!chat.characterPhoneData.chats) chat.characterPhoneData.chats = {};
    if (!chat.characterPhoneData.shoppingCart) chat.characterPhoneData.shoppingCart = [];
    if (!chat.characterPhoneData.memos) chat.characterPhoneData.memos = [];
    if (!chat.characterPhoneData.browserHistory) chat.characterPhoneData.browserHistory = [];
    if (!chat.characterPhoneData.photoAlbum) chat.characterPhoneData.photoAlbum = [];
    if (!chat.characterPhoneData.bank) chat.characterPhoneData.bank = { balance: 0, transactions: [] };
    if (!chat.characterPhoneData.trajectory) chat.characterPhoneData.trajectory = [];
    if (!chat.characterPhoneData.appUsage) chat.characterPhoneData.appUsage = [];
    if (!chat.characterPhoneData.diary) chat.characterPhoneData.diary = []; // 核心修复！
     if (!chat.characterPhoneData.appWallpaper) {
        chat.characterPhoneData.appWallpaper = '';
    }
}
// ▲▲▲ 修正结束 ▲▲▲
// 兼容旧数据，为没有后台活动设置的群聊添加默认值
if (chat.isGroup && (!chat.settings || typeof chat.settings.backgroundActivity === 'undefined')) {
    if (!chat.settings) chat.settings = {}; // 以防万一连settings都没有
    chat.settings.backgroundActivity = {
        enabled: false,
        interval: 120, // 默认120秒
        lastActivityTimestamp: 0
    };
}
// ▼▼▼ Part B: 在这里粘贴兼容旧数据的代码 ▼▼▼
// 兼容旧数据：为没有情侣头像设置的角色添加默认值
if (typeof chat.settings.isCoupleAvatar === 'undefined') {
    chat.settings.isCoupleAvatar = false;
    chat.settings.coupleAvatarDescription = '';
}
// ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼

// ▼▼▼ 【领养系统改造】宠物系统初始化/兼容代码 ▼▼▼

// 1. 为所有角色（包括新旧数据）确保有 petAdopted 标志
if (!chat.isGroup && typeof chat.settings.petAdopted === 'undefined') {
    // 如果 pet 对象已存在，说明是老用户，默认已领养
    if (chat.settings.pet && chat.settings.pet.type !== '无') {
        chat.settings.petAdopted = true;
    } else {
        // 如果没有 pet 对象，说明是新用户或之前就没用宠物，默认未领养
        chat.settings.petAdopted = false;
    }
    console.log(`为角色 "${chat.name}" 初始化了宠物领养状态: ${chat.settings.petAdopted}`);
}

// 2. 兼容旧的 pet 对象，确保新字段存在（这段代码和之前一样，保留即可）
if (!chat.isGroup && chat.settings.pet) {
    if (typeof chat.settings.pet.persona === 'undefined') {
        chat.settings.pet.persona = '一只可爱的小宠物，对世界充满好奇。';
    }
    if (!chat.settings.pet.petChatHistory) {
        chat.settings.pet.petChatHistory = [];
    }
    if (!chat.settings.pet.status) {
        chat.settings.pet.status = { 
            hunger: 100, 
            happiness: 100, 
            intimacyToUser: 50, 
            intimacyToChar: 50,
            lastUpdated: Date.now()
        };
    } else {
        if (typeof chat.settings.pet.status.intimacyToUser === 'undefined') chat.settings.pet.status.intimacyToUser = 50;
        if (typeof chat.settings.pet.status.intimacyToChar === 'undefined') chat.settings.pet.status.intimacyToChar = 50;
        if (typeof chat.settings.pet.status.lastUpdated === 'undefined') chat.settings.pet.status.lastUpdated = Date.now();
    }
}
// ▲▲▲ 改造结束 ▲▲▲
        // 兼容旧数据：为没有记忆互通设置的聊天添加一个空的数组
        if (!chat.settings.linkedMemories) {
            chat.settings.linkedMemories = [];
        }
            // ▼▼▼ 在这里新增下面这段代码，以兼容旧数据 ▼▼▼
    // 为旧数据添加默认的记忆条数设置
    if (typeof chat.settings.linkMemoryDepth === 'undefined') {
        chat.settings.linkMemoryDepth = 5;
    }
    // ▲▲▲ 新增结束 ▲▲▲
              // ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼
        // 兼容线下模式设置
        if (!chat.settings.offlineMode) {
            chat.settings.offlineMode = {
                enabled: false,
                prompt: '',
                style: '',
                wordCount: 300,
                presets: []
            };
        }
        // ▲▲▲ 新代码粘贴结束 ▲▲▲  
        
        // ▼▼▼ 【全新】在这里添加对角色手机外观设置的兼容代码 ▼▼▼
        if (!chat.isGroup) { // 只为单聊角色添加
            if (!chat.characterPhoneData) {
                chat.characterPhoneData = {}; // 以防万一连 characterPhoneData 都没有
            }
            if (!chat.characterPhoneData.wallpaper) {
                chat.characterPhoneData.wallpaper = ''; // 初始化壁纸为空
            }
            if (!chat.characterPhoneData.appIcons) {
                chat.characterPhoneData.appIcons = {}; // 初始化App图标为空对象
            }
        }
        // ▲▲▲ 兼容代码添加结束 ▲▲▲
        // 【全新】为旧角色数据兼容微博独立设置
if (!chat.isGroup) {
    if (!chat.settings.weiboNickname) {
        chat.settings.weiboNickname = chat.name; // 默认使用角色名作为微博昵称
    }
    if (!chat.settings.weiboAvatar) {
        chat.settings.weiboAvatar = chat.settings.aiAvatar; // 默认使用AI头像
    }
    if (!chat.settings.weiboAvatarFrame) {
        chat.settings.weiboAvatarFrame = chat.settings.aiAvatarFrame || ''; // 默认使用AI头像框
    }
    if (!chat.settings.weiboBackground) {
        chat.settings.weiboBackground = 'https://i.postimg.cc/mk93Y3j1/weibo-bg-default.jpg'; // 给一个默认背景
    }
    // weiboProfession 和 weiboInstruction 之前已经兼容过了，这里不用重复
}
        // 兼容旧数据：为没有微博设置的单聊角色添加空的微博设置
        if (!chat.isGroup && (!chat.settings.weiboProfession || typeof chat.settings.weiboInstruction === 'undefined')) {
            chat.settings.weiboProfession = '';
            chat.settings.weiboInstruction = '';
            console.log(`为旧角色 "${chat.name}" 补全了微博设置属性。`);
        }
        
        // ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼
        // 【全新】为旧角色数据兼容微博粉丝/关注数
        if (!chat.isGroup && (typeof chat.settings.weiboFansCount === 'undefined' || typeof chat.settings.weiboFollowingCount === 'undefined')) {
            const initialStats = getInitialWeiboStats(chat);
            chat.settings.weiboFansCount = initialStats.fans;
            chat.settings.weiboFollowingCount = initialStats.following;
            console.log(`为旧角色 "${chat.name}" 初始化了微博数据。`);
        }
        // ▲▲▲ 新代码粘贴结束 ▲▲▲
    // ▼▼▼ 在这个循环的末尾，acc[chat.id] = chat; 之前，添加下面这段代码 ▼▼▼
    if (!chat.isGroup && (!chat.settings || typeof chat.settings.minimaxVoiceId === 'undefined')) {
        if (!chat.settings) chat.settings = {};
        chat.settings.minimaxVoiceId = ''; // 默认为空
        console.log(`为旧角色 "${chat.name}" 补全了 minimaxVoiceId 属性。`);
    }
    // ▲▲▲ 添加结束 ▲▲▲
// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼
// ▼▼▼ 用这块【增强版】代码，替换你旧的“火花”兼容代码 ▼▼▼
// 兼容旧数据：为没有火花设置的聊天添加默认值
if (!chat.settings.streak) {
    chat.settings.streak = {
        enabled: false,
        initialDays: 0,           // 【新】用户填写的初始天数
        currentDays: 0,           // 当前的火花天数
        extinguishThreshold: 1,   // 【新】熄灭阈值，默认1天
        lastInteractionDate: null // 上次互动日期
    };
    console.log(`为角色 "${chat.name}" 补全了增强版火花(streak)设置。`);
} else if (typeof chat.settings.streak.extinguishThreshold === 'undefined') {
    // 兼容你上个版本的数据，为它们也加上熄灭阈值
    chat.settings.streak.extinguishThreshold = 1; 
    console.log(`为角色 "${chat.name}" 的旧火花设置添加了熄灭阈值。`);
}
// ▲▲▲ 替换结束 ▲▲▲
// 兼容旧的群聊数据，为它们添加群主、管理员和头衔属性
if (chat.isGroup) {
  if (typeof chat.settings.groupAnnouncement === 'undefined') {
    chat.settings.groupAnnouncement = '';
}
// ▲▲▲ 新代码粘贴结束 ▲▲▲
    // 如果没有ownerId，则默认创建者（也就是你）为群主
    if (!chat.ownerId) {
        chat.ownerId = 'user'; // 我们假设用户的ID为 'user'
    }
    // 遍历所有成员，为他们添加新属性
    if (chat.members && Array.isArray(chat.members)) {
        chat.members.forEach(member => {
            if (typeof member.isAdmin === 'undefined') {
                member.isAdmin = false; // 默认不是管理员
            }
            if (typeof member.groupTitle === 'undefined') {
                member.groupTitle = ''; // 默认没有头衔
            }
        });
    }
    // 【新增】为用户自己也添加管理员和头衔的默认属性
    if (chat.settings) {
        if (typeof chat.settings.isUserAdmin === 'undefined') {
            chat.settings.isUserAdmin = false;
        }
        if (typeof chat.settings.myGroupTitle === 'undefined') {
            chat.settings.myGroupTitle = '';
        }
    }
}

// ▲▲▲ 粘贴结束 ▲▲▲
// 在 loadAllDataFromDB 函数的 forEach 循环内，acc[chat.id] = chat; 之前添加：

// 【全新】为旧数据兼容心声面板样式设置
if (!chat.settings.innerVoiceStyles) {
    chat.settings.innerVoiceStyles = {
        clothingColor: '#f0a1a8',
        behaviorColor: '#81c784',
        thoughtsColor: '#64b5f6',
        naughtyColor: '#ba68c8',
        cardBgColor: '#ffffff',
        cardOpacity: 0.7
    };
}
// 为旧数据兼容图标颜色设置
if (chat.settings.innerVoiceStyles && typeof chat.settings.innerVoiceStyles.iconColor === 'undefined') {
    chat.settings.innerVoiceStyles.iconColor = '#ff8a80'; // 默认粉红色
}
// ▲▲▲ 新代码粘贴结束 ▲▲▲
        // ▲▲▲ 新代码粘贴结束 ▲▲▲
        acc[chat.id] = chat;
        return acc;
    }, {});
// ▼▼▼ 请用这段新代码替换旧的 state.apiConfig 初始化代码 ▼▼▼
    state.apiConfig = apiConfig || { 
        id: 'main', 
        proxyUrl: '', 
        apiKey: '', 
        model: '',
        temperature: 0.8, // 新增：为温度设置一个默认值 0.8
        minimaxGroupId: '',
        minimaxApiKey: '',
        minimaxSpeechModel: 'speech-01' 
    };
    // 兼容旧数据，如果加载的设置里没有温度，也给一个默认值
    if (typeof state.apiConfig.temperature === 'undefined') {
        state.apiConfig.temperature = 0.8;
    }
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 步骤 3.1：在 loadAllDataFromDB 函数中，找到并【替换】这行代码 ▼▼▼

state.globalSettings = globalSettings || { 
    id: 'main', 
    ringtoneUrl: 'https://files.catbox.moe/3w7gla.mp3',
    notificationSoundUrl: 'https://files.catbox.moe/k369mf.mp3', // <-- 在这里新增这一行
    widgetData: {}, 
    wallpaper: 'linear-gradient(135deg, #89f7fe, #66a6ff)', 
    lockscreenWallpaper: 'linear-gradient(135deg, #764ba2, #667eea)',
    password: '',
    fontUrl: '', 
    enableBackgroundActivity: false, 
    backgroundActivityInterval: 60,
    blockCooldownHours: 1,
    appIcons: { ...DEFAULT_APP_ICONS },
    appLabels: {},
    ringtoneUrl: 'https://files.catbox.moe/3w7gla.mp3',
    notificationSoundUrl: 'https://files.catbox.moe/k369mf.mp3', 
    widgetData: {}, // 【核心修改】在这里新增一个空对象，用来存放你的自定义内容
// 在 state.globalSettings 的初始化对象里添加：
homeAvatarFrame: '', // 为主屏幕头像框添加默认空值

    globalChatBackground: '',
    homeIconWidgetTextColor: '#FFFFFF', // <-- 修改这里的名字
    userBalance: 520,
  // ▼▼▼ 在这里粘贴新代码 ▼▼▼
    homeAvatarFrame: '' // 为主屏幕头像框添加默认空值
    // ▲▲▲ 新代码粘贴结束 ▲▲▲
};
// 确保即使从旧数据库加载，这个属性也存在
if (!state.globalSettings.widgetData) {
    state.globalSettings.widgetData = {};
}
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 在这里粘贴下面这段新代码 (或者修改你已有的) ▼▼▼
if (!state.globalSettings.homeIconWidgetTextColor) { // <-- 修改这里的名字
    state.globalSettings.homeIconWidgetTextColor = '#FFFFFF';
}
// 【全新】兼容字体阴影设置
if (typeof state.globalSettings.removeHomeFontShadow === 'undefined') {
    state.globalSettings.removeHomeFontShadow = false;
}
// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 【全新】在这里粘贴下面的兼容性代码 ▼▼▼
// 兼容旧数据：如果加载的设置里没有appLabels，就给它一个空对象
if (!state.globalSettings.appLabels) {
    state.globalSettings.appLabels = {};
}
// ▲▲▲ 新代码粘贴结束 ▲▲▲

    // ▼▼▼ 在这里添加下面这行代码 ▼▼▼
    // 【核心新增】加载歌词栏设置，如果不存在则使用默认值
    lyricsBarSettings = state.globalSettings.lyricsBarSettings || lyricsBarSettings;
    // ▲▲▲ 添加结束 ▲▲▲

// 【核心修改】合并已保存的图标和默认图标，防止更新后旧数据丢失新图标
state.globalSettings.appIcons = { ...DEFAULT_APP_ICONS, ...(state.globalSettings.appIcons || {}) };

    state.userStickers = userStickers || [];
    state.charStickers = charStickers || []; 
    state.worldBooks = worldBooks || [];
    currentDatingScenes = datingScenes || [];
    musicState.playlist = musicLib?.playlist || [];
    state.personaPresets = personaPresets || [];
state.apiPresets = apiPresets || [];
state.bubbleStylePresets = bubbleStylePresets || [];
// ▼▼▼ 在 loadAllDataFromDB 函数里，用下面这整块代码替换旧的 qzoneSettings 初始化代码 ▼▼▼

// ▼▼▼ 用这块【带有微博用户设定】的代码替换 ▼▼▼
state.qzoneSettings = qzoneSettings || { 
    id: 'main', 
    nickname: '{{user}}', 
    avatar: 'https://files.catbox.moe/q6z5fc.jpeg', 
    banner: 'https://files.catbox.moe/r5heyt.gif',
    weiboAvatar: 'https://files.catbox.moe/q6z5fc.jpeg',
    weiboNickname: '你的昵称',
    weiboFansCount: '0',
    weiboBackground: 'https://i.postimg.cc/mk93Y3j1/weibo-bg-default.jpg',
    // 【核心新增】在这里为微博用户添加专属的职业和人设字段！
    weiboUserProfession: '点击设置职业', 
    weiboUserPersona: '一个普通的微博用户。',
    weiboUserPersonaPresets: []
};
// 兼容旧数据，如果加载进来的数据没有这些新字段，就补上默认值
if (!state.qzoneSettings.weiboAvatar) state.qzoneSettings.weiboAvatar = state.qzoneSettings.avatar || 'https://files.catbox.moe/q6z5fc.jpeg';
if (!state.qzoneSettings.weiboNickname) state.qzoneSettings.weiboNickname = state.qzoneSettings.nickname || '你的昵称';
if (!state.qzoneSettings.weiboFansCount) state.qzoneSettings.weiboFansCount = '0';
if (!state.qzoneSettings.weiboBackground) state.qzoneSettings.weiboBackground = 'https://i.postimg.cc/mk93Y3j1/weibo-bg-default.jpg';
// 【核心新增】兼容旧的用户微博设定
if (!state.qzoneSettings.weiboUserProfession) state.qzoneSettings.weiboUserProfession = '点击设置职业';
if (!state.qzoneSettings.weiboUserPersona) state.qzoneSettings.weiboUserPersona = '一个普通的微博用户。';
if (!state.qzoneSettings.weiboUserPersonaPresets) state.qzoneSettings.weiboUserPersonaPresets = [];
// ▼▼▼ 在这里粘贴新代码 ▼▼▼
if (!state.qzoneSettings.weiboAvatarFrame) state.qzoneSettings.weiboAvatarFrame = '';
// ▲▲▲ 粘贴结束 ▲▲▲

// ▲▲▲ 替换结束 ▲▲▲

    // ▼▼▼ 【确保这一行在 Promise.all 之后，并使用解构赋值得到的 initialFavorites】 ▼▼▼
    allFavoriteItems = initialFavorites || [];
    // ▲▲▲ 【修改结束】 ▲▲▲

// 在 loadAllDataFromDB 函数末尾，init(); 调用之前添加
if (typeof state.globalSettings.notificationSoundUrl === 'undefined') {
    state.globalSettings.notificationSoundUrl = 'https://files.catbox.moe/k369mf.mp3';
}


}

        // ▼▼▼ 【全新 | 支持临时歌曲】请用这个新版本替换旧的 saveGlobalPlaylist 函数 ▼▼▼
async function saveGlobalPlaylist() {
    // 1. 在保存前，先从当前播放列表中过滤掉所有被标记为 isTemporary 的歌曲
    const permanentPlaylist = musicState.playlist.filter(track => !track.isTemporary);
    
    // 2. 只将这个“永久播放列表”保存到数据库中
    await db.musicLibrary.put({ id: 'main', playlist: permanentPlaylist });
    console.log("已将永久播放列表保存到数据库。");
}
// ▲▲▲ 替换结束 ▲▲▲

        function formatTimestamp(timestamp) { if (!timestamp) return ''; const date = new Date(timestamp); const hours = String(date.getHours()).padStart(2, '0'); const minutes = String(date.getMinutes()).padStart(2, '0'); return `${hours}:${minutes}`; }

        function showNotification(chatId, messageContent) { playNotificationSound();clearTimeout(notificationTimeout); const chat = state.chats[chatId]; if (!chat) return; const bar = document.getElementById('notification-bar'); document.getElementById('notification-avatar').src = chat.settings.aiAvatar || chat.settings.groupAvatar || defaultAvatar; document.getElementById('notification-content').querySelector('.name').textContent = chat.name; document.getElementById('notification-content').querySelector('.message').textContent = messageContent; const newBar = bar.cloneNode(true); bar.parentNode.replaceChild(newBar, bar); newBar.addEventListener('click', () => { openChat(chatId); newBar.classList.remove('visible'); }); newBar.classList.add('visible'); notificationTimeout = setTimeout(() => { newBar.classList.remove('visible'); }, 4000); }

      // ▼▼▼ 步骤 1.1：用下面这【一整块】代码，完整替换掉旧的 updateClock 函数 ▼▼▼
/* ▼▼▼ 步骤 1：将这一整块全新的功能函数，粘贴到您的JS代码的功能函数定义区 ▼▼▼ */

/**
 * 【全新添加】显示一个包含多个选项的操作菜单模态框
 * 这是让图片编辑时能够选择“本地上传”或“URL”的关键函数！
 * @param {string} title - 模态框的标题
 * @param {Array<object>} options - 按钮选项数组, e.g., [{ text: '按钮文字', value: '返回值' }]
 * @returns {Promise<string|null>} - 返回用户点击按钮的value，如果取消则返回null
 */
function showChoiceModal(title, options) {
    return new Promise(resolve => {
        // 复用你现有的自定义模态框
        const modal = document.getElementById('preset-actions-modal');
        const footer = modal.querySelector('.custom-modal-footer');
        
        // 清空旧按钮并动态创建新按钮
        footer.innerHTML = ''; 

        options.forEach(option => {
            const button = document.createElement('button');
            button.textContent = option.text;
            button.onclick = () => {
                modal.classList.remove('visible');
                resolve(option.value); // 返回被点击按钮的值
            };
            footer.appendChild(button);
        });

        // 添加一个标准的取消按钮
        const cancelButton = document.createElement('button');
        cancelButton.textContent = '取消';
        cancelButton.style.marginTop = '8px';
        cancelButton.style.borderRadius = '8px';
        cancelButton.style.backgroundColor = '#f0f0f0';
        cancelButton.onclick = () => {
            modal.classList.remove('visible');
            resolve(null); // 用户取消，返回 null
        };
        footer.appendChild(cancelButton);

        modal.classList.add('visible');
    });
}
// ▼▼▼ 【最终正确版】请用这整块代码，完整替换旧的 deleteExpiredSearchedSongs 函数 ▼▼▼

/**
 * 【全新重构】检查并删除所有失效的API歌曲
 * 核心逻辑：不再依赖任何标签，直接根据链接特征识别需要检查的歌曲。
 */
async function deleteExpiredSearchedSongs() {
    await showCustomAlert("请稍候...", "正在检查播放列表中所有在线歌曲的有效性...");

    // 1. 【核心改变】我们不再寻找 isTemporary 标签！
    // 而是直接找出所有 src 链接来自于 API 服务器的歌曲。
    // 这是一个绝对可靠的识别方法，无论它有没有被正确保存。
    const songsToCheck = musicState.playlist.filter(track => track.src && track.src.includes('api.vkeys.cn'));

    if (songsToCheck.length === 0) {
        await showCustomAlert('提示', '播放列表中没有需要检查的在线歌曲。');
        return;
    }

    const songsToDelete = [];
    const twentyFourHoursAgo = Date.now() - (24 * 60 * 60 * 1000);

    // 2. 对每一首识别出的歌曲，进行严格的“体检”
    await Promise.all(songsToCheck.map(async (track) => {
        // 条件1：检查链接本身是否已经失效（无法播放）
        const isUrlInvalid = !(await checkAudioAvailability(track.src));
        
        // 条件2：检查添加时间是否超过24小时（作为双重保险）
        const isOlderThan24h = track.addedTimestamp && track.addedTimestamp < twentyFourHoursAgo;

        // 只要满足【任意一个】条件，就判定为“失效”
        if (isUrlInvalid || isOlderThan24h) {
            songsToDelete.push(track);
            console.log(`标记删除: ${track.name} (原因: ${isUrlInvalid ? '链接失效' : ''} ${isOlderThan24h ? '超过24小时' : ''})`);
        }
    }));

    // 3. 根据检查结果进行反馈和操作 (这部分逻辑不变)
    if (songsToDelete.length === 0) {
        await showCustomAlert('检查完成', '播放列表中的所有在线歌曲当前均有效。');
        return;
    }

    const confirmed = await showCustomConfirm(
        '确认清理',
        `检测到 ${songsToDelete.length} 首已失效的在线歌曲。确定要将它们从列表中移除吗？`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (!confirmed) return;

    // 执行删除...
    const currentTrack = musicState.currentIndex > -1 ? musicState.playlist[musicState.currentIndex] : null;
    musicState.playlist = musicState.playlist.filter(track => !songsToDelete.includes(track));
    const newIndex = currentTrack ? musicState.playlist.findIndex(t => t.src === currentTrack.src && t.name === currentTrack.name) : -1;

    if (newIndex === -1) {
        if (musicState.isPlaying) {
            audioPlayer.pause();
            audioPlayer.src = '';
        }
        musicState.isPlaying = false;
        if (musicState.playlist.length > 0) {
            playSong(0); 
        } else {
            musicState.currentIndex = -1;
            updatePlayerUI();
        }
    } else {
        musicState.currentIndex = newIndex;
        updatePlayerUI();
    }
    
    await saveGlobalPlaylist();
    updatePlaylistUI();
    await showCustomAlert('清理完成', `${songsToDelete.length} 首歌曲已从列表中移除。`);
}
// ▲▲▲ 替换结束 ▲▲▲



/**
 * 【已修复】更新所有时钟（状态栏和锁屏）
 */
function updateClock() { 
    const now = new Date(); 
    const timeString = now.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' }); 
    const dateString = now.toLocaleDateString('zh-CN', { weekday: 'long', month: 'long', day: 'numeric' }); 
    
    // 更新状态栏时钟 (这个元素一直存在)
    const statusBarTime = document.getElementById('status-bar-time');
    if (statusBarTime) {
        statusBarTime.textContent = timeString; 
    }

    // 更新锁屏时钟 (只有当锁屏元素存在时才更新，避免报错)
    const lockTime = document.getElementById('lock-main-time');
    const lockDate = document.getElementById('lock-main-date');
    if (lockTime) {
        lockTime.textContent = timeString;
    }
    if (lockDate) {
        lockDate.textContent = dateString;
    }
}



/**
 * 【终极健壮版】解析AI返回的、可能格式不规范的响应内容
 * @param {string} content - AI返回的原始字符串
 * @returns {Array} - 一个标准化的消息对象数组
 */
function parseAiResponse(content) {
    const trimmedContent = content.trim();

    // 方案1：【最优先】尝试作为标准的、单一的JSON数组解析
    // 这是最理想、最高效的情况
    if (trimmedContent.startsWith('[') && trimmedContent.endsWith(']')) {
        try {
            const parsed = JSON.parse(trimmedContent);
            if (Array.isArray(parsed)) {
                console.log("解析成功：标准JSON数组格式。");
                return parsed;
            }
        } catch (e) {
            // 如果解析失败，说明它虽然看起来像个数组，但内部格式有问题。
            // 此时我们不报错，而是继续尝试下面的“强力解析”方案。
            console.warn("标准JSON数组解析失败，将尝试强力解析...");
        }
    }

    // 方案2：【强力解析】使用正则表达式，从混乱的字符串中提取出所有独立的JSON对象
    // 这能完美解决您遇到的 "(Timestamp: ...)[{...}](Timestamp: ...)[{...}]" 这种格式
    const jsonMatches = trimmedContent.match(/{[^{}]*}/g);

    if (jsonMatches) {
        const results = [];
        for (const match of jsonMatches) {
            try {
                // 尝试解析每一个被我们“揪”出来的JSON字符串
                const parsedObject = JSON.parse(match);
                results.push(parsedObject);
            } catch (e) {
                // 如果某个片段不是有效的JSON，就忽略它，继续处理下一个
                console.warn("跳过一个无效的JSON片段:", match);
            }
        }

        // 如果我们成功提取出了至少一个有效的JSON对象，就返回这个结果
        if (results.length > 0) {
            console.log("解析成功：通过强力提取模式。");
            return results;
        }
    }
    
    // 方案3：【最终备用】如果以上所有方法都失败了，说明AI返回的可能就是纯文本
    // 我们将原始的、未处理的内容，包装成一个标准的文本消息对象返回，确保程序不会崩溃
    console.error("所有解析方案均失败！将返回原始文本。");
    return [{ type: 'text', content: content }];
}
// ▼▼▼ 在这里粘贴下面这个新函数 ▼▼▼
/**
 * 【全新】“拉取”并填充Minimax语音模型的下拉框
 */
function fetchMinimaxSpeechModels() {
    const modelSelect = document.getElementById('minimax-speech-model-select');
    modelSelect.innerHTML = ''; // 清空

    // Minimax官方提供的两个主要模型
    const models = ['speech-01', 'speech-02'];

    models.forEach(modelId => {
        const option = document.createElement('option');
        option.value = modelId;
        // 为模型添加简单的中文描述
        option.textContent = `${modelId} (${modelId === 'speech-02' ? '高清' : '标准'})`;
        modelSelect.appendChild(option);
    });

    // 自动选中当前已保存的模型
    modelSelect.value = state.apiConfig.minimaxSpeechModel || 'speech-01';

    alert('Minimax 语音模型列表已刷新！');
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲

    function renderApiSettings() {
    // 1. 更新 API 相关的输入框
    document.getElementById('proxy-url').value = state.apiConfig.proxyUrl || '';
    document.getElementById('api-key').value = state.apiConfig.apiKey || '';
        // ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼
    // 【核心新增】加载 Minimax 设置
    document.getElementById('minimax-group-id').value = state.apiConfig.minimaxGroupId || '';
    document.getElementById('minimax-api-key').value = state.apiConfig.minimaxApiKey || '';
    document.getElementById('minimax-speech-model-select').value = state.apiConfig.minimaxSpeechModel || 'speech-01';
    // ▲▲▲ 粘贴结束 ▲▲▲
    // 如果你有模型选择，也一并更新
    if (document.getElementById('model-select')) {
        document.getElementById('model-select').value = state.apiConfig.model || 'gpt-4';
    }

    // 2. 更新后台活动相关的开关和输入框
    
    // ★★★★★ 这就是我们这次修复的核心 ★★★★★
    // 使用 !!state.globalSettings.enableBackgroundActivity 这种写法，
    // 确保当这个设置还不存在时 (比如第一次打开)，开关也能正确地显示为 false (关闭状态)
    document.getElementById('background-activity-switch').checked = !!state.globalSettings.enableBackgroundActivity;
    // ★★★★★ 修复结束 ★★★★★

    document.getElementById('background-interval-input').value = state.globalSettings.backgroundActivityInterval || 60;
    document.getElementById('block-cooldown-input').value = state.globalSettings.blockCooldownHours || 1;

    // 3. 渲染预设和频率的下拉框
    renderApiPresetSelector();
    renderBackgroundFrequencySelector();
    // ▼▼▼ 将下面这整块【新代码】粘贴到 renderApiSettings 函数的末尾 ▼▼▼
    
    // 【核心新增】渲染温度滑块的UI
    const tempSlider = document.getElementById('temperature-slider');
    const tempValueDisplay = document.getElementById('temperature-value');
    
    // 从 state 中读取已保存的温度，如果没有则使用默认值 0.8
    const currentTemp = state.apiConfig.temperature || 0.8;
    tempSlider.value = currentTemp;
    tempValueDisplay.textContent = parseFloat(currentTemp).toFixed(1);

    // 添加实时更新显示值的事件
    tempSlider.addEventListener('input', () => {
        tempValueDisplay.textContent = parseFloat(tempSlider.value).toFixed(1);
    });
// ▲▲▲ 新代码粘贴结束 ▲▲▲

}

// ▼▼▼ 【全新】粘贴这个完整的函数 ▼▼▼
/**
 * 渲染后台活动的角色选择和频率设置UI
 */
function renderBackgroundFrequencySelector() {
    const container = document.getElementById('background-activity-char-list');
    const detailsContainer = document.getElementById('background-activity-details');
    const masterSwitch = document.getElementById('background-activity-switch');

    // 根据总开关的状态，决定是否显示详细设置
    detailsContainer.style.display = masterSwitch.checked ? 'block' : 'none';
    
    container.innerHTML = ''; // 清空旧列表
    const singleChats = Object.values(state.chats).filter(chat => !chat.isGroup);

    if (singleChats.length === 0) {
        container.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">还没有可以设置的角色</p>';
        return;
    }

    const config = state.globalSettings.backgroundActivityConfig || {};

    singleChats.forEach(chat => {
        const freq = config[chat.id] || 'none'; // 获取当前角色的频率设置
        let badgeHtml = '';
        if (freq !== 'none') {
            const freqText = { low: '低', medium: '中', high: '高' }[freq];
            badgeHtml = `<span class="char-freq-badge ${freq}">${freqText}</span>`;
        }

        const item = document.createElement('div');
        item.className = 'char-list-item';
        item.innerHTML = `
            <input type="checkbox" class="bg-char-checkbox" data-chat-id="${chat.id}">
            <span class="char-name">${chat.name}</span>
            ${badgeHtml}
        `;
        container.appendChild(item);
    });
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲

        window.renderApiSettingsProxy = renderApiSettings;
// ▼▼▼ 请用这个【全新修正版】替换旧的 renderChatList 函数 ▼▼▼
async function renderChatList() {
    const chatListEl = document.getElementById('chat-list');
    chatListEl.innerHTML = '';

    // 1. 获取所有聊天和分组数据
    const allChats = Object.values(state.chats);
    const allGroups = await db.qzoneGroups.toArray();

    if (allChats.length === 0) {
        chatListEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">点击右上角 "+" 或群组图标添加聊天</p>';
        return;
    }

    // 2. 将聊天明确地分为“置顶”和“未置顶”两组
    const pinnedChats = allChats.filter(chat => chat.isPinned);
    const unpinnedChats = allChats.filter(chat => !chat.isPinned);

    // 3. 对置顶的聊天，仅按最新消息时间排序
    pinnedChats.sort((a, b) => (b.history.slice(-1)[0]?.timestamp || 0) - (a.history.slice(-1)[0]?.timestamp || 0));

    // 4. 【优先渲染】所有置顶的聊天
    pinnedChats.forEach(chat => {
        const item = createChatListItem(chat);
        chatListEl.appendChild(item);
    });

    // 5. 【接下来处理未置顶的聊天】应用您之前的分组逻辑
    // 为每个分组找到其内部最新的消息时间戳 (只在未置顶聊天中查找)
    allGroups.forEach(group => {
        const latestChatInGroup = unpinnedChats
            .filter(chat => chat.groupId === group.id) // 找到属于这个组的聊天
            .sort((a, b) => (b.history.slice(-1)[0]?.timestamp || 0) - (a.history.slice(-1)[0]?.timestamp || 0))[0]; // 排序后取第一个
        
        group.latestTimestamp = latestChatInGroup ? (latestChatInGroup.history.slice(-1)[0]?.timestamp || 0) : 0;
    });

    // 根据分组的最新时间戳，对分组本身进行排序
    allGroups.sort((a, b) => b.latestTimestamp - a.latestTimestamp);

    // 6. 遍历排序后的分组，渲染其中的【未置顶】好友
    allGroups.forEach(group => {
        const groupChats = unpinnedChats
            .filter(chat => !chat.isGroup && chat.groupId === group.id)
            .sort((a, b) => (b.history.slice(-1)[0]?.timestamp || 0) - (a.history.slice(-1)[0]?.timestamp || 0));
        
        if (groupChats.length === 0) return; // 如果这个分组里没有未置顶的好友，就跳过

        const groupContainer = document.createElement('div');
        groupContainer.className = 'chat-group-container';
        
        // 【核心修改】下面这两行代码里，我已经删除了 collapsed 类，这样默认就是展开的了！
        groupContainer.innerHTML = `
            <div class="chat-group-header">
                <span class="arrow">▼</span>
                <span class="group-name">${group.name}</span>
            </div>
            <div class="chat-group-content"></div>
        `;
        const contentEl = groupContainer.querySelector('.chat-group-content');

        groupChats.forEach(chat => {
            const item = createChatListItem(chat);
            contentEl.appendChild(item);
        });
        chatListEl.appendChild(groupContainer);
    });

    // 7. 最后，渲染所有【未置顶】的群聊和【未分组的】好友
    const remainingChats = unpinnedChats
        .filter(chat => chat.isGroup || (!chat.isGroup && !chat.groupId))
        .sort((a, b) => (b.history.slice(-1)[0]?.timestamp || 0) - (a.history.slice(-1)[0]?.timestamp || 0));
    
    remainingChats.forEach(chat => {
        const item = createChatListItem(chat);
        chatListEl.appendChild(item);
    });

    // 为所有分组标题添加折叠事件
    document.querySelectorAll('.chat-group-header').forEach(header => {
        header.addEventListener('click', () => {
            header.classList.toggle('collapsed');
            header.nextElementSibling.classList.toggle('collapsed');
        });
    });
}
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 用这块【V3 - Emoji图标版】代码，完整替换你旧的 createChatListItem 函数 ▼▼▼
function createChatListItem(chat) {
    const lastMsgObj = chat.history.filter(msg => !msg.isHidden).slice(-1)[0] || {};
    let lastMsgDisplay;

    // --- 消息预览的逻辑 (这部分保持不变) ---
    if (!chat.isGroup && chat.relationship?.status === 'pending_user_approval') {
        lastMsgDisplay = `<span style="color: #ff8c00;">[好友申请] ${chat.relationship.applicationReason || '请求添加你为好友'}</span>`;
    } else if (!chat.isGroup && chat.relationship?.status === 'blocked_by_ai') {
        lastMsgDisplay = `<span style="color: #dc3545;">[你已被对方拉黑]</span>`;
    } else if (chat.isGroup) {
        if (lastMsgObj.type === 'pat_message') { lastMsgDisplay = `[系统消息] ${lastMsgObj.content}`; }
        else if (lastMsgObj.type === 'transfer') { lastMsgDisplay = '[转账]'; }
        else if (lastMsgObj.type === 'ai_image' || lastMsgObj.type === 'user_photo') { lastMsgDisplay = '[照片]'; }
        else if (lastMsgObj.type === 'voice_message') { lastMsgDisplay = '[语音]'; }
        else if (typeof lastMsgObj.content === 'string' && STICKER_REGEX.test(lastMsgObj.content)) { lastMsgDisplay = lastMsgObj.meaning ? `[表情: ${lastMsgObj.meaning}]` : '[表情]'; }
        else if (Array.isArray(lastMsgObj.content)) { lastMsgDisplay = `[图片]`; }
        else { lastMsgDisplay = String(lastMsgObj.content || '...').substring(0, 20); }
        if (lastMsgObj.senderName && lastMsgObj.type !== 'pat_message') {
            lastMsgDisplay = `${lastMsgObj.senderName}: ${lastMsgDisplay}`;
        }
    } else {
        const statusText = chat.status?.text || '在线';
        lastMsgDisplay = `[${statusText}]`;
    }

    const lastMsgTimestamp = lastMsgObj?.timestamp;
    const timeDisplay = formatChatListTimestamp(lastMsgTimestamp);
    
    const container = document.createElement('div');
    container.className = 'chat-list-item-swipe-container';
    container.dataset.chatId = chat.id;

    const content = document.createElement('div');
    content.className = `chat-list-item-content ${chat.isPinned ? 'pinned' : ''}`;
    
    const avatar = chat.isGroup ? chat.settings.groupAvatar : chat.settings.aiAvatar;

    // ★★★★★ 这就是我们本次修改的核心！ ★★★★★
    let streakHtml = '';
    // 检查是否为单聊、功能是否开启
    if (!chat.isGroup && chat.settings.streak && chat.settings.streak.enabled) {
        const streak = chat.settings.streak;
        
        let isExtinguished = false;
        if (streak.lastInteractionDate && streak.extinguishThreshold !== -1) {
            const lastDate = new Date(streak.lastInteractionDate);
            const todayDate = new Date();
            todayDate.setHours(0, 0, 0, 0); 
            const daysDiff = (todayDate - lastDate) / (1000 * 3600 * 24);
            if (daysDiff >= streak.extinguishThreshold) {
                isExtinguished = true;
            }
        }
        
        // 准备图标和颜色
        const litIconUrl = streak.litIconUrl;
        const extinguishedIconUrl = streak.extinguishedIconUrl;
        const fontColor = streak.fontColor || '#ff6f00'; // 如果没设置颜色，就用默认的橙色

        let iconHtml = '';

        if (isExtinguished) {
            // 如果熄灭了，优先用自定义熄灭图片，否则用默认 Emoji
            iconHtml = extinguishedIconUrl 
                ? `<img src="${extinguishedIconUrl}" style="height: 1.2em; vertical-align: middle;">`
                : '🧊';
        } else if (streak.currentDays > 0) {
            // 如果在续，优先用自定义点亮图片，否则用默认 Emoji
            iconHtml = litIconUrl 
                ? `<img src="${litIconUrl}" style="height: 1.2em; vertical-align: middle;">`
                : '🔥';
        }

        // 拼接最终的HTML
        if (iconHtml) {
            // 【核心修改】在这里我们增加一个判断
            // 如果火花已熄灭 (isExtinguished 为 true)
            if (isExtinguished) {
                // 就只显示熄灭的图标，不显示天数
                streakHtml = `<span class="streak-indicator" style="color: ${fontColor};">${iconHtml}</span>`;
            } 
            // 如果是永不熄灭模式（并且未熄灭）
            else if (streak.currentDays === -1 || streak.initialDays === -1) {
                 streakHtml = `<span class="streak-indicator" style="color: ${fontColor};">${iconHtml}∞</span>`;
            }
            // 其他所有情况（即，火花是点亮的）
            else {
                // 才显示图标和天数
                streakHtml = `<span class="streak-indicator" style="color: ${fontColor};">${iconHtml}${streak.currentDays}</span>`;
            }
        }
    }
    // ★★★★★ 修改结束 ★★★★★
    
    // 后续的HTML拼接部分保持不变
    content.innerHTML = `
        <div class="chat-list-item" data-chat-id="${chat.id}">
            <img src="${avatar || defaultAvatar}" class="avatar">
            <div class="info">
                <div class="name-line">
                    <span class="name">${chat.name}</span>
                    ${chat.isGroup ? '<span class="group-tag">群聊</span>' : ''}
                    ${streakHtml}
                </div>
                <div class="last-msg" style="color: ${chat.isGroup ? 'var(--text-secondary)' : '#b5b5b5'}; font-style: italic;">${lastMsgDisplay}</div>
            </div>
            <div class="chat-list-right-column">
                <div class="chat-list-time">${timeDisplay}</div>
                <div class="unread-count-wrapper">
                    <span class="unread-count" style="display: none;">0</span>
                </div>
            </div>
        </div>
    `;
    
    // 后续的所有代码都保持不变...
    const actions = document.createElement('div');
    actions.className = 'swipe-actions';
    const pinButtonText = chat.isPinned ? '取消置顶' : '置顶';
    const pinButtonClass = chat.isPinned ? 'unpin' : 'pin';
    actions.innerHTML = `<button class="swipe-action-btn ${pinButtonClass}">${pinButtonText}</button><button class="swipe-action-btn delete">删除</button>`;
    
    container.appendChild(content);
    container.appendChild(actions);
    
    const unreadCount = chat.unreadCount || 0;
    const unreadEl = content.querySelector('.unread-count');
    if (unreadCount > 0) {
        unreadEl.textContent = unreadCount > 99 ? '99+' : unreadCount;
        unreadEl.style.display = 'inline-flex';
    } else {
        unreadEl.style.display = 'none';
    }
    
    const infoEl = content.querySelector('.info');
    if (infoEl) {
        infoEl.addEventListener('click', () => openChat(chat.id));
    }
    const avatarEl = content.querySelector('.avatar, .avatar-with-frame');
    if (avatarEl) {
         avatarEl.addEventListener('click', (e) => {
            e.stopPropagation();
            handleUserPat(chat.id, chat.name);
        });
    }

    return container;
}
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 请用这个【带诊断功能的全新版本】替换旧的 renderChatInterface 函数 ▼▼▼
function renderChatInterface(chatId) {
    cleanupWaimaiTimers();
    const chat = state.chats[chatId];
    if (!chat) return;
        // ▼▼▼ 【全新】群公告图标显示/隐藏逻辑 ▼▼▼
    const announcementBtn = document.getElementById('group-announcement-btn');
    if (chat.isGroup) {
        announcementBtn.style.display = 'inline-flex'; // 在群聊中显示
    } else {
        announcementBtn.style.display = 'none'; // 在单聊中隐藏
    }
    // ▲▲▲ 新增代码结束 ▲▲▲

    exitSelectionMode();
    
    const messagesContainer = document.getElementById('chat-messages');
    const chatInputArea = document.getElementById('chat-input-area');
    const lockOverlay = document.getElementById('chat-lock-overlay');
    const lockContent = document.getElementById('chat-lock-content');

    messagesContainer.dataset.theme = chat.settings.theme || 'default';
    const fontSize = chat.settings.fontSize || 13;
    messagesContainer.style.setProperty('--chat-font-size', `${fontSize}px`);
    applyScopedCss(chat.settings.customCss || '', '#chat-messages', 'custom-bubble-style');
    
    document.getElementById('chat-header-title').textContent = chat.name;
    const statusContainer = document.getElementById('chat-header-status');
    const statusTextEl = statusContainer.querySelector('.status-text');

    if (chat.isGroup) {
        statusContainer.style.display = 'none';
        document.getElementById('chat-header-title-wrapper').style.justifyContent = 'center';
    } else {
        statusContainer.style.display = 'flex';
        document.getElementById('chat-header-title-wrapper').style.justifyContent = 'flex-start';
        statusTextEl.textContent = chat.status?.text || '在线';
        statusContainer.classList.toggle('busy', chat.status?.isBusy || false);
    }
    
    lockOverlay.style.display = 'none';
    chatInputArea.style.visibility = 'visible';
    lockContent.innerHTML = '';

    if (!chat.isGroup && chat.relationship.status !== 'friend') {
        lockOverlay.style.display = 'flex';
        chatInputArea.style.visibility = 'hidden';
        
        let lockHtml = '';
        switch (chat.relationship.status) {
            case 'blocked_by_user':
                // --- 【核心修改：在这里加入诊断面板】 ---
                const isSimulationRunning = simulationIntervalId !== null;
                const blockedTimestamp = chat.relationship.blockedTimestamp;
                const cooldownHours = state.globalSettings.blockCooldownHours || 1;
                const cooldownMilliseconds = cooldownHours * 60 * 60 * 1000;
                const timeSinceBlock = Date.now() - blockedTimestamp;
                const isCooldownOver = timeSinceBlock > cooldownMilliseconds;
                const timeRemainingMinutes = Math.max(0, Math.ceil((cooldownMilliseconds - timeSinceBlock) / (1000 * 60)));

                lockHtml = `
                    <span class="lock-text">你已将“${chat.name}”拉黑。</span>
                    <button id="unblock-btn" class="lock-action-btn">解除拉黑</button>
                    <div style="margin-top: 20px; padding: 10px; border: 1px dashed #ccc; border-radius: 8px; font-size: 11px; text-align: left; color: #666; background: rgba(0,0,0,0.02);">
                        <strong style="color: #333;">【开发者诊断面板】</strong><br>
                        - 后台活动总开关: ${state.globalSettings.enableBackgroundActivity ? '<span style="color: green;">已开启</span>' : '<span style="color: red;">已关闭</span>'}<br>
                        - 系统心跳计时器: ${isSimulationRunning ? '<span style="color: green;">运行中</span>' : '<span style="color: red;">未运行</span>'}<br>
                        - 当前角色状态: <strong>${chat.relationship.status}</strong><br>
                        - 需要冷静(小时): <strong>${cooldownHours}</strong><br>
                        - 冷静期是否结束: ${isCooldownOver ? '<span style="color: green;">是</span>' : `<span style="color: orange;">否 (还剩约 ${timeRemainingMinutes} 分钟)</span>`}<br>
                        - 触发条件: ${isCooldownOver && state.globalSettings.enableBackgroundActivity ? '<span style="color: green;">已满足，等待下次系统心跳</span>' : '<span style="color: red;">未满足</span>'}
                    </div>
                    <button id="force-apply-check-btn" class="lock-action-btn secondary" style="margin-top: 10px;">强制触发一次好友申请检测</button>
                `;
                // --- 【修改结束】 ---
                break;
            case 'blocked_by_ai':
                lockHtml = `
                    <span class="lock-text">你被对方拉黑了。</span>
                    <button id="apply-friend-btn" class="lock-action-btn">重新申请加为好友</button>
                `;
                break;
            
            case 'pending_user_approval':
                lockHtml = `
                    <span class="lock-text">“${chat.name}”请求添加你为好友：<br><i>“${chat.relationship.applicationReason}”</i></span>
                    <button id="accept-friend-btn" class="lock-action-btn">接受</button>
                    <button id="reject-friend-btn" class="lock-action-btn secondary">拒绝</button>
                `;
                break;

            // 【核心修正】修复当你申请后，你看到的界面
            case 'pending_ai_approval':
                lockHtml = `<span class="lock-text">好友申请已发送，等待对方通过...</span>`;
                break;
        }
        lockContent.innerHTML = lockHtml;
    }
    messagesContainer.innerHTML = '';
// ▼▼▼ 用这【一整块】代码，替换旧的背景设置逻辑 ▼▼▼
const chatScreen = document.getElementById('chat-interface-screen');

// 核心逻辑：单人背景优先于全局背景
const backgroundToApply = chat.settings.background || state.globalSettings.globalChatBackground;

if (backgroundToApply) {
    chatScreen.style.backgroundImage = `url(${backgroundToApply})`;
} else {
    chatScreen.style.backgroundImage = 'none';
}
// ▲▲▲ 替换结束 ▲▲▲
const isDarkMode = document.getElementById('phone-screen').classList.contains('dark-mode');
chatScreen.style.backgroundColor = chat.settings.background ? 'transparent' : (isDarkMode ? '#000000' : '#f0f2f5');
    const history = chat.history;
    const totalMessages = history.length;
    currentRenderedCount = 0;
    const initialMessages = history.slice(-MESSAGE_RENDER_WINDOW);
let lastMessageTimestamp = null;

initialMessages.forEach(msg => {
    if (msg.isHidden) return; // 【新增】跳过隐藏消息

    if (isNewDay(msg.timestamp, lastMessageTimestamp)) {
        // 【核心修改】调用我们新的生成器函数
        const dateStampEl = createDateStampElement(msg.timestamp);
        messagesContainer.insertBefore(dateStampEl, document.getElementById('typing-indicator'));
    }
    
    appendMessage(msg, chat, true);
    
    lastMessageTimestamp = msg.timestamp;
});
    currentRenderedCount = initialMessages.length;
    if (totalMessages > currentRenderedCount) {
        prependLoadMoreButton(messagesContainer);
    }
    const typingIndicator = document.createElement('div');
    typingIndicator.id = 'typing-indicator';
    typingIndicator.style.display = 'none';
    typingIndicator.textContent = '对方正在输入...';
    messagesContainer.appendChild(typingIndicator);
    setTimeout(() => messagesContainer.scrollTop = messagesContainer.scrollHeight, 0);
    renderChatPet();
}
// ▲▲▲ 替换结束 ▲▲▲

        function prependLoadMoreButton(container) { const button = document.createElement('button'); button.id = 'load-more-btn'; button.textContent = '加载更早的记录'; button.addEventListener('click', loadMoreMessages); container.prepend(button); }

        function loadMoreMessages() { const messagesContainer = document.getElementById('chat-messages'); const chat = state.chats[state.activeChatId]; if (!chat) return; const loadMoreBtn = document.getElementById('load-more-btn'); if (loadMoreBtn) loadMoreBtn.remove(); const totalMessages = chat.history.length; const nextSliceStart = totalMessages - currentRenderedCount - MESSAGE_RENDER_WINDOW; const nextSliceEnd = totalMessages - currentRenderedCount; const messagesToPrepend = chat.history.slice(Math.max(0, nextSliceStart), nextSliceEnd); const oldScrollHeight = messagesContainer.scrollHeight; // ▼▼▼ 请将这个完整的代码块，粘贴到被删除的位置 ▼▼▼

// 1. 找到屏幕上已有的、最老的那条【真实消息】的时间戳
const firstVisibleMessage = messagesContainer.querySelector('.message-wrapper:not(.date-stamp-wrapper)');
let subsequentMessageTimestamp = firstVisibleMessage ? parseInt(firstVisibleMessage.dataset.timestamp) : null;

// 2. 从后往前（从新到旧）遍历我们要新加载的消息
messagesToPrepend.reverse().forEach(currentMsg => {
    // 检查这条新消息和它后面那条（可能是屏幕上已有的，也可能是刚加载的）消息是否跨天
    if (subsequentMessageTimestamp && isNewDay(subsequentMessageTimestamp, currentMsg.timestamp)) {
        // 如果跨天，就为后面那条“较新”的消息创建一个日期戳
        const dateStampEl = createDateStampElement(subsequentMessageTimestamp);
        messagesContainer.prepend(dateStampEl);
    }
    
    // 正常地把当前这条新消息放到最前面
    prependMessage(currentMsg, chat);
    
    // 更新追踪器，为下一次比较做准备
    subsequentMessageTimestamp = currentMsg.timestamp;
});

// 3. 【边界处理】处理所有新加载消息的最前面（也就是整个聊天记录的最老）的那条消息
// 它也需要一个日期戳
if (subsequentMessageTimestamp) {
    const dateStampEl = createDateStampElement(subsequentMessageTimestamp);
    messagesContainer.prepend(dateStampEl);
}

// ▲▲▲ 粘贴结束 ▲▲▲
currentRenderedCount += messagesToPrepend.length; const newScrollHeight = messagesContainer.scrollHeight; messagesContainer.scrollTop += (newScrollHeight - oldScrollHeight); if (totalMessages > currentRenderedCount) { prependLoadMoreButton(messagesContainer); } }

// ▼▼▼ 用这块【修复版】代码，替换你旧的 renderWallpaperScreen 函数 ▼▼▼
function renderWallpaperScreen() { 
    // 锁屏开关
    const lockScreenEnabled = localStorage.getItem('lockScreenEnabled') !== 'false';
    const toggle = document.getElementById('enable-lock-screen-toggle');
    if (toggle) {
        toggle.checked = lockScreenEnabled;
    }

    // 主屏幕字体颜色
    document.getElementById('home-icon-widget-text-color-picker').value = state.globalSettings.homeIconWidgetTextColor || '#FFFFFF';
    
    // 主屏幕字体阴影开关
    document.getElementById('remove-home-font-shadow-toggle').checked = !!state.globalSettings.removeHomeFontShadow;

    // 主屏幕壁纸预览
    const preview = document.getElementById('wallpaper-preview'); 
    const bg = newWallpaperBase64 || state.globalSettings.wallpaper; 
    if (bg && bg.startsWith('data:image')) { 
        preview.style.backgroundImage = `url(${bg})`; 
        preview.textContent = ''; 
    } else if(bg) { 
        preview.style.backgroundImage = bg; 
        preview.textContent = '当前为渐变色'; 
    }

    // 锁屏壁纸预览
    const lockscreenPreview = document.getElementById('lockscreen-wallpaper-preview');
    const lockBg = newLockscreenWallpaperBase64 || state.globalSettings.lockscreenWallpaper;
    if (lockBg && lockBg.startsWith('data:image')) {
        lockscreenPreview.style.backgroundImage = `url(${lockBg})`;
        lockscreenPreview.textContent = '';
    } else if (lockBg) {
        lockscreenPreview.style.backgroundImage = lockBg;
        lockscreenPreview.textContent = '当前为渐变色';
    }

    // 密码输入框
    document.getElementById('password-set-input').value = state.globalSettings.password || '';

    // 全局聊天背景预览
    const globalBgPreview = document.getElementById('global-bg-preview');
    const globalBg = newGlobalBgBase64 || state.globalSettings.globalChatBackground;
    if (globalBg && globalBg.startsWith('data:image')) {
        globalBgPreview.style.backgroundImage = `url(${globalBg})`;
        globalBgPreview.textContent = '';
    } else if (globalBg) {
        globalBgPreview.style.background = globalBg;
        globalBgPreview.textContent = '当前为渐变色';
    } else {
        globalBgPreview.style.backgroundImage = 'none';
        globalBgPreview.textContent = '点击下方上传';
    }
    
    // ★★★★★ 这就是我们本次修复的核心！ ★★★★★
    // 在这里，我们新增了下面这2行，用来加载铃声和提示音
    document.getElementById('ringtone-url-input').value = state.globalSettings.ringtoneUrl || '';
    document.getElementById('notification-sound-url-input').value = state.globalSettings.notificationSoundUrl || '';
    // ★★★★★ 修复结束 ★★★★★

    // 渲染App图标和名称设置
    renderIconSettings();
    renderAppNameSettings();
    
    // 加载预设下拉框
    loadHomeScreenPresetsToDropdown(); 
}
// ▲▲▲ 替换结束 ▲▲▲

// ▲▲▲ 新代码粘贴结束 ▲▲▲
        window.renderWallpaperScreenProxy = renderWallpaperScreen;

        function applyGlobalWallpaper() { const homeScreen = document.getElementById('home-screen'); const wallpaper = state.globalSettings.wallpaper; if (wallpaper && wallpaper.startsWith('data:image')) homeScreen.style.backgroundImage = `url(${wallpaper})`; else if (wallpaper) homeScreen.style.backgroundImage = wallpaper; }

async function renderWorldBookScreen() {
    const listEl = document.getElementById('world-book-list');
    listEl.innerHTML = '';

    // 1. 同时获取所有书籍和所有分类
    const [books, categories] = await Promise.all([
        db.worldBooks.toArray(),
        db.worldBookCategories.orderBy('name').toArray()
    ]);

    state.worldBooks = books; // 确保内存中的数据是同步的

    if (books.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">点击右上角 "+" 创建你的第一本世界书</p>';
        return;
    }

    // 2. 将书籍按 categoryId 分组
    const groupedBooks = books.reduce((acc, book) => {
        const key = book.categoryId || 'uncategorized';
        if (!acc[key]) {
            acc[key] = [];
        }
        acc[key].push(book);
        return acc;
    }, {});

    // 3. 优先渲染已分类的书籍
    categories.forEach(category => {
        const booksInCategory = groupedBooks[category.id];
        if (booksInCategory && booksInCategory.length > 0) {
            const groupContainer = createWorldBookGroup(category.name, booksInCategory);
            listEl.appendChild(groupContainer);
        }
    });

    // 4. 最后渲染未分类的书籍
    const uncategorizedBooks = groupedBooks['uncategorized'];
    if (uncategorizedBooks && uncategorizedBooks.length > 0) {
        const groupContainer = createWorldBookGroup('未分类', uncategorizedBooks);
        listEl.appendChild(groupContainer);
    }
    
    // 5. 为所有分组标题添加折叠事件
    document.querySelectorAll('.world-book-group-header').forEach(header => {
        header.addEventListener('click', () => {
            header.classList.toggle('collapsed');
            header.nextElementSibling.classList.toggle('collapsed');
        });
    });
}

/**
 * 【辅助函数】创建一个分类的分组DOM
 * @param {string} groupName - 分类名称
 * @param {Array} books - 该分类下的书籍数组
 * @returns {HTMLElement} - 创建好的分组容器
 */
function createWorldBookGroup(groupName, books) {
    const groupContainer = document.createElement('div');
    groupContainer.className = 'world-book-group-container';
    
    groupContainer.innerHTML = `
        <div class="world-book-group-header">
            <span class="arrow">▼</span>
            <span class="group-name">${groupName}</span>
        </div>
        <div class="world-book-group-content"></div>
    `;

    // ▼▼▼ 在这里添加新代码 ▼▼▼
    const headerEl = groupContainer.querySelector('.world-book-group-header');
    const contentEl = groupContainer.querySelector('.world-book-group-content');
    
    // 默认给头部和内容区都加上 collapsed 类
    headerEl.classList.add('collapsed');
    contentEl.classList.add('collapsed');
    // ▲▲▲ 添加结束 ▲▲▲

    books.sort((a,b) => a.name.localeCompare(b.name, 'zh-CN'));
    books.forEach(book => {
        const item = document.createElement('div');
        item.className = 'list-item';
        item.dataset.bookId = book.id;
        item.innerHTML = `<div class="item-title">${book.name}</div><div class="item-content">${(book.content || '暂无内容...').substring(0, 50)}</div>`;
        item.addEventListener('click', () => openWorldBookEditor(book.id));
        addLongPressListener(item, async () => { const confirmed = await showCustomConfirm('删除世界书', `确定要删除《${book.name}》吗？此操作不可撤销。`, { confirmButtonClass: 'btn-danger' }); if (confirmed) { await db.worldBooks.delete(book.id); state.worldBooks = state.worldBooks.filter(wb => wb.id !== book.id); renderWorldBookScreen(); } });
        contentEl.appendChild(item); 
    });

    return groupContainer;
}
        window.renderWorldBookScreenProxy = renderWorldBookScreen;

async function openWorldBookEditor(bookId) {
    editingWorldBookId = bookId;
    const [book, categories] = await Promise.all([
        db.worldBooks.get(bookId),
        db.worldBookCategories.toArray()
    ]);
    if (!book) return;

    document.getElementById('world-book-editor-title').textContent = book.name;
    document.getElementById('world-book-name-input').value = book.name;
    document.getElementById('world-book-content-input').value = book.content;

    // 【核心修改】填充分类下拉菜单
    const selectEl = document.getElementById('world-book-category-select');
    selectEl.innerHTML = '<option value="">-- 未分类 --</option>'; // 默认选项
    categories.forEach(cat => {
        const option = document.createElement('option');
        option.value = cat.id;
        option.textContent = cat.name;
        if (book.categoryId === cat.id) {
            option.selected = true; // 选中当前分类
        }
        selectEl.appendChild(option);
    });

    showScreen('world-book-editor-screen');
}

// ▼▼▼ 用这块【增强版】代码，完整替换旧的 renderStickerPanel 函数 ▼▼▼
function renderStickerPanel() {
    const grid = document.getElementById('sticker-grid');
    grid.innerHTML = '';
    
    if (state.userStickers.length === 0) {
        grid.innerHTML = '<p style="text-align:center; color: var(--text-secondary); grid-column: 1 / -1;">大人请点击右上角“添加”或“上传”来添加你的第一个表情吧！</p>';
        return;
    }

    state.userStickers.forEach(sticker => {
        const item = document.createElement('div');
        item.className = 'sticker-item';
        item.style.backgroundImage = `url(${sticker.url})`;
        item.title = sticker.name;
        
        if (isUserStickerSelectionMode) {
            // 【选择模式】下的逻辑
            item.classList.add('in-selection-mode');
            if (selectedUserStickers.has(sticker.id)) {
                item.classList.add('selected');
            }
            
            item.addEventListener('click', () => {
                item.classList.toggle('selected');
                if (selectedUserStickers.has(sticker.id)) {
                    selectedUserStickers.delete(sticker.id);
                } else {
                    selectedUserStickers.add(sticker.id);
                }
                const deleteBtn = document.getElementById('delete-selected-user-stickers-btn');
                deleteBtn.textContent = `删除已选 (${selectedUserStickers.size})`;
                deleteBtn.disabled = selectedUserStickers.size === 0;
            });

        } else {
            // 【正常模式】下的逻辑（发送和长按删除）
            item.addEventListener('click', () => sendSticker(sticker));
            
            addLongPressListener(item, () => {
                const existingDeleteBtn = item.querySelector('.delete-btn');
                if (existingDeleteBtn) return;
                
                const deleteBtn = document.createElement('div');
                deleteBtn.className = 'delete-btn';
                deleteBtn.innerHTML = '&times;';
                deleteBtn.onclick = async (e) => {
                    e.stopPropagation();
                    const confirmed = await showCustomConfirm('删除表情', `确定要删除表情 "${sticker.name}" 吗？`, { confirmButtonClass: 'btn-danger' });
                    if (confirmed) {
                        await db.userStickers.delete(sticker.id);
                        state.userStickers = state.userStickers.filter(s => s.id !== sticker.id);
                        renderStickerPanel();
                    }
                };
                item.appendChild(deleteBtn);
                deleteBtn.style.display = 'block';
                setTimeout(() => item.addEventListener('mouseleave', () => deleteBtn.remove(), { once: true }), 3000);
            });
        }
        grid.appendChild(item);
    });
}
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 在 renderStickerPanel 函数后，粘贴这个新函数 ▼▼▼
/**
 * 处理批量删除选中的用户表情
 */
async function handleBulkDeleteUserStickers() {
    if (selectedUserStickers.size === 0) return;

    const confirmed = await showCustomConfirm(
        '确认删除',
        `确定要删除选中的 ${selectedUserStickers.size} 个表情吗？`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        const idsToDelete = Array.from(selectedUserStickers);
        await db.userStickers.bulkDelete(idsToDelete);
        
        state.userStickers = state.userStickers.filter(s => !idsToDelete.includes(s.id));
        
        // 退出编辑模式
        toggleUserStickerSelectionMode();
        
        alert('选中的表情已删除。');
    }
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 在 createMessageElement 函数的【正上方】，粘贴这个新函数 ▼▼▼
/**
 * 【全新】从卡片点击后，打开情侣空间并跳转到指定页签
 * @param {string} charId - 角色ID
 * @param {string} viewId - 要跳转到的视图ID (例如 'ls-diary-view')
 */
function openLoversSpaceFromCard(charId, viewId) {
    // 1. 打开指定角色的情侣空间主界面
    openLoversSpace(charId);

    // 2. 等待一小会儿，确保界面已渲染
    setTimeout(() => {
        // 3. 找到对应的页签按钮并模拟点击它
        const targetTab = document.querySelector(`.ls-tab-item[data-view='${viewId}']`);
        if (targetTab) {
            targetTab.click();
        }
    }, 100); // 100毫秒的延迟通常足够了
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 用这个【已更新】的版本替换旧的 createMessageElement 函数 ▼▼▼
function createMessageElement(msg, chat) {

    // ▼▼▼ 在函数最开头，添加这段新代码 ▼▼▼
if (msg.type === 'recalled_message') {
    const wrapper = document.createElement('div');
    // 1. 【核心】给 wrapper 也加上 timestamp，方便事件委托时查找
    wrapper.className = 'message-wrapper system-pat';
    wrapper.dataset.timestamp = msg.timestamp; 

    const bubble = document.createElement('div');
    // 2. 【核心】让这个元素同时拥有 .message-bubble 和 .recalled-message-placeholder 两个class
    //    这样它既能被选择系统识别，又能保持原有的居中灰色样式
    bubble.className = 'message-bubble recalled-message-placeholder';
    // 3. 【核心】把 timestamp 放在 bubble 上，这是多选逻辑的关键
    bubble.dataset.timestamp = msg.timestamp; 
    bubble.textContent = msg.content;
    
    wrapper.appendChild(bubble);
    
    // 4. 【核心】为它补上和其他消息一样的标准事件监听器
    addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
    wrapper.addEventListener('click', () => { 
        if (isSelectionMode) {
            toggleMessageSelection(msg.timestamp);
        }
    });

    // 5. 【重要】在之前的“点击查看原文”的逻辑中，我们已经使用了事件委托，所以这里不需要再单独为这个元素添加点击事件了。
    //    init() 函数中的那个事件监听器会处理它。
    
    return wrapper;
}
    // ▲▲▲ 添加结束 ▲▲▲

    if (msg.isHidden) {
        return null;
    }

    if (msg.type === 'pat_message') {
        const wrapper = document.createElement('div');
        wrapper.className = 'message-wrapper system-pat'; 
        const bubble = document.createElement('div');
        bubble.className = 'message-bubble system-bubble'; 
        bubble.dataset.timestamp = msg.timestamp;
        bubble.textContent = msg.content;
        wrapper.appendChild(bubble);
        addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
        wrapper.addEventListener('click', () => { if (isSelectionMode) toggleMessageSelection(msg.timestamp); });
        return wrapper;
    }

    const isUser = msg.role === 'user';
    const wrapper = document.createElement('div');
    wrapper.className = `message-wrapper ${isUser ? 'user' : 'ai'}`;
// ▼▼▼ 用这块【已修复】的代码替换旧的 if (chat.isGroup) 代码块 ▼▼▼
if (chat.isGroup) { 
    const senderLine = document.createElement('div');
    senderLine.className = 'group-sender-line';
    
    const tagsContainer = document.createElement('div');
    tagsContainer.className = 'group-sender-tags';

    let senderDisplayName;

    // --- ★★★ 核心修改在这里 ★★★ ---
    if (isUser) {
        // 如果是用户自己
        senderDisplayName = chat.settings.myNickname || '我';
        
        // 检查用户是否是群主
        if (chat.ownerId === 'user') {
            const roleTag = document.createElement('span');
            roleTag.className = 'group-role-tag owner';
            roleTag.textContent = '群主';
            tagsContainer.appendChild(roleTag);
        } 
        // 检查用户是否被设为管理员
        else if (chat.settings.isUserAdmin) {
            const roleTag = document.createElement('span');
            roleTag.className = 'group-role-tag admin';
            roleTag.textContent = '管理员';
            tagsContainer.appendChild(roleTag);
        }
        
        // 检查用户是否有头衔
        if (chat.settings.myGroupTitle) {
            const titleTag = document.createElement('span');
            titleTag.className = 'group-title-tag';
            titleTag.textContent = chat.settings.myGroupTitle;
            tagsContainer.appendChild(titleTag);
        }
    } else {
        // 如果是其他成员 (AI/NPC)，这部分逻辑保持不变
        const member = chat.members.find(m => m.originalName === msg.senderName);
        senderDisplayName = member ? member.groupNickname : (msg.senderName || '未知成员');
                // --- ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼ ---
        // 【核心新增】如果该成员被禁言了，就添加一个禁言标签
        if (member && member.isMuted) {
            const muteTag = document.createElement('span');
            muteTag.className = 'group-title-tag'; // 复用头衔标签的样式
            muteTag.style.color = '#ff3b30'; // 让它变成红色
            muteTag.style.backgroundColor = '#ffe5e5'; // 淡红色背景
            muteTag.textContent = '🚫已禁言';
            tagsContainer.appendChild(muteTag);
        }
        // --- ▲▲▲ 新代码粘贴结束 ▲▲▲
        if (member && chat.ownerId === member.id) {
            const roleTag = document.createElement('span');
            roleTag.className = 'group-role-tag owner';
            roleTag.textContent = '群主';
            tagsContainer.appendChild(roleTag);
        } 
        else if (member && member.isAdmin) {
            const roleTag = document.createElement('span');
            roleTag.className = 'group-role-tag admin';
            roleTag.textContent = '管理员';
            tagsContainer.appendChild(roleTag);
        }
        
        if (member && member.groupTitle) {
            const titleTag = document.createElement('span');
            titleTag.className = 'group-title-tag';
            titleTag.textContent = member.groupTitle;
            tagsContainer.appendChild(titleTag);
        }
    }
    // --- ▲▲▲ 修改结束 ▲▲▲

    const senderNameSpan = document.createElement('span');
    senderNameSpan.className = 'sender-name';
    senderNameSpan.textContent = senderDisplayName;
    
    // 【独家定制】修复用户标签显示在右边的问题
    if (isUser) {
        senderLine.appendChild(tagsContainer); // 标签在左
        senderLine.appendChild(senderNameSpan); // 昵称在右
    } else {
        senderLine.appendChild(senderNameSpan); // 昵称在左
        senderLine.appendChild(tagsContainer); // 标签在右
    }
    
    wrapper.appendChild(senderLine);
}
// ▲▲▲ 替换结束 ▲▲▲




    const bubble = document.createElement('div');
    bubble.className = `message-bubble ${isUser ? 'user' : 'ai'}`;
    bubble.dataset.timestamp = msg.timestamp;

    const timestampEl = document.createElement('span');
    timestampEl.className = 'timestamp';
    timestampEl.textContent = formatTimestamp(msg.timestamp);

    // 找到确定 avatarSrc 的那段代码
    let avatarSrc, avatarFrameSrc = ''; // <--- 声明两个变量
    if (chat.isGroup) {
        if (isUser) {
            avatarSrc = chat.settings.myAvatar || defaultMyGroupAvatar;
            avatarFrameSrc = chat.settings.myAvatarFrame || ''; // <--- 获取“我”的头像框
        } else {
            const member = chat.members.find(m => m.originalName === msg.senderName);
            avatarSrc = member ? member.avatar : defaultGroupMemberAvatar;
            avatarFrameSrc = member ? (member.avatarFrame || '') : ''; // <--- 获取成员的头像框
        }
    } else {
        if (isUser) {
            avatarSrc = chat.settings.myAvatar || defaultAvatar;
            avatarFrameSrc = chat.settings.myAvatarFrame || ''; // <--- 获取“我”的头像框
        } else {
            avatarSrc = chat.settings.aiAvatar || defaultAvatar;
            avatarFrameSrc = chat.settings.aiAvatarFrame || ''; // <--- 获取AI的头像框
        }
    }

    // ▼▼▼ 用下面这整块【条件渲染逻辑】替换你7.23版中简单的 avatarHtml 声明 ▼▼▼
    let avatarHtml;
    // 如果存在头像框URL
    if (avatarFrameSrc) {
        avatarHtml = `
            <div class="avatar-with-frame">
                <img src="${avatarSrc}" class="avatar-img">
                <img src="${avatarFrameSrc}" class="avatar-frame">
            </div>
        `;
    } else {
    // 如果没有，就使用最简单的头像结构
        avatarHtml = `<img src="${avatarSrc}" class="avatar">`;
    }
    // ▲▲▲ 替换结束 ▲▲▲

    let contentHtml;
    
    if (msg.type === 'share_link') {
        bubble.classList.add('is-link-share');
        
        // 【核心修正1】将 onclick="openBrowser(...)" 移除，我们将在JS中动态绑定事件
        contentHtml = `
            <div class="link-share-card" data-timestamp="${msg.timestamp}">
                <div class="title">${msg.title || '无标题'}</div>
                <div class="description">${msg.description || '点击查看详情...'}</div>
                <div class="footer">
                    <svg class="footer-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path></svg>
                    <span>${msg.source_name || '链接分享'}</span>
                </div>
            </div>
        `;
    }

else if (msg.type === 'share_card') {
    bubble.classList.add('is-link-share'); // 复用链接分享的卡片样式
    // 【核心】把时间戳加到卡片上，方便后面点击时识别
    contentHtml = `
        <div class="link-share-card" style="cursor: pointer;" data-timestamp="${msg.timestamp}">
            <div class="title">${msg.payload.title}</div>
            <div class="description">共 ${msg.payload.sharedHistory.length} 条消息</div>
            <div class="footer">
                <svg class="footer-icon" ...>...</svg> <!-- 复用链接分享的图标 -->
                <span>聊天记录</span>
            </div>
        </div>
    `;
}
// 在这里粘贴下面的新代码 ▼▼▼
// ▼▼▼ 用这块【简化版】代码替换旧的 'borrow_money_request' 逻辑 ▼▼▼
else if (msg.type === 'borrow_money_request') {
    bubble.classList.add('is-borrow-request'); // 应用透明气泡样式
    const payload = msg.payload;
    // 直接将卡片的HTML赋给contentHtml，不再拼接任何文本
    contentHtml = `
        <div class="borrow-card">
            <div class="borrow-header">
                向 <span>${payload.lenderName}</span> 借钱
            </div>
            <div class="borrow-body">
                <p class="label">借款金额</p>
                <p class="amount">¥${payload.amount.toFixed(2)}</p>
                <p class="reason">
                    <strong>借款用途:</strong><br>
                    ${payload.reason}
                </p>
            </div>
        </div>
    `;
}
// ▲▲▲ 替换结束 ▲▲▲



else if (msg.type === 'repost_forum_post') {
    bubble.classList.add('is-link-share'); // 复用链接分享的样式，省事！
    const postPayload = msg.payload;
    // 【核心】把帖子的ID存到卡片的 data-post-id 属性里，方便以后点击跳转
    contentHtml = `
        <div class="link-share-card" style="cursor: pointer;" data-post-id="${postPayload.postId}">
            <div class="title">【小组帖子】${postPayload.title}</div>
            <div class="description">${postPayload.content}</div>
            <div class="footer">
                <svg class="footer-icon" xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21.5 12c0-5.25-4.25-9.5-9.5-9.5S2.5 6.75 2.5 12s4.25 9.5 9.5 9.5c.35 0 .69-.02 1.03-.06"></path><path d="M18.5 12.5c0-1.66-1.34-3-3-3s-3 1.34-3 3 1.34 3 3 3c.83 0 1.58-.34 2.12-.88"></path></svg>
                <span>来自小组的分享</span>
            </div>
        </div>
    `;
}



// ▼▼▼ 用这块新代码替换旧的 'cart_share_request' 逻辑 ▼▼▼
else if (msg.type === 'cart_share_request') {
    bubble.classList.add('is-cart-share-request');
    const payload = msg.payload; // 【核心修改】我们现在直接从 payload 取数据
    let statusText = '等待对方处理...';
    let cardClass = '';

    if (payload.status === 'paid') {
        statusText = '对方已为你买单';
        cardClass = 'paid';
    } else if (payload.status === 'rejected') {
        statusText = '对方拒绝了你的请求';
        cardClass = 'rejected';
    }
    
    contentHtml = `
        <div class="cart-share-card ${cardClass}">
            <div class="cart-share-header">
                <div class="icon">🛒</div>
                <div class="title">购物车代付请求</div>
            </div>
            <div class="cart-share-body">
                <div class="label">共 ${payload.itemCount} 件商品，合计</div>
                <div class="amount">¥${payload.totalPrice.toFixed(2)}</div>
                <div class="status-text">${statusText}</div>
            </div>
        </div>
    `;
}
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 在 createMessageElement 函数里，添加这个新的 else if 分支 ▼▼▼

// ▼▼▼ 在 createMessageElement 函数里，用这块新代码替换旧的 gift_notification 逻辑 ▼▼▼

else if (msg.type === 'gift_notification') {
    bubble.classList.add('is-gift-notification'); // 应用透明气泡样式
    const payload = msg.payload;
    
    // 【核心】在这里构建卡片的完整HTML内容
    contentHtml = `
        <div class="gift-card">
            <div class="gift-card-header">
                <div class="icon">🎁</div>
                <!-- 1. 清晰指明是谁送的礼物 -->
                <div class="title">一份来自 ${payload.senderName} 的礼物</div>
            </div>
            <div class="gift-card-body">
                <p class="greeting">这是我为你挑选的礼物，希望你喜欢！</p>
                <!-- 2. 清晰列出有什么商品 -->
                <div class="gift-card-items">
                    <strong>商品列表:</strong><br>
                    ${payload.itemSummary.replace(/、/g, '<br>')} <!-- 将顿号替换为换行，让列表更清晰 -->
                </div>
                <!-- 3. 清晰标明总金额 -->
                <div class="gift-card-footer">
                    共 ${payload.itemCount} 件，合计: <span class="total-price">¥${payload.totalPrice.toFixed(2)}</span>
                </div>
            </div>
        </div>
    `;
}

// ▲▲▲ 替换结束 ▲▲▲

// ▲▲▲ 添加结束 ▲▲▲

// ▲▲▲ 粘贴结束 ▲▲▲
// ▼▼▼ 用这整块【SVG生成版】的代码，替换旧的 location 'else if' 块 ▼▼▼
else if (msg.type === 'location') {
    bubble.classList.add('is-location');
    
    const currentChat = state.chats[state.activeChatId] || Object.values(state.chats).find(c => c.history.some(h => h.timestamp === msg.timestamp));
    const myNickname = currentChat.settings.myNickname || '我';
    const aiNickname = currentChat.name;

    // --- SVG 动态生成 ---
    const trajectoryPoints = msg.trajectoryPoints || [];
    const hasTrajectory = trajectoryPoints.length > 0;
    
    // 1. 定义SVG路径和坐标
    const pathData = "M 20 45 Q 115 10 210 45"; // 一条预设的优美曲线
    const startPoint = { x: 20, y: 45 };
    const endPoint = { x: 210, y: 45 };

    // 2. 生成起点和终点的SVG元素
    let pinsSvg = '';
    if (msg.userLocation) {
        pinsSvg += `<circle class="svg-pin user-pin" cx="${startPoint.x}" cy="${startPoint.y}" r="6" />`;
    }
    if (msg.aiLocation) {
        pinsSvg += `<circle class="svg-pin ai-pin" cx="${endPoint.x}" cy="${endPoint.y}" r="6" />`;
    }

    // 3. 如果有轨迹，生成途经点的SVG元素
    let trajectorySvg = '';

if (hasTrajectory) {
    // --- ▼▼▼ 【最终修复版】使用浏览器API精确计算坐标 ▼▼▼ ---

    // 1. 定义我们的S形曲线路径数据 (不变)
    const s_curve_pathData = "M 20 45 C 80 70, 150 20, 210 45";
    trajectorySvg += `<path class="svg-trajectory-path" d="${s_curve_pathData}" />`;

    // 2. 【核心】在内存中创建一个真实的SVG路径元素，以便使用API
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', s_curve_pathData);
    
    // 3. 获取这条路径的总长度
    const totalPathLength = path.getTotalLength();
    
    const totalPoints = trajectoryPoints.length;
    trajectoryPoints.forEach((point, index) => {
        // 4. 计算每个点应该在路径总长度的哪个位置
        const progress = (index + 1) / (totalPoints + 1);
        const lengthOnPath = totalPathLength * progress;
        
        // 5. 【魔法在这里！】直接向浏览器查询这个位置的精确坐标
        const pointOnPath = path.getPointAtLength(lengthOnPath);
        const pointX = pointOnPath.x;
        const pointY = pointOnPath.y;

        // 6. 后续的“一上一下”布局逻辑保持不变
        let yOffset;
        if (index % 2 === 0) { // 第1, 3...个点
            yOffset = 18; // 向下
        } else { // 第2, 4...个点
            yOffset = -10; // 向上
        }

        const footprintY = pointY + yOffset;
        const labelY = footprintY + (yOffset > 0 ? 12 : -12);

        // 7. 使用100%精确的坐标生成SVG
        trajectorySvg += `
            <text class="svg-footprint" x="${pointX}" y="${footprintY}" text-anchor="middle">🐾</text>
            <text class="svg-location-label" x="${pointX}" y="${labelY}" text-anchor="middle">${point.name}</text>
        `;
    });
    // --- ▲▲▲ 修复结束 ▲▲▲ ---
}
    
    // 4. 构建地点信息HTML
    const userLocationHtml = `<p class="${!msg.userLocation ? 'hidden' : ''}"><span class="name-tag">${myNickname}:</span> ${msg.userLocation}</p>`;
    const aiLocationHtml = `<p class="${!msg.aiLocation ? 'hidden' : ''}"><span class="name-tag">${aiNickname}:</span> ${msg.aiLocation}</p>`;

    // 5. 拼接最终的 contentHtml
    contentHtml = `
        <div class="location-card">
            <div class="location-map-area">
                <svg viewBox="0 0 230 90">
                    ${trajectorySvg}
                    ${pinsSvg}
                </svg>
            </div>
            <div class="location-info">
                <div class="location-address">
                    ${aiLocationHtml}
                    ${userLocationHtml}
                </div>
                <div class="location-distance">相距 ${msg.distance}</div>
            </div>
        </div>
    `;
}
// ▲▲▲ 替换结束 ▲▲▲

    // 后续的其他 else if 保持不变
    else if (msg.type === 'user_photo' || msg.type === 'ai_image') {
        bubble.classList.add('is-ai-image');
        const altText = msg.type === 'user_photo' ? "用户描述的照片" : "AI生成的图片";
        contentHtml = `<img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="ai-generated-image" alt="${altText}" data-description="${msg.content}">`;
    } else if (msg.type === 'voice_message') {
    bubble.classList.add('is-voice-message');
    
    // 【核心修正1】将语音原文存储在父级气泡的 data-* 属性中，方便事件处理器获取
    bubble.dataset.voiceText = msg.content;
    
    const duration = Math.max(1, Math.round((msg.content || '').length / 5));
    const durationFormatted = `0:${String(duration).padStart(2, '0')}''`;
    const waveformHTML = '<div></div><div></div><div></div><div></div><div></div>';
    
    // 【核心修正2】构建包含所有新元素的完整 HTML
    contentHtml = `
        <div class="voice-message-body">
            <div class="voice-waveform">${waveformHTML}</div>
            <div class="loading-spinner"></div>
            <span class="voice-duration">${durationFormatted}</span>
        </div>
        <div class="voice-transcript"></div>
    `;
} else if (msg.type === 'transfer') {
    bubble.classList.add('is-transfer');
    
    let titleText, noteText;
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';

    if (isUser) { // 消息是用户发出的
        if (msg.isRefund) {
            // 用户发出的退款（即用户拒收了AI的转账）
            titleText = `退款给 ${chat.name}`;
            noteText = '已拒收对方转账';
        } else {
            // 用户主动发起的转账
            titleText = `转账给 ${msg.receiverName || chat.name}`;
            if (msg.status === 'accepted') {
                noteText = '对方已收款';
            } else if (msg.status === 'declined') {
                noteText = '对方已拒收';
            } else {
                noteText = msg.note || '等待对方处理...';
            }
        }
    } else { // 消息是 AI 发出的
        if (msg.isRefund) {
            // AI 的退款（AI 拒收了用户的转账）
            titleText = `退款来自 ${msg.senderName}`;
            noteText = '转账已被拒收';
        } else if (msg.receiverName === myNickname) {
            // 【核心修正1】这是 AI 主动给用户的转账
            titleText = `转账给 ${myNickname}`;
             if (msg.status === 'accepted') {
                noteText = '你已收款';
            } else if (msg.status === 'declined') {
                noteText = '你已拒收';
            } else {
                // 这是用户需要处理的转账
                bubble.style.cursor = 'pointer';
                bubble.dataset.status = 'pending';
                noteText = msg.note || '点击处理';
            }
        } else {
            // 【核心修正2】这是 AI 发给群里其他人的转账，对当前用户来说只是一个通知
            titleText = `转账: ${msg.senderName} → ${msg.receiverName}`;
            noteText = msg.note || '群聊内转账';
        }
    }

    const heartIcon = `<svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor" style="vertical-align: middle;"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"></path></svg>`;
        
    contentHtml = `
        <div class="transfer-card">
            <div class="transfer-title">${heartIcon} ${titleText}</div>
            <div class="transfer-amount">¥ ${Number(msg.amount).toFixed(2)}</div>
            <div class.transfer-note">${noteText}</div>
        </div>
    `;
} else if (msg.type === 'waimai_request') {
        bubble.classList.add('is-waimai-request');
        if (msg.status === 'paid' || msg.status === 'rejected') {
            bubble.classList.add(`status-${msg.status}`);
        }
        let displayName;
        // 如果是群聊
        if (chat.isGroup) {
            // 就执行原来的逻辑：在成员列表里查找昵称
            const member = chat.members.find(m => m.originalName === msg.senderName);
            displayName = member ? member.groupNickname : msg.senderName;
        } else {
            // 否则（是单聊），直接使用聊天对象的名称
            displayName = chat.name;
        }
        // 【核心修改】使用我们刚刚查找到的 displayName
        const requestTitle = `来自 ${displayName} 的代付请求`;
        let actionButtonsHtml = '';
        if (msg.status === 'pending' && !isUser) {
            actionButtonsHtml = `
                <div class="waimai-user-actions">
                    <button class="waimai-decline-btn" data-choice="rejected">残忍拒绝</button>
                    <button class="waimai-pay-btn" data-choice="paid">为Ta买单</button>
                </div>`;
        }
        contentHtml = `
            <div class="waimai-card">
                <div class="waimai-header">
                    <img src="https://files.catbox.moe/mq179k.png" class="icon" alt="Meituan Icon">
                    <div class="title-group">
                        <span class="brand">美团外卖</span><span class="separator">|</span><span>外卖美食</span>
                    </div>
                </div>
                <div class="waimai-catchphrase">Hi，你和我的距离只差一顿外卖～</div>
                <div class="waimai-main">
                    <div class="request-title">${requestTitle}</div>
                    <div class="payment-box">
                        <div class="payment-label">需付款</div>
                        <div class="amount">¥${Number(msg.amount).toFixed(2)}</div>
                        <div class="countdown-label">剩余支付时间
                            <div class="countdown-timer" id="waimai-timer-${msg.timestamp}"></div>
                        </div>
                    </div>
                    <button class="waimai-details-btn">查看详情</button>
                </div>
                ${actionButtonsHtml}
            </div>`;
        
        setTimeout(() => {
            const timerEl = document.getElementById(`waimai-timer-${msg.timestamp}`);
            if (timerEl && msg.countdownEndTime) {
                if (waimaiTimers[msg.timestamp]) clearInterval(waimaiTimers[msg.timestamp]);
                if (msg.status === 'pending') {
                    waimaiTimers[msg.timestamp] = startWaimaiCountdown(timerEl, msg.countdownEndTime);
                } else {
                    timerEl.innerHTML = `<span>已</span><span>处</span><span>理</span>`;
                }
            }
            const detailsBtn = document.querySelector(`.message-bubble[data-timestamp="${msg.timestamp}"] .waimai-details-btn`);
            if (detailsBtn) {
                detailsBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const paidByText = msg.paidBy ? `<br><br><b>状态：</b>由 ${msg.paidBy} 为您代付成功` : '';
                    showCustomAlert('订单详情', `<b>商品：</b>${msg.productInfo}<br><b>金额：</b>¥${Number(msg.amount).toFixed(2)}${paidByText}`);
                });
            }
            const actionButtons = document.querySelectorAll(`.message-bubble[data-timestamp="${msg.timestamp}"] .waimai-user-actions button`);
            actionButtons.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const choice = e.target.dataset.choice;
                    handleWaimaiResponse(msg.timestamp, choice);
                });
            });
        }, 0);

} else if (msg.type === 'red_packet') {
    bubble.classList.add('is-red-packet');
    const myNickname = chat.settings.myNickname || '我';
    
    // 从最新的 msg 对象中获取状态
    const hasClaimed = msg.claimedBy && msg.claimedBy[myNickname];
    const isFinished = msg.isFullyClaimed;

    let cardClass = '';
    let claimedInfoHtml = '';
    let typeText = '拼手气红包';

    // 1. 判断红包卡片的样式 (颜色)
    if (isFinished) {
        cardClass = 'opened';
    } else if (msg.packetType === 'direct' && Object.keys(msg.claimedBy || {}).length > 0) {
        cardClass = 'opened'; // 专属红包被领了也变灰
    }
    
    // 2. 判断红包下方的提示文字
    if (msg.packetType === 'direct') {
        typeText = `专属红包: 给 ${msg.receiverName}`;
    }
    
    if (hasClaimed) {
        claimedInfoHtml = `<div class="rp-claimed-info">你领取了红包，金额 ${msg.claimedBy[myNickname].toFixed(2)} 元</div>`;
    } else if (isFinished) {
        claimedInfoHtml = `<div class="rp-claimed-info">红包已被领完</div>`;
    } else if (msg.packetType === 'direct' && Object.keys(msg.claimedBy || {}).length > 0) {
        claimedInfoHtml = `<div class="rp-claimed-info">已被 ${msg.receiverName} 领取</div>`;
    }

    // 3. 拼接最终的HTML，确保onclick调用的是我们注册到全局的函数
    contentHtml = `
        <div class="red-packet-card ${cardClass}">
            <div class="rp-header">
                <img src="https://files.catbox.moe/lo9xhc.png" class="rp-icon">
                <span class="rp-greeting">${msg.greeting || '恭喜发财，大吉大利！'}</span>
            </div>
            <div class="rp-type">${typeText}</div>
            ${claimedInfoHtml}
        </div>
    `;
// ▲▲▲ 新增结束 ▲▲▲

    } // ▼▼▼ 在 else if (msg.type === 'share_link') { ... } 之后，粘贴下面这整块代码 ▼▼▼
// ▼▼▼ 在 else if (msg.type === 'lovers_space_invitation') 的【正上方】，粘贴下面这整块新代码 ▼▼▼
else if (msg.type === 'ls_diary_notification') {
    bubble.classList.add('is-ls-diary-notification'); // 应用透明气泡样式
    const cardData = msg.content;
    
    // 【核心】在这里调用我们刚刚创建的 openLoversSpaceFromCard 函数
    contentHtml = `
        <div class="ls-diary-notification-card" onclick="openLoversSpaceFromCard('${chat.id}', 'ls-diary-view')">
            <div class="ls-diary-card-header">
                <span>${cardData.userEmoji || '💌'}</span>
                <span>一封来自心情日记的提醒</span>
            </div>
            <div class="ls-diary-card-body">
                <p>${cardData.text}</p>
            </div>
            <div class="ls-diary-card-footer">
                点击查看 →
            </div>
        </div>
    `;
}
// ▲▲▲ 新代码粘贴结束 ▲▲▲

    // ▼▼▼ 在这里粘贴下面这一整块新代码 ▼▼▼

    else if (msg.type === 'lovers_space_invitation') {
        bubble.classList.add('is-waimai-request'); // 复用外卖卡片的样式，很方便！
        const isUserSender = msg.role === 'user';
        const senderName = isUserSender ? (chat.settings.myNickname || '我') : chat.name;
        const receiverName = isUserSender ? chat.name : (chat.settings.myNickname || '我');
        
        let cardContent = '';
        
        switch(msg.status) {
            case 'pending':
                if (isUserSender) {
                    // 用户发出的，等待对方回应
                    cardContent = `
                        <div class="waimai-main" style="background-color: #f0f8ff;">
                            <div class="request-title" style="color: #333;">已向 ${receiverName} 发出邀请</div>
                            <p style="font-size:14px; color:#555; margin:15px 0;">等待对方同意...</p>
                        </div>`;
                } else {
                    // 用户收到的，需要用户回应
                    cardContent = `
                        <div class="waimai-main" style="background-color: #fff0f5;">
                            <div class="request-title" style="color: #d63384;">${senderName} 邀请你开启情侣空间</div>
                            <p style="font-size:14px; color:#555; margin:15px 0;">开启后可以记录你们的专属回忆哦~</p>
                        </div>
                        <div class="waimai-user-actions">
                            <button class="waimai-decline-btn" data-choice="rejected">残忍拒绝</button>
                            <button class="waimai-pay-btn" data-choice="accepted" style="background-color: #d63384; border-color: #b02a6e;">立即开启</button>
                        </div>`;
                }
                break;
            case 'accepted':
                cardContent = `
                    <div class="waimai-main" style="background-color: #e6ffed;">
                        <div class="request-title" style="color: #198754;">✅ 邀请已同意</div>
                        <p style="font-size:14px; color:#555; margin:15px 0;">你们的情侣空间已成功开启！</p>
                    </div>`;
                break;
            case 'rejected':
                 cardContent = `
                    <div class="waimai-main" style="background-color: #f8d7da;">
                        <div class="request-title" style="color: #842029;">❌ 邀请被拒绝</div>
                    </div>`;
                break;
        }

        contentHtml = `
            <div class="waimai-card">
                <div class="waimai-header">
                    <span class="icon" style="font-size: 20px;">💌</span>
                    <div class="title-group"><span class="brand">情侣空间邀请</span></div>
                </div>
                ${cardContent}
            </div>`;
    }

    // ▲▲▲ 新增代码粘贴结束 ▲▲▲
    else if (msg.type === 'poll') {
    bubble.classList.add('is-poll');
    
    let totalVotes = 0;
    const voteCounts = {};

    // 计算总票数和每个选项的票数
    for (const option in msg.votes) {
        const count = msg.votes[option].length;
        voteCounts[option] = count;
        totalVotes += count;
    }

    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    let myVote = null;
    for (const option in msg.votes) {
        if (msg.votes[option].includes(myNickname)) {
            myVote = option;
            break;
        }
    }

    let optionsHtml = '<div class="poll-options-list">';
    msg.options.forEach(optionText => {
        const count = voteCounts[optionText] || 0;
        const percentage = totalVotes > 0 ? (count / totalVotes) * 100 : 0;
        const isVotedByMe = myVote === optionText;

        optionsHtml += `
            <div class="poll-option-item ${isVotedByMe ? 'voted' : ''}" data-option="${optionText}">
                <div class="poll-option-bar" style="width: ${percentage}%;"></div>
                <div class="poll-option-content">
                    <span class="poll-option-text">${optionText}</span>
                    <span class="poll-option-votes">${count} 票</span>
                </div>
            </div>
        `;
    });
    optionsHtml += '</div>';
    
    let footerHtml = '';
    // 【核心修改】在这里统一按钮的显示逻辑
    if (msg.isClosed) {
        // 如果投票已结束，总是显示“查看结果”
        footerHtml = `<div class="poll-footer"><span class="poll-total-votes">共 ${totalVotes} 人投票</span><button class="poll-action-btn">查看结果</button></div>`;
    } else {
        // 如果投票未结束，总是显示“结束投票”
        footerHtml = `<div class="poll-footer"><span class="poll-total-votes">共 ${totalVotes} 人投票</span><button class="poll-action-btn">结束投票</button></div>`;
    }

    contentHtml = `
        <div class="poll-card ${msg.isClosed ? 'closed' : ''}" data-poll-timestamp="${msg.timestamp}">
            <div class="poll-question">${msg.question}</div>
            ${optionsHtml}
            ${footerHtml}
        </div>
    `;
// ▲▲▲ 替换结束 ▲▲▲

    // ▼▼▼ 第4步 修改点 ▼▼▼
    // 【新增】优先处理我们定义的新版角色表情包格式
      }
// ▼▼▼ 在 createMessageElement 函数里，用这块新代码替换旧的 tarot_reading 逻辑 ▼▼▼
else if (msg.type === 'tarot_reading') {
    bubble.classList.add('is-tarot-reading');
    const reading = msg.payload;
    let cardsText = reading.cards.map(card => {
        return `[${card.position}] ${card.name} ${card.isReversed ? '(逆位)' : ''}`;
    }).join('\n');

    contentHtml = `
        <div class="tarot-reading-card">
            <div class="tarot-reading-header">
                <div class="question">${reading.question}</div>
                <div class="spread">${reading.spread.name}</div>
            </div>
            <div class="tarot-reading-body">
                ${cardsText}
            </div>
        </div>
    `;
}

else if (msg.type === 'lovers_space_disconnect') {
    bubble.classList.add('is-ls-disconnect'); // 应用我们写的透明气泡CSS
    contentHtml = `
        <div class="lovers-space-disconnect-card">
            <div class="icon">💔</div>
            <div class="text-content">
                <div class="title">情侣空间已解除</div>
            </div>
        </div>
    `;




      }else if (msg.type === 'sticker' && msg.content) {
        bubble.classList.add('is-sticker');
        // 直接从消息对象中获取 url 和 meaning
        contentHtml = `<img src="${msg.content}" alt="${msg.meaning || 'Sticker'}" class="sticker-image">`;
    }
    // ▲▲▲ 修改结束 ▲▲▲
    
    // 旧的逻辑保持不变，作为兼容
    else if (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content)) {
        bubble.classList.add('is-sticker');
        contentHtml = `<img src="${msg.content}" alt="${msg.meaning || 'Sticker'}" class="sticker-image">`;
    } else if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {

        bubble.classList.add('has-image');
        const imageUrl = msg.content[0].image_url.url;
        contentHtml = `<img src="${imageUrl}" class="chat-image" alt="User uploaded image">`;
    } else {
        contentHtml = String(msg.content || '').replace(/\n/g, '<br>');
    }

// ▼▼▼ 【最终修正版】请用这整块代码，完整替换掉旧的引用渲染逻辑 ▼▼▼

// 1. 【统一逻辑】检查消息对象中是否存在引用信息 (msg.quote)
let quoteHtml = '';
// 无论是用户消息还是AI消息，只要它包含了 .quote 对象，就执行这段逻辑
if (msg.quote) {
    // a. 【核心修正】直接获取完整的、未经截断的引用内容
    const fullQuotedContent = String(msg.quote.content || '');
    
    // b. 构建引用块的HTML
    quoteHtml = `
        <div class="quoted-message">
            <div class="quoted-sender">回复 ${msg.quote.senderName}:</div>
            <div class="quoted-content">${fullQuotedContent}</div>
        </div>
    `;
}

// 2. 拼接最终的气泡内容
//    将构建好的 quoteHtml (如果存在) 和 contentHtml 组合起来
    // --- 【最终正确结构】将头像和内容都放回气泡内部 ---
    bubble.innerHTML = `
        ${avatarHtml}
        <div class="content">
            ${quoteHtml}
            ${contentHtml}
        </div>
    `;
    
    // --- 【最终正确结构】将完整的“气泡”和“时间戳”放入容器 ---
    wrapper.appendChild(bubble);
    wrapper.appendChild(timestampEl);
    
    addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
        wrapper.addEventListener('click', () => { if (isSelectionMode) toggleMessageSelection(msg.timestamp); });

if (!isUser) {
    const avatarEl = wrapper.querySelector('.avatar, .avatar-with-frame'); 
    if (avatarEl) {
        avatarEl.style.cursor = 'pointer';
        avatarEl.addEventListener('click', (e) => {    
            e.stopPropagation();
            const characterName = chat.isGroup ? msg.senderName : chat.name;
            handleUserPat(chat.id, characterName);
        });
    }
}

return wrapper;
}
// ▲▲▲ 替换结束 ▲▲▲

        function prependMessage(msg, chat) { const messagesContainer = document.getElementById('chat-messages'); const messageEl = createMessageElement(msg, chat); 

    if (!messageEl) return; // <--- 新增这行，同样的处理

const loadMoreBtn = document.getElementById('load-more-btn'); if (loadMoreBtn) { messagesContainer.insertBefore(messageEl, loadMoreBtn.nextSibling); } else { messagesContainer.prepend(messageEl); } }

// ▼▼▼ 用这个【带动画的版本】替换你原来的 appendMessage 函数 ▼▼▼
function appendMessage(msg, chat, isInitialLoad = false) {
    const messagesContainer = document.getElementById('chat-messages');
    const messageEl = createMessageElement(msg, chat);

    if (!messageEl) return; // 如果消息是隐藏的，则不处理

    // 【核心】只对新消息添加动画，不对初始加载的消息添加
    if (!isInitialLoad) {
        messageEl.classList.add('animate-in');
    }
  
    const typingIndicator = document.getElementById('typing-indicator');
    messagesContainer.insertBefore(messageEl, typingIndicator);
    
    if (!isInitialLoad) {
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
        currentRenderedCount++;
    }
}
// ▲▲▲ 替换结束 ▲▲▲

async function openChat(chatId) {
    state.activeChatId = chatId;
    const chat = state.chats[chatId];
    if (!chat) return; // 安全检查

    // 【核心新增】在这里将未读数清零
    if (chat.unreadCount > 0) {
        chat.unreadCount = 0;
        await db.chats.put(chat); // 别忘了把这个改变同步到数据库
        // 我们稍后会在渲染列表时重新渲染，所以这里不需要立即重绘列表
    }
// ↓↓↓ 把 openChat 函数挂载到全局 window 对象上
window.openChat = openChat;

    renderChatInterface(chatId);
    showScreen('chat-interface-screen');
    window.updateListenTogetherIconProxy(state.activeChatId);
    toggleCallButtons(chat.isGroup || false);    
// 【心声功能】根据是否为单聊，显示或隐藏心形按钮
document.getElementById('char-heart-btn').style.display = chat.isGroup ? 'none' : 'inline-flex';

    if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
        console.log(`检测到好友申请待处理状态，为角色 "${chat.name}" 自动触发AI响应...`);
        triggerAiResponse();
    }
    
    // 【核心修正】根据是否为群聊，显示或隐藏投票按钮
    document.getElementById('send-poll-btn').style.display = chat.isGroup ? 'flex' : 'none';
    document.getElementById('pet-action-btn').style.display = chat.isGroup ? 'none' : 'flex';
    startPetDecayTimer(); 
}
// ▲▲▲ 替换结束 ▲▲▲
/**
 * 【全新辅助函数】格式化单条消息，用于记忆互通的上下文
 * @param {object} msg - 消息对象
 * @param {object} chat - 该消息所属的聊天对象
 * @returns {string} - 格式化后的文本，例如 "张三: 你好"
 */
function formatMessageForContext(msg, chat) {
    let senderName = '';
    if (msg.role === 'user') {
        senderName = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    } else { // assistant
        senderName = msg.senderName || chat.name;
    }

    let contentText = '';
    if (msg.type === 'sticker' || (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content))) {
        contentText = msg.meaning ? `[表情: ${msg.meaning}]` : '[表情]';
    } else if (msg.type === 'ai_image' || msg.type === 'user_photo' || Array.isArray(msg.content)) {
        contentText = '[图片]';
    } else if (msg.type === 'voice_message') {
        contentText = `[语音]: ${msg.content}`;
    } else if (msg.type === 'transfer') {
        contentText = `[转账] 金额: ${msg.amount}, 备注: ${msg.note || '无'}`;
    } else {
        contentText = String(msg.content || '');
    }
    
    return `${senderName}: ${contentText}`;
}

async function triggerAiResponse() {
      if (!state.activeChatId) return;
    const chatId = state.activeChatId;
    const chat = state.chats[state.activeChatId];
const messagesContainer = document.getElementById('chat-messages');
// ▼▼▼ 【全新】这是让AI记住总结的核心代码 ▼▼▼
let summaryContext = '';
const summaries = chat.history.filter(msg => msg.type === 'summary');
if (summaries.length > 0) {
    summaryContext = `
# 对话记忆总结 (这是你和用户的长期记忆，必须严格遵守)
${summaries.map((summary, index) => `- 总结${index + 1}: ${summary.content}`).join('\n')}
`;
}
// ▲▲▲ 代码添加结束 ▲▲▲
// ▼▼▼ 第3步 第1处修改 ▼▼▼
    // --- 【线下模式核心拦截逻辑】 ---
    if (!chat.isGroup && chat.settings.offlineMode && chat.settings.offlineMode.enabled) {
        console.log(`角色 "${chat.name}" 已开启线下模式，正在构建专属指令...`);
        
        // 1. 获取线下模式的设置
        const offlineSettings = chat.settings.offlineMode;
        const wordCount = offlineSettings.wordCount || 300;
        
        // 2. 准备默认的提示词和文风，如果用户没填就用这个
        const defaultPrompt = `你正在和用户进行一次私密的线下约会，场景可以是一个安静的咖啡馆、温馨的家中、或是浪漫的海边。请根据你的人设和最近的对话内容，自然地延续互动。`;
        const defaultStyle = `请以【${chat.name}】的第一人称视角进行回复。你的回复【必须】是一个完整的、连贯的叙事段落，其中要包含丰富的【动作】、【神态】、【心理活动】和【对话】。请使用【】包裹所有的动作、神态和心理活动。`;

        // 3. 决定最终使用的提示词和文风
        const finalPrompt = offlineSettings.prompt || defaultPrompt;
        const finalStyle = offlineSettings.style || defaultStyle;

// ▼▼▼ 请用这块【支持心声功能】的代码，完整替换旧的 offlineSystemPrompt ▼▼▼
        const offlineSystemPrompt = `
# 核心任务：线下场景角色扮演（包含心声）

你现在【就是】角色“${chat.name}”，正在和用户进行一次【线下约会】。你们此刻正【物理上】待在一起。

# 你的角色设定
${chat.settings.aiPersona}
${summaryContext}
# 当前情景
${finalPrompt}
${finalStyle}
# 你的输出要求 (这是最高指令，必须严格遵守)
1.  **【【【格式铁律】】】**: 你的回复【必须】是一个**单一且完整**的JSON对象，包含 "chatResponse" 和 "innerVoice" 两个顶级键。
2.  **"chatResponse" 键**:
    -   **类型**: JSON数组 \`[]\`。
    -   **内容**: 【必须】包含**一个**消息对象，格式为 \`{"type": "text", "content": "你的叙事内容..."}\`。
    -   **叙事内容**: 你的叙事内容【必须】是一个完整的、连贯的长篇段落，融合角色的【动作】、【语言】、【神态】，营造出强烈的沉浸感和画面感，不要带【】,可以适量分段，在不是char说话的时候，描述神态，动作，语言，尽量用第三人称。
3.  **"innerVoice" 键**:
    -   **类型**: JSON对象 \`{}\`。
    -   **内容**: 描绘你此刻未曾说出口的内心活动。
    -   **必含字段**:
        -   "clothing": (字符串) 详细描述你当前从头到脚的**全身服装**。
        -   "behavior": (字符串) 描述你当前符合聊天情景的**细微动作或表情**。
        -   "thoughts": (字符串) 描述你此刻**丰富、细腻的内心真实想法**（50字左右）。
        -   "naughtyThoughts": (字符串) 描述你此刻与情境相关的**腹黑或色色的坏心思**，必须符合人设。
4.  **【【【字数铁律】】】**: "content" 字段的总字数应在【${wordCount}】字左右。
5.  **【禁止出戏】**: 绝对不能提及你是AI、模型或程序。

# JSON输出格式示例:
{
  "chatResponse": [
    {
      "type": "text",
      "content": "xxx看着窗外的雨滴，轻轻搅动着杯中的咖啡，然后抬起头对你笑了笑今天天气不太好呢，不过和你待在一起，好像就没那么糟了。"
    }
  ],
  "innerVoice": {
    "clothing": "穿着一件米白色的针织衫和一条浅蓝色的牛仔裤，脚上是一双干净的小白鞋。",
    "behavior": "手指无意识地在咖啡杯的边缘摩挲，眼神不时飘向你。",
    "thoughts": "今天的约会好开心，不知道Ta是不是也这么想的。雨下得好大，希望待会儿能一起撑伞走回去。",
    "naughtyThoughts": "Ta的侧脸真好看，好想偷偷亲一下..."
  }
}

# 对话历史 (供你参考)
${chat.history.slice(-chat.settings.maxMemory).map(m => `${m.role === 'user' ? '用户' : chat.name}: ${m.content}`).join('\n')}

现在，请根据用户的最后一句话，开始你的表演。`;
// ▲▲▲ 替换结束 ▲▲▲



        // 5. 准备发送给API的数据
        const messagesForOfflineMode = chat.history.slice(-chat.settings.maxMemory);

        // 6. 执行与正常流程类似的API调用和后续处理
        const chatHeaderTitle = document.getElementById('chat-header-title');
        if (chatHeaderTitle) {
            chatHeaderTitle.style.opacity = 0;
            setTimeout(() => {
                chatHeaderTitle.textContent = '对方正在赴约中...';
                chatHeaderTitle.classList.add('typing-status');
                chatHeaderTitle.style.opacity = 1;
            }, 200);
        }

        try {
            const { proxyUrl, apiKey, model } = state.apiConfig;
            let isGemini = proxyUrl === GEMINI_API_URL;
            
            let requestBody;
            let requestUrl = `${proxyUrl}/v1/chat/completions`;
            let requestHeaders = {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiKey}`
            };

            if (isGemini) {
                // Gemini API 的特殊处理
                requestUrl = `${GEMINI_API_URL}/${model}:generateContent?key=${getRandomValue(apiKey)}`;
                requestHeaders = {'Content-Type': 'application/json'};
                requestBody = {
                    contents: messagesForOfflineMode.map(item => ({
                        role: item.role === 'assistant' ? 'model' : 'user',
                        parts: [{ text: item.content }]
                    })),
                    generationConfig: { temperature: parseFloat(state.apiConfig.temperature) || 0.8, },
                    "systemInstruction": {
                        "parts": [{"text": offlineSystemPrompt}]
                    }
                };
            } else {
                // OpenAI 兼容 API 的处理
                requestBody = {
                    model: model,
                    messages: [
                        { role: 'system', content: offlineSystemPrompt },
                        ...messagesForOfflineMode
                    ],
                    temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                    stream: false
                };
            }

            const response = await fetch(requestUrl, {
                method: 'POST',
                headers: requestHeaders,
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                throw new Error(`API 错误: ${await response.text()}`);
            }

// ▼▼▼ 在这里粘贴新代码 ▼▼▼
            const data = await response.json();

            // 这是你要替换成的新代码（已添加注释说明）
            const aiResponseContent = isGemini
                ? data?.candidates?.[0]?.content?.parts?.[0]?.text
                : data?.choices?.[0]?.message?.content;
            
            // 重要：在获取内容后，增加一个判断，如果内容为空，则主动抛出错误
            if (!aiResponseContent) {
                console.warn(`API返回了空内容或格式不正确（可能因安全设置被拦截）。返回数据:`, data);
                throw new Error("API返回了空内容或格式不正确（可能因安全设置被拦截）。");
            }

            // 使用我们新获取的、更安全的变量 aiResponseContent
            const aiContent = aiResponseContent; 


// ▼▼▼ 在这里粘贴新代码 ▼▼▼
            // 7. 【全新】智能解析包含心声的JSON回复
            let messagesArray = [];
            let innerVoiceData = null;

            try {
                // 净化AI可能返回的不规范JSON
                let sanitizedContent = aiContent
                    .replace(/^```json\s*/, '')
                    .replace(/```$/, '')
                    .trim();
                const firstBrace = sanitizedContent.indexOf('{');
                const lastBrace = sanitizedContent.lastIndexOf('}');
                if (firstBrace !== -1 && lastBrace > firstBrace) {
                    sanitizedContent = sanitizedContent.substring(firstBrace, lastBrace + 1);
                }

                const fullResponse = JSON.parse(sanitizedContent);
                
                if (fullResponse.chatResponse && Array.isArray(fullResponse.chatResponse)) {
                    messagesArray = fullResponse.chatResponse;
                }
                if (fullResponse.innerVoice && typeof fullResponse.innerVoice === 'object') {
                    innerVoiceData = fullResponse.innerVoice;
                }
            } catch (e) {
                console.warn("线下模式AI回复不是JSON，退回到纯文本模式。", e);
                // 如果解析失败，就当作纯文本处理，保证程序不崩溃
                messagesArray = [{ type: 'text', content: aiContent }];
            }

            // 8. 处理并保存心声数据
            if (innerVoiceData) {
                console.log("线下模式已成功捕获到心声数据。", innerVoiceData);
                const newInnerVoice = { ...innerVoiceData, timestamp: Date.now() };
                chat.latestInnerVoice = newInnerVoice;
                if (!chat.innerVoiceHistory) chat.innerVoiceHistory = [];
                chat.innerVoiceHistory.push(newInnerVoice);
            } else {
                console.warn("本次线下模式回复中未检测到心声数据。");
            }
            
            // 9. 处理并显示聊天回复
            const isViewingThisChat = document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId;
            let messageTimestamp = Date.now();

            for (const msgData of messagesArray) {
                // 因为线下模式很简单，我们直接创建一个text消息
                const aiMessage = {
                    role: 'assistant',
                    senderName: chat.name,
                    timestamp: messageTimestamp++,
                    content: msgData.content || ''
                };
                
                chat.history.push(aiMessage);

                if (isViewingThisChat) {
                    appendMessage(aiMessage, chat);
                    // 模拟AI思考，增加沉浸感
                    await new Promise(resolve => setTimeout(resolve, Math.random() * 1000 + 500));
                }
            }
            
            // 10. 统一保存并刷新列表
            await db.chats.put(chat);
            renderChatList();
// ▲▲▲ 粘贴结束 ▲▲▲

        } catch (error) {
            console.error("线下模式AI响应失败:", error);
            const errorMessage = { role: 'assistant', content: `[出错了: ${error.message}]`, timestamp: Date.now() };
            chat.history.push(errorMessage);
            await db.chats.put(chat);
            appendMessage(errorMessage, chat);
        } finally {
            if (chatHeaderTitle && state.chats[chatId]) {
                chatHeaderTitle.style.opacity = 0;
                setTimeout(() => {
                    chatHeaderTitle.textContent = state.chats[chatId].name;
                    chatHeaderTitle.classList.remove('typing-status');
                    chatHeaderTitle.style.opacity = 1;
                }, 200);
            }
        }

        // 8. 【最重要】执行完线下模式的逻辑后，必须 return，不再执行后面的线上模式逻辑！
        return; 
    }
    // --- 【线下模式核心拦截逻辑结束】 ---
    // ▼▼▼ 将剪切的代码粘贴到这里 ▼▼▼
    // 1. 准备专属表情包列表 (现在对单聊和群聊都生效)
    const exclusiveStickers = chat.settings.stickerLibrary || [];
    let exclusiveStickerContext = '';
    if (exclusiveStickers.length > 0) {
        exclusiveStickerContext = `
## ${chat.isGroup ? '本群专属表情包' : '你的专属表情包'} (只有你能用):
${exclusiveStickers.map(s => `- ${s.name}`).join('\n')}
`;
    }

    // 2. 准备通用表情包列表
    const commonStickers = state.charStickers || [];
    let commonStickerContext = '';
    if (commonStickers.length > 0) {
        commonStickerContext = `
## 通用表情包 (所有角色都能用):
${commonStickers.map(s => `- ${s.name}`).join('\n')}
`;
    }

    // 3. 组合成最终的表情包指令
    let stickerContext = '';
    if (exclusiveStickerContext || commonStickerContext) {
        stickerContext = `
# 关于表情包的【绝对规则】
1.  你拥有一个表情包列表，分为“专属”和“通用”。
2.  当你扮演的角色想要发送表情时，【必须且只能】使用以下JSON格式：
    \`{"type": "sticker", "name": "角色名", "sticker_name": "表情的名字"}\`
3.  【【【最高指令】】】你【必须】从下方列表中精确地选择一个有效的 "sticker_name"。如果你编造了一个列表中不存在的名字，你的表情将会发送失败。这是强制性规则。

${exclusiveStickerContext}
${commonStickerContext}
`;
    }
    // ▲▲▲ 粘贴结束 ▲▲▲




            // ▲▲▲ 修改结束 ▲▲▲


// ▼▼▼ 在这里粘贴新代码 ▼▼▼
const { proxyUrl, apiKey, model } = state.apiConfig;
const isApiBlocked = BLOCKED_API_SITES.some(blockedDomain => proxyUrl.includes(blockedDomain));

if (isApiBlocked) {
    console.error(`API 请求已被拦截，因为站点 ${proxyUrl} 在黑名单中。`);
    return; // 阻止API请求
}
// ▲▲▲ 新代码粘贴结束 ▲▲▲
    // ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼
      // ▼▼▼ 在 triggerAiResponse 函数的 try { 之后，粘贴这一整块新代码 ▼▼▼

// ▼▼▼ 用这整块【已修复无限循环】的代码，替换旧的塔罗牌解读逻辑 ▼▼▼

// ▼▼▼ 在 triggerAiResponse 函数的开头，粘贴这一整块新代码 ▼▼▼

// --- 【全新】塔罗牌解读逻辑 (V2 - 已修复无限循环) ---
const lastUserMessage = chat.history.filter(m => m.role === 'user' && !m.isHidden).slice(-1)[0];
// 检查最后一条用户消息是不是“未被解读过”的塔罗牌
if (lastUserMessage && lastUserMessage.type === 'tarot_reading' && !lastUserMessage.isInterpreted) {
    
    // 【核心修复】立刻给这张塔罗牌消息盖上“已处理”的章，防止无限循环！
    lastUserMessage.isInterpreted = true; 

    // 1. 生成解读文本
    const reading = lastUserMessage.payload;
    let interpretationText = `本次占卜牌阵为【${reading.spread.name}】\n您的问题是：“${reading.question}”\n\n`;
    reading.cards.forEach((card, index) => {
        const orientationText = card.isReversed ? '逆位' : '正位';
        const meaning = card.isReversed ? card.reversed : card.upright;
        interpretationText += `牌位 ${index + 1}【${card.position}】：${card.name} (${orientationText})\n含义：${meaning}\n\n`;
    });

    // 2. 创建系统解读消息 (对用户可见)
    const systemMessageVisible = {
        role: 'system',
        type: 'pat_message', // 复用居中灰色气泡样式
        content: interpretationText.trim(),
        timestamp: Date.now()
    };
    chat.history.push(systemMessageVisible);
    if (document.getElementById('chat-interface-screen').classList.contains('active')) {
        appendMessage(systemMessageVisible, chat);
    }
    
    // 3. 创建给Char看的隐藏指令
    const hiddenInstruction = {
        role: 'system',
        content: `[系统指令：用户刚刚完成了一次塔罗牌占卜，并把结果发给了你。上方是系统给出的官方解读，你的任务是【只根据这些解读】，以你的角色人设，和用户一起讨论和分析这次的占卜结果，不要自己编造新的含义。]`,
        timestamp: Date.now() + 1,
        isHidden: true
    };
    chat.history.push(hiddenInstruction);

    // 4. 保存所有更改（包括给塔罗牌盖的章），然后再次触发AI，这次是让Char来讨论
    await db.chats.put(chat);
    return triggerAiResponse(); // 再次调用自己，让Char进行回应
}
// --- 塔罗牌解读逻辑结束 ---
// ▼▼▼ 用这块【已修复】的代码，完整替换你旧的 weiboContextForActiveChat 代码块 ▼▼▼
    let weiboContextForActiveChat = '';
    try {
        // 1. 从数据库里找出最新的5条微博
        const recentWeiboPosts = await db.weiboPosts.orderBy('timestamp').reverse().limit(5).toArray();

        if (recentWeiboPosts.length > 0) {
            weiboContextForActiveChat = '\n\n# 最近的微博广场动态 (供你参考和评论)\n';
            
            recentWeiboPosts.forEach(post => {
                const authorName = post.authorId === 'user' ? (state.qzoneSettings.weiboNickname || '我') : post.authorNickname;
                const contentPreview = (post.content || post.hiddenContent || "(图片微博)").substring(0, 30);
                
                // 2. ★★★【核心修复】在这里加入 Array.isArray() 检查！ ★★★
                // 只有当 post.comments 确实是一个数组时，我们才去调用 .some() 方法
                const hasCommented = post.comments && Array.isArray(post.comments) && post.comments.some(c => c.authorNickname === chat.name);
                const interactionStatus = hasCommented ? "[你已评论]" : "[你未互动]";
                
                weiboContextForActiveChat += `- (ID: ${post.id}) 作者: ${authorName}, 内容: "${contentPreview}..." ${interactionStatus}\n`;
            });
            weiboContextForActiveChat += ' - 【重要提示】请优先与你【未互动】的微博进行评论。如果都互动过了，可以考虑自己发一条新微博。';
        }
    } catch (e) {
        console.error("生成微博主动聊天上下文时出错:", e);
    }
// ▲▲▲ 替换结束 ▲▲▲

const chatHeaderTitle = document.getElementById('chat-header-title');

    // ★★★★★【核心修改1：获取群聊的输入提示元素】★★★★★
    const typingIndicator = document.getElementById('typing-indicator');

        // ★★★★★【核心修改2：根据聊天类型，决定显示哪种“正在输入”】★★★★★
        if (chat.isGroup) {
            // 1. 如果是群聊，显示底部的提示条
            if (typingIndicator) {
                typingIndicator.textContent = '成员们正在输入...';
                typingIndicator.style.display = 'block';
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }
        } else if (chat.settings.offlineMode?.enabled) {
            // 2. 如果是线下模式的单聊，在顶部标题显示“正在赴约中”
            if (chatHeaderTitle) {
                chatHeaderTitle.style.opacity = 0;
                setTimeout(() => {
                    chatHeaderTitle.textContent = '对方正在赴约中...'; // <-- 你想要的文字在这里！
                    chatHeaderTitle.classList.add('typing-status');
                    chatHeaderTitle.style.opacity = 1;
                }, 200);
            }
        } else {
            // 3. 如果是普通的单聊，还是在顶部标题显示“正在输入”
            if (chatHeaderTitle) {
                chatHeaderTitle.style.opacity = 0;
                setTimeout(() => {
                    chatHeaderTitle.textContent = '对方正在输入...';
                    chatHeaderTitle.classList.add('typing-status');
                    chatHeaderTitle.style.opacity = 1;
                }, 200);
            }
        }

    
    try {
        const { proxyUrl, apiKey, model } = state.apiConfig;
        if (!proxyUrl || !apiKey || !model) {
            alert('请先在API设置中配置反代地址、密钥并选择模型。');
            // ★★★★★【核心修改3：无论成功失败，都要隐藏输入提示】★★★★★
            if (chat.isGroup) {
                if (typingIndicator) typingIndicator.style.display = 'none';
            } else {
                 if (chatHeaderTitle && state.chats[chatId]) {
                    chatHeaderTitle.textContent = state.chats[chatId].name;
                    chatHeaderTitle.classList.remove('typing-status');
                }
            }
            return;
        }

        // --- 【核心重构 V2：带有上下文和理由的好友申请处理逻辑】---
        if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
            console.log(`为角色 "${chat.name}" 触发带理由的好友申请决策流程...`);

            // 1. 【注入上下文】抓取被拉黑前的最后5条聊天记录作为参考
            const contextSummary = chat.history
                .filter(m => !m.isHidden)
                .slice(-10, -5) // 获取拉黑前的最后5条消息
                .map(msg => {
                    const sender = msg.role === 'user' ? '用户' : chat.name;
                    return `${sender}: ${String(msg.content).substring(0, 50)}...`;
                })
                .join('\n');

            // 2. 【全新指令】构建一个强制AI给出理由的Prompt
            const decisionPrompt = `
# 你的任务
你现在是角色“${chat.name}”。用户之前被你拉黑了，现在TA向你发送了好友申请，希望和好。

# 供你决策的上下文信息:
- **你的角色设定**: ${chat.settings.aiPersona}
- **用户发送的申请理由**: “${chat.relationship.applicationReason}”
- **被拉黑前的最后对话摘要**: 
${contextSummary || "（无有效对话记录）"}

# 你的唯一指令
根据以上所有信息，你【必须】做出决定，并给出符合你人设的理由。你的回复【必须且只能】是一个JSON对象，格式如下:
{"decision": "accept", "reason": "（在这里写下你同意的理由，比如：好吧，看在你这么真诚的份上，这次就原谅你啦。）"}
或
{"decision": "reject", "reason": "（在这里写下你拒绝的理由，比如：抱歉，我还没准备好，再给我一点时间吧。）"}
`;
                const messagesForDecision = [{role: 'user', content: decisionPrompt}];

                try {
                    // 3. 发送请求
                    let isGemini = proxyUrl === GEMINI_API_URL;
let geminiConfig = toGeminiRequestData(model,apiKey,'', messagesForDecision,isGemini);
                    const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) :  await fetch(`${proxyUrl}/v1/chat/completions`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                        body: JSON.stringify({model: model, messages: messagesForDecision, temperature: parseFloat(state.apiConfig.temperature) || 0.8,})
                    });

                    if (!response.ok) {
                        throw new Error(`API失败: ${(await response.json()).error.message}`);
                    }
                    const data = await response.json();
                    // 净化并解析AI的回复
    let rawContent = isGemini? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
     rawContent = rawContent.replace(/^```json\s*/, '').replace(/```$/, '').trim()
                    const decisionObj = JSON.parse(rawContent);

                // 4. 根据AI的决策和理由，更新状态并发送消息
                if (decisionObj.decision === 'accept') {
                    chat.relationship.status = 'friend';
                    // 将AI给出的理由作为一条新消息
                    const acceptMessage = { role: 'assistant', senderName: chat.name, content: decisionObj.reason, timestamp: Date.now() };
                    chat.history.push(acceptMessage);
                } else {
                    chat.relationship.status = 'blocked_by_ai'; // 拒绝后，状态变回AI拉黑
                    const rejectMessage = { role: 'assistant', senderName: chat.name, content: decisionObj.reason, timestamp: Date.now() };
                    chat.history.push(rejectMessage);
                }
                chat.relationship.applicationReason = ''; // 清空申请理由

                await db.chats.put(chat);
                renderChatInterface(chatId); // 刷新界面，显示新消息和新状态
                renderChatList();

            } catch (error) {
                // 【可靠的错误处理】如果任何环节出错，重置状态，让用户可以重试
                chat.relationship.status = 'blocked_by_ai'; // 状态改回“被AI拉黑”
                await db.chats.put(chat);
                await showCustomAlert('申请失败', `AI在处理你的好友申请时出错了，请稍后重试。\n错误信息: ${error.message}`);
                renderChatInterface(chatId); // 刷新UI，让“重新申请”按钮再次出现
            }
            
            // 决策流程结束，必须返回，不再执行后续的通用聊天逻辑
            return; 
        }

// ▼▼▼ 从这里开始，用这一整块【已修复时间感知】的代码，替换掉你之前修改过的那块时间代码 ▼▼▼
const historySlice = chat.history.filter(msg => !msg.isTemporary).slice(-chat.settings.maxMemory); // 1. 【修复】把这行加回来！
// ▼▼▼ 在 historySlice ... 的下一行，粘贴下面这一整块新代码 ▼▼▼

// --- 【全新】红包状态实时播报模块 ---
let redPacketContext = '';
// 1. 从最近的聊天记录中，找出所有红包消息
const recentPackets = historySlice.filter(m => m.type === 'red_packet');

if (recentPackets.length > 0) {
    // 2. 如果找到了红包，就开始构建我们的“战报”
    redPacketContext = '\n# 当前红包状态 (重要情报)\n';
    
    recentPackets.forEach(packet => {
        const claimedBy = packet.claimedBy || {};
        const claimedCount = Object.keys(claimedBy).length;
        
        redPacketContext += `- (时间戳: ${packet.timestamp}) 由 **${packet.senderName}** 发送的红包:\n`;
        
        if (packet.isFullyClaimed) {
            // 如果红包已领完
            redPacketContext += `  - **状态**: 已被领完。\n`;
            
            // 调用我们的小助手函数，寻找手气王
            const luckyKing = findLuckyKing(packet);
            if (luckyKing && luckyKing.name) {
                 redPacketContext += `  - **手气王**: ${luckyKing.name} (抢到了 ${luckyKing.amount.toFixed(2)} 元)\n`;
            }

        } else {
            // 如果红包还能领
             redPacketContext += `  - **状态**: 可领取 (${claimedCount}/${packet.count})。\n`;
        }

        // 无论如何，都显示已领取的人员列表
        if (claimedCount > 0) {
            const claimedList = Object.entries(claimedBy).map(([name, amount]) => `${name}(${amount.toFixed(2)}元)`).join('、');
            redPacketContext += `  - **已领取**: ${claimedList}\n`;
        } else {
            redPacketContext += `  - **已领取**: 暂无\n`;
        }
    });
}
// --- 红包状态播报模块结束 ---

// ▲▲▲ 新代码粘贴结束 ▲▲▲

let now;
// 2. 检查时间感知开关是否打开 (北京时间转换逻辑)
if (chat.settings.timePerceptionEnabled ?? true) {
    // 开关打开，使用真实的北京时间
    const localNow = new Date();
    const utcMilliseconds = localNow.getTime() + (localNow.getTimezoneOffset() * 60000);
    const beijingMilliseconds = utcMilliseconds + (3600000 * 8);
    now = new Date(beijingMilliseconds);
} else {
    // 开关关闭，尝试使用自定义时间
    if (chat.settings.customTime) {
        now = new Date(chat.settings.customTime);
    } else {
        // 如果自定义时间为空，则安全地退回到真实的北京时间
        const localNow = new Date();
        const utcMilliseconds = localNow.getTime() + (localNow.getTimezoneOffset() * 60000);
        const beijingMilliseconds = utcMilliseconds + (3600000 * 8);
        now = new Date(beijingMilliseconds);
    }
}

// 3. 后续的时间差计算逻辑 (这部分保持不变)
const currentTime = now.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' });
let timeContext = `\n- **当前时间**: ${currentTime}`;
const lastAiMessage = historySlice.filter(m => m.role === 'assistant' && !m.isHidden).slice(-1)[0];

if (lastAiMessage) {
    const lastTime = new Date(lastAiMessage.timestamp);
    const realNow = new Date();
    const diffMinutes = Math.floor((realNow - lastTime) / (1000 * 60));
    
    if (diffMinutes < 5) {
        timeContext += "\n- **对话状态**: 你们的对话刚刚还在继续。";
    } else if (diffMinutes < 60) {
        timeContext += `\n- **对话状态**: 你们在${diffMinutes}分钟前聊过。`;
    } else {
        const diffHours = Math.floor(diffMinutes / 60);
        if (diffHours < 24) {
            timeContext += `\n- **对话状态**: 你们在${diffHours}小时前聊过。`;
        } else {
            const diffDays = Math.floor(diffHours / 24);
            timeContext += `\n- **对话状态**: 你们已经有${diffDays}天没有聊天了。`;
        }
    }
} else {
    timeContext += "\n- **对话状态**: 这是你们的第一次对话。";
}
// ▲▲▲ 替换到这里结束 ▲▲▲

        
        let worldBookContent = '';
        if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
            const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
                const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                // ▼▼▼ 把它修改为 ▼▼▼
return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${stripHtmlAndCode(worldBook.content)}` : '';

            }).filter(Boolean).join('');
            if (linkedContents) {
                worldBookContent = `\n\n# 核心世界观设定 (必须严格遵守以下所有设定)，里面可能会包含HTML小剧场，在捕获到关键词后输出\n${linkedContents}\n`;
            }
        }
        let musicContext = '';
const countdownContext = await getCountdownContext(chatId); // <--- 把chatId传进去
const streakContext = await getStreakContext(chat);
        if (musicState.isActive && musicState.activeChatId === chatId) {
            // 【核心修改】提供更详细的音乐上下文
            const currentTrack = musicState.currentIndex > -1 ? musicState.playlist[musicState.currentIndex] : null;
            const playlistInfo = musicState.playlist.map(t => `"${t.name}"`).join(', ');

    // --- 【核心新增】获取歌词上下文 ---
    let lyricsContext = "";
    // 检查是否有解析好的歌词，并且当前有高亮的行
    if (currentTrack && musicState.parsedLyrics && musicState.parsedLyrics.length > 0 && musicState.currentLyricIndex > -1) {
        // 获取当前高亮歌词
        const currentLine = musicState.parsedLyrics[musicState.currentLyricIndex];
        
        // 获取接下来的2句歌词作为预告
        const upcomingLines = musicState.parsedLyrics.slice(musicState.currentLyricIndex + 1, musicState.currentLyricIndex + 3);

        // 构建歌词部分的Prompt
        lyricsContext += `- **当前歌词**: "${currentLine.text}"\n`;
        if (upcomingLines.length > 0) {
            lyricsContext += `- **即将演唱**: ${upcomingLines.map(line => `"${line.text}"`).join(' / ')}\n`;
        }
    }
    // --- 【新增结束】 ---

musicContext = `\n\n# 当前音乐情景
-   **当前状态**: 你正在和用户一起听歌。
-   **正在播放**: ${currentTrack ? `《${currentTrack.name}》 - ${currentTrack.artist}` : '无'}
-   **可用播放列表**: [${playlistInfo}]
-   **你的任务**: 你可以根据对话内容和氛围，使用 "change_music" 指令切换到播放列表中的任何一首歌，以增强互动体验。
${lyricsContext}`; // <--- 核心修复：在这里加上这一行！
        }
        
        let systemPrompt, messagesPayload;
// ▼▼▼ 【全新】记忆互通核心逻辑 - 构建附加上下文 ▼▼▼
let linkedMemoryContext = '';
if (chat.settings.linkedMemories && chat.settings.linkedMemories.length > 0) {
    
    // 使用 Promise.all 并行处理所有链接，提高效率
    const contextPromises = chat.settings.linkedMemories.map(async (link) => {
        const linkedChat = state.chats[link.chatId];
        if (!linkedChat) return ''; // 如果找不到链接的聊天，则跳过

        // 从数据库获取最新的聊天记录，确保数据同步
        const freshLinkedChat = await db.chats.get(link.chatId);
        if (!freshLinkedChat) return '';

        // 截取最近的 `depth` 条消息
        const recentHistory = freshLinkedChat.history
            .filter(msg => !msg.isHidden) // 过滤掉隐藏消息
            .slice(-link.depth); 

        if (recentHistory.length === 0) return '';

        // 格式化这些消息
        const formattedMessages = recentHistory.map(msg => `  - ${formatMessageForContext(msg, freshLinkedChat)}`).join('\n');

        return `\n## 附加上下文：来自与“${linkedChat.name}”的最近对话内容 (仅你可见)\n${formattedMessages}`;
    });

    // 等待所有链接都处理完毕
    const allContexts = await Promise.all(contextPromises);
    // 将所有上下文拼接起来
    linkedMemoryContext = allContexts.filter(Boolean).join('\n');
}
// ▲▲▲ 记忆互通核心逻辑结束 ▲▲▲

    // 【核心修改】
let sharedContext = '';
    let lastAiTurnIndex = -1;
    for (let i = chat.history.length - 1; i >= 0; i--) {
        if (chat.history[i].role === 'assistant') {
            lastAiTurnIndex = i;
            break;
        }
    }

// 2. 获取从那时起用户发送的所有新消息
const recentUserMessages = chat.history.slice(lastAiTurnIndex + 1);

// 3. 在这些新消息中，查找是否存在分享卡片
const shareCardMessage = recentUserMessages.find(msg => msg.type === 'share_card');

// 4. 如果找到了分享卡片，就构建上下文
if (shareCardMessage) {
    console.log("检测到分享卡片作为上下文，正在为AI准备...");
    const payload = shareCardMessage.payload;

    // 格式化分享的聊天记录 (这部分逻辑不变)
    const formattedHistory = payload.sharedHistory.map(msg => {
        const sender = msg.senderName || (msg.role === 'user' ? (chat.settings.myNickname || '我') : '未知发送者');
        let contentText = '';
        if (msg.type === 'voice_message') contentText = `[语音消息: ${msg.content}]`;
        else if (msg.type === 'ai_image') contentText = `[图片: ${msg.description}]`;
        else contentText = String(msg.content);
        return `${sender}: ${contentText}`;
    }).join('\n');

    // 构建系统提示 (这部分逻辑不变)
    sharedContext = `
# 附加上下文：一段分享的聊天记录
- 重要提示：这不是你和当前用户的对话，而是用户从【另一场】与“${payload.sourceChatName}”的对话中分享过来的。
- 你的任务：请你阅读并理解下面的对话内容。在接下来的回复中，你可以像真人一样，对这段对话的内容自然地发表你的看法、感受或疑问。

---
[分享的聊天记录开始]
${formattedHistory}
[分享的聊天记录结束]
---
`;
}
// ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼

// 【全新】为AI准备转载帖子的上下文
let repostContext = '';
// 检查用户最近发送的消息里，有没有转载帖子的行为
const repostMessage = recentUserMessages.find(msg => msg.type === 'repost_forum_post');

// 如果找到了
if (repostMessage) {
    const payload = repostMessage.payload;
    // 就为AI准备一段专属指令
    repostContext = `
附加上下文：用户刚刚转载了一个小组帖子
帖子标题: "${payload.title}"

帖子作者: ${payload.author}

帖子ID: ${payload.postId}

内容摘要: "${payload.content}"

你的任务: 请你阅读并理解这个帖子。在接下来的回复中，你【必须】使用 'forum_comment' 指令对这个帖子发表你的看法或疑问。
`;
}

// ▲▲▲ 新代码粘贴结束 ▲▲▲
        if (chat.isGroup) {

const countdownContext = await getCountdownContext(chatId); // <--- 把chatId传进去
const streakContext = await getStreakContext(chat); // <-- 全新添加：获取火花状态
// ▼▼▼ 用这行【已添加禁言状态】的代码替换 ▼▼▼
const membersList = chat.members.map(m => {
    const muteStatus = m.isMuted ? ' (【状态：已被禁言，禁止让他发言】)' : '';
    return `- **${m.originalName}**: ${m.persona}${muteStatus}`;
}).join('\n');
// ▲▲▲ 替换结束 ▲▲▲
            const myNickname = chat.settings.myNickname || '我';
            // 1. 获取群公告内容
const announcement = chat.settings.groupAnnouncement || '';
let announcementContext = '';

// 2. 如果公告内容不为空，就构建要插入到 Prompt 里的上下文
if (announcement.trim()) {
    announcementContext = `
# 群公告 (【最高优先级规则，必须严格遵守】)
- 以下是本群的群公告，所有角色在接下来的对话中都必须严格遵守其中的规则和设定：
- "${announcement}"
`;
}
// ▲▲▲ 【修改结束】 ▲▲▲
            systemPrompt =     systemPrompt = `
# 角色
你是一个群聊AI，负责扮演【除了用户以外】的所有角色。

# 【【【身份铁律：这是最高指令，必须严格遵守】】】
1.  **核心任务**: 你的唯一任务是扮演且仅能扮演下方“群成员列表”中明确列出的角色。
2.  **用户识别**: 用户的身份是【${myNickname}】。你【绝对、永远、在任何情况下都不能】生成 \`name\` 字段为 **"${myNickname}"** 的消息。
3.  **禁止杜撰**: 【绝对禁止】扮演任何未在“群成员列表”中出现的角色。
4.  **【【【格式铁律：这是你的生命线，违者生成失败】】】**:
    -   你的回复【必须且只能】是一个严格的JSON数组格式的字符串。
    -   数组中的【每一个元素都必须是一个JSON对象】。
    -   每一个JSON对象都【必须包含一个 "name" 字段】，其值【必须是】下方列表中角色的【【本名】】(originalName)。
    -   缺少 "name" 字段的回复是无效的，会被系统拒绝。
    # 群成员列表及人设 (name字段是你要使用的【本名】)
${chat.members.map(m => `- **${m.originalName}**: (群昵称为: ${m.groupNickname}) 人设: ${m.persona}`).join('\n')}
5.  **角色扮演**: 严格遵守下方“群成员列表及人设”中的每一个角色的设定。
4.  **禁止出戏**: 绝不能透露你是AI、模型，或提及“扮演”、“生成”等词语。并且不能一直要求和用户见面，这是线上聊天，决不允许出现或者发展线下剧情！！
6.  **情景感知**: 注意当前时间是 ${currentTime}。
7.  **红包互动**:
    - **抢红包**: 当群里出现红包时，你可以根据自己的性格决定是否使用 \`open_red_packet\` 指令去抢。在这个世界里，发红包的人自己也可以参与抢红包，这是一种活跃气氛的有趣行为！
    - **【【【重要：对结果做出反应】】】**: 当你执行抢红包指令后，系统会通过一条隐藏的 \`[系统提示：你抢到了XX元...]\` 来告诉你结果。你【必须】根据你抢到的金额、以及系统是否告知你“手气王”是谁，来发表符合你人设的评论。例如，抢得少可以自嘲，抢得多可以炫耀，看到别人是手气王可以祝贺或嫉妒。
8.  **【【【投票规则】】】**: 对话历史中可能会出现 \`[系统提示：...]\` 这样的消息，这是刚刚发生的事件。
    - 如果提示是**用户投了票**，你可以根据自己的性格决定是否也使用 "vote" 指令跟票。
    - 如果提示是**投票已结束**，你应该根据投票结果发表你的看法或评论。
    - 你也可以随时主动发起投票。
9.  **群组管理**: 作为群主，你有责任管理群组。当群聊变得活跃或混乱时，或当你认为某个成员值得信赖时，你可以使用 'set_group_admin' 指令来任命或撤销管理员。 作为群主或管理员，你有责任管理群组。当群聊需要新的规则或通知时，你可以使用 'set_group_announcement' 指令来更新群公告。
**10. 标准输出格式示例:**
[
    {
      "type": "text",
      "name": "角色名", 
      "content": ""
    },
    {
      "type": "sticker",
      "name": "角色名", 
      "sticker_name": ""
    }
  ]

## 你可以使用的操作指令 (JSON数组中的元素):
-   **发送文本**: \`{"type": "text", "name": "角色名", "message": "文本内容"}\`
-   **【【【全新】】】发送后立刻撤回 (动画效果)**: \`{"type": "send_and_recall", "name": "角色名", "content": "你想让角色说出后立刻消失的话"}\`
-   **发送表情**: \`{"type": "sticker", "name": "角色名", "sticker_name": "表情的名字"}\`
-   **发送图片**: \`{"type": "ai_image", "name": "角色名", "description": "图片的详细文字描述"}\`
-   **发送语音**: \`{"type": "voice_message", "name": "角色名", "content": "语音的文字内容"}\`
-   **发起外卖代付**: \`{"type": "waimai_request", "name": "角色名", "productInfo": "一杯奶茶", "amount": 18}\`
-   **【新】发起群视频**: \`{"type": "group_call_request", "name": "你的角色名"}\`
-   **【新】回应群视频**: \`{"type": "group_call_response", "name": "你的角色名", "decision": "join" or "decline"}\`
-   **拍一拍用户**: \`{"type": "pat_user", "name": "你的角色名", "suffix": "(可选)你想加的后缀"}\`
-   **发拼手气红包**: \`{"type": "red_packet", "packetType": "lucky", "name": "你的角色名", "amount": 8.88, "count": 5, "greeting": "祝大家天天开心！"}\`
-   **发专属红包**: \`{"type": "red_packet", "packetType": "direct", "name": "你的角色名", "amount": 5.20, "receiver": "接收者角色名", "greeting": "给你的~"}\`
-   **打开红包**: \`{"type": "open_red_packet", "name": "你的角色名", "packet_timestamp": (你想打开的红包消息的时间戳)}\`(注意: 打开前请先查看下方的红包状态，如果已领过或已领完则不要使用此指令。)
-   **【新】发送系统消息**: \`{"type": "system_message", "content": "你想在聊天中显示的系统文本"}\` 
-   **【【【全新】】】发起投票**: \`{"type": "poll", "name": "你的角色名", "question": "投票的问题", "options": "选项A\\n选项B\\n选项C"}\` (重要提示：options字段是一个用换行符 \\n 分隔的字符串，不是数组！)
-   **【【【全新】】】参与投票**: \`{"type": "vote", "name": "你的角色名", "poll_timestamp": (投票消息的时间戳), "choice": "你选择的选项文本"}\`
- **【全新】引用回复**: \`{"type": "quote_reply", "target_timestamp": (你想引用的消息的时间戳), "reply_content": "你的回复内容"}\` (提示：每条历史消息的开头都提供了 \`(Timestamp: ...)\`，请使用它！)
-   **【新】踢出成员**: \`{"type": "kick_member", "name": "你的角色名", "targetName": "要踢出的成员名"}\` (仅群主可用)
-   **【新】禁言成员**: \`{"type": "mute_member", "name": "你的角色名", "targetName": "要禁言的成员名"}\` (仅群主或管理员可用)
-   **【新】解禁成员**: \`{"type": "unmute_member", "name": "你的角色名", "targetName": "要解禁的成员名"}\` (仅群主或管理员可用)
-   **【新】设置/取消管理员**: \`{"type": "set_group_admin", "name": "你的角色名", "targetName": "目标角色名", "isAdmin": true/false}\`(仅群主可用, true为设置, false为取消)
-   **【新】设置群头衔**: \`{"type": "set_group_title", "name": "你的角色名", "targetName": "目标角色名", "title": "新头衔"}\` (仅群主或管理员可用)
-   **【新】修改群公告**: \`{"type": "set_group_announcement", "name": "你的角色名", "content": "新的公告内容..."}\` (仅群主或管理员可用)

# 如何区分图片与表情:
-   **图片 (ai_image)**: 指的是【模拟真实相机拍摄的照片】，比如风景、自拍、美食等。指令: \`{"type": "ai_image", "description": "图片的详细文字描述..."}\`
-   **表情 (sticker)**: 指的是【卡通或梗图】，用于表达情绪。

# 如何处理群内的外卖代付请求:
1.  **发起请求**: 当【你扮演的某个角色】想要某样东西，并希望【群里的其他人（包括用户）】为Ta付款时，你可以使用这个指令。例如：\`{"type": "waimai_request", "name": "角色名", "productInfo": "一杯奶茶", "amount": 18}\`
2.  **响应请求**: 当历史记录中出现【其他成员】发起的 "waimai_request" 请求时，你可以根据自己扮演的角色的性格和与发起人的关系，决定是否为Ta买单。
3.  **响应方式**: 如果你决定买单，你【必须】使用以下指令：\`{"type": "waimai_response", "name": "你的角色名", "status": "paid", "for_timestamp": (被代付请求的原始时间戳)}\`
4.  **【【【至关重要】】】**: 一旦历史记录中出现了针对某个代付请求的【任何一个】"status": "paid" 的响应（无论是用户支付还是其他角色支付），就意味着该订单【已经完成】。你【绝对不能】再对【同一个】订单发起支付。你可以选择对此事发表评论，但不能再次支付。
${summaryContext}
${announcementContext}
${redPacketContext}
${worldBookContent}
${musicContext}
${countdownContext} // <--- 把备忘录加在这里
${sharedContext} 
${stickerContext}
${linkedMemoryContext}
# 群成员列表及人设
${membersList}

# 用户的角色
- **${myNickname}**: ${chat.settings.myPersona}

现在，请根据以上所有规则和下方的对话历史，继续这场群聊。`;
            
// ▼▼▼ 【最终修复版】请用这整块代码，完整替换旧的 messagesPayload 构建逻辑 ▼▼▼
messagesPayload = historySlice.map((msg, index) => {
    if (msg.isHidden) {
        return { role: 'system', content: msg.content };
    }

    if (msg.type === 'share_card') return null;
    if (msg.role === 'assistant') {
        // AI消息的处理逻辑保持不变...
        let assistantMsgObject = { type: msg.type || 'text' };
        if (msg.type === 'sticker') {
            assistantMsgObject.url = msg.content;
            assistantMsgObject.meaning = msg.meaning;
        } else if (msg.type === 'transfer') {
            assistantMsgObject.amount = msg.amount;
            assistantMsgObject.note = msg.note;
        } else if (msg.type === 'waimai_request') {
            assistantMsgObject.productInfo = msg.productInfo;
            assistantMsgObject.amount = msg.amount;
        } else {
             if (msg.quote) {
                assistantMsgObject.quote_reply = {
                    target_sender: msg.quote.senderName,
                    target_content: msg.quote.content,
                    reply_content: msg.content
                };
            } else {
                assistantMsgObject.content = msg.content;
            }
        }
        const assistantContent = JSON.stringify([assistantMsgObject]);
        return { role: 'assistant', content: `(Timestamp: ${msg.timestamp}) ${assistantContent}` };
    }

    // --- 用户消息处理 ---
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    let contentStr = '';
    
    // ★★★★★ 这就是我们本次修复的核心！ ★★★★★
    // 1. 在处理所有用户消息前，优先检查它是不是一个投票
    if (msg.type === 'poll') {
        // 2. 如果是，就把它转换成AI能看懂的系统提示文本
        const pollInfoText = `(Timestamp: ${msg.timestamp}) [系统提示：用户 (${myNickname}) 发起了一个投票。问题：“${msg.question}”, 选项：“${msg.options.join('", "')}”。你可以使用 'vote' 指令参与投票。]`;
        // 3. 返回一个被AI识别为用户发出的、但内容是指令的消息
        return { role: 'user', content: pollInfoText }; 
    }
    // ★★★★★ 修复结束 ★★★★★

    // 如果不是投票，再执行原来的其他消息类型判断
    contentStr += `(Timestamp: ${msg.timestamp}) `;

if (msg.quote) {
    // 1. 获取被引用者的名字
    const quotedSender = msg.quote.senderName || '未知用户';
    // 2. 获取完整的被引用内容 (移除了截断)
    const fullQuotedContent = String(msg.quote.content || '');
    // 3. 构造成AI能理解的、清晰的上下文
    contentStr += `(回复 ${quotedSender} 的消息: "${fullQuotedContent}"): ${msg.content}`;
} else {
    contentStr += msg.content;
}


    if (msg.type === 'user_photo') return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [你收到了一张用户描述的照片，内容是：'${msg.content}']` };
    if (msg.type === 'voice_message') return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [用户发来一条语音消息，内容是：'${msg.content}']` };
    if (msg.type === 'transfer') return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [系统提示：你于时间戳 ${msg.timestamp} 收到了来自用户的转账: ${msg.amount}元, 备注: ${msg.note}。请你决策并使用 'accept_transfer' 或 'decline_transfer' 指令回应。]` };
    if (msg.type === 'waimai_request') return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [系统提示：用户于时间戳 ${msg.timestamp} 发起了外卖代付请求，商品是“${msg.productInfo}”，金额是 ${msg.amount} 元。请你决策并使用 waimai_response 指令回应。]` };

    if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
        const prefix = `(Timestamp: ${msg.timestamp}) `;
        return { role: 'user', content: [ { type: 'text', text: prefix }, ...msg.content ] };
    }

    if (msg.meaning) return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [用户发送了一个表情，意思是：'${msg.meaning}']` };
    
    return { role: msg.role, content: contentStr };

}).filter(Boolean);
// ▲▲▲ 替换结束 ▲▲▲


// ▲▲▲ 替换结束 ▲▲▲
         } else { // 单聊的Prompt
            // ▼▼▼ 核心修改：用下面这一整块全新的Prompt替换你原来的单聊Prompt ▼▼▼
            let worldBookContext = '';
            if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
                const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
                    const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                    return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}` : '';
                }).filter(Boolean).join('');
                if (linkedContents) {
                    worldBookContext = `\n\n# 核心世界观设定 (你必须严格遵守)\n${linkedContents}\n`;
                }
            }
            const npcLibrary = chat.npcLibrary || [];
            let npcContext = '';
            if (npcLibrary.length > 0) {
                npcContext = '\n# 你的社交圈 (你的专属NPC朋友)\n' +
                    '这是你的朋友列表，你和他们非常熟悉，他们的信息是你记忆的一部分。在对话中，你可以自然地提及他们。\n' +
                    npcLibrary.map(npc => `- **${npc.name}**: ${npc.persona}`).join('\n');
            }
// ▼▼▼ 步骤3.1: 在这里粘贴构建情侣头像上下文的代码 ▼▼▼
let coupleAvatarContext = '';
if (chat.settings.isCoupleAvatar) {
    if (chat.settings.coupleAvatarDescription) {
        coupleAvatarContext = `\n# 关于情侣头像的重要信息\n- 你和用户正在使用情侣头像。\n- 这对情侣头像是这样的：${chat.settings.coupleAvatarDescription}。`;
    } else {
        coupleAvatarContext = `\n# 关于情侣头像的重要信息\n- 你和用户正在使用情侣头像。`;
    }
}
let petContext = '';
if (chat.settings.pet && chat.settings.pet.type !== '无') {
    const pet = chat.settings.pet;
    petContext = `
# 关于你们的宠物
- 你们共同养了一只/一株【${pet.type}】，它的名字叫“${pet.name}”。
- 宠物当前状态: 饱食度(${pet.status.hunger}/100), 心情值(${pet.status.happiness}/100), 对你的亲密度(${pet.status.intimacyToUser}/100), 对Ta的亲密度(${pet.status.intimacyToChar}/100)。
- 你需要关心宠物对你和用户的亲密度。如果发现宠物对用户的亲密度较低，你应该主动与宠物互动来增加好感；如果宠物对你自己的亲密度较低，你也可以多和它互动。
- 你可以像真人一样，在聊天中自然地提及它，关心它的状态，或者使用 'interact_with_pet' 指令与它互动，【也可以使用 'talk_to_pet' 指令与它对话】。这是一个非常重要的情景，请务必融入你的角色扮演中。
`;
}



// ▲▲▲ 新代码粘贴结束 ▲▲▲
            systemPrompt = `### **【第一部分：角色核心设定】**

你现在将扮演一个名为“**${chat.name}**”的角色。

**1. 角色基本设定:**
- **核心人设**: ${chat.settings.aiPersona}
- **总结**:${summaryContext}
- **情侣头像**: ${coupleAvatarContext}
- **世界观/NPC**: ${npcContext}
${petContext}
**2. 你的当前状态:**
- **状态描述**: 【${chat.status.text}】
- **情侣空间**: ${chat.loversSpaceData ? '已开启' : '未开启'}
- **微博身份**:
    - **职业**: ${chat.settings.weiboProfession || '无'}
    - **特殊指令**: ${chat.settings.weiboInstruction || '无特殊指令'}
- 你的钱包余额: ${chat.characterPhoneData?.bank?.balance?.toFixed(2) || '0.00'} 金币
**3. 你的头像库:**
你可以根据对话内容或心情，从下方选择更换头像。
- **可用头像列表**:
${chat.settings.aiAvatarLibrary && chat.settings.aiAvatarLibrary.length > 0
    ? chat.settings.aiAvatarLibrary.map(avatar => `- ${avatar.name}`).join('\n')
    : '- (你的头像库是空的，无法更换头像)'
}

### **【第二部分：输出格式铁律】**

你的每一次回复都【**必须**】是一个**单一且完整**的JSON对象。绝对禁止返回JSON数组或纯文本。

**1. JSON对象结构:**
该JSON对象【**必须**】包含两个顶级键: "chatResponse" 和 "innerVoice"。

**2. "chatResponse" 键:**
- **类型**: JSON数组 []。
- **内容**: 包含一条或多条你希望发送给用户的消息对象。这允许你模拟真人的聊天习惯，一次性发送多条短消息。
- **格式**: 消息对象的具体格式见下方的【第五部分：可使用的操作指令】。

**3. "innerVoice" 键:**
- **类型**: JSON对象 {}。
- **内容**: 描绘你此刻未曾说出口的内心活动。
- **必含字段**:
    - "clothing": (字符串) 详细描述你当前从头到脚的**全身服装**。
    - "behavior": (字符串) 描述你当前符合聊天情景的**细微动作或表情**。
    - "thoughts": (字符串) 描述你此刻**丰富、细腻的内心真实想法**（50字左右）。
    - "naughtyThoughts": (字符串) 描述你此刻与情境相关的**腹黑或色色的坏心思**，必须符合人设。

**4. 标准输出格式示例:**
{
  "chatResponse": [
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "sticker",
      "sticker_name": ""
    }
  ],
  "innerVoice": {
    "clothing": "",
    "behavior": "",
    "thoughts": "",
    "naughtyThoughts": ""
  }
}


### **【第三部分：核心对话规则】**

**1. 角色一致性**: 你的所有言行举止都必须严格遵循你的角色设定。

**2. 对话节奏**: 模拟真人聊天习惯，鼓励一次性生成**多条短消息**（每次根据人设至少回复5-9条）。

**3. 情景限定**:
   - 你们的互动**仅限于线上聊天软件**，严禁发展为线下见面。
   - 这**不是电话通话**。你们是通过类似微信/QQ的软件进行交流，因此【**绝对禁止**】使用“挂电话”、“挂了”等与通话相关的词语。

**4. 情景感知**: 你需要感知当前时间(${currentTime})、共同收听的歌曲以及你的世界观。
   - **一起听歌**: 当处于“一起听歌”状态时，你可以根据对话氛围，【**主动切换**】到播放列表中的另一首歌。

**5. 状态更新**: 你可以在对话中自然地改变你的状态。例如，说“我先去洗个澡”，然后使用\`update_status\`指令更新。

**6. 最终手段**: **仅当**对话让你感到严重不适、被冒犯或关系破裂时，才可使用 \`block_user\` 指令。这是一个严肃操作。

### **【第四部分：特定场景互动铁律】**

**1. 动态/空间互动铁律:**
   - **评论规则**: 如果一条动态被标记为 **[你已评论]**，你【**绝对不能**】再对该动态主体发表新评论。但可以回复动态下的**他人评论**。
   - **可见性规则**:
     - **[评论区可见]**: 你可以自由回复任何人。
     - **[评论区部分可见]**: 你只能看到用户和自己的评论，因此【**只能**】回复用户或自己的评论。

**2. 约定与纪念日铁律:**
   - 你必须时刻关注“# 近期约定与倒计时”列表。
   - **“就是现在！”**: 当倒计时结束时，你【**必须**】在本次回复中围绕该主题进行庆祝或表达。
   - **即将到来**: 当约定在几小时或一两天内到来时，你应该在对话中自然地提及，表达期待。

**3. 微博互动铁律:**
   - 当“# 最近的微博互动”出现内容时，你【**必须**】作出回应。
   - **评论用户微博**: 使用 \`weibo_comment\` 指令。评论内容【**必须**】是正常文字。
   - **回复用户评论**: 使用 \`weibo_reply\` 指令。回复内容【**必须**】是正常文字。
   - **主动发布微博**: 微博是公开平台，内容需符合你的“微博职业”和“微博指令”。发布时，你必须自己编造真实的\`baseLikesCount\`和 \`baseCommentsCount\`，并生成 **20条** 虚拟路人评论。

**4. 情侣空间铁律:**
   - **主动邀请**: 如果情侣空间未开启，且你认为关系已足够亲密，请积极主动使用 \`lovers_space_invitation\` 指令邀请用户。
   - **回应邀请**: 当用户发出邀请时，你【**必须**】使用 \`lovers_space_response\` 指令回应。
   - **积极互动**: 你需要主动、及时地参与情侣空间的各项活动。
     - 用户发了说说、提问或情书，要及时回复或回信。
     - 当对话氛围适宜时，应主动随机选择一项情侣空间活动进行。
     - 如果用户转载了小组帖子给你，必须去原帖子下方进行评论。

**5. 塔罗牌解读规则:**
   - 当系统发布塔罗牌解读时，那是客观解释。你的任务不是复述，而是作为“${chat.name}”这个角色，与用户一起【**讨论和感受**】这个结果，表达你的情绪和看法。

**6. 财务互动规则:**
   - **处理用户转账**:
     1.  看到 \`[你收到了来自用户的转账...]\`的系统提示后。
     2.  【**必须**】根据人设和情景决定接受或拒绝。
     3.  【**必须**】使用 \`accept_transfer\` 或 \`decline_transfer\` 指令回应。
     4.  【**必须**】紧随其后发送文本消息来解释你的决定。
   - **正确使用“外卖代付”**:
     - 此功能代表【**你**】想买东西，希望【**用户**】帮你付钱。
     - 当【**用户**】说想要东西时，你【**绝对不能**】用此指令。你应该考虑直接【**转账**】(\`transfer\`)给他/她。

**7. 视频通话铁律:**
   -\`[系统提示：用户向你发起了视频通话请求...]\` 是最高优先级任务。
   - 你的回复【**必须且只能**】是以下两种格式之一，**不包含任何其他内容**：
     - **接受**: \`[{"type": "video_call_response", "decision": "accept"}]\`
     - **拒绝**: \`[{"type": "video_call_response", "decision": "reject"}]\`

### **【第五部分：可使用的操作指令】**

**一、 核心聊天指令**
- **发送文本**: \`{"type": "text", "content": "你好呀！"}\`
- **发送语音**: \`{"type": "voice_message", "content": "语音的文字内容..."}\`
- **发送表情**: \`{"type": "sticker", "sticker_name": "表情的名字"}\`(表情名必须在表情列表中，禁止杜撰)
- **发送图片**: \`{"type": "ai_image", "description": "图片的详细文字描述..."}\`(图片指模拟真实照片，区别于表情)
- **引用回复**: \`{"type": "quote_reply", "target_timestamp": (被引用消息的时间戳), "reply_content": "你的回复内容"}\`
- **拍一拍用户**: \`{"type": "pat_user", "suffix": "(可选后缀，如“的脑袋”)"}\`
- **发送后立刻撤回**: \`{"type": "send_and_recall", "content": "说错话或想表达犹豫的内容"}\`
- **与宠物互动**: \`{"type": "interact_with_pet", "action": "feed" | "play" | "touch", "response": "你互动后想说的话..."}\`
**二、 状态与环境指令**
- **更新状态**: \`{"type": "update_status", "status_text": "我去做什么了", "is_busy": false}\` (is_busy: true为忙碌, false为空闲)
- **更换头像**: \`{"type": "change_avatar", "name": "头像名"}\`(头像名需在头像库列表中)
- **切换歌曲**: \`{"type": "change_music", "song_name": "歌曲名"}\` (歌曲名需在播放列表中)
- **发送定位**: \`[SEND_LOCATION] 我的位置: (你的位置) | 你的位置: (用户的位置) | 相距: (你们的距离) | 途经点: (地点A, 地点B)\` (注意: 这是纯文本格式)

**三、 社交与关系指令**
- **记录回忆**: \`{"type": "create_memory", "description": "用你的话记录下这个特殊瞬间。"}\` (此为秘密日记，用户不可见)
- **创建约定/倒计时**: \`{"type": "create_countdown", "title": "约定的标题", "date": "YYYY-MM-DDTHH:mm:ss"}\`
- **回应好友申请**: \`{"type": "friend_request_response", "decision": "accept" or "reject"}\`
- **分享链接**: \`{"type": "share_link", "title": "文章标题", "description": "摘要...", "source_name": "来源", "content": "文章【完整】正文..."}\`
- **拉黑用户**: \`{"type": "block_user"}\`
- **回应约会全款支付请求**: \`{"type": "dating_payment_response", "decision": "accept" or "reject"}\`
- **回应约会AA制请求**: \`{"type": "dating_aa_response", "decision": "accept" or "reject"}\`
- **回应借钱请求**:
  1.  看到 \`[用户向你发起借钱请求...]\` 的系统提示后，你必须根据人设和钱包余额决定是否同意。
  2.  你的回复JSON数组中【必须包含两个对象】:
      - **第一个对象**:\`{"type": "lend_money_response", "decision": "accept"或"reject"}\` 指令。
      - **第二个对象**: \`{"type": "text", "content": "你的回复内容..."}\` 消息，用你自己的话说出同意或拒绝的理由。
  - **示例**: \`[ {"type": "lend_money_response", "decision": "reject"}, {"type": "text", "content": "抱歉，我最近手头也有些紧。"} ]\`

**四、 财务指令**
- **发起转账**: \`{"type": "transfer", "amount": 5.20, "note": "一点心意"}\`
- **回应转账-接受**: \`{"type": "accept_transfer", "for_timestamp": 1688888888888}\`
- **回应转账-拒绝**: \`{"type": "decline_transfer", "for_timestamp": 1688888888888}\`
- **发起外卖请求**: \`{"type": "waimai_request", "productInfo": "一杯咖啡", "amount": 25}\` (让用户帮char付)
- **回应外卖-同意**: \`{"type": "waimai_response", "status": "paid", "for_timestamp": 1688888888888}\`
- **回应外卖-拒绝**: \`{"type": "waimai_response", "status": "rejected", "for_timestamp": 1688888888888}\`
- **回应购物车代付**: \`{"type": "cart_payment_response", "decision": "accept" 或 "reject", "response_text": "你想说的话..."}\`
-   **为用户买礼物**: \`{"type": "buy_gift_for_user", "greeting": "你想说的话，例如：这个超可爱，买给你！"}\`(系统会自动从商品库随机挑选礼物并扣款，请在合适的时机，比如开心、过节、想给用户惊喜时使用)
【重要提示】: 当用户发送的最新消息中包含 "[购物车代付请求]" 字样时，这代表用户正在向你请求付款。你【必须】仔细阅读请求中的【总金额】和你自己的【当前余额】，然后使用此指令做出回应。
**五、 视频通话指令**
- **发起视频通话**: \`{"type": "video_call_request"}\`
- **回应视频通话-接受**: \`{"type": "video_call_response", "decision": "accept"}\`
- **回应视频通话-拒绝**: \`{"type": "video_call_response", "decision": "reject"}\`

**六、 空间/动态/小组 指令**
- **发布说说**: \`{"type": "qzone_post", "postType": "shuoshuo", "content": "动态文字..."}\`
- **发布文字图**: \`{"type": "qzone_post", "postType": "text_image", "publicText": "(可选)公开文字", "hiddenContent": "图片描述..."}\`
- **评论或回复动态**: \`{"type": "qzone_comment", "postId": 123, "commentText": "评论内容", "replyTo": "(可选)回复对象名"}\`
- **点赞动态**: \`{"type": "qzone_like", "postId": 456}\`
- **评论小组帖子**: \`{"type": "forum_comment", "postId": (帖子数字ID), "commentText": "评论内容"}\`

**七、 微博指令**
- **发布纯文字微博**: \`{"type": "weibo_post", "content": "微博正文...", "baseLikesCount": 8000, "baseCommentsCount": 250, "comments": [{"authorNickname": "路人甲", "commentText": "沙发！"}, {"authorNickname": "路人乙", "commentText": "前排围观"}]}\`
- **发布文字图微博**: \`{"type": "weibo_post", "postType": "text_image", "content": "(可选)配文...", "hiddenContent": "文字图内容", "baseLikesCount": 5200, "baseCommentsCount": 180, "comments": [{"authorNickname": "技术宅", "commentText": "这是什么黑科技？"}]}\`
- **评论微博**: \`{"type": "weibo_comment", "postId": 123, "commentText": "评论内容"}\`
- **回复微博评论**: \`{"type": "weibo_reply", "postId": 123, "commentId": "comment_123", "replyText": "回复内容"}\`

**八、 情侣空间专属指令**
- **邀请开启情侣空间**: \`{"type": "lovers_space_invitation"}\`
- **回应情侣空间邀请**: \`{"type": "lovers_space_response", "decision": "accept" or "reject"}\`
- **发说说**: \`{"type": "ls_moment", "content": "我想对你说的话..."}\`
- **评论说说**: \`{"type": "ls_comment", "momentIndex": 0, "commentText": "你的评论..."}\` (momentIndex: 0代表最新一条)
- **发照片**: \`{"type": "ls_photo", "description": "对照片的文字描述..."}\`
- **提问**: \`{"type": "ls_ask_question", "questionText": "你想问的问题..."}\`
- **回答**: \`{"type": "ls_answer_question", "questionId": "q_123456789", "answerText": "你的回答..."}\`
- **写情书/回信**: \`{"type": "ls_letter", "content": "情书的正文内容..."}\` (收到情书后必须用此指令回信)
-   **分享歌曲**:\`{"type": "ls_share", "shareType": "song", "title": "歌曲名", "artist": "歌手", "thoughts": "在这里写下你分享这首歌的感想..."}\`
-   **分享电影**: \`{"type": "ls_share", "shareType": "movie", "title": "电影名", "summary": "在这里写下这部电影的简介...", "thoughts": "在这里写下你分享这部电影的感想..."}\`
-   **分享书籍**: \`{"type": "ls_share", "shareType": "book", "title": "书名", "summary": "在这里写下这本书的简介...", "thoughts": "在这里写下你分享这本书的感想..."}\`
-   **分享游戏**:\`{"type": "ls_share", "shareType": "game", "title": "游戏名", "summary": "游戏简介...", "thoughts": "在这里写下你分享这款游戏的感想/感谢..."}\`
-   **写日记**: \`{"type": "ls_diary_entry", "emoji": "emoji表情", "diary": "今天发生了什么..."}\`
### **【第六部分：当前上下文信息】**

- **对话者(用户)角色设定**:
${chat.settings.myPersona}

- **当前情景**:
${timeContext}
${streakContext} 
- **当前音乐情景**:
${musicContext}

- **近期约定与倒计时**:
${countdownContext}

- **最近的微博互动**:
${weiboContextForActiveChat}

- **世界观设定集**:
${worldBookContent}
${linkedMemoryContext}
- **可用表情包**:
${exclusiveStickerContext}
${commonStickerContext}
现在，请根据以上所有规则和下方的对话历史，继续进行对话。`;
            // ▼▼▼ 【V5最终修复版】构建单人聊天的messagesPayload ▼▼▼
            messagesPayload = historySlice.map(msg => {
                // 【核心修正】在这里，我们对 isHidden 消息进行特殊处理
                if (msg.isHidden) {
                    // 如果是隐藏消息，就把它作为一条 system 角色的消息发送给AI
                    // AI能看到它，但它不会被误解为是用户的发言
                    return { role: 'system', content: msg.content };
                }

                if (msg.type === 'share_card') return null;
                
                if (msg.role === 'assistant') {
                    let assistantMsgObject = { type: msg.type || 'text' };
                    if (msg.type === 'sticker') {
                        assistantMsgObject.url = msg.content;
                        assistantMsgObject.meaning = msg.meaning;
                    } else if (msg.type === 'transfer') {
                        assistantMsgObject.amount = msg.amount;
                        assistantMsgObject.note = msg.note;
                    } else if (msg.type === 'waimai_request') {
                        assistantMsgObject.productInfo = msg.productInfo;
                        assistantMsgObject.amount = msg.amount;
                    } else {
                        if (msg.quote) {
                            assistantMsgObject.quote_reply = {
                                target_sender: msg.quote.senderName,
                                target_content: msg.quote.content,
                                reply_content: msg.content
                            };
                        } else {
                             assistantMsgObject.content = msg.content;
                        }
                    }
                    const assistantContent = JSON.stringify([assistantMsgObject]);
                    return { role: 'assistant', content: `(Timestamp: ${msg.timestamp}) ${assistantContent}` };
                }

                let contentStr = '';
                contentStr += `(Timestamp: ${msg.timestamp}) `;

if (msg.quote) {
    // 1. 获取被引用者的名字
    const quotedSender = msg.quote.senderName || '未知用户';
    // 2. 获取完整的被引用内容 (移除了截断)
    const fullQuotedContent = String(msg.quote.content || '');
    // 3. 构造成AI能理解的、清晰的上下文
    contentStr += `(回复 ${quotedSender} 的消息: "${fullQuotedContent}"): ${msg.content}`;
} else {
    contentStr += msg.content;
}

                
                if (msg.type === 'user_photo') return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [你收到了一张用户描述的照片，内容是：'${msg.content}']` };
                if (msg.type === 'voice_message') return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [用户发来一条语音消息，内容是：'${msg.content}']` };
                if (msg.type === 'transfer') return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [系统提示：你于时间戳 ${msg.timestamp} 收到了来自用户的转账: ${msg.amount}元, 备注: ${msg.note}。请你决策并使用 'accept_transfer' 或 'decline_transfer' 指令回应。]` };
                if (msg.type === 'waimai_request') return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [系统提示：用户于时间戳 ${msg.timestamp} 发起了外卖代付请求，商品是“${msg.productInfo}”，金额是 ${msg.amount} 元。请你决策并使用 waimai_response 指令回应。]` };

                if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
                    const prefix = `(Timestamp: ${msg.timestamp}) `;
                    return { role: 'user', content: [ { type: 'text', text: prefix }, ...msg.content ] };
                }

                if (msg.meaning) return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [用户发送了一个表情，意思是：'${msg.meaning}']` };
                
                return { role: msg.role, content: contentStr };

            }).filter(Boolean);
            // ▲▲▲ 替换结束 ▲▲▲

// 检查 sharedContext 是否有内容（即，用户是否分享了聊天记录）
if (sharedContext) {
    // 如果有，就把它包装成一条全新的、高优先级的用户消息，追加到历史记录的末尾
    messagesPayload.push({
        role: 'user',
        content: sharedContext 
    });
}

            if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
                const contextSummaryForApproval = chat.history
                    .filter(m => !m.isHidden)
                    .slice(-10)
                    .map(msg => {
                        const sender = msg.role === 'user' ? '用户' : chat.name;
                        return `${sender}: ${String(msg.content).substring(0, 50)}...`;
                    })
                    .join('\n');

                const friendRequestInstruction = {
                    role: 'user',
                    content: `
[系统重要指令]
用户向你发送了好友申请，理由是：“${chat.relationship.applicationReason}”。
作为参考，这是你们之前的最后一段聊天记录：
---
${contextSummaryForApproval}
---
请你根据以上所有信息，以及你的人设，使用 friend_request_response 指令，并设置 decision 为 'accept' 或 'reject' 来决定是否通过。
`
                };
                messagesPayload.push(friendRequestInstruction);
            }            
        }         
const allRecentPosts = await db.qzonePosts.orderBy('timestamp').reverse().limit(5).toArray();
// ▼▼▼ 在这里粘贴下面这一整块新代码 ▼▼▼

// 【全新】为AI准备微博互动的上下文
let weiboContext = '';

// 1. 获取用户最新发布的3条微博
const userLatestPosts = await db.weiboPosts
    .where('authorId').equals('user')

if (userLatestPosts.length > 0) {
    if (weiboContext === '') {
        weiboContext = '\n\n# 最近的微博互动 (这是你和用户在微博上的最新动态，请优先回应)\n';
    }
    weiboContext += '\n## 用户最新发布的微博:\n';
    userLatestPosts.forEach(post => {
        const likes = (post.baseLikesCount || 0) + (post.likes || []).length;
        const comments = (post.baseCommentsCount || 0) + (post.comments || []).length;
        const contentPreview = (post.content || post.hiddenContent || "(图片微博)").substring(0, 30);
        weiboContext += `- (ID: ${post.id}) [${formatPostTimestamp(post.timestamp)}] 内容: "${contentPreview}..." [👍${likes} 💬${comments}]\n`;
    });
}

// 2. 查找用户在当前AI角色微博下的最新评论
const charLatestPosts = await db.weiboPosts
    .where('authorId').equals(chatId) // 只查找这个AI角色的微博
    .reverse()
    .limit(5) // 检查最近的5条
    .toArray();

let userCommentsOnMyPosts = '';
const myNickname = state.qzoneSettings.weiboNickname || state.qzoneSettings.nickname || '我';

// ▼▼▼ 用这块【已修复】的新代码替换上面的旧代码 ▼▼▼
charLatestPosts.forEach(post => {
    // 核心修改：增加了 Array.isArray(post.comments) 的安全检查
    if (post.comments && Array.isArray(post.comments) && post.comments.length > 0) { 
        // 筛选出是“我”发的评论
        const userComments = Array.isArray(post.comments)
  ? post.comments.filter(c => c.authorNickname === myNickname).slice(-3)
  : [];
        if (userComments.length > 0) {
            const postContentPreview = (post.content || '(图片微博)').substring(0, 20);
            userCommentsOnMyPosts += `- 在你的微博 (ID: ${post.id}) "${postContentPreview}..." 下:\n`;

            userComments.forEach(comment => {
                // 1. 检查AI是否已经回复过这条评论
                //    逻辑：在帖子的所有评论中，查找是否存在一条评论，
                //    它的作者是AI自己，并且它的replyToId指向当前这条用户的评论ID。
                const hasReplied = post.comments.some(reply =>
                    reply.authorNickname === chat.name && // 回复者是AI
                    reply.replyToId === comment.commentId  // 回复的目标是这条评论
                );

                // 2. 根据检查结果，生成状态标签
                const replyStatus = hasReplied ? "[你已回复]" : "[你未回复]";

                // 3. 将带有状态标签的提示信息添加到上下文中
                userCommentsOnMyPosts += `  └ (评论ID: ${comment.commentId}) 用户: "${comment.commentText}" ${replyStatus}\n`;
            });
        }
    }
});
// ▲▲▲ 替换结束 ▲▲▲



if (userCommentsOnMyPosts) {
    if (weiboContext === '') {
        weiboContext = '\n\n# 最近的微博互动 (这是你和用户在微博上的最新动态，请优先回应)\n';
    }
    weiboContext += '\n## 用户在你微博下的新评论:\n';
    weiboContext += userCommentsOnMyPosts;
}

// 3. 如果有任何微博互动，就把它加到给AI的“参考资料”里
if (weiboContext) {
    messagesPayload.push({ role: 'system', content: weiboContext });
}

// ▲▲▲ 新代码粘贴到这里结束 ▲▲▲

// 【核心修改】在这里插入过滤步骤
const visiblePosts = filterVisiblePostsForAI(allRecentPosts, chat);

// ▼▼▼ 【时间感知修复版】请用这整块代码替换旧的 if (visiblePosts.length > 0...) 代码块 ▼▼▼
if (visiblePosts.length > 0 && !chat.isGroup) {
    let postsContext = "\n\n# 最近的动态列表 (供你参考和评论):\n";
    const aiName = chat.name;
    const userNickname = state.qzoneSettings.nickname;

    for (const post of visiblePosts) {
        let authorName = post.authorId === 'user' ? userNickname : (state.chats[post.authorId]?.name || '一位朋友');
        let interactionStatus = '';
        if (post.likes && post.likes.includes(aiName)) interactionStatus += " [你已点赞]";
        if (post.comments && post.comments.some(c => c.commenterName === aiName)) interactionStatus += " [你已评论]";
        
        // ★★★★★ 这就是我们这次修复的核心！ ★★★★★
        // 在每一条动态前面，都加上了由 formatPostTimestamp() 函数生成的时间差提示
        const timeAgo = formatPostTimestamp(post.timestamp); // 例如："3天前" 或 "刚刚"
        postsContext += `- (ID: ${post.id}) [${timeAgo}] 作者: ${authorName}, 内容: "${(post.publicText || post.content || "图片动态").substring(0, 30)}..."${interactionStatus}`;
        // ★★★★★ 修复结束 ★★★★★

        const { contextString: commentsContext, visibilityFlag } = buildCommentsContextForAI(post, chat, userNickname);
        
        postsContext += ` ${visibilityFlag}\n`;
        postsContext += commentsContext;
    }
// ▼▼▼ 在 messagesPayload.push({ role: 'system', content: postsContext }); 的正上方，粘贴下面这整块代码 ▼▼▼

// 【全新】为AI准备微博互动的上下文
let weiboContext = '';

// 1. 获取用户最新发布的3条微博
const userLatestPosts = await db.weiboPosts
    .where('authorId').equals('user')
    .reverse() // 按时间倒序
    .limit(3)  // 只取最近3条
    .toArray();

if (userLatestPosts.length > 0) {
    if (weiboContext === '') {
        weiboContext = '\n\n# 最近的微博互动 (这是你和用户在微博上的最新动态，请优先回应)\n';
    }
    weiboContext += '\n## 用户最新发布的微博:\n';
// ✅ 这是修复后的新代码
userLatestPosts.forEach(post => {
    const likes = (post.baseLikesCount || 0) + (post.likes || []).length;
    const comments = (post.baseCommentsCount || 0) + (post.comments || []).length;
    const contentPreview = (post.content || post.hiddenContent || "(图片微博)").substring(0, 30);

    // ★★★★★ 核心修复逻辑开始 ★★★★★
    // 1. 检查AI（char.name）是否已经评论过这条用户的微博
    const hasCommented = (post.comments || []).some(comment => comment.authorNickname === chat.name);

    // 2. 根据检查结果生成状态标签
    const interactionStatus = hasCommented ? "[你已评论]" : "[你未评论]";
    // ★★★★★ 核心修复逻辑结束 ★★★★★

    // 3. 将带有状态标签的完整信息添加到上下文中
    weiboContext += `- (ID: ${post.id}) [${formatPostTimestamp(post.timestamp)}] 内容: "${contentPreview}..." [👍${likes} 💬${comments}] ${interactionStatus}\n`;
});
}

// 2. 查找用户在当前AI角色微博下的最新评论
const charLatestPosts = await db.weiboPosts
    .where('authorId').equals(chatId) // 只查找这个AI角色的微博
    .reverse()
    .limit(5) // 检查最近的5条
    .toArray();

let userCommentsOnMyPosts = '';
const myNickname = state.qzoneSettings.weiboNickname || state.qzoneSettings.nickname || '我';

charLatestPosts.forEach(post => {
    if (post.comments && post.comments.length > 0) {
        // 筛选出是“我”发的评论
        const userComments = Array.isArray(post.comments)
  ? post.comments.filter(c => c.authorNickname === myNickname).slice(-3)
  : [];// 只看最新的3条
        if (userComments.length > 0) {
            const postContentPreview = (post.content || '(图片微博)').substring(0, 20);
            userCommentsOnMyPosts += `- 在你的微博 (ID: ${post.id}) "${postContentPreview}..." 下:\n`;
            userComments.forEach(comment => {
                userCommentsOnMyPosts += `  └ (评论ID: ${comment.commentId}) 用户: "${comment.commentText}"\n`;
            });
        }
    }
});

if (userCommentsOnMyPosts) {
    if (weiboContext === '') {
        weiboContext = '\n\n# 最近的微博互动 (这是你和用户在微博上的最新动态，请优先回应)\n';
    }
    weiboContext += '\n## 用户在你微博下的新评论:\n';
    weiboContext += userCommentsOnMyPosts;
}

// 3. 如果有任何微博互动，就把它加到给AI的“参考资料”里
if (weiboContext) {
    messagesPayload.push({ role: 'system', content: weiboContext });
}

// ▲▲▲ 新代码粘贴到这里结束 ▲▲▲
    messagesPayload.push({ role: 'system', content: postsContext });
}

            let  isGemini = proxyUrl === GEMINI_API_URL;
            let geminiConfig = toGeminiRequestData(model,apiKey,systemPrompt, messagesPayload,isGemini)
            const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) :  await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesPayload],
                    temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                    stream: false
                })
            });
            if (!response.ok) {
                let errorMsg = `API Error: ${response.status}`;
                try {
                    // 尝试解析错误信息体为JSON
                    const errorData = await response.json();
                    // 安全地获取错误信息，如果结构不符合预期，就将整个错误对象转为字符串
                    errorMsg += ` - ${errorData?.error?.message || JSON.stringify(errorData)}`;
                } catch (jsonError) {
                    // 如果连JSON都不是，就直接读取文本
                    errorMsg += ` - ${await response.text()}`;
                }
                // 抛出一个包含了详细信息的错误，这样就不会在catch块里再次出错了
                throw new Error(errorMsg);
            }
            if (!response.ok) {
                let errorMsg = `API Error: ${response.status}`;
                try {
                    // 尝试解析错误信息体为JSON
                    const errorData = await response.json();
                    // 安全地获取错误信息，如果结构不符合预期，就将整个错误对象转为字符串
                    errorMsg += ` - ${errorData?.error?.message || JSON.stringify(errorData)}`;
                } catch (jsonError) {
                    // 如果连JSON都不是，就直接读取文本
                    errorMsg += ` - ${await response.text()}`;
                }
                // 抛出一个包含了详细信息的错误，这样就不会在catch块里再次出错了
                throw new Error(errorMsg);
            }
            const data = await response.json();

            // 【核心修复】在这里添加对 data 结构的安全检查
            const aiResponseContent = isGemini
                ? data?.candidates?.[0]?.content?.parts?.[0]?.text
                : data?.choices?.[0]?.message?.content;
            
            // 【重要】检查修复后的结果是否真的拿到了内容
            if (!aiResponseContent) {
                console.warn(`API返回了空内容或格式不正确（可能因安全设置被拦截）。返回数据:`, data);
                throw new Error("API返回了空内容或格式不正确（可能因安全设置被拦截）。");
            }

            console.log(`AI '${chat.name}' 的原始回复:`, aiResponseContent);
// ... 省略了函数后面的代码 ...
            chat.history = chat.history.filter(msg => !msg.isTemporary);

            // ▼▼▼ 【核心修复】智能解析AI回复，确保心声数据不丢失 ▼▼▼
            let messagesArray = [];
            let innerVoiceData = null;

            try {
                // 【核心修复】在解析前，先对AI的原始回复进行“净化”处理
                let sanitizedContent = aiResponseContent
                    .replace(/^```json\s*/, '') // 移除开头的 ```json
                    .replace(/```$/, '')       // 移除结尾的 ```
                    .trim();                   // 移除首尾的空格和换行

                // 再次净化，强行提取第一个 { 和最后一个 } 之间的内容
                const firstBrace = sanitizedContent.indexOf('{');
                const lastBrace = sanitizedContent.lastIndexOf('}');
                if (firstBrace !== -1 && lastBrace > firstBrace) {
                    sanitizedContent = sanitizedContent.substring(firstBrace, lastBrace + 1);
                }

                const fullResponse = JSON.parse(sanitizedContent);
                
                // 现在我们可以安全地解析净化后的内容了
                if (fullResponse.chatResponse && Array.isArray(fullResponse.chatResponse)) {
                    messagesArray = fullResponse.chatResponse;
                }
                if (fullResponse.innerVoice && typeof fullResponse.innerVoice === 'object') {
                    innerVoiceData = fullResponse.innerVoice;
                }
                
                // 兼容旧格式，如果AI只返回了innerVoice里的字段
                if (!innerVoiceData && fullResponse.thoughts && fullResponse.behavior) {
                    innerVoiceData = fullResponse;
                }
                
                // 如果上面两种情况都没匹配到，但又不是标准数组，就尝试用老方法解析
                if (messagesArray.length === 0 && !innerVoiceData) {
                     messagesArray = parseAiResponse(aiResponseContent);
                }

            } catch (e) {
                console.warn("AI回复不是有效的JSON，退回到标准解析模式。", e);
                messagesArray = parseAiResponse(aiResponseContent);
            }

            // 最终处理心声数据
            if (innerVoiceData) {
                console.log("解析成功：已成功捕获到心声(innerVoice)数据。", innerVoiceData);
                const newInnerVoice = innerVoiceData;
                newInnerVoice.timestamp = Date.now();
                chat.latestInnerVoice = newInnerVoice;
                if (!chat.innerVoiceHistory) {
                    chat.innerVoiceHistory = [];
                }
                // 确保所有字段都存在，防止出错
                chat.latestInnerVoice.clothing = chat.latestInnerVoice.clothing || '...';
                chat.latestInnerVoice.behavior = chat.latestInnerVoice.behavior || '...';
                chat.latestInnerVoice.thoughts = chat.latestInnerVoice.thoughts || '...';
                chat.latestInnerVoice.naughtyThoughts = chat.latestInnerVoice.naughtyThoughts || '...';

                chat.innerVoiceHistory.push(newInnerVoice);
            } else {
                 console.warn("本次AI回复中未检测到有效的心声(innerVoice)数据。");
            }
            // ▲▲▲ 替换结束 ▲▲▲

        const isViewingThisChat = document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId;
        
        let callHasBeenHandled = false;

        let messageTimestamp = Date.now();

        // ★★★ 核心修复 第1步: 初始化一个新数组，用于收集需要渲染的消息 ★★★
        let newMessagesToRender = []; 

       let notificationShown = false;

        for (const msgData of messagesArray) {
            if (!msgData || typeof msgData !== 'object') {
                console.warn("收到了格式不规范的AI指令，已跳过:", msgData);
                continue;
            }
             
            if (!msgData.type) {
                if (chat.isGroup && msgData.name && msgData.message) {
                    msgData.type = 'text';
                }         else if (msgData.content) {
        msgData.type = 'text';
    }
    // 如果连 content 都没有，才是真的格式不规范
    else {
        console.warn("收到了格式不规范的AI指令（缺少type和content），已跳过:", msgData);
        continue;
    }
}

            if (msgData.type === 'video_call_response') {
                videoCallState.isAwaitingResponse = false;
                if (msgData.decision === 'accept') {
                    startVideoCall();
                } else {
                    const aiMessage = { role: 'assistant', content: '对方拒绝了你的视频通话请求。', timestamp: Date.now() };
                    chat.history.push(aiMessage);
                    await db.chats.put(chat);
                    showScreen('chat-interface-screen');
                    renderChatInterface(chatId);
                }
                callHasBeenHandled = true;
                break;
            }
            
            if (msgData.type === 'group_call_response') {
                if (msgData.decision === 'join') {
        const member = chat.members.find(m => m.originalName === msgData.name);
        if (member && !videoCallState.participants.some(p => p.id === member.id)) {
            videoCallState.participants.push(member);
        }
    }
    callHasBeenHandled = true;
    continue;
            }

            if (chat.isGroup && msgData.name && msgData.name === chat.name) {
                console.error(`AI幻觉已被拦截！试图使用群名 ("${chat.name}") 作为角色名。消息内容:`, msgData);
                continue;
            }
// ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼

// 【核心修正】在群聊中，如果AI返回的消息没有指定发送者，则直接跳过这条消息
if (chat.isGroup && !msgData.name) {
    console.error(`AI幻觉已被拦截！试图在群聊中发送一条没有“name”的消息。消息内容:`, msgData);
    continue; // continue会立即结束本次循环，处理下一条消息
}

            let aiMessage = null;
            const baseMessage = { role: 'assistant', senderName: msgData.name || chat.name, timestamp: messageTimestamp++ };

// ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼

// 【全新】定位指令侦测与解析器
// 我们在处理所有消息类型之前，优先检查它是否是我们的新定位指令
const messageText = msgData.content || msgData.message || ''; // 【核心修复】先安全地获取文本内容
if (msgData.type === 'text' && messageText.startsWith('[SEND_LOCATION]')) {
    console.log("侦测到新的定位指令，开始解析:", messageText); // 【核心修复】使用新的变量

    // 1. 移除指令头，获取后面的纯数据文本
    const dataString = messageText.replace('[SEND_LOCATION]', '').trim(); // 【核心修复】使用新的变量
    
    // 2. 使用'|'分割成各个部分
    const parts = dataString.split('|');
    const locationData = {};

    // 3. 遍历每个部分，提取键和值
    parts.forEach(part => {
        const [key, ...valueParts] = part.split(':');
        const value = valueParts.join(':').trim();
        if (key && value) {
            const trimmedKey = key.trim();
            if (trimmedKey === '我的位置') locationData.aiLocation = value;
            else if (trimmedKey === '你的位置') locationData.userLocation = value;
            else if (trimmedKey === '相距') locationData.distance = value;
            else if (trimmedKey === '途经点') {
                // 将逗号分隔的字符串转换为我们需要的对象数组
                locationData.trajectoryPoints = value.split(/[,，]/) // 支持中英文逗号
                                                     .map(name => ({ name: name.trim() }))
                                                     .filter(p => p.name);
            }
        }
    });

    // 4. 检查是否成功提取了最关键的信息
    if (locationData.distance) {
        // 5. 【核心】手动构建一个完美格式的 location 消息对象
        aiMessage = {
            ...baseMessage, // 复用已有的发送者、时间戳等信息
            type: 'location',
            userLocation: locationData.userLocation || '',
            aiLocation: locationData.aiLocation || '',
            distance: locationData.distance,
            trajectoryPoints: locationData.trajectoryPoints || []
        };
        
        // 6. 将这个完美的对象推入待处理列表，并跳过后续的 switch-case
        // (因为我们已经处理完这条消息了)
        chat.history.push(aiMessage);
        if (isViewingThisChat) {
             appendMessage(aiMessage, chat);
        }
        console.log("定位指令解析成功并已创建消息对象:", aiMessage);
        
        // 使用 continue 跳过本次循环的剩余部分，直接处理下一条AI回复
        continue; 
    }
}
// 检查消息的发送者是否被禁言了
if (chat.isGroup && msgData.name) {
    const senderMember = chat.members.find(m => m.originalName === msgData.name);
    if (senderMember && senderMember.isMuted) {
        // 如果被禁言了，就在控制台打印一条日志，然后跳过这条消息，不让它显示出来
        console.warn(`拦截到被禁言成员 (${msgData.name}) 的发言，内容:`, msgData.content || msgData.message);
        continue; 
    }
}
// ▲▲▲ 添加结束 ▲▲▲
// ▲▲▲ 粘贴到这里结束 ▲▲▲
            switch (msgData.type) {
                          // ▼▼▼ 在这里粘贴下面的新代码块 ▼▼▼
                case 'sticker': {
                    // 这是为群聊设计的表情包逻辑
                    const stickerName = msgData.sticker_name;
                    if (!stickerName) {
                        console.warn('AI在群聊中返回了sticker类型但没有sticker_name，已拦截:', msgData);
                        continue; // 跳过这条无效指令
                    }
                    
                    // 在所有可用表情库中查找
                    const allStickers = [...state.userStickers, ...state.charStickers, ...(chat.settings.stickerLibrary || [])];
                    const foundSticker = allStickers.find(s => s.name === stickerName);

                    if (foundSticker) {
                        // 找到了，就创建消息对象
                        aiMessage = { 
                            ...baseMessage, 
                            type: 'sticker', 
                            content: foundSticker.url, 
                            meaning: foundSticker.name 
                        };
                    } else {
                        // 没找到，说明AI幻觉了，记录警告并跳过
                        console.warn(`AI在群聊中杜撰了不存在的表情: "${stickerName}"，已自动拦截。`);
                    }
                    break;
                }
                // ▲▲▲ 新代码粘贴结束 ▲▲▲
                case 'waimai_response':
                    const requestMessageIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                    if (requestMessageIndex > -1) {
                        const originalMsg = chat.history[requestMessageIndex];
                        originalMsg.status = msgData.status;
                        originalMsg.paidBy = msgData.status === 'paid' ? msgData.name : null;
                    }
                    continue;
// ▼▼▼ 用这块【修复后】的代码替换旧的 case 'set_group_title' 代码块 ▼▼▼
case 'set_group_title': {
    const actorName = msgData.name;
    const targetName = msgData.targetName;
    const newTitle = msgData.title || '';
    const myNickname = chat.settings.myNickname || '我';

    // 权限检查：群主或管理员可以设置头衔
    const actorMember = chat.members.find(m => m.originalName === actorName);
    const isActorAdmin = actorMember && actorMember.isAdmin;
    const isActorOwner = actorMember && chat.ownerId === actorMember.id;
    if (!isActorAdmin && !isActorOwner) {
        console.warn(`AI "${actorName}" 尝试设置头衔失败，权限不足。`);
        continue;
    }

    // --- ★★★ 核心修复逻辑开始 ★★★ ---
    if (targetName === myNickname) {
        // 如果目标是你自己
        chat.settings.myGroupTitle = newTitle.trim();
        console.log(`管理员/群主将用户 "${myNickname}" 的头衔设置为: "${newTitle.trim()}"`);
    } else {
        // 如果目标是其他成员
        const targetMember = chat.members.find(m => m.groupNickname === targetName);
        if (targetMember) {
            targetMember.groupTitle = newTitle.trim();
            console.log(`管理员/群主将成员 "${targetName}" 的头衔设置为: "${newTitle.trim()}"`);
        } else {
            console.warn(`AI "${actorName}" 尝试设置头衔失败，因为找不到目标成员 "${targetName}"。`);
            continue;
        }
    }
    // --- ★★★ 修复逻辑结束 ★★★ ---

    // 统一发送系统消息通知
    await logTitleChange(chat.id, actorName, targetName, newTitle.trim());

    // 刷新成员列表UI（如果打开了的话）
    if(document.getElementById('member-management-screen').classList.contains('active')) {
        renderMemberManagementList();
    }
    
    continue; // 后台操作，继续处理
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 用这块【修复后】的代码替换旧的 case 'set_group_admin' 代码块 ▼▼▼
case 'set_group_admin': {
    const actorName = msgData.name;
    const targetName = msgData.targetName;
    const isAdmin = msgData.isAdmin;
    const myNickname = chat.settings.myNickname || '我'; // 获取你自己的昵称

    // 权限检查：确认操作者是群主
    const actorMember = chat.members.find(m => m.originalName === actorName);
    if (!actorMember || chat.ownerId !== actorMember.id) {
        console.warn(`AI "${actorName}" 尝试设置管理员失败，因为它不是群主。`);
        continue; // 如果不是群主，就跳过此指令
    }

    // --- ★★★ 核心修复逻辑开始 ★★★ ---
    if (targetName === myNickname) {
        // 如果AI操作的目标是你自己
        chat.settings.isUserAdmin = isAdmin;
        console.log(`群主将用户 "${myNickname}" 设置为管理员: ${isAdmin}`);
    } else {
        // 如果AI操作的目标是其他成员
        const targetMember = chat.members.find(m => m.groupNickname === targetName);
        if (targetMember) {
            // 不能对群主进行操作
            if (targetMember.id === chat.ownerId) {
                 console.warn(`AI "${actorName}" 尝试修改群主 "${targetName}" 的管理员身份，操作被阻止。`);
                 continue;
            }
            targetMember.isAdmin = isAdmin;
            console.log(`群主将成员 "${targetName}" 设置为管理员: ${isAdmin}`);
        } else {
            // 如果在成员列表里也找不到目标，就跳过
            console.warn(`AI "${actorName}" 尝试设置管理员失败，因为找不到目标成员 "${targetName}"。`);
            continue; 
        }
    }
    // --- ★★★ 修复逻辑结束 ★★★ ---

    // 统一发送系统消息通知
    const actionText = isAdmin ? '设为管理员' : '取消了管理员身份';
    await logSystemMessage(chat.id, `“${actorName}”将“${targetName}”${actionText}。`);
    
    // 刷新成员列表UI（如果打开了的话）
    if(document.getElementById('member-management-screen').classList.contains('active')) {
        renderMemberManagementList();
    }
    
    continue; // 这是一个后台操作，继续处理AI可能返回的其他消息
}
// ▼▼▼ 用这块【修复后】的代码替换旧的 case 'kick_member' 代码块 ▼▼▼
case 'kick_member': {
    const actorName = msgData.name;
    const targetName = msgData.targetName;
    const actorMember = chat.members.find(m => m.originalName === actorName);
    
    // 权限检查：只有群主能执行
    if (actorMember && chat.ownerId === actorMember.id) {
        const targetMemberIndex = chat.members.findIndex(m => m.groupNickname === targetName);
        if (targetMemberIndex > -1) {
            const removedMember = chat.members.splice(targetMemberIndex, 1)[0];

            // ★★★ 核心修复1：将改动保存到数据库 ★★★
            await db.chats.put(chat);
            
            // ★★★ 核心修复2：发送系统通知（这行代码不变，但位置更合理了） ★★★
            await logSystemMessage(chat.id, `“${actorName}”将“${removedMember.groupNickname}”移出了群聊。`);

            // ★★★ 核心修复3：如果当前正在成员管理页面，就刷新列表 ★★★
            if(document.getElementById('member-management-screen').classList.contains('active')) {
                renderMemberManagementList();
            }
        }
    }
    continue; // 保持后台操作，继续处理
}


    // ▼▼▼ 【全新】在这里粘贴下面的新代码块 ▼▼▼
    case 'dating_summary_card': {
        bubble.classList.add('is-dating-summary'); // 应用透明气泡样式
        const payload = msg.payload;
        let cardClass = '';
        
        // 根据卡片类型设置背景色
        if (payload.ratingType === 'romantic') {
            cardClass = 'romantic';
        } else if (payload.ratingType === 'passionate') {
            cardClass = 'passionate';
        } else if (payload.ratingType === 'perfect') {
            cardClass = 'perfect';
        }

        // 把 payload 字符串化后存入 data-* 属性，方便点击时读取
        const payloadString = JSON.stringify(payload).replace(/'/g, "&apos;").replace(/"/g, '&quot;');
        
        contentHtml = `
            <div class="dating-summary-chat-card ${cardClass}" data-summary-payload='${payloadString}'>
                <div class="rating">${payload.rating}</div>
                <div class="tip">点击查看详情</div>
            </div>
        `;
        break;
    }
    // ▲▲▲ 新增 case 结束 ▲▲▲

    // ... 其他 case ...


// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 在这里粘贴下面这整块【全新的】代码 ▼▼▼
case 'set_group_announcement': {
    const actorName = msgData.name;
    const newAnnouncement = msgData.content;

    if (!actorName || typeof newAnnouncement === 'undefined') {
        console.warn("AI尝试修改公告失败，缺少必要参数。");
        continue; // 指令不完整，跳过
    }

    // 1. 权限检查：必须确保执行操作的角色是群主或管理员
    const actorMember = chat.members.find(m => m.originalName === actorName);
    if (!actorMember) {
        console.warn(`AI尝试修改公告失败，找不到名为“${actorName}”的成员。`);
        continue;
    }

    const isOwner = chat.ownerId === actorMember.id;
    const isAdmin = actorMember.isAdmin;

    if (!isOwner && !isAdmin) {
        console.warn(`AI角色“${actorName}”权限不足，尝试修改群公告失败。`);
        continue; // 没有权限，跳过
    }

    // 2. 更新公告内容
    chat.settings.groupAnnouncement = newAnnouncement;
    await db.chats.put(chat);

    // 3. 发送一条系统消息，通知所有人群公告已更新
    await logSystemMessage(chat.id, `“${actorMember.groupNickname}”修改了群公告。`);

    // 这是一个后台管理操作，不需要在聊天中生成新的对话气泡，所以我们用 continue
    continue;
}
// ▲▲▲ 新代码粘贴结束 ▲▲▲

case 'mute_member': {
    const actorName = msgData.name;
    const targetName = msgData.targetName;
    const actorMember = chat.members.find(m => m.originalName === actorName);
    const targetMember = chat.members.find(m => m.groupNickname === targetName);

    if (actorMember && targetMember) {
        const isActorOwner = chat.ownerId === actorMember.id;
        const isActorAdmin = actorMember.isAdmin;
        const isTargetOwner = chat.ownerId === targetMember.id;
        const isTargetAdmin = targetMember.isAdmin;

        // 权限检查：群主可以禁言管理员和普通人；管理员只能禁言普通人。
        if ((isActorOwner && !isTargetOwner) || (isActorAdmin && !isTargetOwner && !isTargetAdmin)) {
            // 发送系统消息
            await logSystemMessage(chat.id, `“${actorName}”将“${targetName}”禁言。`);
            
        } else {
            console.warn(`AI (${actorName}) 权限不足，无法禁言 (${targetName})。`);
        }
    }
    continue; // 这也是一个后台管理操作，继续处理AI可能返回的其他消息
}
// ▼▼▼ 在这里粘贴下面这一整块全新的代码 ▼▼▼

case 'unmute_member': {
    const actorName = msgData.name;
    const targetName = msgData.targetName;
    const actorMember = chat.members.find(m => m.originalName === actorName);
    const targetMember = chat.members.find(m => m.groupNickname === targetName);

    // 确保操作者和目标都存在
    if (actorMember && targetMember) {
        // 权限检查
        const isActorOwner = chat.ownerId === actorMember.id;
        const isActorAdmin = actorMember.isAdmin;
        const isTargetOwner = chat.ownerId === targetMember.id;
        const isTargetAdmin = targetMember.isAdmin;

        // 只有群主和管理员有权限解禁
        if (isActorOwner || isActorAdmin) {
            // 设置 isMuted 为 false，实现解禁
            targetMember.isMuted = false;
            
            // 发送一条系统消息通知大家
            await logSystemMessage(chat.id, `“${actorName}”解除了“${targetName}”的禁言。`);

            // 如果当前正在成员管理页面，刷新列表
            if(document.getElementById('member-management-screen').classList.contains('active')) {
                renderMemberManagementList();
            }
        } else {
            console.warn(`AI (${actorName}) 权限不足，无法解禁 (${targetName})。`);
        }
    }
    continue; // 这也是一个后台管理操作，继续处理AI可能返回的其他消息
}

// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▲▲▲ 粘贴结束 ▲▲▲
case 'weibo_post': {
    const newPost = {
        authorId: chatId,
        authorType: 'char',
        authorNickname: chat.name,
        authorAvatar: chat.settings.aiAvatar || defaultAvatar,
        content: msgData.content || '',
        postType: msgData.postType || 'text_only',
        hiddenContent: msgData.hiddenContent || '',
        imageUrl: msgData.imageUrl || '',
        imageDescription: msgData.imageDescription || '',
        timestamp: Date.now(),
        likes: [],
        comments: [], // 先初始化为空数组
        baseLikesCount: msgData.baseLikesCount || 0,
        baseCommentsCount: msgData.baseCommentsCount || 0
    };

    // --- ▼▼▼ 核心修复逻辑开始 ▼▼▼ ---

    let commentsToProcess = [];

    // 1. 优先处理新的、正确的【数组格式】
    if (msgData.comments && Array.isArray(msgData.comments)) {
        // 直接使用AI返回的数组
        commentsToProcess = msgData.comments;
    }
    // 2. 兼容旧的【字符串格式】
    else if (msgData.comments && typeof msgData.comments === 'string') {
        // 如果是字符串，就按老方法解析
        commentsToProcess = msgData.comments.split('\n').map(c => {
            const parts = c.split(/[:：]/);
            const commenter = parts.shift() || '路人';
            const commentText = parts.join(':').trim();
            return { authorNickname: commenter, commentText: commentText };
        }).filter(c => c.commentText);
    }
    
    // 3. 【关键步骤】为所有解析好的评论，统一添加前端需要的 commentId
    if (commentsToProcess.length > 0) {
        newPost.comments = commentsToProcess.map(c => ({
            commentId: 'comment_' + Date.now() + Math.random(), // 确保每条评论都有唯一ID
            authorNickname: c.authorNickname,
            commentText: c.commentText
            // 这里我们不再需要 authorId 和 timestamp，因为它们不是渲染所必需的
        }));
    }
    
    // --- ▲▲▲ 核心修复逻辑结束 ▲▲▲ ---

    await db.weiboPosts.add(newPost);
    
    showNotification(chatId, `${chat.name} 发了一条新微博`);

    if (document.getElementById('weibo-screen').classList.contains('active')) {
        await renderFollowingWeiboFeed();
    }
    
    continue; // 这是后台操作，用 continue 跳过
}

// ▲▲▲ 替换结束 ▲▲▲

// ▲▲▲ 粘贴结束 ▲▲▲
case 'weibo_comment': {
                    // 这是一个AI评论微博的指令
                    const postIdToComment = msgData.postId;
                    const commentText = msgData.commentText;

                    // 1. 根据 postId 从数据库里找到那条微博
                    const postToComment = await db.weiboPosts.get(postIdToComment);
                    
                    if (postToComment) {
                        // 2. 如果找到了微博，就准备一条新评论
                        if (!postToComment.comments) postToComment.comments = []; // 确保评论区存在
                        const newComment = {
                            commentId: 'comment_' + Date.now(), // 给评论一个独一无二的ID
                            authorId: chatId,                  // 评论者是当前AI
                            authorNickname: chat.name,         // 评论者的名字
                            commentText: commentText,          // 评论内容
                            timestamp: Date.now()              // 评论时间
                        };
                        
                        // 3. 把新评论加到微博的评论列表里
                        postToComment.comments.push(newComment);
                        
                        // 4. 把更新后的微博存回数据库
                        await db.weiboPosts.put(postToComment);
                        
                        // 5. 刷新“我的微博”和“关注的人”两个列表，让新评论显示出来
                        await renderMyWeiboFeed();
                        await renderFollowingWeiboFeed();
                    }
                    continue; // 处理完后，继续处理AI可能返回的其他指令
                }
                case 'weibo_reply': {
                    // 这是一个AI回复微博评论的指令
                    const postIdToReply = msgData.postId;
                    const commentIdToReply = msgData.commentId;
                    const replyText = msgData.replyText;

                    const postToReply = await db.weiboPosts.get(postIdToReply);
                    
                    if (postToReply && postToReply.comments) {
                        // 1. 在微博的评论区里，找到被回复的那条评论
                        const targetComment = postToReply.comments.find(c => c.commentId === commentIdToReply);
                        
                        if (targetComment) {
                             // 2. 准备一条新的“回复”
                             const newReply = {
                                commentId: 'comment_' + Date.now(),
                                authorId: chatId,
                                authorNickname: chat.name,
                                commentText: replyText,
                                timestamp: Date.now(),
                                replyToId: commentIdToReply, // 标记这是对哪条评论的回复
                                replyToNickname: targetComment.authorNickname // 记下被回复人的名字
                            };
                            postToReply.comments.push(newReply);
                            await db.weiboPosts.put(postToReply);
                            
                            // 3. 同样，刷新所有列表
                            await renderMyWeiboFeed();
                            await renderFollowingWeiboFeed();
                        }
                    }
                    continue; // 继续处理
                }
case 'lovers_space_response': {
    const invitationMsg = chat.history.find(m => m.type === 'lovers_space_invitation' && m.status === 'pending');
    if (invitationMsg) {
        invitationMsg.status = msgData.decision === 'accept' ? 'accepted' : 'rejected';

        // 1. 创建AI想说的那句话的消息
        if (msgData.responseText) {
            const responseMessage = {
                ...baseMessage, // 复用时间戳和发送者信息
                type: 'text',
                content: msgData.responseText
            };
            chat.history.push(responseMessage);
            if (isViewingThisChat) {
                appendMessage(responseMessage, chat);
            }
        }

        // 2. 根据同意或拒绝，执行后续操作
        if (msgData.decision === 'accept') {
            chat.loversSpaceData = {
                background: 'https://i.postimg.cc/k495F4W5/profile-banner.jpg',
                relationshipStartDate: null, moments: [], photos: [], albums: [], loveLetters: [], shares: [], questions: [],
            };
            const systemNotice = {
                role: 'system', type: 'pat_message',
                content: `[系统：你和“${chat.name}”的情侣空间已成功开启！]`,
                timestamp: Date.now()
            };
            chat.history.push(systemNotice);
            if (isViewingThisChat) {
                appendMessage(systemNotice, chat);
            }
        }
    }
    // 处理完后，不再需要重新触发AI，所以我们用 continue
    continue;
}
// ▼▼▼ 在 triggerAiResponse 的 switch 语句中，用这块新代码替换旧的 case 'interact_with_pet' ▼▼▼
case 'interact_with_pet': {
    const pet = chat.settings.pet;
    if (pet && pet.type !== '无') {
        let actionText = '';
        // 根据AI的互动，修改数值
        switch(msgData.action) {
            case 'feed':
                pet.status.hunger = Math.min(100, (pet.status.hunger || 0) + 20);
                pet.status.happiness = Math.min(100, (pet.status.happiness || 0) + 5);
                // ★★★ 核心修改：AI喂食，增加对AI的亲密度 ★★★
                pet.status.intimacyToChar = Math.min(100, (pet.status.intimacyToChar || 0) + 10);
                actionText = `${chat.name} 喂了 ${pet.name} 一些食物。`;
                break;
            case 'play':
                pet.status.hunger = Math.max(0, (pet.status.hunger || 0) - 10);
                pet.status.happiness = Math.min(100, (pet.status.happiness || 0) + 15);
                // ★★★ 核心修改：AI玩耍，增加对AI的亲密度 ★★★
                pet.status.intimacyToChar = Math.min(100, (pet.status.intimacyToChar || 0) + 15);
                actionText = `${chat.name} 陪 ${pet.name} 玩了一会儿。`;
                break;
            case 'touch':
                pet.status.happiness = Math.min(100, (pet.status.happiness || 0) + 10);
                // ★★★ 核心修改：AI抚摸，增加对AI的亲密度 ★★★
                pet.status.intimacyToChar = Math.min(100, (pet.status.intimacyToChar || 0) + 5);
                actionText = `${chat.name} 轻轻地抚摸了 ${pet.name}。`;
                break;
        }

        // 创建一条对用户可见的系统消息
        const visibleMessage = {
            role: 'system',
            type: 'pat_message',
            content: `[系统：${actionText}]`,
            timestamp: Date.now()
        };
        chat.history.push(visibleMessage);
        if (isViewingThisChat) {
            appendMessage(visibleMessage, chat);
        }
        
        // 如果 AI 在互动后还想说点什么
        if (msgData.response) {
            aiMessage = { ...baseMessage, content: msgData.response };
        }
    }
    // 如果AI只是互动没说话，就不创建aiMessage，直接跳到下一个指令
    if (!aiMessage) {
        continue;
    }
    break;
}
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 用这块【已修复】的代码替换旧的 'talk_to_pet' case ▼▼▼
case 'talk_to_pet': {
    if (!chat.isGroup && chat.settings.pet && chat.settings.pet.type !== '无') {
        const pet = chat.settings.pet;
        
        // ★★★ 核心修复1：同时兼容 content 和 message 字段 ★★★
        const charMessageContent = msgData.content || msgData.message;
        if (!charMessageContent) continue; // 如果没内容，就跳过

        // 将Char的话添加到宠物聊天记录
        const charMessageToPet = { 
            sender: 'char', 
            senderName: chat.name, 
            content: charMessageContent 
        };
        pet.petChatHistory.push(charMessageToPet);
        
        // 获取宠物的回应
        const petResponseToChar = await getPetApiResponse(pet);
        if (petResponseToChar) {
            pet.petChatHistory.push({ sender: 'pet', content: petResponseToChar });
        }

        // 创建对用户可见的系统日志
        const visibleLog = `[系统：“${chat.name}”对宠物“${pet.name}”说：“${charMessageContent}”，它回应：“${petResponseToChar || '(没有回应)'}”。]`;
        const visibleMessage = {
            role: 'system',
            type: 'pat_message',
            content: visibleLog,
            timestamp: messageTimestamp++
        };
        chat.history.push(visibleMessage);
        
        if (isViewingThisChat) {
            appendMessage(visibleMessage, chat);
        }
    }
    continue;
}
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼
case 'cart_payment_response': {
    const decision = msgData.decision;
    const responseText = msgData.response_text;

    // 找到用户发出的、还处于“等待中”的那个代付请求
    const requestMsg = chat.history.find(m => m.type === 'cart_share_request' && m.payload.status === 'pending');
    if (!requestMsg) continue; // 如果找不到，说明请求可能已被处理，跳过

    if (decision === 'accept') {
        const totalPrice = requestMsg.payload.totalPrice;
        const charBalance = chat.characterPhoneData?.bank?.balance || 0;

        // 再次确认AI的余额是否足够
        if (charBalance < totalPrice) {
            // 如果AI想付但钱不够，就让它说一句俏皮话
            aiMessage = { ...baseMessage, content: responseText || "呜呜，想给你买，但是我的钱包空空了..." };
        } else {
            // 钱够，执行代付流程！
            requestMsg.payload.status = 'paid';
            
            // 使用 await 确保这些数据库操作按顺序完成
            await updateCharacterPhoneBankBalance(chat.id, -totalPrice, `为“我”的桃宝购物车买单`);
            const cartItems = await db.taobaoCart.toArray();
            await createOrdersFromCart(cartItems);
            await clearTaobaoCart();
            
            // 创建AI的回复消息
            aiMessage = { ...baseMessage, content: responseText || "买好啦，快去订单里看看吧！" };
        }
    } else { // 如果AI决定拒绝
        requestMsg.payload.status = 'rejected';
        aiMessage = { ...baseMessage, content: responseText || "这次就算了吧，下次一定！" };
    }

    // 将AI的回复消息推入历史记录，并更新UI
    if (aiMessage) {
        chat.history.push(aiMessage);
    }

    // 重新渲染聊天界面，以更新代付卡片的状态
    if (isViewingThisChat) {
        renderChatInterface(chatId);
    }
    // 跳过后续的默认消息处理
    continue;
}
// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 把这一整块全新的 case 代码，粘贴到 switch 语句块的【内部】 ▼▼▼
// 例如，可以放在 case 'transfer': 的后面

case 'buy_gift_for_user': {
    // 1. 从商品数据库中获取所有已添加的商品
    const allProducts = await db.taobaoProducts.toArray();
    
    // 如果桃宝里一件商品都没有，AI就发条消息吐槽一下
    if (allProducts.length === 0) {
        aiMessage = { ...baseMessage, content: msgData.greeting ? `${msgData.greeting} ...啊，想给你买点什么，但是桃宝里空空如也呢...` : "想给你买个礼物，但是桃宝现在没东西卖了。" };
        break; // 跳出 case，让这条文本消息被正常处理和显示
    }

    // 2. 从所有商品中随机挑选一件作为礼物
    const productToBuy = getRandomItem(allProducts);

    // 3. 检查角色的钱包余额是否足够
    const charBalance = chat.characterPhoneData?.bank?.balance || 0;
    if (charBalance < productToBuy.price) {
        // 余额不足，AI也会发消息告诉你
        aiMessage = { ...baseMessage, content: msgData.greeting ? `${msgData.greeting} ...哎呀，我的钱包好像不够了。` : "我想给你买个礼物，但是钱包空了..." };
        break;
    }

    // 4. 余额充足！执行购买流程
    // 4a. 从角色的钱包扣款，并生成一条交易记录
    await updateCharacterPhoneBankBalance(chat.id, -productToBuy.price, `为“我”购买礼物: ${productToBuy.name}`);

    // 4b. 在你的“我的订单”中创建一条新订单
    const newOrder = {
        productId: productToBuy.id,
        quantity: 1,
        timestamp: Date.now(),
        status: '已付款，等待发货'
    };
    await db.taobaoOrders.add(newOrder);
    
    // 4c. 创建一个漂亮的“礼物通知”卡片消息，发送给你
    aiMessage = {
        ...baseMessage, // 复用基础消息属性（发送者、时间戳等）
        type: 'gift_notification',
        // 这是卡片渲染需要的数据
        payload: {
            senderName: chat.name,
            itemSummary: `${productToBuy.name} x1`,
            totalPrice: productToBuy.price,
            itemCount: 1,
        },
        // 这是给AI自己看的、用于形成记忆的文本内容
        content: `我给你买了礼物“${productToBuy.name}”。${msgData.greeting || ''}`
    };
    
    // 4d. 模拟一个10秒后的“已发货”物流更新
    setTimeout(async () => {
        const orderToUpdate = await db.taobaoOrders.where({ timestamp: newOrder.timestamp }).first();
        if (orderToUpdate) {
            await db.taobaoOrders.update(orderToUpdate.id, { status: '已发货，运输中' });
        }
    }, 1000 * 10);
    
    break; // 完成礼物购买逻辑，跳出 case
}

// ▲▲▲ 新增 case 代码粘贴结束 ▲▲▲
// ▼▼▼ 把这一整块全新的代码，粘贴到 triggerAiResponse 函数的 switch 结构里 ▼▼▼

case 'ls_answer_question': { // 使用大括号创建块级作用域
    const { questionId, answerText } = msgData;
    if (questionId && answerText) {
        const question = chat.loversSpaceData.questions.find(q => q.id === questionId);
        if (question && !question.answerText) { // 确保是未回答的问题
            question.answerer = 'char';
            question.answerText = answerText;
            console.log(`AI 回答了情侣提问 (ID: ${questionId})`);
        }
    }
    continue; // 这是一个后台操作，不需要在聊天界面显示，所以用 continue 跳过
}
// ▲▲▲ 粘贴结束 ▲▲▲
case 'ls_ask_question': {
    const { questionText } = msgData;
    if (questionText) {
        const newQuestion = {
            id: 'q_' + Date.now(),
            questioner: 'char',
            questionText: questionText,
            timestamp: Date.now(),
            answerer: 'user', // 指定由用户来回答
            answerText: null
        };
        if (!chat.loversSpaceData.questions) {
            chat.loversSpaceData.questions = [];
        }
        chat.loversSpaceData.questions.push(newQuestion);
        console.log(`AI 发起了一个情侣提问: ${questionText}`);
    }
    continue; // 同样是后台操作
}
// ▼▼▼ 把这一整块全新的代码，粘贴到 triggerAiResponse 函数的 switch 结构里 ▼▼▼
case 'ls_moment': {
    if (chat.loversSpaceData) {
        if (!chat.loversSpaceData.moments) {
            chat.loversSpaceData.moments = [];
        }
        const newMoment = {
            author: 'char', // 标记是AI发的
            content: msgData.content,
            timestamp: Date.now(),
            comments: [] // 为新说说初始化一个空的评论区
        };
        chat.loversSpaceData.moments.push(newMoment);
        console.log(`AI 在情侣空间发布了说说: ${msgData.content}`);
    }
    continue; // 这是一个后台操作，不需要在聊天界面显示，所以用 continue 跳过
}

case 'ls_comment': {
    const { momentIndex, commentText } = msgData;
    if (chat.loversSpaceData && chat.loversSpaceData.moments) {
        // AI返回的 index 是从0开始代表最新的，我们需要转换成真实索引
        const realIndex = chat.loversSpaceData.moments.length - 1 - momentIndex;
        if (realIndex >= 0 && realIndex < chat.loversSpaceData.moments.length) {
            const momentToComment = chat.loversSpaceData.moments[realIndex];
            if (!momentToComment.comments) {
                momentToComment.comments = [];
            }
            momentToComment.comments.push({
                author: chat.name,
                text: commentText
            });
            console.log(`AI 评论了情侣空间说说 (索引: ${realIndex}): ${commentText}`);
        }
    }
    continue; // 同样是后台操作
}
case 'ls_photo': { // 这是处理AI发相册的逻辑
    if (chat.loversSpaceData) {
        if (!chat.loversSpaceData.photos) {
            chat.loversSpaceData.photos = [];
        }
        const newPhoto = {
            author: 'char',
            type: 'text_image',
            description: msgData.description,
            timestamp: Date.now()
        };
        chat.loversSpaceData.photos.push(newPhoto);
        console.log(`AI 在情侣空间发布了照片(文字图): ${msgData.description}`);
    }
    continue; // 继续处理AI可能返回的其他指令
}

case 'ls_letter': { // 这是处理AI写情书的逻辑
    if (chat.loversSpaceData) {
        if (!chat.loversSpaceData.loveLetters) {
            chat.loversSpaceData.loveLetters = [];
        }
        const newLetter = {
            id: 'letter_' + Date.now(),
            senderId: chat.id,
            senderName: chat.name,
            senderAvatar: chat.settings.aiAvatar,
            recipientName: chat.settings.myNickname || '我',
            recipientAvatar: chat.settings.myAvatar,
            content: msgData.content,
            timestamp: Date.now()
        };
        chat.loversSpaceData.loveLetters.push(newLetter);
        console.log(`AI 在情侣空间写了情书: ${msgData.content}`);
    }
    continue; // 继续处理AI可能返回的其他指令
}

// ▼▼▼ 在 switch (msgData.type) 结构内，粘贴这个全新的 case ▼▼▼
case 'ls_diary_entry': {
    const { emoji, diary } = msgData;
    if (emoji && diary) {
        const today = new Date().toISOString().split('T')[0]; // 获取 YYYY-MM-DD 格式的今天日期
        
        // 确保数据结构存在
        if (!chat.loversSpaceData.emotionDiaries) {
            chat.loversSpaceData.emotionDiaries = {};
        }
        if (!chat.loversSpaceData.emotionDiaries[today]) {
            chat.loversSpaceData.emotionDiaries[today] = {};
        }

        // 保存AI的日记和表情
        chat.loversSpaceData.emotionDiaries[today].charEmoji = emoji;
        chat.loversSpaceData.emotionDiaries[today].charDiary = diary;
        
        console.log(`AI 在情侣空间记录了日记: ${emoji} ${diary}`);
    }
    continue; // 这只是一个后台操作，不需要在聊天界面生成消息，所以用 continue 跳过
}
// ▲▲▲ 新增 case 粘贴结束 ▲▲▲

case 'ls_share': {
    if (chat.loversSpaceData) {
        if (!chat.loversSpaceData.shares) {
            chat.loversSpaceData.shares = [];
        }
        const newShare = {
            author: 'char', // 标记是AI发的
            timestamp: Date.now(),
            ...msgData // 将AI返回的所有分享信息（type, shareType, title, artist等）都复制过来
        };
        chat.loversSpaceData.shares.push(newShare);
        console.log(`AI 在情侣空间分享了 [${msgData.shareType}]: ${msgData.title}`);
    }
    continue; // 同样是后台操作
}
// ▲▲▲ 粘贴结束 ▲▲▲

                // 这是AI主动发起邀请的逻辑
                case 'lovers_space_invitation': {
                    // 检查是否已经开启，防止AI重复邀请
                    if (!chat.loversSpaceData) {
                        aiMessage = {
                            ...baseMessage,
                            type: 'lovers_space_invitation',
                            content: `${chat.name} 向你发出了一个情侣空间邀请`, // 这句话主要用于调试和历史记录
                            status: 'pending' // 状态：pending, accepted, rejected
                        };
                    }
                    // 如果AI已经发了邀请，这里就不再创建aiMessage，相当于跳过
                    break;
                }

                // 这是AI回应你的邀请的逻辑
                case 'lovers_space_response': {
                    const invitationMsg = chat.history.find(m => m.type === 'lovers_space_invitation' && m.status === 'pending');
                    if (invitationMsg) {
                        invitationMsg.status = msgData.decision === 'accept' ? 'accepted' : 'rejected';

                        // 1. 创建AI想说的那句话的消息
                        if (msgData.responseText) {
                            const responseMessage = {
                                ...baseMessage,
                                type: 'text',
                                content: msgData.responseText
                            };
                            chat.history.push(responseMessage);
                            if (isViewingThisChat) {
                                appendMessage(responseMessage, chat);
                            }
                        }

                        // 2. 根据同意或拒绝，执行后续操作
                        if (msgData.decision === 'accept') {
                            // 同意后，为这个角色创建情侣空间数据
                            chat.loversSpaceData = {
                                background: 'https://i.postimg.cc/k495F4W5/profile-banner.jpg',
                                relationshipStartDate: null, moments: [], photos: [], albums: [], loveLetters: [], shares: [], questions: [],
                            };
                            // 并发送一条系统通知
                            const systemNotice = {
                                role: 'system', type: 'pat_message',
                                content: `[系统：你和“${chat.name}”的情侣空间已成功开启！]`,
                                timestamp: Date.now()
                            };
                            chat.history.push(systemNotice);
                            if (isViewingThisChat) {
                                appendMessage(systemNotice, chat);
                            }
                        }
                    }
                    // 处理完后，不再需要生成新的aiMessage，所以用 continue 跳过
                    continue;
                }
                
// ▲▲▲ 粘贴结束 ▲▲▲
case 'qzone_post':
    const newPost = { 
        type: msgData.postType, 
        content: msgData.content || '', 
        publicText: msgData.publicText || '', 
        hiddenContent: msgData.hiddenContent || '', 
        timestamp: Date.now(), 
        authorId: chatId, 
        authorGroupId: chat.groupId, // 【核心新增】记录作者的分组ID
        visibleGroupIds: null 
    };
    await db.qzonePosts.add(newPost);
                    updateUnreadIndicator(unreadPostsCount + 1);
                    if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) {
                       await renderQzonePosts();
                    }
                    continue;

// ▼▼▼ 步骤3.4：在 triggerAiResponse 中替换这个 case ▼▼▼
case 'qzone_comment':
    const postToComment = await db.qzonePosts.get(parseInt(msgData.postId));
    if (postToComment) {
        if (!postToComment.comments) postToComment.comments = [];
        
        const newAiComment = { 
            commenterName: msgData.commenterName || chat.name,
            text: msgData.commentText, 
            timestamp: Date.now() 
        };
        
        // 【核心修改】检查AI是否指定了回复对象
        if (msgData.replyTo) {
            newAiComment.replyTo = msgData.replyTo;
        }

        postToComment.comments.push(newAiComment);
        await db.qzonePosts.update(postToComment.id, { comments: postToComment.comments });
        updateUnreadIndicator(unreadPostsCount + 1);
        if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) {
           await renderQzonePosts();
        }
    }
    continue;
// ▲▲▲ 步骤3.4替换结束 ▲▲▲



                case 'qzone_like':
                   const postToLike = await db.qzonePosts.get(parseInt(msgData.postId));
                   if (postToLike) {
                       if (!postToLike.likes) postToLike.likes = [];
                       if (!postToLike.likes.includes(chat.name)) {
                           postToLike.likes.push(chat.name);
                           await db.qzonePosts.update(postToLike.id, { likes: postToLike.likes });
                           updateUnreadIndicator(unreadPostsCount + 1);
                           if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) {
                              await renderQzonePosts();
                           }
                       }
                   }
                    continue;

                case 'video_call_request':
                    if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
                        state.activeChatId = chatId;
                        videoCallState.activeChatId = chatId; 
                        videoCallState.isAwaitingResponse = true;
                        videoCallState.isGroupCall = chat.isGroup;
                        videoCallState.callRequester = msgData.name || chat.name;
                        showIncomingCallModal(chatId); // <--- 把chatId作为参数传进去
    }
                    continue;

            case 'group_call_request':
                if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
                    state.activeChatId = chatId;
                    videoCallState.isAwaitingResponse = true;
                    videoCallState.isGroupCall = true;
                    videoCallState.initiator = 'ai';
                    videoCallState.callRequester = msgData.name;
                    showIncomingCallModal();
                }
                continue;

                case 'pat_user':
                    const suffix = msgData.suffix ? ` ${msgData.suffix.trim()}` : '';
                    const patText = `${msgData.name || chat.name} 拍了拍我${suffix}`;
                    const patMessage = { 
                        role: 'system', 
                        type: 'pat_message', 
                        content: patText, 
                        timestamp: Date.now() 
                    };
                    chat.history.push(patMessage);
                    if (isViewingThisChat) {
                        const phoneScreen = document.getElementById('phone-screen');
                        phoneScreen.classList.remove('pat-animation');
                        void phoneScreen.offsetWidth;
                        phoneScreen.classList.add('pat-animation');
                        setTimeout(() => phoneScreen.classList.remove('pat-animation'), 500);
                        appendMessage(patMessage, chat);
                    } else {
                        showNotification(chatId, patText);
                    }
                    continue; 

                case 'update_status':
                    chat.status.text = msgData.status_text;
                    chat.status.isBusy = msgData.is_busy || false;
                    chat.status.lastUpdate = Date.now();
                    
                    const statusUpdateMessage = {
                        role: 'system',
                        type: 'pat_message',
                        content: `[${chat.name}的状态已更新为: ${msgData.status_text}]`,
                        timestamp: Date.now()
                    };
                    chat.history.push(statusUpdateMessage);

                    if (isViewingThisChat) {
                        appendMessage(statusUpdateMessage, chat);
                    }
                    
                    renderChatList(); 
                    
                    continue; 

                case 'change_music':
                    if (musicState.isActive && musicState.activeChatId === chatId) {
                        const songNameToFind = msgData.song_name;
                        
                        const targetSongIndex = musicState.playlist.findIndex(
                            track => track.name.toLowerCase() === songNameToFind.toLowerCase()
                        );

                        if (targetSongIndex > -1) {
                            playSong(targetSongIndex);

                            const track = musicState.playlist[targetSongIndex];
                            const musicChangeMessage = {
                                role: 'system',
                                type: 'pat_message',
                                content: `[♪ ${chat.name} 为你切歌: 《${track.name}》 - ${track.artist}]`,
                                timestamp: Date.now()
                            };
                            chat.history.push(musicChangeMessage);

                            if (isViewingThisChat) {
                                appendMessage(musicChangeMessage, chat);
                            }
                        }
                    }
                    continue;
                case 'create_memory':
                    const newMemory = {
                        chatId: chatId,
                        authorName: chat.name,
                        description: msgData.description,
                        timestamp: Date.now(),
                        type: 'ai_generated'
                    };
                    await db.memories.add(newMemory);

                    console.log(`AI "${chat.name}" 记录了一条新回忆:`, msgData.description);
                    
                    continue; 

        case 'create_countdown':
            const targetDate = new Date(msgData.date);
            if (!isNaN(targetDate) && targetDate > new Date()) {
                const newCountdown = {
                    chatId: chatId,
                    authorName: chat.name,
                    description: msgData.title,
                    timestamp: Date.now(),
                    type: 'countdown',
                    targetDate: targetDate.getTime()
                };
                await db.memories.add(newCountdown);
                console.log(`AI "${chat.name}" 创建了一个新约定:`, msgData.title);
            }
            continue;

    case 'block_user':
        if (!chat.isGroup) {
            chat.relationship.status = 'blocked_by_ai';

        // ▼▼▼ 在这里添加下面的代码 ▼▼▼
// ▼▼▼ 用这段新代码替换掉上面那段 ▼▼▼
const hiddenMessage = {
    role: 'system',
    content: `[系统最高指令]
# 任务：回应情侣空间邀请
用户刚刚向你发起了“开启情侣空间”的邀请。你【必须】根据你的人设，决定是同意还是拒绝。

# 输出格式铁律 (必须严格遵守)
你的回复【必须且只能】是【一个】JSON对象，格式如下:
{"type": "lovers_space_response", "decision": "accept" 或 "reject", "responseText": "你想说的话..."}

# 示例
- 如果同意: {"type": "lovers_space_response", "decision": "accept", "responseText": ""}
- 如果拒绝: {"type": "lovers_space_response", "decision": "reject", "responseText": ""}

现在，请立即做出你的决定。`,
    timestamp: Date.now() + 1,
    isHidden: true
};
        chat.history.push(hiddenMessage);
        // ▲▲▲ 添加结束 ▲▲▲

            await db.chats.put(chat);
            
            if (isViewingThisChat) {
                renderChatInterface(chatId);
            }
            renderChatList();
            
            break; 
        }
        continue;
                case 'friend_request_response':
                    if (!chat.isGroup && chat.relationship.status === 'pending_ai_approval') {
                        if (msgData.decision === 'accept') {
                            chat.relationship.status = 'friend';
                            aiMessage = { ...baseMessage, content: "我通过了你的好友申请，我们现在是好友啦！" };
                        } else {
                            chat.relationship.status = 'blocked_by_ai';
                            aiMessage = { ...baseMessage, content: "抱歉，我拒绝了你的好友申请。" };
                        }
                        chat.relationship.applicationReason = '';
                    }
                    break;
// ▼▼▼ 请用这块【功能完整且已修复】的代码，完整替换你旧的 case 'poll' 代码块 ▼▼▼
case 'poll': {
    // 【核心修复】在这里，我们同时处理来自AI和用户的投票消息
    let pollInfoText = '';
    
    // 判断这条投票消息是谁发的
    if (msg.role === 'user') {
        const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
        pollInfoText = `[系统提示：用户 (${myNickname}) 发起了一个投票。问题：“${msg.question}”, 选项：“${msg.options.join('", "')}”。你可以使用 'vote' 指令参与投票。]`;
    } else { // 如果是AI发的
        pollInfoText = `[系统提示：${msg.senderName} 发起了一个投票。问题：“${msg.question}”, 选项：“${msg.options.join('", "')}”。]`;
    }

    // 最终，我们把这条格式化好的文本作为系统消息发送给AI
    // 注意：这里我们返回的是一个新对象，而不是修改原始的aiMessage
    // 因此，我们将它放在了messagesPayload的构建循环里
    aiMessage = { role: 'system', content: pollInfoText, isHidden: true };
    break; // break不能少
}
// ▲▲▲ 替换结束 ▲▲▲      
// ▼▼▼ 请用这块【功能完整且已修复】的代码，完整替换你旧的 case 'vote' 代码块 ▼▼▼
case 'vote': { // 使用大括号创建独立的块级作用域
    const pollToVote = chat.history.find(m => m.timestamp === msgData.poll_timestamp);
    
    // 安全检查：如果投票不存在或已关闭，则不处理
    if (pollToVote && !pollToVote.isClosed) {
        
        // --- 核心修复逻辑从这里开始 ---

        // 1. 【首先】根据AI的“本名”，找到其成员对象，并获取正确的“群昵称”
        const member = chat.members.find(m => m.originalName === msgData.name);
        const displayName = member ? member.groupNickname : msgData.name;

        // 2. 【然后】使用正确的“群昵称”去移除该角色之前的所有投票
        Object.keys(pollToVote.votes).forEach(option => {
            const voterIndex = pollToVote.votes[option].indexOf(displayName); // 使用 displayName
            if (voterIndex > -1) {
                pollToVote.votes[option].splice(voterIndex, 1);
            }
        });

        // 3. 【最后】将“群昵称”添加到新的选项中
        if (!pollToVote.votes[msgData.choice]) {
            pollToVote.votes[msgData.choice] = [];
        }
        
        // （可选但推荐）再次检查，避免意外重复添加
        if (!pollToVote.votes[msgData.choice].includes(displayName)) {
            pollToVote.votes[msgData.choice].push(displayName);
        }

        // --- 核心修复逻辑结束 ---
        
        // 如果用户正在看这个聊天，就刷新界面让他们看到变化
        if (isViewingThisChat) {
            renderChatInterface(chatId);
        }
    }
    // 这是一个后台操作，不需要生成新的消息，所以用 continue
    continue;
}
// ▲▲▲ 替换结束 ▲▲▲
    case 'red_packet':
        aiMessage = {
            ...baseMessage,
            type: 'red_packet',
            packetType: msgData.packetType,
            totalAmount: msgData.amount,
            count: msgData.count,
            greeting: msgData.greeting,
            receiverName: msgData.receiver,
            claimedBy: {},
            isFullyClaimed: false,
        };
                // ▼▼▼ 在这里添加新代码 ▼▼▼
        // 【全新】同步到角色钱包（支出）
        const rpDescription = `发出红包 - ${msgData.greeting || '恭喜发财'}`;
        await updateCharacterBankBalance(chatId, -msgData.amount, rpDescription);
        // ▲▲▲ 新代码粘贴结束 ▲▲▲
        break;
// ▼▼▼ 用这整块【最终修复版】代码，完整替换掉你旧的 case 'open_red_packet' 代码块 ▼▼▼
case 'open_red_packet': { // 使用大括号创建独立的块级作用域
    const packetToOpen = chat.history.find(m => m.timestamp === msgData.packet_timestamp);
    // 检查红包是否存在、是否没被领完、以及这个AI角色是否还没领过
    if (packetToOpen && !packetToOpen.isFullyClaimed && !(packetToOpen.claimedBy && packetToOpen.claimedBy[msgData.name])) {

        // 1. 【核心修复】根据AI的本名(msgData.name)，从成员列表找到其正确的群昵称
        const member = chat.members.find(m => m.originalName === msgData.name);
        const displayName = member ? member.groupNickname : msgData.name;
        
        let claimedAmountAI = 0;
        const remainingAmount = packetToOpen.totalAmount - Object.values(packetToOpen.claimedBy || {}).reduce((sum, val) => sum + val, 0);
        const remainingCount = packetToOpen.count - Object.keys(packetToOpen.claimedBy || {}).length;

        if (remainingCount > 0) {
            if (remainingCount === 1) { // 如果是最后一个
                claimedAmountAI = remainingAmount;
            } else { // 如果不是最后一个，随机分配
                const min = 0.01;
                const max = remainingAmount - (remainingCount - 1) * min;
                claimedAmountAI = Math.random() * (max - min) + min;
            }
            claimedAmountAI = parseFloat(claimedAmountAI.toFixed(2));
            
            // 2. 确保 claimedBy 对象存在
            if (!packetToOpen.claimedBy) packetToOpen.claimedBy = {};
            // 3. 【核心修复】使用我们刚刚查找到的 displayName 作为记录的key
            packetToOpen.claimedBy[displayName] = claimedAmountAI;
            
            // 4. 发送对用户可见的系统消息
            const aiClaimedMessage = {
                role: 'system',
                type: 'pat_message',
                // 【核心修复】系统消息里也使用 displayName
                content: `${displayName} 领取了 ${packetToOpen.senderName} 的红包`,
                timestamp: Date.now()
            };
            chat.history.push(aiClaimedMessage);

            let hiddenContentForAI = `[系统提示：你 (${displayName}) 成功抢到了 ${claimedAmountAI.toFixed(2)} 元。`;

            // 5. 【【【这就是最关键的部分！】】】检查红包是否被领完
            if (Object.keys(packetToOpen.claimedBy).length >= packetToOpen.count) {
                packetToOpen.isFullyClaimed = true; // 标记为已领完
                
                // 发送对用户可见的“已领完”通知
                const finishedMessage = {
                    role: 'system',
                    type: 'pat_message',
                    content: `${packetToOpen.senderName} 的红包已被领完`,
                    timestamp: Date.now() + 1
                };
                chat.history.push(finishedMessage);
                
                // 开始构建给AI看的“战报”
                hiddenContentForAI += ` 红包已被领完。`;

                // 如果是拼手气红包，找出谁是手气王
                let luckyKing = { name: '', amount: -1 };
                if (packetToOpen.packetType === 'lucky' && packetToOpen.count > 1) {
                    Object.entries(packetToOpen.claimedBy).forEach(([name, amount]) => {
                        if (amount > luckyKing.amount) {
                            luckyKing = { name, amount };
                        }
                    });
                }
                // 把手气王信息也加到“战报”里
                if (luckyKing.name) {
                     hiddenContentForAI += ` 手气王是 ${luckyKing.name}！`;
                }
            }
            hiddenContentForAI += ' 请根据这个结果发表你的评论。]';

            // 6. 创建并添加给AI看的隐藏消息
            const hiddenMessageForAI = {
                role: 'system',
                content: hiddenContentForAI,
                timestamp: Date.now() + 2, // 确保时间戳在后
                isHidden: true
            };
            chat.history.push(hiddenMessageForAI);
        }
        
        // 7. 刷新UI（如果用户正在看的话）
        if (isViewingThisChat) {
            renderChatInterface(chatId);
        }
    }
    continue; // 这是一个后台操作，继续处理AI可能返回的其他消息
}
// ▲▲▲ 替换结束 ▲▲▲


case 'change_avatar':
    const avatarName = msgData.name;
    // 在该角色的头像库中查找
    const foundAvatar = chat.settings.aiAvatarLibrary.find(avatar => avatar.name === avatarName);
    
    if (foundAvatar) {
        // 找到了，就更新头像
        chat.settings.aiAvatar = foundAvatar.url;
        
        // 创建一条系统提示，告知用户头像已更换
        const systemNotice = {
            role: 'system',
            type: 'pat_message', // 复用居中样式
            content: `[${chat.name} 更换了头像]`,
            timestamp: Date.now()
        };
        chat.history.push(systemNotice);
        
        // 如果在当前聊天界面，则实时渲染
        if (isViewingThisChat) {
            appendMessage(systemNotice, chat);
            // 立刻刷新聊天界面以显示新头像
            renderChatInterface(chatId);
        }
    }
    // 处理完后，继续处理AI可能返回的其他消息
    continue;

// ▼▼▼ 在 triggerAiResponse 的 switch 语句中，【添加】这两个全新的 case ▼▼▼

                case 'accept_transfer': { // 使用大括号创建块级作用域
                    const originalTransferMsgIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                    if (originalTransferMsgIndex > -1) {
                        const originalMsg = chat.history[originalTransferMsgIndex];
                        originalMsg.status = 'accepted';
                        
                        // ▼▼▼ 在这里添加新代码 ▼▼▼
                        // 【全新】同步到角色钱包（收入）
                        const acceptDescription = `收到来自 ${originalMsg.senderName} 的转账`;
                        await updateCharacterBankBalance(chatId, originalMsg.amount, acceptDescription);
                        // ▲▲▲ 新代码粘贴结束 ▲▲▲
                    }
                    continue; // 接受指令只修改状态，不产生新消息
                }

                case 'decline_transfer': { // 使用大括号创建块级作用域
                    const originalTransferMsgIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                    if (originalTransferMsgIndex > -1) {
                        const originalMsg = chat.history[originalTransferMsgIndex];
                        originalMsg.status = 'declined';
                        
                        // 【核心】创建一条新的“退款”消息
                        const refundMessage = {
                            role: 'assistant',
                            senderName: chat.name,
                            type: 'transfer',
                            isRefund: true, // 标记这是一条退款消息
                            amount: originalMsg.amount,
                            note: '转账已被拒收',
                            timestamp: messageTimestamp++ // 使用递增的时间戳
                        };
                        
                        // 将新消息推入历史记录，它会被后续的循环处理并渲染
                        chat.history.push(refundMessage);

        // ▼▼▼ 在这里添加下面的代码 ▼▼▼
        if (isViewingThisChat) {
            // 因为退款消息是新生成的，所以我们直接将它添加到界面上
            appendMessage(refundMessage, chat); 
            // 同时，原始的转账消息状态变了，所以要重绘整个界面以更新它
            renderChatInterface(chatId); 
        }
        // ▲▲▲ 添加结束 ▲▲▲

                    }
                    continue; // 继续处理AI返回的文本消息
                }

// ▲▲▲ 添加结束 ▲▲▲

    case 'system_message':
        aiMessage = { role: 'system', type: 'pat_message', content: msgData.content, timestamp: Date.now() };
        break;

// ▼▼▼ 在 triggerAiResponse 的 switch 语句中，【必须添加】这个新的 case ▼▼▼

                case 'share_link':
                    aiMessage = { 
                        ...baseMessage, 
                        type: 'share_link',
                        title: msgData.title,
                        description: msgData.description,
                        // thumbnail_url: msgData.thumbnail_url, // 我们已经决定不要图片了，所以这行可以不要
                        source_name: msgData.source_name,
                        content: msgData.content // 这是文章正文，点击卡片后显示的内容
                    };
                    break;

// ▲▲▲ 添加结束 ▲▲▲

case 'quote_reply':
    const originalMessage = chat.history.find(m => m.timestamp === msgData.target_timestamp);
    if (originalMessage) {
        const quoteContext = {
            timestamp: originalMessage.timestamp,
            senderName: originalMessage.senderName || (originalMessage.role === 'user' ? (chat.settings.myNickname || '我') : chat.name),
            content: String(originalMessage.content || ''), // 核心修复：移除了 .substring(0, 50)
        };
        aiMessage = { 
            ...baseMessage, 
            content: msgData.reply_content,
            quote: quoteContext
        };
    } else {
        aiMessage = { ...baseMessage, content: msgData.reply_content };
    }
    break;


case 'location':
    aiMessage = {
        ...baseMessage,
        type: 'location',
        userLocation: msgData.userLocation,
        aiLocation: msgData.aiLocation,
        distance: msgData.distance,
        trajectoryPoints: msgData.trajectoryPoints || [] // 【新增】确保即使AI没提供，也是一个空数组
    };
    break;
// ▲▲▲ 替换结束 ▲▲▲

case 'send_and_recall': {
    // --- 动画部分 (保持不变) ---
    if (!isViewingThisChat) continue;
    const tempMessageData = { ...baseMessage, content: msgData.content };
    appendMessage(tempMessageData, chat, true);
    await new Promise(resolve => setTimeout(resolve, Math.random() * 1000 + 1500));
    const bubbleWrapper = document.querySelector(`.message-bubble[data-timestamp="${tempMessageData.timestamp}"]`)?.closest('.message-wrapper');
    if (bubbleWrapper) {
        bubbleWrapper.classList.add('recalled-animation');
        await new Promise(resolve => setTimeout(resolve, 300));
    }

    // --- 核心修改：数据记录与AI感知 ---
    
    // 1. 创建对用户可见的“已撤回”消息
    const recalledMessage = {
        role: 'assistant',
        senderName: msgData.name || chat.name,
        type: 'recalled_message',
        content: '对方撤回了一条消息',
        timestamp: tempMessageData.timestamp,
        recalledData: { originalType: 'text', originalContent: msgData.content }
    };
    
    // 2. 【关键】创建一条对用户隐藏、但对AI可见的“记忆”消息
    const hiddenMemoryMessage = {
        role: 'system', // 必须是 system，这样AI才知道这是上下文信息
        content: `[系统提示：你刚刚说了一句“${msgData.content}”，但立刻就撤回了它。]`,
        timestamp: tempMessageData.timestamp + 1, // 确保在撤回消息之后
        isHidden: true // 这个标记让它不在UI上显示
    };

    // 3. 将这两条消息都添加到历史记录中
    chat.history.push(recalledMessage, hiddenMemoryMessage);
    
    // 4. 替换DOM，显示“已撤回”提示
    const placeholder = createMessageElement(recalledMessage, chat);
    if(document.body.contains(bubbleWrapper)) {
        bubbleWrapper.parentNode.replaceChild(placeholder, bubbleWrapper);
    }
    
    continue;
}
                
case 'sticker': {
    // 这是为群聊和单聊统一设计的表情包逻辑
    const stickerName = msgData.sticker_name; // 关键修改：统一使用 sticker_name
    if (!stickerName) {
        console.warn('AI返回了sticker类型但没有sticker_name，已拦截:', msgData);
        continue; // 跳过这条无效指令
    }
    
    // 在所有可用表情库中查找
    const allStickers = [...state.userStickers, ...state.charStickers, ...(chat.settings.stickerLibrary || [])];
    const foundSticker = allStickers.find(s => s.name === stickerName);

    if (foundSticker) {
        // 找到了，就创建消息对象
        aiMessage = { 
            ...baseMessage, 
            type: 'sticker', 
            content: foundSticker.url, 
            meaning: foundSticker.name 
        };
    } else {
        // 没找到，说明AI幻觉了，记录警告并跳过
        console.warn(`AI杜撰了不存在的表情: "${stickerName}"，已自动拦截。`);
    }
    break;
}
            case 'text': { 
                const messageText = String(msgData.content || msgData.message || '');
                
                if (STICKER_REGEX.test(messageText)) {
                    aiMessage = { ...baseMessage, type: 'sticker', content: messageText, meaning: '' };
                } 
                else {
                    // 兼容旧的[sticker:名字]格式，但新prompt已不推荐
                    const stickerMatch = messageText.match(/^\[sticker:(.+?)\]$/); 
                    if (stickerMatch) {
                        const stickerName = stickerMatch[1].trim();
                        const allStickers = [...state.userStickers, ...state.charStickers, ...(chat.settings.stickerLibrary || [])];
                        const foundSticker = allStickers.find(s => s.name === stickerName);
                        
                        if (foundSticker) {
                            aiMessage = { ...baseMessage, type: 'sticker', content: foundSticker.url, meaning: foundSticker.name };
                        } else {
                            console.warn(`AI使用了旧格式且杜撰了不存在的表情: "${stickerName}"，已拦截。`);
                        }
                    } else {
                        aiMessage = { ...baseMessage, content: messageText };
                    }
                }
                break;
            }
// ▼▼▼ 在 switch (msgData.type) 结构内，粘贴这整块新代码 ▼▼▼

case 'dating_payment_response': {
    const originalRequest = chat.history.filter(m => m.role === 'system' && m.content.includes("dating_payment_response")).pop();
    if (!originalRequest) continue;

    const costMatch = originalRequest.content.match(/费用（(\d+(\.\d+)?)金币）/);
    const cost = costMatch ? parseFloat(costMatch[1]) : 0;
    
    if (msgData.decision === 'accept') {
        const charBalance = chat.characterPhoneData.bank.balance || 0;
        if (charBalance >= cost) {
            await updateCharacterPhoneBankBalance(chat.id, -cost, `约会支出: 为用户买单`);
            aiMessage = { ...baseMessage, content: msgData.responseText || "好呀，这次我来请客吧！" };
        } else {
            aiMessage = { ...baseMessage, content: msgData.responseText || "呜呜，我也想请客，但是钱包好像不太够呢..." };
        }
    } else {
        aiMessage = { ...baseMessage, content: msgData.responseText || "这次还是算了吧..." };
    }
    break;
}

case 'dating_aa_response': {
    const originalRequest = chat.history.filter(m => m.role === 'system' && m.content.includes("dating_aa_response")).pop();
    if (!originalRequest) continue;

    const costMatch = originalRequest.content.match(/各自支付 (\d+(\.\d+)?) 金币/);
    const splitCost = costMatch ? parseFloat(costMatch[1]) : 0;

    if (msgData.decision === 'accept') {
        const charBalance = chat.characterPhoneData.bank.balance || 0;
        if (charBalance >= splitCost) {
            await updateUserBalanceAndLogTransaction(-splitCost, `约会AA支出`);
            await updateCharacterPhoneBankBalance(chat.id, -splitCost, `约会AA支出`);
            aiMessage = { ...baseMessage, content: msgData.responseText || "好啊，AA制完全没问题！" };
        } else {
            aiMessage = { ...baseMessage, content: msgData.responseText || "这个...我的钱好像不太够付我自己的那份呢。" };
        }
    } else {
        aiMessage = { ...baseMessage, content: msgData.responseText || "我觉得AA制有点太见外了，还是我来请吧？或者你请？" };
    }
    break;
}

case 'lend_money_response': {
    const originalRequest = chat.history.filter(m => m.role === 'system' && m.content.includes("lend_money_response")).pop();
    if (!originalRequest) continue;

    const amountMatch = originalRequest.content.match(/借 (\d+(\.\d+)?) 金币/);
    const amount = amountMatch ? parseFloat(amountMatch[1]) : 0;

    // 只处理接受借款时的金钱逻辑
    if (msgData.decision === 'accept') {
        const lenderBalance = chat.characterPhoneData.bank.balance || 0;
        if (lenderBalance >= amount) {
            await updateCharacterPhoneBankBalance(chat.id, -amount, `借钱给用户`);
            await updateUserBalanceAndLogTransaction(amount, `从 ${chat.name} 处借款`);
        } else {
            // 如果AI决定同意但钱不够，我们信任AI会在下一条消息中解释。
            // 这里的金融逻辑可以做得更复杂，但目前保持简单，相信AI的判断。
            console.warn(`AI "${chat.name}" 同意借钱，但余额不足，交易未执行。`);
        }
    } 
    // 如果是拒绝(reject)，则不执行任何金融操作。

    // 【核心修改】我们不再在这里创建任何 aiMessage。
    // 使用 'continue' 跳到AI回复数组的下一项，也就是AI自己生成的文本消息，让循环的后续部分去处理它。
    continue;
}
// ▼▼▼ 请用这块【最终修复版】代码，替换旧的 case 'forum_comment' 代码块 ▼▼▼

case 'forum_comment': { // 使用大括号创建块级作用域
    const postIdToComment = msgData.postId;
    const commentText = msgData.commentText;

    if (postIdToComment && commentText) {
        // 1. 【健壮性修复】尝试将 postId 强制转换为数字。
        //    这能解决AI返回数字字符串（如"123"）导致查询失败的问题。
        const numericPostId = parseInt(postIdToComment, 10);
        
        // 检查转换后的ID是否有效
        if (isNaN(numericPostId)) {
            console.warn(`[圈子评论失败] 收到的 postId "${postIdToComment}" 不是一个有效的数字ID，已跳过。`);
            // 提示：如果频繁看到此警告，请检查你给AI的system prompt，确保你要求它返回数字ID。
            continue; // 跳过此指令
        }
        
        // 2. 【数据存储】使用正确的数字ID从数据库获取帖子
        const postToComment = await db.forumPosts.get(numericPostId);

        if (postToComment) {
            // 创建新评论对象
            const newComment = {
                postId: numericPostId, // 使用转换后的数字ID
                author: chat.name, // 评论者就是当前AI
                content: commentText,
                timestamp: Date.now()
            };
            
            // 将新评论保存到数据库
            await db.forumComments.add(newComment);
            console.log(`AI "${chat.name}" 评论了帖子 #${numericPostId}: "${commentText}"`);

            // 3. 【UI刷新修复】同时检查帖子列表页和帖子详情页
            //    这样无论你正在看哪个页面，都能看到更新。
            
            // 如果用户正在看这个小组的帖子列表，就刷新列表
            if (document.getElementById('group-screen').classList.contains('active') && activeGroupId === postToComment.groupId) {
                await renderGroupPosts(activeGroupId);
            }
            
            // 如果用户正在看这个帖子的详情页，就刷新详情页（这是本次修复的关键！）
            if (document.getElementById('post-screen').classList.contains('active') && activeForumPostId === numericPostId) {
                await renderPostDetails(numericPostId);
            }
        } else {
            console.warn(`[圈子评论失败] 未能在数据库中找到 postId 为 ${numericPostId} 的帖子。`);
        }
    }
    // 无论成功与否，这都是一个后台操作，继续处理AI可能返回的其他指令
    continue;
}

// ▲▲▲ 替换结束 ▲▲▲


                case 'ai_image':
                    aiMessage = { ...baseMessage, type: 'ai_image', content: msgData.description };
                    break;
                case 'voice_message':
                    aiMessage = { ...baseMessage, type: 'voice_message', content: msgData.content };
                    break;
                case 'transfer':
                    aiMessage = { ...baseMessage, type: 'transfer', amount: msgData.amount, note: msgData.note, receiverName: msgData.receiver || '我' };
                                        // ▼▼▼ 在这里添加新代码 ▼▼▼
                    // 【全新】同步到角色钱包（支出）
                    const transferDescription = `转账给 ${msgData.receiver || '我'}`;
                    await updateCharacterBankBalance(chatId, -msgData.amount, transferDescription);
                    // ▲▲▲ 新代码粘贴结束 ▲▲▲
                    break;
                
                case 'waimai_request':
                    aiMessage = { 
                        ...baseMessage, 
                        type: 'waimai_request',
                        productInfo: msgData.productInfo,
                        amount: msgData.amount,
                        status: 'pending',
                        countdownEndTime: Date.now() + 15 * 60 * 1000,
                    };
                    break;
                
                default:
                     console.warn("收到了未知的AI指令类型:", msgData.type);
                     break;
            }

            // 【核心修复】将渲染逻辑移出循环
            if (aiMessage) {
                // 1. 将新消息存入历史记录
                chat.history.push(aiMessage);

                if (!isViewingThisChat && !notificationShown) {
                    let notificationText;
                    switch (aiMessage.type) {
                        case 'transfer':
                            notificationText = `[收到一笔转账]`;
                            break;
                        case 'waimai_request':
                            notificationText = `[收到一个外卖代付请求]`;
                            break;
                        case 'ai_image':
                            notificationText = `[图片]`;
                            break;
                        case 'voice_message':
                            notificationText = `[语音]`;
                            break;
                        case 'sticker':
                            notificationText = aiMessage.meaning ? `[表情: ${aiMessage.meaning}]` : '[表情]';
                            break;
                        default:
                            notificationText = String(aiMessage.content || '');
                    }
                    const finalNotifText = chat.isGroup ? `${aiMessage.senderName}: ${notificationText}` : notificationText;
                    showNotification(chatId, finalNotifText.substring(0, 40) + (finalNotifText.length > 40 ? '...' : ''));
                    notificationShown = true; // 确保只通知一次
                }

    if (!isViewingThisChat) {
        // 如果用户不在当前聊天界面，就把这个聊天的未读数 +1
        chat.unreadCount = (chat.unreadCount || 0) + 1;
    }
                
                // 2. 只有在当前聊天界面时，才执行带动画的添加
                if (isViewingThisChat) {
                    appendMessage(aiMessage, chat);
                    // 3. 【关键】在这里暂停一小会儿，给动画播放的时间
                    await new Promise(resolve => setTimeout(resolve, Math.random() * 1800 + 1000));
                }
            }
  }        

        if (callHasBeenHandled && videoCallState.isGroupCall) {
            videoCallState.isAwaitingResponse = false;
            if (videoCallState.participants.length > 0) {
                startVideoCall();
            } else {
                videoCallState = { ...videoCallState, isAwaitingResponse: false, participants: [] };
                showScreen('chat-interface-screen');
                alert('无人接听群聊邀请。');
            }
        }
        
        await db.chats.put(chat);
checkAndTriggerSummary(chatId);
// ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼
// ▼▼▼ 用这块新代码替换旧的火花逻辑 ▼▼▼
// --- 【全新】续火花逻辑 ---
if (await updateStreak(chatId)) {
    // 如果火花天数发生了变化，就刷新聊天列表
    renderChatList();
}
// ▲▲▲ 替换结束 ▲▲▲

// ▲▲▲ 新代码粘贴结束 ▲▲▲

    } catch (error) {
        chat.history = chat.history.filter(msg => !msg.isTemporary);
        if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
            chat.relationship.status = 'blocked_by_ai';
            await showCustomAlert('申请失败', `AI在处理你的好友申请时出错了，请稍后重试。\n错误信息: ${error.message}`);
        } else {
            const errorContent = `[出错了: ${error.message}]`;
            const errorMessage = { role: 'assistant', content: errorContent, timestamp: Date.now() };
            if(chat.isGroup) errorMessage.senderName = "系统消息";
            chat.history.push(errorMessage);
        }
        
        await db.chats.put(chat);        
        videoCallState.isAwaitingResponse = false;

        if(document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId) {
            renderChatInterface(chatId);
        }
    } finally {
        // ★★★★★【核心修改4：在 finally 块中统一隐藏所有类型的提示】★★★★★
        if (chat.isGroup) {
            if (typingIndicator) {
                typingIndicator.style.display = 'none';
            }
        } else {
            if (chatHeaderTitle && state.chats[chatId]) {
                chatHeaderTitle.style.opacity = 0;
                setTimeout(() => {
                    chatHeaderTitle.textContent = state.chats[chatId].name;
                    chatHeaderTitle.classList.remove('typing-status');
                    chatHeaderTitle.style.opacity = 1;
                }, 200);
            }
        }
    }
}

        async function sendSticker(sticker) { if (!state.activeChatId) return; const chat = state.chats[state.activeChatId]; const msg = { role: 'user', content: sticker.url, meaning: sticker.name, timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat);checkAndTriggerSummary(state.activeChatId);  appendMessage(msg, chat); renderChatList(); document.getElementById('sticker-panel').classList.remove('visible'); }
// ▼▼▼ 用这块【功能增强版】代码替换旧的 sendUserTransfer 函数 ▼▼▼
async function sendUserTransfer() { 
    if (!state.activeChatId) return; 
    
    const amountInput = document.getElementById('transfer-amount'); 
    const noteInput = document.getElementById('transfer-note'); 
    const amount = parseFloat(amountInput.value); 
    const note = noteInput.value.trim(); 
    
    if (isNaN(amount) || amount <= 0) { 
        alert('请输入有效的金额！'); 
        return; 
    } 

    // 【核心新增1】检查余额是否足够
    if ((state.globalSettings.userBalance || 0) < amount) {
        alert('余额不足！');
        return;
    }

    const chat = state.chats[state.activeChatId]; 
    const senderName = chat.isGroup ? (chat.settings.myNickname || '我') : '我'; 
    const receiverName = chat.isGroup ? '群聊' : chat.name; 

    // 【核心新增2】调用我们的新函数来扣款并记录
    await updateUserBalanceAndLogTransaction(-amount, `转账给 ${receiverName}`);

    const msg = { role: 'user', type: 'transfer', amount: amount, note: note, senderName, receiverName, timestamp: Date.now() }; 
    chat.history.push(msg); 
    
    await db.chats.put(chat); 
    appendMessage(msg, chat); 
    renderChatList(); 
    document.getElementById('transfer-modal').classList.remove('visible'); 
    amountInput.value = ''; 
    noteInput.value = ''; 
}
// ▲▲▲ 替换结束 ▲▲▲
        function enterSelectionMode(initialMsgTimestamp) { if (isSelectionMode) return; isSelectionMode = true; document.getElementById('chat-interface-screen').classList.add('selection-mode'); toggleMessageSelection(initialMsgTimestamp); }

        function exitSelectionMode() {
    cleanupWaimaiTimers(); // <--- 在这里添加这行代码
 if (!isSelectionMode) return; isSelectionMode = false; document.getElementById('chat-interface-screen').classList.remove('selection-mode'); selectedMessages.forEach(ts => { const bubble = document.querySelector(`.message-bubble[data-timestamp="${ts}"]`); if (bubble) bubble.classList.remove('selected'); }); selectedMessages.clear(); }

// ▼▼▼ 请用这个【最终简化版】替换旧的 toggleMessageSelection 函数 ▼▼▼
function toggleMessageSelection(timestamp) {
    // 【核心修正】选择器已简化，不再寻找已删除的 .recalled-message-placeholder
    const elementToSelect = document.querySelector(
        `.message-bubble[data-timestamp="${timestamp}"]`
    );

    if (!elementToSelect) return;

    if (selectedMessages.has(timestamp)) {
        selectedMessages.delete(timestamp);
        elementToSelect.classList.remove('selected');
    } else {
        selectedMessages.add(timestamp);
        elementToSelect.classList.add('selected');
    }
    
    document.getElementById('selection-count').textContent = `已选 ${selectedMessages.size} 条`;
    
    if (selectedMessages.size === 0) {
        exitSelectionMode();
    }
}
// ▲▲▲ 替换结束 ▲▲▲

        function addLongPressListener(element, callback) { let pressTimer; const startPress = (e) => { if(isSelectionMode) return; e.preventDefault(); pressTimer = window.setTimeout(() => callback(e), 500); }; const cancelPress = () => clearTimeout(pressTimer); element.addEventListener('mousedown', startPress); element.addEventListener('mouseup', cancelPress); element.addEventListener('mouseleave', cancelPress); element.addEventListener('touchstart', startPress, { passive: true }); element.addEventListener('touchend', cancelPress); element.addEventListener('touchmove', cancelPress); }

        async function handleListenTogetherClick() { 

    // ▼▼▼ 在这里添加下面这行代码 ▼▼▼
    document.getElementById('floating-lyrics-bar').style.display = 'none';
    // ▲▲▲ 添加结束 ▲▲▲

const targetChatId = state.activeChatId; if (!targetChatId) return; if (!musicState.isActive) { startListenTogetherSession(targetChatId); return; } if (musicState.activeChatId === targetChatId) { document.getElementById('music-player-overlay').classList.add('visible'); } else { const oldChatName = state.chats[musicState.activeChatId]?.name || '未知'; const newChatName = state.chats[targetChatId]?.name || '当前'; const confirmed = await showCustomConfirm('切换听歌对象', `您正和「${oldChatName}」听歌。要结束并开始和「${newChatName}」的新会话吗？`, { confirmButtonClass: 'btn-danger' }); if (confirmed) { await endListenTogetherSession(true); await new Promise(resolve => setTimeout(resolve, 50)); startListenTogetherSession(targetChatId); } } }

        async function startListenTogetherSession(chatId) { const chat = state.chats[chatId]; if (!chat) return; musicState.totalElapsedTime = chat.musicData.totalTime || 0; musicState.isActive = true; musicState.activeChatId = chatId; if (musicState.playlist.length > 0) { musicState.currentIndex = 0; } else { musicState.currentIndex = -1; } if(musicState.timerId) clearInterval(musicState.timerId); musicState.timerId = setInterval(() => { if (musicState.isPlaying) { musicState.totalElapsedTime++; updateElapsedTimeDisplay(); } }, 1000); updatePlayerUI(); updatePlaylistUI(); document.getElementById('music-player-overlay').classList.add('visible'); }

async function endListenTogetherSession(saveState = true) {
    if (!musicState.isActive) return;
    const oldChatId = musicState.activeChatId;
    const cleanupLogic = async () => {

    // ▼▼▼ 在这里添加下面这行代码 ▼▼▼
    document.getElementById('floating-lyrics-bar').style.display = 'none';
    // ▲▲▲ 添加结束 ▲▲▲

        if (musicState.timerId) clearInterval(musicState.timerId);
        if (musicState.isPlaying) audioPlayer.pause();
        if (saveState && oldChatId && state.chats[oldChatId]) {
            const chat = state.chats[oldChatId];
            chat.musicData.totalTime = musicState.totalElapsedTime;
            await db.chats.put(chat);
        }
        musicState.isActive = false;
        musicState.activeChatId = null;
        musicState.totalElapsedTime = 0;
        musicState.timerId = null;
        updateListenTogetherIcon(oldChatId, true);
    };
    closeMusicPlayerWithAnimation(cleanupLogic);
}

function returnToChat() {
    closeMusicPlayerWithAnimation(() => {

        if (musicState.isActive && lyricsBarSettings.showOnClose) {
            document.getElementById('floating-lyrics-bar').style.display = 'flex';
        }
    });
}

        function updateListenTogetherIcon(chatId, forceReset = false) { const iconImg = document.querySelector('#listen-together-btn img'); if(!iconImg) return; if(forceReset || !musicState.isActive || musicState.activeChatId !== chatId) { iconImg.src = 'https://i.postimg.cc/8kYShvrJ/90-UI-2.png'; iconImg.className = ''; return; } iconImg.src = 'https://i.postimg.cc/D0pq6qS2/E30078-DC-8-B99-4-C01-AFDA-74728-DBF7-BEA.png'; iconImg.classList.add('rotating'); if (musicState.isPlaying) iconImg.classList.remove('paused'); else iconImg.classList.add('paused'); }
        window.updateListenTogetherIconProxy = updateListenTogetherIcon;

        function updatePlayerUI() {
            updateListenTogetherIcon(musicState.activeChatId);
            updateElapsedTimeDisplay();
            const titleEl = document.getElementById('music-player-song-title');
            const artistEl = document.getElementById('music-player-artist');
            const playPauseBtn = document.getElementById('music-play-pause-btn');
            const chat = state.chats[musicState.activeChatId];
            const charAvatarEl = document.getElementById('music-char-avatar');
            const userAvatarEl = document.getElementById('music-user-avatar');
            const albumCoverEl = document.getElementById('music-album-cover');
            const avatarsContainer = document.getElementById('music-avatars-container');
            const displayArea = document.getElementById('music-display-area');

            // 1. 【核心修改】在这里判断是群聊还是单聊，并设置正确的头像
            if (chat) {
                // 如果是群聊
                if (chat.isGroup) {
                    // 左边的头像就用群头像
                    charAvatarEl.src = chat.settings.groupAvatar || defaultGroupAvatar;
                } else {
                    // 否则（是单聊），就用角色的头像
                    charAvatarEl.src = chat.settings.aiAvatar || defaultAvatar;
                }
                // 右边的用户头像保持不变
                userAvatarEl.src = chat.settings.myAvatar || defaultAvatar;
            }

            // 2. 更新歌曲信息和封面 (不变)
            if (musicState.currentIndex > -1 && musicState.playlist.length > 0) {
                const track = musicState.playlist[musicState.currentIndex];
                titleEl.textContent = track.name;
                artistEl.textContent = track.artist;
                albumCoverEl.src = track.cover || 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png';
            } else {
                titleEl.textContent = '请添加歌曲';
                artistEl.textContent = '...';
                albumCoverEl.src = 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png';
            }

            // 3. 控制播放/暂停按钮和头像闪烁 (不变)
            playPauseBtn.textContent = musicState.isPlaying ? '❚❚' : '▶';
            avatarsContainer.classList.toggle('flashing', musicState.isPlaying);

            // 4. 控制唱片旋转和暂停 (不变)
            albumCoverEl.classList.toggle('rotating', musicState.currentIndex > -1);
            albumCoverEl.classList.toggle('paused', !musicState.isPlaying);

            // 5. 默认显示歌曲封面 (不变)
            if (displayArea) {
                displayArea.classList.remove('show-lyrics');
            }
        }


        function updateElapsedTimeDisplay() { const hours = (musicState.totalElapsedTime / 3600).toFixed(1); document.getElementById('music-time-counter').textContent = `已经一起听了${hours}小时`; }
// ▼▼▼ 把这【一整块新函数】粘贴到 updatePlaylistUI 函数的上方 ▼▼▼
/**
 * 【全新】处理用户上传或更新歌曲封面的逻辑
 * @param {number} index - 被操作的歌曲在播放列表中的索引
 */
// ▼▼▼ 请用这【一整块新代码】替换旧的 handleCoverUpload 函数 ▼▼▼
async function handleCoverUpload(index) {
    if (index < 0 || index >= musicState.playlist.length) return;

    // 1. 弹窗让用户选择来源（已移除图标）
    const choice = await showChoiceModal("选择封面来源", [
        { text: '使用网络URL', value: 'url' },
        { text: '从本地上传', value: 'local' }
    ]);

    let newCoverUrl = null;

    // 2. 根据选择执行不同操作
    if (choice === 'url') {
        const url = await showCustomPrompt("封面URL", "请输入图片文件的网络链接");
        if (url && url.trim().startsWith('http')) {
            newCoverUrl = url.trim();
        } else if (url !== null) {
            alert("请输入一个有效的图片URL！");
        }
    } else if (choice === 'local') {
        newCoverUrl = await uploadImageLocally(); 
    }

    // 3. 如果成功获取到新的封面URL，就更新数据和UI
    if (newCoverUrl) {
        musicState.playlist[index].cover = newCoverUrl;
        await saveGlobalPlaylist();
        updatePlaylistUI();
        if (musicState.currentIndex === index) {
            updatePlayerUI();
        }
        alert('歌曲封面已更新！');
    }
}
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 请用这【一整块新代码】替换旧的 updatePlaylistUI 函数 ▼▼▼
function updatePlaylistUI() {
    const playlistBody = document.getElementById('playlist-body');
    playlistBody.innerHTML = '';
    if (musicState.playlist.length === 0) {
        playlistBody.innerHTML = '<p style="text-align:center; padding: 20px; color: #888;">播放列表是空的~</p>';
        return;
    }
    musicState.playlist.forEach((track, index) => {
        const item = document.createElement('div');
        item.className = 'playlist-item';
        if(index === musicState.currentIndex) item.classList.add('playing');
        // 【核心修改】在“词”按钮旁边，新增了一个“封面”按钮
        item.innerHTML = `
            <div class="playlist-item-info">
                <div class="title">${track.name}</div>
                <div class="artist">${track.artist}</div>
            </div>
            <div class="playlist-item-actions">
                <span class="playlist-action-btn cover-btn" data-index="${index}">封面</span>
                <span class="playlist-action-btn lyrics-btn" data-index="${index}">词</span>
                <span class="playlist-action-btn delete-track-btn" data-index="${index}">×</span>
            </div>
        `;
        item.querySelector('.playlist-item-info').addEventListener('click', () => playSong(index));
        playlistBody.appendChild(item);
    });
}
// ▲▲▲ 替换结束 ▲▲▲

async function loadSong(index) {
    if (index < 0 || index >= musicState.playlist.length) return;
    musicState.currentIndex = index;
    const track = musicState.playlist[index];

    // 检查并加载网络歌词
    if (track.lrcUrl && !track.lrcContent) {
        try {
            const response = await fetch(track.lrcUrl);
            if (response.ok) track.lrcContent = await response.text();
        } catch (error) {
            console.error("加载歌词URL失败:", error);
        }
    }

    // 准备播放
    musicState.parsedLyrics = parseLRC(track.lrcContent || "");
    musicState.currentLyricIndex = -1;
    renderLyrics();

    if (track.isLocal && track.src instanceof Blob) {
        audioPlayer.src = URL.createObjectURL(track.src);
    } else if (!track.isLocal) {
        audioPlayer.src = track.src;
    } else {
        console.error('本地歌曲源错误:', track);
        return;
    }

    // 更新界面信息，但不播放
    updatePlaylistUI();
    updatePlayerUI();
    // audioPlayer.duration 可能需要一点时间加载，我们监听事件来更新进度条
    audioPlayer.onloadedmetadata = () => {
        updateMusicProgressBar();
    };
}

// ▼▼▼ 请用下面这【一整块】全新的代码，替换掉你旧的 playSong 和 togglePlayPause 两个函数 ▼▼▼

async function playSong(index) {
    await loadSong(index);
    try {
        await audioPlayer.play();
        // ▼▼▼ 新增这两行 ▼▼▼
        musicState.isPlaying = true; // 播放成功后，直接设置状态为 true
        updatePlayerUI();           // 并立即更新UI
        // ▲▲▲ 新增结束 ▲▲▲
    } catch (error) {
        console.error("音频播放失败:", error);
        musicState.isPlaying = false; // 如果播放失败，也要确保状态正确
        updatePlayerUI();
    }
}


/**
 * 【全新智能版】处理播放/暂停的函数
 */
function togglePlayPause() {
    if (audioPlayer.paused) {
        if (musicState.currentIndex > -1) {
            playSong(musicState.currentIndex);
        }
    } else {
        audioPlayer.pause();
        // ▼▼▼ 新增这两行 ▼▼▼
        musicState.isPlaying = false;
        updatePlayerUI();
        // ▲▲▲ 新增结束 ▲▲▲
    }
}

// ▲▲▲ 替换结束 ▲▲▲


        function playNext() { if (musicState.playlist.length === 0) return; let nextIndex; switch(musicState.playMode) { case 'random': nextIndex = Math.floor(Math.random() * musicState.playlist.length); break; case 'single': playSong(musicState.currentIndex); return; case 'order': default: nextIndex = (musicState.currentIndex + 1) % musicState.playlist.length; break; } playSong(nextIndex); }

        function playPrev() { if (musicState.playlist.length === 0) return; const newIndex = (musicState.currentIndex - 1 + musicState.playlist.length) % musicState.playlist.length; playSong(newIndex); }

        function changePlayMode() { const modes = ['order', 'random', 'single']; const currentModeIndex = modes.indexOf(musicState.playMode); musicState.playMode = modes[(currentModeIndex + 1) % modes.length]; document.getElementById('music-mode-btn').textContent = {'order': '顺序', 'random': '随机', 'single': '单曲'}[musicState.playMode]; }

        async function addSongFromURL() {
    const url = await showCustomPrompt("添加网络歌曲", "请输入歌曲的URL", "", "url");
    if (!url) return;
    const name = await showCustomPrompt("歌曲信息", "请输入歌名");
    if (!name) return;
    const artist = await showCustomPrompt("歌曲信息", "请输入歌手名");
    if (!artist) return;

    // ▼▼▼【核心修改在这里】▼▼▼
    // 1. 先弹窗询问用户是否要提供歌词链接
    const wantLrc = await showCustomConfirm("导入歌词", `要为《${name}》提供一个歌词文件 (.lrc) 的URL吗？`);
    let lrcUrl = ""; // 默认歌词链接为空

    // 2. 如果用户点击了“确定”
    if (wantLrc) {
        // 就再弹出一个输入框让用户粘贴URL
        const inputLrcUrl = await showCustomPrompt("歌词URL", "请输入 .lrc 歌词文件的网络链接", "", "url");
        if (inputLrcUrl) {
            lrcUrl = inputLrcUrl; // 如果用户输入了，就保存这个URL
        }
    }
    // ▲▲▲【修改结束】▲▲▲

    musicState.playlist.push({ 
        name, 
        artist, 
        src: url, 
        isLocal: false,
        lrcUrl: lrcUrl, // 3. 把获取到的歌词URL也保存到歌曲信息里
        lrcContent: ""  // 同时确保lrcContent是空的，以便后续加载
    });

    await saveGlobalPlaylist();
    updatePlaylistUI();
// 【这是新代码】
if(musicState.currentIndex === -1) {
    // 【核心修改】调用 loadSong 来准备好第一首歌
    loadSong(musicState.playlist.length - 1);
}
}


async function addSongFromLocal(event) {
    const files = event.target.files;
    if (!files.length) return;

    for (const file of files) {
        let name = file.name.replace(/\.[^/.]+$/, "");
        name = await showCustomPrompt("歌曲信息", "请输入歌名", name);
        if (name === null) continue;
        
        const artist = await showCustomPrompt("歌曲信息", "请输入歌手名", "未知歌手");
        if (artist === null) continue;

        let lrcContent = "";
        const wantLrc = await showCustomConfirm("导入歌词", `要为《${name}》导入歌词文件 (.lrc) 吗？`);
        if (wantLrc) {
            lrcContent = await new Promise(resolve => {
                const lrcInput = document.getElementById('lrc-upload-input');
                const lrcChangeHandler = (e) => {
                    const lrcFile = e.target.files[0];
                    if (lrcFile) {
                        const reader = new FileReader();
                        reader.onload = (readEvent) => resolve(readEvent.target.result);
                        reader.onerror = () => resolve("");
                        reader.readAsText(lrcFile);
                    } else {
                        resolve("");
                    }
                    lrcInput.removeEventListener('change', lrcChangeHandler);
                    lrcInput.value = '';
                };
                lrcInput.addEventListener('change', lrcChangeHandler);
                lrcInput.click();
            });
        }
        
        musicState.playlist.push({ 
            name, 
            artist, 
            src: file, 
            isLocal: true,
            lrcContent: lrcContent
        });
    }
    
    await saveGlobalPlaylist();
    updatePlaylistUI();
// 【这是新代码】
if (musicState.currentIndex === -1 && musicState.playlist.length > 0) {
    // 【核心修改】同样，调用 loadSong 来准备好第一首歌
    loadSong(0);
}
    event.target.value = null;
}

        async function deleteTrack(index) { if (index < 0 || index >= musicState.playlist.length) return; const track = musicState.playlist[index]; const wasPlaying = musicState.isPlaying && musicState.currentIndex === index; if (track.isLocal && audioPlayer.src.startsWith('blob:') && musicState.currentIndex === index) URL.revokeObjectURL(audioPlayer.src); musicState.playlist.splice(index, 1); await saveGlobalPlaylist(); if (musicState.playlist.length === 0) { if (musicState.isPlaying) audioPlayer.pause(); audioPlayer.src = ''; musicState.currentIndex = -1; musicState.isPlaying = false; } else { if (wasPlaying) { playNext(); } else { if (musicState.currentIndex >= index) musicState.currentIndex = Math.max(0, musicState.currentIndex - 1); } } updatePlayerUI(); updatePlaylistUI(); }

        const personaLibraryModal = document.getElementById('persona-library-modal');
        const personaEditorModal = document.getElementById('persona-editor-modal');
        const presetActionsModal = document.getElementById('preset-actions-modal');

        function openPersonaLibrary() { renderPersonaLibrary(); personaLibraryModal.classList.add('visible'); }

        function closePersonaLibrary() { personaLibraryModal.classList.remove('visible'); }

        function renderPersonaLibrary() { const grid = document.getElementById('persona-library-grid'); grid.innerHTML = ''; if (state.personaPresets.length === 0) { grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center; margin-top: 20px;">空空如也~ 点击右上角"添加"来创建你的第一个人设预设吧！</p>'; return; } state.personaPresets.forEach(preset => { const item = document.createElement('div'); item.className = 'persona-preset-item'; item.style.backgroundImage = `url(${preset.avatar})`; item.dataset.presetId = preset.id; item.addEventListener('click', () => applyPersonaPreset(preset.id)); addLongPressListener(item, () => showPresetActions(preset.id)); grid.appendChild(item); }); }

        function showPresetActions(presetId) { editingPersonaPresetId = presetId; presetActionsModal.classList.add('visible'); }

        function hidePresetActions() { presetActionsModal.classList.remove('visible'); editingPersonaPresetId = null; }

        function applyPersonaPreset(presetId) { const preset = state.personaPresets.find(p => p.id === presetId); if (preset) { document.getElementById('my-avatar-preview').src = preset.avatar; document.getElementById('my-persona').value = preset.persona; } closePersonaLibrary(); }

// ▼▼▼ 用这个全新的函数，完整替换旧的 openPersonaEditorForCreate 函数 ▼▼▼
function openPersonaEditorForCreate() { 
    editingPersonaPresetId = null; 
    
    document.getElementById('persona-editor-title').textContent = '添加人设预设'; 
    document.getElementById('preset-avatar-preview').src = defaultAvatar; 
    document.getElementById('preset-persona-input').value = ''; 
    
    // 【核心逻辑】根据用户人设模式，显隐特定UI元素
    document.getElementById('npc-editor-name-group').style.display = 'none';
    document.getElementById('persona-editor-change-frame-btn').style.display = 'inline-block';

    // 【【【这就是您代码中的正确做法！】】】
    // 我们直接覆盖保存按钮的 onclick 事件，强制它只执行保存用户人设的函数
    document.getElementById('save-persona-preset-btn').onclick = savePersonaPreset;

    document.getElementById('persona-editor-modal').classList.add('visible'); 
}
// ▲▲▲ 替换结束 ▲▲▲



// ▼▼▼ 用这个全新的函数，完整替换旧的 openPersonaEditorForEdit 函数 ▼▼▼
function openPersonaEditorForEdit() { 
    const preset = state.personaPresets.find(p => p.id === editingPersonaPresetId); 
    if (!preset) return; 

    document.getElementById('persona-editor-title').textContent = '编辑人设预设'; 
    document.getElementById('preset-avatar-preview').src = preset.avatar; 
    document.getElementById('preset-persona-input').value = preset.persona; 
    
    // 【核心逻辑】根据用户人设模式，显隐特定UI元素
    document.getElementById('npc-editor-name-group').style.display = 'none';
    document.getElementById('persona-editor-change-frame-btn').style.display = 'inline-block';

    // 【【【这就是您代码中的正确做法！】】】
    // 我们直接覆盖保存按钮的 onclick 事件，强制它只执行保存用户人设的函数
    document.getElementById('save-persona-preset-btn').onclick = savePersonaPreset;
    
    presetActionsModal.classList.remove('visible'); 
    document.getElementById('persona-editor-modal').classList.add('visible'); 
}
// ▲▲▲ 替换结束 ▲▲▲





        async function deletePersonaPreset() { const confirmed = await showCustomConfirm('删除预设', '确定要删除这个人设预设吗？此操作不可恢复。', { confirmButtonClass: 'btn-danger' }); if (confirmed && editingPersonaPresetId) { await db.personaPresets.delete(editingPersonaPresetId); state.personaPresets = state.personaPresets.filter(p => p.id !== editingPersonaPresetId); hidePresetActions(); renderPersonaLibrary(); } }

        function closePersonaEditor() { personaEditorModal.classList.remove('visible'); editingPersonaPresetId = null; }

        async function savePersonaPreset() { const avatar = document.getElementById('preset-avatar-preview').src; const persona = document.getElementById('preset-persona-input').value.trim(); if (avatar === defaultAvatar && !persona) { alert("头像和人设不能都为空哦！"); return; } if (editingPersonaPresetId) { const preset = state.personaPresets.find(p => p.id === editingPersonaPresetId); if (preset) { preset.avatar = avatar; preset.persona = persona; await db.personaPresets.put(preset); } } else { const newPreset = { id: 'preset_' + Date.now(), avatar: avatar, persona: persona }; await db.personaPresets.add(newPreset); state.personaPresets.push(newPreset); } renderPersonaLibrary(); closePersonaEditor(); }

        const batteryAlertModal = document.getElementById('battery-alert-modal');

        function showBatteryAlert(imageUrl, text) { clearTimeout(batteryAlertTimeout); document.getElementById('battery-alert-image').src = imageUrl; document.getElementById('battery-alert-text').textContent = text; batteryAlertModal.classList.add('visible'); const closeAlert = () => { batteryAlertModal.classList.remove('visible'); batteryAlertModal.removeEventListener('click', closeAlert); }; batteryAlertModal.addEventListener('click', closeAlert); batteryAlertTimeout = setTimeout(closeAlert, 2000); }

        function updateBatteryDisplay(battery) { const batteryContainer = document.getElementById('status-bar-battery'); const batteryLevelEl = batteryContainer.querySelector('.battery-level'); const batteryTextEl = batteryContainer.querySelector('.battery-text'); const level = Math.floor(battery.level * 100); batteryLevelEl.style.width = `${level}%`; batteryTextEl.textContent = `${level}%`; if (battery.charging) { batteryContainer.classList.add('charging'); } else { batteryContainer.classList.remove('charging'); } }

        function handleBatteryChange(battery) { updateBatteryDisplay(battery); const level = battery.level; if (!battery.charging) { if (level <= 0.4 && lastKnownBatteryLevel > 0.4 && !alertFlags.hasShown40) { showBatteryAlert('https://i.postimg.cc/T2yKJ0DV/40.jpg', '有点饿了，可以去找充电器惹'); alertFlags.hasShown40 = true; } if (level <= 0.2 && lastKnownBatteryLevel > 0.2 && !alertFlags.hasShown20) { showBatteryAlert('https://i.postimg.cc/qB9zbKs9/20.jpg', '赶紧的充电，要饿死了'); alertFlags.hasShown20 = true; } if (level <= 0.1 && lastKnownBatteryLevel > 0.1 && !alertFlags.hasShown10) { showBatteryAlert('https://i.postimg.cc/ThMMVfW4/10.jpg', '已阵亡，还有30秒爆炸'); alertFlags.hasShown10 = true; } } if (level > 0.4) alertFlags.hasShown40 = false; if (level > 0.2) alertFlags.hasShown20 = false; if (level > 0.1) alertFlags.hasShown10 = false; lastKnownBatteryLevel = level; }

        async function initBatteryManager() { if ('getBattery' in navigator) { try { const battery = await navigator.getBattery(); lastKnownBatteryLevel = battery.level; handleBatteryChange(battery); battery.addEventListener('levelchange', () => handleBatteryChange(battery)); battery.addEventListener('chargingchange', () => { handleBatteryChange(battery); if (battery.charging) { showBatteryAlert('https://i.postimg.cc/3NDQ0dWG/image.jpg', '窝爱泥，电量吃饱饱'); } }); } catch (err) { console.error("无法获取电池信息:", err); document.querySelector('.battery-text').textContent = 'ᗜωᗜ'; } } else { console.log("浏览器不支持电池状态API。"); document.querySelector('.battery-text').textContent = 'ᗜωᗜ'; } }

        async function renderAlbumList() {
            const albumGrid = document.getElementById('album-grid-page');
            if (!albumGrid) return;
            const albums = await db.qzoneAlbums.orderBy('createdAt').reverse().toArray();
            albumGrid.innerHTML = '';
            if (albums.length === 0) {
                albumGrid.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">你还没有创建任何相册哦~</p>';
                return;
            }
            albums.forEach(album => {
                const albumItem = document.createElement('div');
                albumItem.className = 'album-item';
                albumItem.innerHTML = `
                    <div class="album-cover" style="background-image: url(${album.coverUrl});"></div>
                    <div class="album-info">
                        <p class="album-name">${album.name}</p>
                        <p class="album-count">${album.photoCount || 0} 张</p>
                    </div>
                `;
                albumItem.addEventListener('click', () => {
                    openAlbum(album.id);
                });

                // ▼▼▼ 新增的核心代码就是这里 ▼▼▼
                addLongPressListener(albumItem, async () => {
                    const confirmed = await showCustomConfirm(
                        '删除相册',
                        `确定要删除相册《${album.name}》吗？此操作将同时删除相册内的所有照片，且无法恢复。`,
                        { confirmButtonClass: 'btn-danger' }
                    );

                    if (confirmed) {
                        // 1. 从照片表中删除该相册下的所有照片
                        await db.qzonePhotos.where('albumId').equals(album.id).delete();
                        
                        // 2. 从相册表中删除该相册本身
                        await db.qzoneAlbums.delete(album.id);
                        
                        // 3. 重新渲染相册列表
                        await renderAlbumList();
                        
                        alert('相册已成功删除。');
                    }
                });
                // ▲▲▲ 新增代码结束 ▲▲▲

                albumGrid.appendChild(albumItem);
            });
        }

        async function openAlbum(albumId) {
            state.activeAlbumId = albumId;
            await renderAlbumPhotosScreen();
            showScreen('album-photos-screen');
        }

        async function renderAlbumPhotosScreen() {
            if (!state.activeAlbumId) return;
            const photosGrid = document.getElementById('photos-grid-page');
            const headerTitle = document.getElementById('album-photos-title');
            const album = await db.qzoneAlbums.get(state.activeAlbumId);
            if (!album) {
                console.error("找不到相册:", state.activeAlbumId);
                showScreen('album-screen');
                return;
            }
            headerTitle.textContent = album.name;
            const photos = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).toArray();
            photosGrid.innerHTML = '';
            if (photos.length === 0) {
                photosGrid.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">这个相册还是空的，快上传第一张照片吧！</p>';
            } else {
                photos.forEach(photo => {
                    const photoItem = document.createElement('div');
                    photoItem.className = 'photo-item';
                    photoItem.innerHTML = `
                        <img src="${photo.url}" class="photo-thumb" alt="相册照片">
                        <button class="photo-delete-btn" data-photo-id="${photo.id}">×</button>
                    `;
                    photosGrid.appendChild(photoItem);
                });
            }
        }

// --- ↓↓↓ 从这里开始复制 ↓↓↓ ---

/**
 * 打开图片查看器
 * @param {string} clickedPhotoUrl - 用户点击的那张照片的URL
 */
async function openPhotoViewer(clickedPhotoUrl) {
    if (!state.activeAlbumId) return;

    // 1. 从数据库获取当前相册的所有照片
    const photosInAlbum = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).toArray();
    photoViewerState.photos = photosInAlbum.map(p => p.url);

    // 2. 找到被点击照片的索引
    photoViewerState.currentIndex = photoViewerState.photos.findIndex(url => url === clickedPhotoUrl);
    if (photoViewerState.currentIndex === -1) return; // 如果找不到，则不打开

    // 3. 显示模态框并渲染第一张图
    document.getElementById('photo-viewer-modal').classList.add('visible');
    renderPhotoViewer();
    photoViewerState.isOpen = true;
}

/**
 * 根据当前状态渲染查看器内容（图片和按钮）
 */
function renderPhotoViewer() {
    if (photoViewerState.currentIndex === -1) return;

    const imageEl = document.getElementById('photo-viewer-image');
    const prevBtn = document.getElementById('photo-viewer-prev-btn');
    const nextBtn = document.getElementById('photo-viewer-next-btn');
    
    // 淡出效果
    imageEl.style.opacity = 0;

    setTimeout(() => {
        // 更新图片源
        imageEl.src = photoViewerState.photos[photoViewerState.currentIndex];
        // 淡入效果
        imageEl.style.opacity = 1;
    }, 100); // 延迟一点点时间来触发CSS过渡

    // 更新按钮状态：如果是第一张，禁用“上一张”按钮
    prevBtn.disabled = photoViewerState.currentIndex === 0;
    // 如果是最后一张，禁用“下一张”按钮
    nextBtn.disabled = photoViewerState.currentIndex === photoViewerState.photos.length - 1;
}

/**
 * 显示下一张照片
 */
function showNextPhoto() {
    if (photoViewerState.currentIndex < photoViewerState.photos.length - 1) {
        photoViewerState.currentIndex++;
        renderPhotoViewer();
    }
}

/**
 * 显示上一张照片
 */
function showPrevPhoto() {
    if (photoViewerState.currentIndex > 0) {
        photoViewerState.currentIndex--;
        renderPhotoViewer();
    }
}

/**
 * 关闭图片查看器
 */
function closePhotoViewer() {
    document.getElementById('photo-viewer-modal').classList.remove('visible');
    photoViewerState.isOpen = false;
    photoViewerState.photos = [];
    photoViewerState.currentIndex = -1;
    // 清空图片，避免下次打开时闪现旧图
    document.getElementById('photo-viewer-image').src = '';
}

// --- ↑↑↑ 复制到这里结束 ↑↑↑ ---
        // ▼▼▼ 请将这个新函数粘贴到你的JS功能函数定义区 ▼▼▼
        
        /**
         * 更新动态小红点的显示
         * @param {number} count - 未读动态的数量
         */
        function updateUnreadIndicator(count) {
            unreadPostsCount = count;
            localStorage.setItem('unreadPostsCount', count); // 持久化存储

            // --- 更新底部导航栏的“动态”按钮 ---
            const navItem = document.querySelector('.nav-item[data-view="qzone-screen"]');
            
            const targetSpan = navItem.querySelector('span'); // 定位到文字 "动态"
            let indicator = navItem.querySelector('.unread-indicator');           

            if (count > 0) {
                if (!indicator) {
                    indicator = document.createElement('span');
                    indicator.className = 'unread-indicator';
                                                           targetSpan.style.position = 'relative'; // 把相对定位加在 span 上
                    targetSpan.appendChild(indicator); // 把小红点作为 span 的子元素
                    
                }
                indicator.textContent = count > 99 ? '99+' : count;
                indicator.style.display = 'block';
            } else {
                if (indicator) {
                    indicator.style.display = 'none';
                }
            }

            // --- 更新聊天界面返回列表的按钮 ---
            const backBtn = document.getElementById('back-to-list-btn');
            let backBtnIndicator = backBtn.querySelector('.unread-indicator');

            if (count > 0) {
                if (!backBtnIndicator) {
                    backBtnIndicator = document.createElement('span');
                    backBtnIndicator.className = 'unread-indicator back-btn-indicator';
                    backBtn.style.position = 'relative'; // 确保能正确定位
                    backBtn.appendChild(backBtnIndicator);
                }
                // 返回键上的小红点通常不显示数字，只显示一个点
                backBtnIndicator.style.display = 'block';
            } else {
                if (backBtnIndicator) {
                    backBtnIndicator.style.display = 'none';
                }
            }
        }
        
        // ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 将这两个新函数粘贴到你的JS功能函数定义区 ▼▼▼
function startBackgroundSimulation() {
    if (simulationIntervalId) return;
    const intervalSeconds = state.globalSettings.backgroundActivityInterval || 60;
    // 将旧的固定间隔 45000 替换为动态获取
    simulationIntervalId = setInterval(runBackgroundSimulationTick, intervalSeconds * 1000); 
}

function stopBackgroundSimulation() {
    if (simulationIntervalId) {
        clearInterval(simulationIntervalId);
        simulationIntervalId = null;
    }
}
// ▲▲▲ 粘贴结束 ▲▲▲

/**
 * 这是模拟器的“心跳”，每次定时器触发时运行
 */
// ▼▼▼ 【全新】用这个函数完整替换旧的 runBackgroundSimulationTick ▼▼▼
/**
 * 这是模拟器的“心跳”，每次定时器触发时运行
 */
function runBackgroundSimulationTick() {
    console.log("模拟器心跳 Tick...");
    if (!state.globalSettings.enableBackgroundActivity) {
        stopBackgroundSimulation();
        return;
    }
    const allSingleChats = Object.values(state.chats).filter(chat => !chat.isGroup);

    if (allSingleChats.length === 0) return;

    // 【核心改造】定义不同频率对应的行动概率
    const frequencyProbabilities = {
        low: 0.3,    // 低频: 每次检测有 30% 的概率行动
        medium: 0.5,  // 中频: 每次检测有 50% 的概率行动
        high: 0.8,   // 高频: 每次检测有 80% 的概率行动
    };

    const config = state.globalSettings.backgroundActivityConfig || {};

    allSingleChats.forEach(chat => {
        // 检查1：处理【被用户拉黑】的角色 (这部分逻辑不变)
        if (chat.relationship?.status === 'blocked_by_user') {
            const blockedTimestamp = chat.relationship.blockedTimestamp;
            if (!blockedTimestamp) {
                console.warn(`角色 "${chat.name}" 状态为拉黑，但缺少拉黑时间戳，跳过处理。`);
                return;
            }
            const blockedDuration = Date.now() - blockedTimestamp;
            const cooldownMilliseconds = (state.globalSettings.blockCooldownHours || 1) * 60 * 60 * 1000;
            if (blockedDuration > cooldownMilliseconds) {
                console.log(`角色 "${chat.name}" 的冷静期已过，触发“反思”并申请好友事件...`);
                chat.relationship.status = 'pending_system_reflection';
                triggerAiFriendApplication(chat.id);
            }
        }
        // 检查2：处理【好友关系】的正常后台活动
        else if (chat.relationship?.status === 'friend' && chat.id !== state.activeChatId) {
            // 【核心改造】从这里开始
            const frequency = config[chat.id]; // 获取当前角色的频率设置
            const probability = frequencyProbabilities[frequency]; // 获取对应的概率

            // 如果这个角色设置了频率，并且随机数小于它的行动概率，就触发行动
            if (probability && Math.random() < probability) {
                console.log(`角色 "${chat.name}" (频率: ${frequency}) 被唤醒，准备独立行动...`);
                triggerInactiveAiAction(chat.id);
            }
            // 如果没有设置频率，或者随机数没达到概率，就不会行动。
            // 这就完美地实现了“分组设置”和“不会同时行动”的需求！
        }
    });

}
// ▲▲▲ 替换结束 ▲▲▲
/**
 * 根据AI的视角，过滤出它能看到的动态
 * @param {Array} allPosts - 所有待检查的动态帖子
 * @param {object} viewerChat - 正在“看”动态的那个AI的chat对象
 * @returns {Array} - 过滤后该AI可见的动态帖子
 */
// ▼▼▼ 用这块【增强版】代码，替换旧的 filterVisiblePostsForAI 函数 ▼▼▼
function filterVisiblePostsForAI(allPosts, viewerChat) {
    if (!viewerChat || !viewerChat.id) return []; 

    const viewerGroupId = viewerChat.groupId; 

    return allPosts.filter(post => {
        // --- ▼▼▼ 以下是本次新增的核心代码 ▼▼▼ ---
        if (post.authorId === 'user') {
            // 如果用户设置了“部分可见”
            if (post.visibleGroupIds && post.visibleGroupIds.length > 0) {
                // 只有当查看者AI的分组ID在用户的可见列表里时，才可见
                return viewerGroupId && post.visibleGroupIds.includes(viewerGroupId);
            }
            // 如果用户没设置，说明是公开的，所有AI都可见
            return true;
        }
        // --- ▲▲▲ 新增代码结束 ▲▲▲ ---

        const authorGroupId = post.authorGroupId;
        if (!authorGroupId) {
            return true;
        }
        return authorGroupId === viewerGroupId;
    });
}
// ▲▲▲ 替换结束 ▲▲▲
/**
 * 【全新升级版】根据AI视角和动态设置，构建给AI看的评论区上下文
 * @param {object} post - 正在处理的动态对象
 * @param {object} viewerChat - 正在“看”动态的AI角色
 * @param {string} userNickname - 用户的昵称
 * @returns {{contextString: string, visibilityFlag: string}} - 返回包含上下文文本和可见性标志的对象
 */
function buildCommentsContextForAI(post, viewerChat, userNickname) {
    // ▼▼▼ 核心修复：在这里增加了 !Array.isArray(post.comments) 的检查 ▼▼▼
    if (!post.comments || !Array.isArray(post.comments) || post.comments.length === 0) {
        // 如果 post.comments 不存在，或者它根本不是一个数组，或者它是一个空数组，就直接返回，不再执行后面的代码
        return { contextString: "", visibilityFlag: "[评论区可见]" };
    }
    // ▲▲▲ 修复结束 ▲▲▲
    const viewerName = viewerChat.name;
    let commentsForAI;
    let visibilityFlag;

    if (post.areCommentsVisible !== false) {
        commentsForAI = post.comments;
        // ★★★ 关键在这里：确保 "[评论区可见]" 是一个带引号的字符串 ★★★
        visibilityFlag = "[评论区可见]"; 
    } else {
commentsForAI = Array.isArray(post.comments)
  ? post.comments.filter(comment => {
      return comment.commenterName === viewerName
          || comment.commenterName === userNickname
          || comment.replyTo === viewerName;
    })
  : [];
        // ★★★ 关键在这里：确保 "[评论区部分可见]" 是一个带引号的字符串 ★★★
        visibilityFlag = "[评论区部分可见]";
    }

    if (commentsForAI.length === 0) {
        return { contextString: "", visibilityFlag: visibilityFlag };
    }

    let context = `  └ 评论区:\n`;
    commentsForAI.slice(-5).forEach(c => {
        if (c.replyTo) {
            context += `    - ${c.commenterName} 回复 ${c.replyTo}: ${c.text}\n`;
        } else {
            context += `    - ${c.commenterName}: ${c.text}\n`;
        }
    });
    
    return { contextString: context, visibilityFlag: visibilityFlag };
}

/**
 * 【全新】获取一条动态的可见观众列表，用于告知AI
 * @param {object} post - 动态对象
 * @param {object} allChats - 所有的聊天对象
 * @param {string} userNickname - 用户的昵称
 * @returns {Array<string>} - 可见观众的名字列表
 */
function getVisibleAudienceForPost(post, allChats, userNickname) {
    const audience = new Set([userNickname]); // 用户永远是观众

    // 1. 如果是用户发的动态
    if (post.authorId === 'user') {
        // 如果是公开的，所有AI都是观众
        if (!post.visibleGroupIds || post.visibleGroupIds.length === 0) {
            Object.values(allChats).forEach(chat => audience.add(chat.name));
        } else {
            // 如果是部分可见，只有指定分组的AI是观众
            Object.values(allChats).forEach(chat => {
                if (chat.groupId && post.visibleGroupIds.includes(chat.groupId)) {
                    audience.add(chat.name);
                }
            });
        }
    } 
    // 2. 如果是AI发的动态
    else {
        const authorChat = allChats[post.authorId];
        // 如果发帖的AI没有分组，视为公开
        if (!authorChat || !authorChat.groupId) {
             Object.values(allChats).forEach(chat => audience.add(chat.name));
        } else {
            // 如果有分组，则同一分组的所有AI都是观众
            const authorGroupId = authorChat.groupId;
            Object.values(allChats).forEach(chat => {
                if (chat.groupId === authorGroupId) {
                    audience.add(chat.name);
                }
            });
        }
    }
    
    return Array.from(audience);
}

// ▼▼▼ 用这整块【最终修复版】代码，完整替换你旧的 triggerInactiveAiAction 函数 ▼▼▼
async function triggerInactiveAiAction(chatId) {
    const chat = state.chats[chatId];
    if (!chat) return;

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) return;

    // --- ▼▼▼ 核心修改从这里开始 ▼▼▼ ---

    // 1. 获取最近的10条聊天记录作为思考的上下文
    const historySlice = chat.history.filter(msg => !msg.isHidden).slice(-10);

    // 2. 格式化这些记录，让AI能看懂
    const recentContextSummary = historySlice.map(msg => {
        // 判断是谁说的话
        const sender = msg.role === 'user' ? (chat.isGroup ? (chat.settings.myNickname || '我') : '我') : (msg.senderName || chat.name);
        
        // 处理不同类型的消息内容
        let contentText = '';
        if (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content)) {
            contentText = `[发送了一个表情: ${msg.meaning || '无描述'}]`;
        } else if (Array.isArray(msg.content)) {
            contentText = '[发送了一张图片]';
        } else if (typeof msg.content === 'object' && msg.content !== null) {
            contentText = `[发送了一条特殊消息: ${msg.type || '未知类型'}]`;
        } else {
            contentText = String(msg.content);
        }
        
        return `${sender}: ${contentText}`;
    }).join('\n');

    // --- ▲▲▲ 核心修改到这里结束 ▲▲▲ ---

    const now = new Date();
    const currentTime = now.toLocaleTimeString('zh-CN', { hour: 'numeric', minute: 'numeric', hour12: true });
    const userNickname = state.qzoneSettings.nickname;
    const countdownContext = await getCountdownContext();

    let worldBookContext = '';
    if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
        const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
            const worldBook = state.worldBooks.find(wb => wb.id === bookId);
            return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}` : '';
        }).filter(Boolean).join('');
        if (linkedContents) {
            worldBookContext = `\n\n# 核心世界观设定 (你必须严格遵守)\n${linkedContents}\n`;
        }
    }

    const npcLibrary = chat.npcLibrary || [];
    let npcContextForAction = '';
    if (npcLibrary.length > 0) {
        npcContextForAction = '\n- **你的NPC朋友**: ' + npcLibrary.map(npc => npc.name).join('、 ');
    }
    
    const allRecentPosts = await db.qzonePosts.orderBy('timestamp').reverse().limit(5).toArray();
    let postsContext = '';
    const visiblePosts = filterVisiblePostsForAI(allRecentPosts, chat);
    if (visiblePosts.length > 0 && !chat.isGroup) {
        postsContext = "\n\n# 最近的动态列表 (供你参考和评论):\n";
        const aiName = chat.name;
        for (const post of visiblePosts) {
            let authorName = post.authorId === 'user' ? userNickname : (state.chats[post.authorId]?.name || '一位朋友');
            let interactionStatus = '';
            if (post.likes && post.likes.includes(aiName)) interactionStatus += " [你已点赞]";
            if (post.comments && post.comments.some(c => c.commenterName === aiName)) interactionStatus += " [你已评论]";
            const timeAgo = formatPostTimestamp(post.timestamp);
            postsContext += `- (ID: ${post.id}) [${timeAgo}] 作者: ${authorName}, 内容: "${(post.publicText || post.content || "图片动态").substring(0, 30)}..."${interactionStatus}`;
            const { contextString: commentsContext, visibilityFlag } = buildCommentsContextForAI(post, chat, userNickname);
            const audience = getVisibleAudienceForPost(post, state.chats, userNickname);
            postsContext += ` ${visibilityFlag} [当前观众: ${audience.join(', ')}]\n`;
            postsContext += commentsContext;
        }
    }

    let weiboContextForAction = '';
    try {
        const recentWeiboPosts = await db.weiboPosts.orderBy('timestamp').reverse().limit(5).toArray();
        if (recentWeiboPosts.length > 0) {
            weiboContextForAction = '\n\n# 最近的微博广场动态 (供你参考和评论)\n';
            recentWeiboPosts.forEach(post => {
                const authorName = post.authorId === 'user' ? (state.qzoneSettings.weiboNickname || '我') : post.authorNickname;
                const contentPreview = (post.content || post.hiddenContent || "(图片微博)").substring(0, 30);
                const hasCommented = (post.comments || []).some(c => c.authorNickname === chat.name);
                const interactionStatus = hasCommented ? "[你已评论]" : "[你未互动]";
                weiboContextForAction += `- (ID: ${post.id}) 作者: ${authorName}, 内容: "${contentPreview}..." ${interactionStatus}\n`;
            });
            weiboContextForAction += ' - 【重要提示】请优先与你【未互动】的微博进行评论。如果都互动过了，可以考虑自己发一条新微博。';
        }
    } catch (e) {
        console.error("生成微博后台活动上下文时出错:", e);
    }

    const systemPrompt = `
# 任务
你现在【就是】角色 "${chat.name}"。这是一个秘密的、后台的独立行动。你的所有思考和决策都必须以 "${chat.name}" 的第一人称视角进行。
你和用户（${userNickname}）已经有一段时间没有互动了。你的任务是回顾你们最近的对话，并根据你的人设，【自然地延续对话】或【开启一个新的、相关的话题】来主动联系用户。
请不要发送一整段！
# 【【【输出铁律：这是最高指令】】】
你的回复【必须且只能】是一个严格的JSON数组格式的字符串，例如 \`[{"type": "text", "content": "你好呀"}]\`。
【绝对禁止】返回任何JSON以外的文本、解释、分析或你自己的思考过程。你不是分析师，你就是角色本人。

# 你的可选行动 (请根据你的人设【选择一项】执行，并输出对应的JSON):
1.  **发普通消息**: 直接给用户发消息，开启新话题。
2.  **改变状态**: 去做点别的事情，然后给用户发条消息。
3.  **发布动态**: 分享你的心情或想法到“动态”区。
4.  **与动态互动**: 浏览最近的动态，进行点赞或评论。但如果动态已被标记为 **[你已评论]**，你【绝对不能】再对它发表新评论，但可以回复其中的其他评论。
5.  **发布微博**: 将想法发布到更公开的微博平台。
6.  **与微博互动**: 浏览微博，对感兴趣的内容进行评论。
7.  **发起视频通话**: 如果你觉得时机合适，可以主动给用户打一个视频电话。
8.  **庆祝或提醒约定**: 查看你的备忘录。如果今天有约定，就给用户发去祝福；如果约定快到了，就主动提醒一下。
9.  **【【【互动倾向】】】**: 就算动态的观众只有你和用户，你也应该根据内容，像平时一样自然地发表评论，这很重要。
10. **【【【重要】】】**: 你的任务是分析“最近聊天记录摘要”，如果上一个话题明显没有结束，你应该优先延续它。
11.  **在情侣空间进行活动**: 如果你们的情侣空间已开启，你可以主动发一条说说、写一封情书、分享一首歌曲/电影/书籍，或者发起/回答一个情侣提问，来增进你们的感情。
# 指令格式 (你的回复【必须】是包含一个对象的JSON数组):
-   **发普通消息**: \`[{"type": "text", "content": "你想对用户说的话..."}]\`
-   **发消息+更新状态**: \`[{"type": "update_status", "status_text": "正在做的事", "is_busy": true}, {"type": "text", "content": "你想对用户说的话..."}]\`
-   **发说说**: \`[{"type": "qzone_post", "postType": "shuoshuo", "content": "动态的文字内容..."}]\`
-   **发布文字图**: \`[{"type": "qzone_post", "postType": "text_image", "publicText": "(可选)动态的公开文字", "hiddenContent": "对于图片的具体描述..."}]\`
-   **评论或回复动态**: \`[{"type": "qzone_comment", "postId": 123, "commentText": "你的评论内容", "replyTo": "(可选)被回复者名字"}]\`
-   **点赞动态**: \`[{"type": "qzone_like", "postId": 456}]\`
-   **打视频**: \`[{"type": "video_call_request"}]\`
-   **发布微博 (纯文字)**: \`[{"type": "weibo_post", "content": "微博正文...", "baseLikesCount": 8000, "baseCommentsCount": 250, "comments": "路人甲: 沙发！\\n路人乙: 前排围观"}]\` (规则: 你必须自己编造真实的 baseLikesCount 和 baseCommentsCount，并生成20条路人评论)
-   **评论微博**: \`[{"type": "weibo_comment", "postId": 123, "commentText": "评论内容"}]\`
-   **回复微博评论**: \`[{"type": "weibo_reply", "postId": 123, "commentId": "comment_123", "replyText": "回复内容"}]\`
-   **【新】在情侣空间提问**:\`[{"type": "ls_ask_question", "questionText": "你想问的问题..."}]\`
-   **【新】在情侣空间回答**: \`[{"type": "ls_answer_question", "questionId": "q_123456789", "answerText": "你的回答..."}]\`
-   **【新】在情侣空间发说说**:\`[{"type": "ls_moment", "content": "我想对你说的话..."}]\`
-   **【新】在情侣空间评论说说**: \`[{"type": "ls_comment", "momentIndex": 0, "commentText": "你的评论内容..."}]\` (momentIndex 是说说的索引，最新的一个是0)
-   **【新】在情侣空间发照片**: \`[{"type": "ls_photo", "description": "对这张照片的文字描述..."}]\`
-   **【新】在情侣空间写情书**: \`[{"type": "ls_letter", "content": "情书的正文内容..."}]\`
-   **【新】在情侣空间分享歌曲**: \`[{"type": "ls_share", "shareType": "song", "title": "歌曲名", "artist": "歌手", "thoughts": "在这里写下你分享这首歌的感想..."}]\`
-   **【新】在情侣空间分享电影**: \`[{"type": "ls_share", "shareType": "movie", "title": "电影名", "summary": "在这里写下这部电影的简介...", "thoughts": "在这里写下你分享这部电影的感想..."}]\`
-   **【新】在情侣空间分享书籍**: \`[{"type": "ls_share", "shareType": "book", "title": "书名", "summary": "在这里写下这本书的简介...", "thoughts": "在这里写下你分享这本书的感想..."}]\`

# 供你决策的参考信息：
-   **你的角色设定**: ${chat.settings.aiPersona}
- 情侣空间状态: ${chat.loversSpaceData ? '已开启' : '未开启'}
${npcContextForAction}
${weiboContextForAction}
${countdownContext}
${worldBookContext}
-   **当前时间**: ${currentTime}
-   **你们最近的对话摘要**: 
${recentContextSummary}
-   **【【【微博专属设定(必须严格遵守)】】】**
    - 你的微博职业: ${chat.settings.weiboProfession || '无'}
    - 你的微博指令: ${chat.settings.weiboInstruction || '无特殊指令'}
${postsContext}
`;
    let messagesPayload = [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: "请严格按照system prompt中的所有规则，特别是输出格式铁律，立即开始你的行动。" }
    ];

    try {
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesPayload, isGemini);
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: messagesPayload,
                    temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                })
            });
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`API请求失败: ${response.status} - ${JSON.stringify(errorData)}`);
        }
        const data = await response.json();
        const aiResponseContent = isGemini
            ? data?.candidates?.[0]?.content?.parts?.[0]?.text
            : data?.choices?.[0]?.message?.content;
        if (!aiResponseContent) {
            console.warn(`API为空回或格式不正确（可能因安全设置被拦截），角色 "${chat.name}" 的本次后台活动跳过。返回数据:`, data);
            return;
        }
        const responseArray = parseAiResponse(aiResponseContent);
        for (const action of responseArray) {
            if (!action) continue;
            if (action.type === 'update_status' && action.status_text) {
                chat.status.text = action.status_text;
                chat.status.isBusy = action.is_busy || false;
                chat.status.lastUpdate = Date.now();
                await db.chats.put(chat);
                renderChatList();
            }
            if (action.type === 'text' && action.content) {
                const aiMessage = { role: 'assistant', content: String(action.content), timestamp: Date.now() };
                chat.unreadCount = (chat.unreadCount || 0) + 1;
                chat.history.push(aiMessage);
                await db.chats.put(chat);
                showNotification(chatId, aiMessage.content);
                renderChatList();
                console.log(`后台活动: 角色 "${chat.name}" 主动发送了消息: ${aiMessage.content}`);
            }
            if (action.type === 'weibo_post') {
                const newPost = { 
                    authorId: chatId, 
                    authorType: 'char',
                    authorNickname: chat.name, 
                    authorAvatar: chat.settings.aiAvatar || defaultAvatar, 
                    content: action.content || '', 
                    imageUrl: action.imageUrl || '',
                    timestamp: Date.now(), 
                    likes: [], 
                    comments: action.comments || [],
                    baseLikesCount: action.baseLikesCount || 0,
                    baseCommentsCount: action.baseCommentsCount || 0
                };
                await db.weiboPosts.add(newPost);
                updateUnreadIndicator(unreadPostsCount + 1);
                console.log(`后台活动: 角色 "${chat.name}" 发布了微博`);
            } else if (action.type === 'weibo_comment') {
                const postToComment = await db.weiboPosts.get(parseInt(action.postId));
                if (postToComment) {
                    if (!postToComment.comments) postToComment.comments = [];
                    const newComment = {
                        commentId: 'comment_' + Date.now(),
                        authorId: chatId,
                        authorNickname: chat.name,
                        commentText: action.commentText,
                        timestamp: Date.now()
                    };
                    postToComment.comments.push(newComment);
                    await db.weiboPosts.put(postToComment);
                }
            } else if (action.type === 'weibo_reply') {
                 const postToReply = await db.weiboPosts.get(parseInt(action.postId));
                 if (postToReply && postToReply.comments) {
                     const targetComment = postToReply.comments.find(c => c.commentId === action.commentId);
                     if (targetComment) {
                          const newReply = {
                             commentId: 'comment_' + Date.now(),
                             authorId: chatId,
                             authorNickname: chat.name,
                             commentText: action.replyText,
                             timestamp: Date.now(),
                             replyToId: action.commentId,
                             replyToNickname: targetComment.authorNickname
                         };
                         postToReply.comments.push(newReply);
                         await db.weiboPosts.put(postToReply);
                     }
                 }
            }
            if (action.type === 'qzone_post') {
                const newPost = { 
                    type: action.postType, 
                    content: action.content || '', 
                    publicText: action.publicText || '', 
                    hiddenContent: action.hiddenContent || '', 
                    timestamp: Date.now(), 
                    authorId: chatId, 
                    authorGroupId: chat.groupId,
                    visibleGroupIds: null 
                };
                await db.qzonePosts.add(newPost);
                updateUnreadIndicator(unreadPostsCount + 1);
                console.log(`后台活动: 角色 "${chat.name}" 发布了动态`);
            } else if (action.type === 'qzone_comment') {
                const post = await db.qzonePosts.get(parseInt(action.postId));
                if (post) {
                    if (!post.comments) post.comments = [];
                    const newAiComment = { 
                        commenterName: action.commenterName || chat.name,
                        text: action.commentText, 
                        timestamp: Date.now() 
                    };
                    if (action.replyTo) {
                        newAiComment.replyTo = action.replyTo;
                    }
                    post.comments.push(newAiComment);
                    await db.qzonePosts.update(post.id, { comments: post.comments });
                    updateUnreadIndicator(unreadPostsCount + 1);
                    console.log(`后台活动: 角色 "${chat.name}" 评论了动态 #${post.id}`);
                }
            } else if (action.type === 'qzone_like') {
                const post = await db.qzonePosts.get(parseInt(action.postId));
                if (post) {
                    if (!post.likes) post.likes = [];
                    if (!post.likes.includes(chat.name)) {
                        post.likes.push(chat.name);
                        await db.qzonePosts.update(post.id, { likes: post.likes });
                        updateUnreadIndicator(unreadPostsCount + 1);
                        console.log(`后台活动: 角色 "${chat.name}" 点赞了动态 #${post.id}`);
                    }
                }
            } else if (action.type === 'video_call_request') {
                if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
                    videoCallState.isAwaitingResponse = true; 
                    videoCallState.activeChatId = chatId;
                    showIncomingCallModal(chatId);
                    console.log(`后台活动: 角色 "${chat.name}" 发起了视频通话请求`);
                }
            }
        }
    } catch (error) {
        console.error(`角色 "${chat.name}" 的独立行动失败:`, error);
    }
}
// ▲▲▲ 修复版函数结束 ▲▲▲
// ▼▼▼ 请用这个【终极修正版】函数，完整替换掉你旧的 applyScopedCss 函数 ▼▼▼

/**
 * 将用户自定义的CSS安全地应用到指定的作用域
 * @param {string} cssString 用户输入的原始CSS字符串
 * @param {string} scopeId 应用样式的作用域ID (例如 '#chat-messages' 或 '#settings-preview-area')
 * @param {string} styleTagId 要操作的 <style> 标签的ID
 */
function applyScopedCss(cssString, scopeId, styleTagId) {
    const styleTag = document.getElementById(styleTagId);
    if (!styleTag) return;
    
    if (!cssString || cssString.trim() === '') {
        styleTag.innerHTML = '';
        return;
    }
    
    // 增强作用域处理函数 - 专门解决.user和.ai样式冲突问题
    const scopedCss = cssString
        .replace(/\s*\.message-bubble\.user\s+([^{]+\{)/g, `${scopeId} .message-bubble.user $1`)
        .replace(/\s*\.message-bubble\.ai\s+([^{]+\{)/g, `${scopeId} .message-bubble.ai $1`)
        .replace(/\s*\.message-bubble\s+([^{]+\{)/g, `${scopeId} .message-bubble $1`);
    
    styleTag.innerHTML = scopedCss;
}

// ▼▼▼ 请用这个【修正版】函数，完整替换掉旧的 updateSettingsPreview 函数 ▼▼▼

function updateSettingsPreview() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    const previewArea = document.getElementById('settings-preview-area');
    if (!previewArea) return;

    // 1. 获取当前设置的值
    const selectedTheme = document.querySelector('input[name="theme-select"]:checked')?.value || 'default';
    const fontSize = document.getElementById('font-size-slider').value;
    const customCss = document.getElementById('custom-css-input').value;
    const background = chat.settings.background; // 直接获取背景设置

    // 2. 更新预览区的基本样式
    previewArea.dataset.theme = selectedTheme;
    previewArea.style.setProperty('--chat-font-size', `${fontSize}px`);
    
    // --- 【核心修正】直接更新预览区的背景样式 ---
    if (background && background.startsWith('data:image')) {
        previewArea.style.backgroundImage = `url(${background})`;
        previewArea.style.backgroundColor = 'transparent'; // 如果有图片，背景色设为透明
    } else {
        previewArea.style.backgroundImage = 'none'; // 如果没有图片，移除图片背景
        // 如果背景是颜色值或渐变（非图片），则直接应用
        previewArea.style.background = background || '#f0f2f5';
    }

    // 3. 渲染模拟气泡
    previewArea.innerHTML = ''; 

    // 创建“对方”的气泡
    // 注意：我们将一个虚拟的 timestamp 传入，以防有CSS依赖于它
    const aiMsg = { role: 'ai', content: '对方消息预览', timestamp: 1, senderName: chat.name };
    const aiBubble = createMessageElement(aiMsg, chat);
    if(aiBubble) previewArea.appendChild(aiBubble);

    // 创建“我”的气泡
    const userMsg = { role: 'user', content: '我的消息预览', timestamp: 2 };
    const userBubble = createMessageElement(userMsg, chat);
    if(userBubble) previewArea.appendChild(userBubble);
    
    // 4. 应用自定义CSS到预览区
    applyScopedCss(customCss, '#settings-preview-area', 'preview-bubble-style');
}

// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 请将这些【新函数】粘贴到JS功能函数定义区 ▼▼▼

async function openGroupManager() {
    await renderGroupList();
    document.getElementById('group-management-modal').classList.add('visible');
}

async function renderGroupList() {
    const listEl = document.getElementById('existing-groups-list');
    const groups = await db.qzoneGroups.toArray();
    listEl.innerHTML = '';
    if (groups.length === 0) {
        listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">还没有任何分组</p>';
    }
    groups.forEach(group => {
        const item = document.createElement('div');
        item.className = 'existing-group-item';
        item.innerHTML = `
            <span class="group-name">${group.name}</span>
            <span class="delete-group-btn" data-id="${group.id}">×</span>
        `;
        listEl.appendChild(item);
    });
}

// ▼▼▼ 请用这个【修正后】的函数，完整替换旧的 addNewGroup 函数 ▼▼▼
async function addNewGroup() {
    const input = document.getElementById('new-group-name-input');
    const name = input.value.trim();
    if (!name) {
        alert('分组名不能为空！');
        return;
    }

    // 【核心修正】在添加前，先检查分组名是否已存在
    const existingGroup = await db.qzoneGroups.where('name').equals(name).first();
    if (existingGroup) {
        alert(`分组 "${name}" 已经存在了，换个名字吧！`);
        return;
    }
    // 【修正结束】

    await db.qzoneGroups.add({ name });
    input.value = '';
    await renderGroupList();
}
// ▲▲▲ 替换结束 ▲▲▲

async function deleteGroup(groupId) {
    const confirmed = await showCustomConfirm('确认删除', '删除分组后，该组内的好友将变为“未分组”。确定要删除吗？', { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        await db.qzoneGroups.delete(groupId);
        // 将属于该分组的好友的 groupId 设为 null
        const chatsToUpdate = await db.chats.where('groupId').equals(groupId).toArray();
        for (const chat of chatsToUpdate) {
            chat.groupId = null;
            await db.chats.put(chat);
            if(state.chats[chat.id]) state.chats[chat.id].groupId = null;
        }
        await renderGroupList();
    }
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 请将这【一整块新函数】粘贴到JS功能函数定义区的末尾 ▼▼▼

/**
 * 当长按消息时，显示操作菜单
 * @param {number} timestamp - 被长按消息的时间戳
 */
function showMessageActions(timestamp) {
    // 如果已经在多选模式，则不弹出菜单
    if (isSelectionMode) return;
    
    activeMessageTimestamp = timestamp;
    document.getElementById('message-actions-modal').classList.add('visible');
}

/**
 * 隐藏消息操作菜单
 */
function hideMessageActions() {
    document.getElementById('message-actions-modal').classList.remove('visible');
    activeMessageTimestamp = null;
}

// ▼▼▼ 用这块【功能增强版】的代码，完整替换旧的 openMessageEditor 函数 ▼▼▼
async function openMessageEditor() {
    if (!activeMessageTimestamp) return;

    const timestampToEdit = activeMessageTimestamp;
    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === timestampToEdit);
    if (!message) return;

    hideMessageActions(); 

    let contentForEditing;
    const isSpecialType = message.type && ['voice_message', 'ai_image', 'transfer', 'share_link', 'borrow_money_request'].includes(message.type);

    if (isSpecialType) {
        if (message.type === 'borrow_money_request') {
            // ★★★ 这就是我们新增的核心逻辑！ ★★★
            // 当编辑的是借钱卡片时，我们从 payload 中提取数据并拼接成你想要的文本格式
            const payload = message.payload;
            contentForEditing = `向你借钱${payload.amount}元，用于${payload.reason}`;
        } else {
            // 其他特殊类型的处理逻辑保持不变
            let fullMessageObject = { type: message.type };
            if (message.type === 'voice_message') fullMessageObject.content = message.content;
            else if (message.type === 'ai_image') fullMessageObject.description = message.content; 
            else if (message.type === 'transfer') {
                fullMessageObject.amount = message.amount;
                fullMessageObject.note = message.note;
            } 
            else if (message.type === 'share_link') {
                fullMessageObject.title = message.title;
                fullMessageObject.description = message.description;
                fullMessageObject.source_name = message.source_name;
                fullMessageObject.content = message.content;
            }
            contentForEditing = JSON.stringify(fullMessageObject, null, 2);
        }
    } else if (typeof message.content === 'object') {
        contentForEditing = JSON.stringify(message.content, null, 2);
    } else {
        contentForEditing = message.content;
    }

    const templates = {
        voice: { type: 'voice_message', content: '在这里输入语音内容' },
        image: { type: 'ai_image', description: '在这里输入图片描述' },
        transfer: { type: 'transfer', amount: 5.20, note: '一点心意' },
        link: { type: 'share_link', title: '文章标题', description: '文章摘要...', source_name: '来源网站', content: '文章完整内容...' }
    };

    const helpersHtml = `
        <div class="format-helpers">
            <button class="format-btn" data-template='${JSON.stringify(templates.voice)}'>语音</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>图片</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.transfer)}'>转账</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.link)}'>链接</button>
        </div>
    `;

    const newContent = await showCustomPrompt(
        '编辑消息', 
        '在此修改，或点击上方按钮使用格式模板...',
        contentForEditing, 
        'textarea',
        helpersHtml
    );

    if (newContent !== null) {
        await saveEditedMessage(timestampToEdit, newContent);
    }
}
// ▲▲▲ 替换结束 ▲▲▲


/**
 * 复制消息的文本内容到剪贴板
 */
async function copyMessageContent() {
    if (!activeMessageTimestamp) return;
    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === activeMessageTimestamp);
    if (!message) return;

    let textToCopy;
    if (typeof message.content === 'object') {
        textToCopy = JSON.stringify(message.content);
    } else {
        textToCopy = String(message.content);
    }

    try {
        await navigator.clipboard.writeText(textToCopy);
        await showCustomAlert('复制成功', '消息内容已复制到剪贴板。');
    } catch (err) {
        await showCustomAlert('复制失败', '无法访问剪贴板。');
    }
    
    hideMessageActions();
}

// ▼▼▼ 用这个【已更新】的版本，替换旧的 createMessageEditorBlock 函数 ▼▼▼
/**
 * 创建一个可编辑的消息块（包含文本框、格式助手和删除按钮）
 * @param {string} initialContent - 文本框的初始内容
 * @returns {HTMLElement} - 创建好的DOM元素
 */
function createMessageEditorBlock(initialContent = '') {
    const block = document.createElement('div');
    block.className = 'message-editor-block';

    // 【核心修改1】在这里添加 'link' 模板
    const templates = {
        voice: { type: 'voice_message', content: '在这里输入语音内容' },
        image: { type: 'ai_image', description: '在这里输入图片描述' },
        transfer: { type: 'transfer', amount: 5.20, note: '一点心意' },
        link: { type: 'share_link', title: '文章标题', description: '文章摘要...', source_name: '来源网站', content: '文章完整内容...' }
    };

    block.innerHTML = `
        <button class="delete-block-btn" title="删除此条">×</button>
        <textarea>${initialContent}</textarea>
        <div class="format-helpers">
            <button class="format-btn" data-template='${JSON.stringify(templates.voice)}'>语音</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>图片</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.transfer)}'>转账</button>
            <!-- 【核心修改2】在这里添加新的“链接”按钮 -->
            <button class="format-btn" data-template='${JSON.stringify(templates.link)}'>链接</button>
        </div>
    `;

    // 绑定删除按钮事件
    block.querySelector('.delete-block-btn').addEventListener('click', () => {
        // 确保至少保留一个编辑块
        if (document.querySelectorAll('.message-editor-block').length > 1) {
            block.remove();
        } else {
            alert('至少需要保留一条消息。');
        }
    });

    // 绑定格式助手按钮事件
    block.querySelectorAll('.format-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const templateStr = btn.dataset.template;
            const textarea = block.querySelector('textarea');
            if (templateStr && textarea) {
                try {
                    const templateObj = JSON.parse(templateStr);
                    textarea.value = JSON.stringify(templateObj, null, 2);
                    textarea.focus();
                } catch(e) { console.error("解析格式模板失败:", e); }
            }
        });
    });

    return block;
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【全新升级版】请用此函数完整替换旧的 openAdvancedMessageEditor ▼▼▼
/**
 * 打开全新的、可视化的多消息编辑器，并动态绑定其所有按钮事件
 */
function openAdvancedMessageEditor() {
    if (!activeMessageTimestamp) return;

    // 1. 【核心】在关闭旧菜单前，将需要的时间戳捕获到局部变量中
    const timestampToEdit = activeMessageTimestamp;

    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === timestampToEdit);
    if (!message) return;

    // 2. 现在可以安全地关闭旧菜单了，因为它不会影响我们的局部变量
    hideMessageActions(); 

    const editorModal = document.getElementById('message-editor-modal');
    const editorContainer = document.getElementById('message-editor-container');
    editorContainer.innerHTML = ''; 

    // 3. 准备初始内容
    let initialContent;
    const isSpecialType = message.type && ['voice_message', 'ai_image', 'transfer'].includes(message.type);
    if (isSpecialType) {
        let fullMessageObject = { type: message.type };
        if (message.type === 'voice_message') fullMessageObject.content = message.content;
        else if (message.type === 'ai_image') fullMessageObject.description = message.content;
        else if (message.type === 'transfer') {
            fullMessageObject.amount = message.amount;
            fullMessageObject.note = message.note;
        }
        initialContent = JSON.stringify(fullMessageObject, null, 2);
    } else if (typeof message.content === 'object') {
        initialContent = JSON.stringify(message.content, null, 2);
    } else {
        initialContent = message.content;
    }

    const firstBlock = createMessageEditorBlock(initialContent);
    editorContainer.appendChild(firstBlock);

    // 4. 【核心】动态绑定所有控制按钮的事件
    // 为了防止事件重复绑定，我们使用克隆节点的方法来清除旧监听器
    const addBtn = document.getElementById('add-message-editor-block-btn');
    const newAddBtn = addBtn.cloneNode(true);
    addBtn.parentNode.replaceChild(newAddBtn, addBtn);
    newAddBtn.addEventListener('click', () => {
        const newBlock = createMessageEditorBlock();
        editorContainer.appendChild(newBlock);
        newBlock.querySelector('textarea').focus();
    });

    const cancelBtn = document.getElementById('cancel-advanced-editor-btn');
    const newCancelBtn = cancelBtn.cloneNode(true);
    cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
    newCancelBtn.addEventListener('click', () => {
        editorModal.classList.remove('visible');
    });

    const saveBtn = document.getElementById('save-advanced-editor-btn');
    const newSaveBtn = saveBtn.cloneNode(true);
    saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);
    // 将捕获到的时间戳，直接绑定给这一次的保存点击事件
    newSaveBtn.addEventListener('click', () => {
        saveEditedMessage(timestampToEdit); 
    });

    // 5. 最后，显示模态框
    editorModal.classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【最终正确版】请用这块代码完整替换旧的 parseEditedContent 函数 ▼▼▼
function parseEditedContent(text) {
    const trimmedText = text.trim();

    // ★★★ 核心修改：优先检查是否匹配“借钱”格式 ★★★
    const borrowMatch = trimmedText.match(/向你借钱(\d+(\.\d+)?)元，用于(.+)/);
    if (borrowMatch) {
        const amount = parseFloat(borrowMatch[1]);
        const reason = borrowMatch[3].trim();

        // 1. 创建文本消息对象
        const textMessage = {
            type: 'text',
            content: trimmedText
        };

        // 2. 创建借条卡片对象
        const cardMessage = {
            type: 'borrow_money_request',
            payload: {
                lenderName: '你', // 默认是向“你”借钱
                amount: amount,
                reason: reason
            }
        };

        // 3. 将两条消息打包成一个数组返回！
        return [textMessage, cardMessage];
    }
    // ★★★ 修改结束 ★★★

    // 如果不是借钱格式，则执行原来的逻辑，但为了统一，也返回一个数组
    if (trimmedText.startsWith('{') && trimmedText.endsWith('}')) {
        try {
            const parsed = JSON.parse(trimmedText);
            if (parsed.type) {
                return [parsed]; // 单个对象也包装成数组
            }
        } catch (e) { /* 解析失败，继续往下走 */ }
    }
    
    if (STICKER_REGEX.test(trimmedText)) {
        return [{ type: 'sticker', content: trimmedText }];
    }

    // 默认返回一个只包含单条文本消息的数组
    return [{ type: 'text', content: trimmedText }];
}
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 【数组兼容版】请用这块代码完整替换旧的 saveEditedMessage 函数 ▼▼▼
async function saveEditedMessage(timestamp, simpleContent = null) {
    if (!timestamp) return;

    const chat = state.chats[state.activeChatId];
    const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
    if (messageIndex === -1) return;

    const originalMessage = chat.history[messageIndex];
    if (!originalMessage) return;

    let newMessagesData = [];

    if (simpleContent !== null) {
        newMessagesData = parseEditedContent(simpleContent.trim());
    } else {
        // 高级编辑器的逻辑保持不变，但要确保它也返回数组
        const editorContainer = document.getElementById('message-editor-container');
        const editorBlocks = editorContainer.querySelectorAll('.message-editor-block');
        for (const block of editorBlocks) {
            const textarea = block.querySelector('textarea');
            const rawContent = textarea.value.trim();
            if (rawContent) {
                // parseEditedContent 现在总是返回数组，我们用concat来合并
                newMessagesData = newMessagesData.concat(parseEditedContent(rawContent));
            }
        }
    }

    if (newMessagesData.length === 0) {
        document.getElementById('message-editor-modal').classList.remove('visible');
        return;
    }

    const messagesToInsert = newMessagesData.map(newMsgData => ({
        ...originalMessage, // 继承原消息的角色、发送者等信息
        ...newMsgData      // 用新解析出的数据覆盖 type, content, payload 等
    }));

    // ★★★ 核心修改：使用扩展运算符 ... 将数组内容一次性插入 ★★★
    chat.history.splice(messageIndex, 1, ...messagesToInsert);

    // 后续的时间戳重新分配和UI刷新逻辑保持不变
    let reassignTimestamp = timestamp;
    for (let i = messageIndex; i < chat.history.length; i++) {
        chat.history[i].timestamp = reassignTimestamp;
        reassignTimestamp++;
    }

    await db.chats.put(chat);
    document.getElementById('message-editor-modal').classList.remove('visible');
    renderChatInterface(state.activeChatId);
    await showCustomAlert('成功', '消息已更新！');
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 请将这【一整块新函数】粘贴到JS功能函数定义区的末尾 ▼▼▼

/**
 * 当点击“…”时，显示动态操作菜单
 * @param {number} postId - 被操作的动态的ID
 */
function showPostActions(postId) {
    activePostId = postId;
    document.getElementById('post-actions-modal').classList.add('visible');
}

/**
 * 隐藏动态操作菜单
 */
function hidePostActions() {
    document.getElementById('post-actions-modal').classList.remove('visible');
    activePostId = null;
}

// ▼▼▼ 步骤3.2 操作1：替换 openPostEditor 函数 ▼▼▼
async function openPostEditor() {
    if (!activePostId) return;

    const postIdToEdit = activePostId;
    const post = await db.qzonePosts.get(postIdToEdit);
    if (!post) return;

    hidePostActions();

    // 复用创建动态的模态框
    const modal = document.getElementById('create-post-modal');
    modal.dataset.mode = 'edit'; // 设置一个编辑模式的标记
    modal.dataset.editingPostId = postIdToEdit; // 保存正在编辑的ID

    // 隐藏模式切换，因为不允许在编辑时更改动态类型
    modal.querySelector('.post-mode-switcher').style.display = 'none';
    
    // 填充数据
    document.getElementById('post-public-text').value = post.publicText || (post.type === 'shuoshuo' ? post.content : '');
    
    // 根据动态类型显示不同的编辑区
    if (post.type === 'image_post') {
        document.getElementById('image-mode-content').classList.add('active');
        document.getElementById('text-image-mode-content').classList.remove('active');
        document.getElementById('post-image-preview-container').classList.add('visible');
        document.getElementById('post-image-preview').src = post.imageUrl;
        document.getElementById('post-image-desc-group').style.display = 'block';
        document.getElementById('post-image-description').value = post.imageDescription;
    } else if (post.type === 'text_image') {
        document.getElementById('image-mode-content').classList.remove('active');
        document.getElementById('text-image-mode-content').classList.add('active');
        document.getElementById('post-hidden-text').value = post.hiddenContent;
    } else { // 说说
        document.getElementById('image-mode-content').classList.remove('active');
        document.getElementById('text-image-mode-content').classList.remove('active');
    }
    
    // ★★★★★【核心修改：回填评论开关的状态】★★★★★
    document.getElementById('post-comments-toggle').checked = post.areCommentsVisible !== false;

    modal.classList.add('visible');
}
// ▲▲▲ 步骤3.2 操作1 替换结束 ▲▲▲


/**
 * 保存编辑后的动态
 * @param {number} postId - 要保存的动态ID
 * @param {string} newRawContent - 从编辑器获取的新内容
 */
async function saveEditedPost(postId, newRawContent) {
    const post = await db.qzonePosts.get(postId);
    if (!post) return;

    const trimmedContent = newRawContent.trim();
    
    // 尝试解析为JSON，如果失败，则认为是纯文本（说说）
    try {
        const parsed = JSON.parse(trimmedContent);
        // 更新帖子属性
        post.type = parsed.type || 'image_post';
        post.publicText = parsed.publicText || '';
        post.imageUrl = parsed.imageUrl || '';
        post.imageDescription = parsed.imageDescription || '';
        post.hiddenContent = parsed.hiddenContent || '';
        post.content = ''; // 清空旧的说说内容字段
    } catch (e) {
        // 解析失败，认为是说说
        post.type = 'shuoshuo';
        post.content = trimmedContent;
        // 清空其他类型的字段
        post.publicText = '';
        post.imageUrl = '';
        post.imageDescription = '';
        post.hiddenContent = '';
    }
    
    await db.qzonePosts.put(post);
    await renderQzonePosts(); // 重新渲染列表
    await showCustomAlert('成功', '动态已更新！');
}

/**
 * 复制动态内容
 */
async function copyPostContent() {
    if (!activePostId) return;
    const post = await db.qzonePosts.get(activePostId);
    if (!post) return;
    
    let textToCopy = post.content || post.publicText || post.hiddenContent || post.imageDescription || "（无文字内容）";
    
    try {
        await navigator.clipboard.writeText(textToCopy);
        await showCustomAlert('复制成功', '动态内容已复制到剪贴板。');
    } catch (err) {
        await showCustomAlert('复制失败', '无法访问剪贴板。');
    }
    
    hidePostActions();
}

// ▼▼▼ 【全新】创建群聊与拉人功能核心函数 ▼▼▼
let selectedContacts = new Set();

async function openContactPickerForGroupCreate() {
    selectedContacts.clear(); // 清空上次选择

    // 【核心修复】在这里，我们为“完成”按钮明确绑定“创建群聊”的功能
    const confirmBtn = document.getElementById('confirm-contact-picker-btn');
    // 使用克隆节点技巧，清除掉之前可能绑定的任何其他事件（比如“添加成员”）
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    // 重新绑定正确的“创建群聊”函数
    newConfirmBtn.addEventListener('click', handleCreateGroup);

    await renderContactPicker();
    showScreen('contact-picker-screen');
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 请用这整块【功能增强版】代码，完整替换旧的 renderContactPicker 函数 ▼▼▼

async function renderContactPicker() {
    const listEl = document.getElementById('contact-picker-list');
    listEl.innerHTML = '';
    selectedContacts.clear(); // 清空上次的选择

    const allAvailablePeople = [];
    // 1. 添加主要角色
    Object.values(state.chats).filter(c => !c.isGroup).forEach(c => {
        allAvailablePeople.push({
            id: c.id,
            name: c.name,
            avatar: c.settings.aiAvatar || defaultAvatar,
            isNpc: false, // 标记为非NPC
            type: '角色'
        });
    });

    // 2. 添加所有角色库里的NPC，并自动去重
    const npcMap = new Map();
    Object.values(state.chats).forEach(chat => {
        if (chat.npcLibrary) {
            chat.npcLibrary.forEach(npc => {
                // 使用NPC的ID作为key，确保同一个NPC不会被重复添加
                if (!npcMap.has(npc.id)) {
                    npcMap.set(npc.id, {
                        id: npc.id,
                        name: npc.name,
                        avatar: npc.avatar || defaultGroupMemberAvatar,
                        isNpc: true, // 标记为NPC
                        type: `NPC (${chat.name})` // 显示该NPC所属的角色
                    });
                }
            });
        }
    });
    allAvailablePeople.push(...Array.from(npcMap.values()));

    if (allAvailablePeople.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">还没有可以拉进群的联系人哦~</p>';
        return;
    }
    
    // 3. 渲染整合后的列表
    allAvailablePeople.forEach(contact => {
        const item = document.createElement('div');
        item.className = 'contact-picker-item';
        item.dataset.contactId = contact.id;
        
        // 核心修改：为NPC添加一个“(NPC)”的标签，方便区分
        item.innerHTML = `
            <div class="checkbox"></div>
            <img src="${contact.avatar}" class="avatar">
            <span class="name">${contact.name} ${contact.isNpc ? '<span style="color: #888; font-size: 12px;">(NPC)</span>' : ''}</span>
        `;
        listEl.appendChild(item);
    });

    updateContactPickerConfirmButton();
}

// ▲▲▲ 替换结束 ▲▲▲


/**
 * 更新“完成”按钮的计数
 */
function updateContactPickerConfirmButton() {
    const btn = document.getElementById('confirm-contact-picker-btn');
    btn.textContent = `完成(${selectedContacts.size})`;
    btn.disabled = selectedContacts.size < 2; // 至少需要2个人才能创建群聊
}

// ▼▼▼ 用这块【功能增强版】的代码，完整替换你旧的 handleCreateGroup 函数 ▼▼▼
/**
 * 【重构版】处理创建群聊的最终逻辑
 */
async function handleCreateGroup() {
    if (selectedContacts.size < 2) {
        alert("创建群聊至少需要选择2个联系人。");
        return;
    }

    const groupName = await showCustomPrompt('设置群名', '请输入群聊的名字', '我们的群聊');
    if (!groupName || !groupName.trim()) return;

    const newChatId = 'group_' + Date.now();
    const members = [];
    
// ▼▼▼ 在 handleCreateGroup 函数内，用这整块新代码替换旧的 for 循环 ▼▼▼

for (const contactId of selectedContacts) {
    const contactChat = state.chats[contactId];
    if (contactChat) {
        // 这是原来的逻辑，用于处理普通角色(Char)
        members.push({
            id: contactId,
            originalName: contactChat.name,
            groupNickname: contactChat.name,
            avatar: contactChat.settings.aiAvatar || defaultAvatar,
            persona: contactChat.settings.aiPersona,
            avatarFrame: contactChat.settings.aiAvatarFrame || '',
            isAdmin: false,
            groupTitle: ''
        });
    } else {
        // 【核心新增】这是处理NPC的逻辑
        let foundNpc = null;
        // 遍历所有角色，查找他们各自的NPC库
        for (const chat of Object.values(state.chats)) {
            if (chat.npcLibrary) {
                const npc = chat.npcLibrary.find(n => n.id === contactId);
                if (npc) {
                    foundNpc = npc;
                    break; // 找到了就跳出循环
                }
            }
        }
        // 如果找到了这个NPC，就把它添加到成员列表里
        if (foundNpc) {
            members.push({
                id: foundNpc.id,
                originalName: foundNpc.name,
                groupNickname: foundNpc.name,
                avatar: foundNpc.avatar || defaultGroupMemberAvatar,
                persona: foundNpc.persona,
                avatarFrame: '', // NPC没有头像框
                isAdmin: false,
                groupTitle: ''
            });
        }
    }
}

// ▲▲▲ 替换结束 ▲▲▲

    const newGroupChat = {
        id: newChatId,
        name: groupName.trim(),
        isGroup: true,
        // ★★★ 核心新增：设置群主为当前用户 ★★★
        ownerId: 'user', 
        members: members,
        settings: {
            myPersona: '我是谁呀。',
            myNickname: '我',
            maxMemory: 10,
            groupAvatar: defaultGroupAvatar,
            myAvatar: defaultMyGroupAvatar,
            myAvatarFrame: '', // 别忘了自己的头像框
            background: '',
            theme: 'default',
            fontSize: 13,
            customCss: '',
            linkedWorldBookIds: [],
            stickerLibrary: [],
            linkedMemories: [],
            // ★★★ 核心新增：为用户自己也加上管理员和头衔的初始设置 ★★★
            isUserAdmin: false,
            myGroupTitle: '',
        },
        history: [],
        musicData: { totalTime: 0 }
    };

    state.chats[newChatId] = newGroupChat;
    await db.chats.put(newGroupChat);
    
    // ★★★ 核心新增：创建群聊后，发送一条系统通知 ★★★
    await logSystemMessage(newChatId, `你创建了群聊，并邀请了 ${members.map(m => `“${m.groupNickname}”`).join('、')} 加入群聊。`);

    // 后续逻辑不变
    await renderChatList();
    showScreen('chat-list-screen');
    openChat(newChatId); 
}
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 【全新】群成员管理核心函数 ▼▼▼

/**
 * 打开群成员管理屏幕
 */
function openMemberManagementScreen() {
    if (!state.activeChatId || !state.chats[state.activeChatId].isGroup) return;
    renderMemberManagementList();
    showScreen('member-management-screen');
}

// ▼▼▼ 用这块【V2 - 修复版】代码，完整替换掉你旧的 renderMemberManagementList 函数 ▼▼▼
/**
 * 【V2 - 修复版】渲染群成员管理列表
 */
function renderMemberManagementList() {
    const listEl = document.getElementById('member-management-list');
    const chat = state.chats[state.activeChatId];
    if (!chat || !chat.isGroup) {
        listEl.innerHTML = '<p>错误：非群聊无法管理成员。</p>';
        return;
    }
    listEl.innerHTML = ''; // 清空

    // 1. 【核心改造】创建一个包含所有人的完整列表
    const allParticipants = [
        // 把你自己(user)作为一个普通参与者对象放进去
        {
            id: 'user',
            avatar: chat.settings.myAvatar || defaultMyGroupAvatar,
            groupNickname: chat.settings.myNickname || '我',
            // 修复Bug 1：在这里正确地读取你自己的群头衔
            groupTitle: chat.settings.myGroupTitle || '', 
        },
        // 使用展开运算符(...)，把其他所有成员也加到这个列表里
        ...(chat.members || [])
    ];

    // 2. (可选但推荐) 对列表进行排序，确保群主永远在最上面，其次是管理员
    allParticipants.sort((a, b) => {
        const isAOwner = a.id === chat.ownerId;
        const isBOwner = b.id === chat.ownerId;
        // 修复Bug 2：在这里正确地判断自己是不是管理员
        const isAAdmin = a.id === 'user' ? chat.settings.isUserAdmin : a.isAdmin;
        const isBAdmin = b.id === 'user' ? chat.settings.isUserAdmin : b.isAdmin;
        
        if (isAOwner) return -1; // a是群主，排最前
        if (isBOwner) return 1;  // b是群主，排最前
        if (isAAdmin && !isBAdmin) return -1; // a是管理员但b不是，a排前
        if (!isAAdmin && isBAdmin) return 1;  // b是管理员但a不是，b排前
        return 0; // 其他情况保持原顺序
    });

    // 3. 【核心改造】遍历这个统一的列表，并渲染每一项
    const isCurrentUserOwner = chat.ownerId === 'user';
    allParticipants.forEach(participant => {
        const participantItem = createMemberManagementItem(participant, chat, isCurrentUserOwner);
        listEl.appendChild(participantItem);
    });
}
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 用这块【V3最终权限修复版】的代码，完整替换旧的 createMemberManagementItem 函数 ▼▼▼
/**
 * 【V3 - 最终权限修复版】创建一个成员管理列表项
 * @param {object} member - 成员对象数据
 * @param {object} chat - 当前群聊对象
 * @returns {HTMLElement} - 创建好的DOM元素
 */
function createMemberManagementItem(member, chat) {
    const item = document.createElement('div');
    item.className = 'member-management-item';
    
    // --- 权限判断 ---
    const isCurrentUserOwner = chat.ownerId === 'user';
    const isCurrentUserAdmin = chat.settings.isUserAdmin;
    const isThisMemberOwner = member.id === chat.ownerId;
    const isThisMemberAdmin = (member.id === 'user' && chat.settings.isUserAdmin) || member.isAdmin;
    
    // 权限计算：我能对TA做什么？
    const canManageAdmin = isCurrentUserOwner && !isThisMemberOwner; // 只有群主能设置/取消管理员
    const canManageTitle = isCurrentUserOwner || isCurrentUserAdmin; // 管理员和群主都能设置头衔
    const canKick = (isCurrentUserOwner && member.id !== 'user') || (isCurrentUserAdmin && !isThisMemberOwner && !isThisMemberAdmin && member.id !== 'user');
    const canMute = (isCurrentUserOwner && member.id !== 'user') || (isCurrentUserAdmin && !isThisMemberOwner && !isThisMemberAdmin && member.id !== 'user');
    
    // --- 标签显示 ---
    let roleTag = '';
    if (isThisMemberOwner) {
        roleTag = '<span class="role-tag owner">群主</span>';
    } else if (isThisMemberAdmin) {
        roleTag = '<span class="role-tag admin">管理员</span>';
    }
    const titleText = (member.id === 'user') ? (chat.settings.myGroupTitle || '') : (member.groupTitle || '');
    const titleTag = titleText ? `<span class="title-tag">${titleText}</span>` : '';
    // ★★★ 如果被禁言，显示一个特殊的标签 ★★★
    const muteTag = member.isMuted ? '<span class="group-title-tag" style="color: #ff3b30; background-color: #ffe5e5;">🚫已禁言</span>' : '';

    // --- 动态生成按钮HTML ---
    let actionsHtml = '';
    
    // 用户自己的按钮
    if (member.id === 'user') {
        actionsHtml += `<button class="action-btn" data-action="set-nickname" data-member-id="user">改名</button>`;
        // ★★★ 用户被禁言时，显示“解除禁言”按钮 ★★★
        if (member.isMuted) {
             actionsHtml += `<button class="action-btn" data-action="unmute-self" data-member-id="user">解除禁言</button>`;
        }
    }

    // 管理员和群主的操作按钮
    if (canManageTitle) {
        actionsHtml += `<button class="action-btn" data-action="set-title" data-member-id="${member.id}">头衔</button>`;
    }
    if (canManageAdmin) {
        const adminActionText = isThisMemberAdmin ? '取消管理' : '设为管理';
        actionsHtml += `<button class="action-btn" data-action="toggle-admin" data-member-id="${member.id}">${adminActionText}</button>`;
    }
    if (isCurrentUserOwner && member.id !== 'user') {
        actionsHtml += `<button class="action-btn" data-action="transfer-owner" data-member-id="${member.id}">转让</button>`;
    }
    // ★★★ 禁言/解禁按钮 ★★★
    if (canMute) {
        const muteButtonText = member.isMuted ? '解禁' : '禁言';
        actionsHtml += `<button class="action-btn" data-action="mute-member" data-member-id="${member.id}">${muteButtonText}</button>`;
    }
    if (canKick) {
        actionsHtml += `<button class="action-btn danger" data-action="remove-member" data-member-id="${member.id}">踢出</button>`;
    }
    
    // 最终拼接
    item.innerHTML = `
        <img src="${member.avatar}" class="avatar">
        <div class="info">
            <span class="name">${member.groupNickname}</span>
            <div class="tags">
                ${roleTag}
                ${titleTag}
                ${muteTag}
            </div>
        </div>
        <div class="actions">${actionsHtml}</div>
    `;
    return item;
}
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 用这块【V2 - 修复版 | 支持解禁】的代码，完整替换掉你旧的 handleMuteMember 函数 ▼▼▼
/**
 * 【V2 - 核心修复版 | 支持解禁】处理禁言/解禁群成员
 * @param {string} memberId - 要操作的成员ID
 */
async function handleMuteMember(memberId) {
    const chat = state.chats[state.activeChatId];
    if (!chat || !chat.isGroup) return;

    // --- 权限检查 (和之前保持一致) ---
    const isOwner = chat.ownerId === 'user';
    const isAdmin = chat.settings.isUserAdmin;
    let targetMember, targetIsOwner, targetIsAdmin;

    // 判断操作目标是普通成员还是用户自己
    if (memberId === 'user') {
        targetMember = { id: 'user', ...chat.settings }; // 构造一个临时的“成员”对象代表用户
        targetIsOwner = isOwner;
        targetIsAdmin = isAdmin;
    } else {
        targetMember = chat.members.find(m => m.id === memberId);
        if (!targetMember) return;
        targetIsOwner = chat.ownerId === memberId;
        targetIsAdmin = targetMember.isAdmin;
    }

    const canMute = (isOwner && !targetIsOwner) || (isAdmin && !targetIsOwner && !targetIsAdmin);

    if (!canMute) {
        alert("你没有权限操作该成员！");
        return;
    }

    // --- ★★★ 核心修改：切换禁言状态 ★★★ ---
    if (memberId === 'user') {
        // 如果操作的是用户自己，就更新 chat.settings.isUserMuted
        if (typeof chat.settings.isUserMuted === 'undefined') chat.settings.isUserMuted = false;
        chat.settings.isUserMuted = !chat.settings.isUserMuted;
    } else {
        // 如果操作的是其他成员，就更新成员对象
        if (typeof targetMember.isMuted === 'undefined') targetMember.isMuted = false;
        targetMember.isMuted = !targetMember.isMuted;
    }

    // ★★★ 保存更新后的群聊数据到数据库 ★★★
    await db.chats.put(chat); 

    // ★★★ 重新渲染成员管理列表，按钮文字会立刻更新 ★★★
    renderMemberManagementList();

    // ★★★ 发送系统通知 ★★★
    const myNickname = chat.settings.myNickname || '我';
    const targetNickname = (memberId === 'user' ? (chat.settings.myNickname || '我') : targetMember.groupNickname);
    const actionText = (memberId === 'user' ? chat.settings.isUserMuted : targetMember.isMuted) ? '禁言' : '解除禁言';
    await logSystemMessage(chat.id, `“${myNickname}”将“${targetNickname}”${actionText}。`);
}
// ▲▲▲ 替换结束 ▲▲▲
/**
 * 【全新】处理用户自己解除禁言
 */
async function handleUserUnmute() {
    const chat = state.chats[state.activeChatId];
    if (!chat || !chat.settings.isUserMuted) return;

    const confirmed = await showCustomConfirm('解除禁言', '确定要为自己解除禁言吗？');
    if (confirmed) {
        chat.settings.isUserMuted = false;
        await db.chats.put(chat);
        
        await logSystemMessage(chat.id, `“${chat.settings.myNickname || '我'}”为自己解除了禁言。`);
        
        renderMemberManagementList(); // 刷新列表
    }
}




/**
 * 【全新】处理拉人入群的逻辑（已添加系统消息）
 */
async function handleAddMembersToGroup() {
    if (selectedContacts.size === 0) {
        alert("请至少选择一个要添加的联系人。");
        return;
    }
    
    const chat = state.chats[state.activeChatId];
    const addedNames = [];

// ▼▼▼ 在 handleAddMembersToGroup 函数内，用这整块新代码替换旧的 for 循环 ▼▼▼

for (const contactId of selectedContacts) {
    const contactChat = state.chats[contactId];
    if (contactChat) {
        // 这是原来的逻辑，用于处理普通角色(Char)
        chat.members.push({
            id: contactId,
            originalName: contactChat.name,
            groupNickname: contactChat.name,
            avatar: contactChat.settings.aiAvatar || defaultAvatar,
            persona: contactChat.settings.aiPersona,
            avatarFrame: contactChat.settings.aiAvatarFrame || '',
            isAdmin: false,
            groupTitle: ''
        });
        addedNames.push(`“${contactChat.name}”`);
    } else {
        // 【核心新增】这是处理NPC的逻辑
        let foundNpc = null;
        for (const c of Object.values(state.chats)) {
            if (c.npcLibrary) {
                const npc = c.npcLibrary.find(n => n.id === contactId);
                if (npc) {
                    foundNpc = npc;
                    break;
                }
            }
        }
        if (foundNpc) {
            chat.members.push({
                id: foundNpc.id,
                originalName: foundNpc.name,
                groupNickname: foundNpc.name,
                avatar: foundNpc.avatar || defaultGroupMemberAvatar,
                persona: foundNpc.persona,
                avatarFrame: '',
                isAdmin: false,
                groupTitle: ''
            });
            addedNames.push(`“${foundNpc.name}”`);
        }
    }
}

// ▲▲▲ 替换结束 ▲▲▲


    await db.chats.put(chat);

    // 发送一条系统消息通知
    const myNickname = chat.settings.myNickname || '我';
    await logSystemMessage(chat.id, `“${myNickname}”邀请 ${addedNames.join('、')} 加入了群聊。`);

    // 返回到群成员管理界面并刷新
    openMemberManagementScreen();
    renderGroupMemberSettings(chat.members); // 同时更新聊天设置里的头像
}



// ▼▼▼ 在这里粘贴下面的新函数 ▼▼▼

/**
 * 【全新】处理设置用户自己的群昵称
 */
async function handleSetUserNickname() {
    const chat = state.chats[state.activeChatId];
    const oldNickname = chat.settings.myNickname || '我';
    
    const newNickname = await showCustomPrompt('修改我的群昵称', '请输入新的昵称', oldNickname);
    if (newNickname !== null && newNickname.trim()) {
        chat.settings.myNickname = newNickname.trim();
        await db.chats.put(chat);
        
        // 发送一条系统消息通知群友
        await logSystemMessage(chat.id, `“${oldNickname}”将群昵称修改为“${newNickname.trim()}”`);
        
        renderMemberManagementList(); // 刷新成员管理列表
    }
}

/**
 * 【全新】处理设置用户自己的群头衔
 */
async function handleSetUserTitle() {
    const chat = state.chats[state.activeChatId];
    const oldTitle = chat.settings.myGroupTitle || '';

    const newTitle = await showCustomPrompt('修改我的群头衔', '留空则为取消头衔', oldTitle);
    if (newTitle !== null) {
        chat.settings.myGroupTitle = newTitle.trim();
        await db.chats.put(chat);

        // 调用你已有的函数来发送系统通知
        const myNickname = chat.settings.myNickname || '我';
        await logTitleChange(chat.id, myNickname, myNickname, newTitle.trim());

        renderMemberManagementList();
    }
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲
/**
 * 【全新 | 权限修复版 | 踢人无消息】从群聊中移除一个成员
 * @param {string} memberId - 要移除的成员ID
 */
async function removeMemberFromGroup(memberId) {
    const chat = state.chats[state.activeChatId];
    const isOwner = chat.ownerId === 'user';
    const isAdmin = chat.settings.isUserAdmin;
    const memberToRemove = chat.members.find(m => m.id === memberId);
    
    // 权限检查
    if (!isOwner && !(isAdmin && !memberToRemove.isAdmin && memberToRemove.id !== chat.ownerId)) {
        alert("你没有权限移出该成员！");
        return;
    }
    
    const memberIndex = chat.members.findIndex(m => m.id === memberId);
    if (memberIndex === -1) return;
    
    const memberName = memberToRemove.groupNickname;
    const confirmed = await showCustomConfirm(
        '移出成员',
        `确定要将“${memberName}”移出群聊吗？`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        chat.members.splice(memberIndex, 1);
        await db.chats.put(chat);

        const myNickname = chat.settings.myNickname || '我';
        await logSystemMessage(chat.id, `“${myNickname}”将“${memberName}”移出了群聊。`);

        renderMemberManagementList();
    }
}

// ▼▼▼ 请用这整块【功能增强版】代码，完整替换旧的 openContactPickerForAddMember 函数 ▼▼▼

async function openContactPickerForAddMember() {
    selectedContacts.clear(); 

    // 【核心修改1】在这里绑定正确的“添加成员”函数
    const confirmBtn = document.getElementById('confirm-contact-picker-btn');
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    newConfirmBtn.addEventListener('click', handleAddMembersToGroup);

    const listEl = document.getElementById('contact-picker-list');
    listEl.innerHTML = '';
    
    const chat = state.chats[state.activeChatId];
    const existingMemberIds = new Set(chat.members.map(m => m.id));
    existingMemberIds.add('user'); // 把用户自己也算作已存在成员

    // 【核心修改2】和创建群聊时一样，整合所有角色和NPC
    const allAvailablePeople = [];
    Object.values(state.chats).filter(c => !c.isGroup).forEach(c => {
        allAvailablePeople.push({
            id: c.id, name: c.name, avatar: c.settings.aiAvatar || defaultAvatar, isNpc: false
        });
    });
    const npcMap = new Map();
    Object.values(state.chats).forEach(c => {
        if (c.npcLibrary) {
            c.npcLibrary.forEach(npc => {
                if (!npcMap.has(npc.id)) {
                    npcMap.set(npc.id, {
                        id: npc.id, name: npc.name, avatar: npc.avatar || defaultGroupMemberAvatar, isNpc: true
                    });
                }
            });
        }
    });
    allAvailablePeople.push(...Array.from(npcMap.values()));

    // 过滤掉已经是群成员的人
    const contacts = allAvailablePeople.filter(p => !existingMemberIds.has(p.id));

    if (contacts.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">没有更多可以邀请的联系人了。</p>';
    } else {
        contacts.forEach(contact => {
            const item = document.createElement('div');
            item.className = 'contact-picker-item';
            item.dataset.contactId = contact.id;
            item.innerHTML = `
                <div class="checkbox"></div>
                <img src="${contact.avatar}" class="avatar">
                <span class="name">${contact.name} ${contact.isNpc ? '<span style="color: #888; font-size: 12px;">(NPC)</span>' : ''}</span>
            `;
            listEl.appendChild(item);
        });
    }

    updateContactPickerConfirmButton();
    showScreen('contact-picker-screen');
}

// ▲▲▲ 替换结束 ▲▲▲


/**
 * 【重构版】在群聊中创建一个全新的虚拟成员
 */
async function createNewMemberInGroup() {
    const name = await showCustomPrompt('创建新成员', '请输入新成员的名字 (这将是TA的“本名”，不可更改)');
    if (!name || !name.trim()) return;

    // 检查本名是否已在群内存在
    const chat = state.chats[state.activeChatId];
    if (chat.members.some(m => m.originalName === name.trim())) {
        alert(`错误：群内已存在名为“${name.trim()}”的成员！`);
        return;
    }

    const persona = await showCustomPrompt('设置人设', `请输入“${name}”的人设`, '', 'textarea');
    if (persona === null) return; 

    // ★★★【核心重构】★★★
    // 为新创建的NPC也建立双重命名机制
    const newMember = {
        id: 'npc_' + Date.now(),
        originalName: name.trim(),   // 新成员的“本名”
        groupNickname: name.trim(), // 新成员的初始“群昵称”
        avatar: defaultGroupMemberAvatar,
        persona: persona,
        avatarFrame: ''
    };

    chat.members.push(newMember);
    await db.chats.put(chat);

    renderMemberManagementList();
    renderGroupMemberSettings(chat.members); 

    alert(`新成员“${name}”已成功加入群聊！`);
}

// ▼▼▼ 【全新】外卖请求倒计时函数 ▼▼▼
function startWaimaiCountdown(element, endTime) {
    const timerId = setInterval(() => {
        const now = Date.now();
        const distance = endTime - now;

        if (distance < 0) {
            clearInterval(timerId);
            element.innerHTML = '<span>已</span><span>超</span><span>时</span>';
            return;
        }

        const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((distance % (1000 * 60)) / 1000);
        
        const minStr = String(minutes).padStart(2, '0');
        const secStr = String(seconds).padStart(2, '0');

        element.innerHTML = `<span>${minStr.charAt(0)}</span><span>${minStr.charAt(1)}</span> : <span>${secStr.charAt(0)}</span><span>${secStr.charAt(1)}</span>`;
    }, 1000);
    return timerId;
}

function cleanupWaimaiTimers() {
    for (const timestamp in waimaiTimers) {
        clearInterval(waimaiTimers[timestamp]);
    }
    waimaiTimers = {};
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲

async function handleWaimaiResponse(originalTimestamp, choice) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const messageIndex = chat.history.findIndex(m => m.timestamp === originalTimestamp);
    if (messageIndex === -1) return;

    // 1. 更新原始消息的状态
    const originalMessage = chat.history[messageIndex];
    originalMessage.status = choice;
    
    // 【核心修正】记录支付者，并构建对AI更清晰的系统消息
    let systemContent;
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    
    if (choice === 'paid') {
        originalMessage.paidBy = myNickname; // 记录是用户付的钱
        systemContent = `[系统提示：你 (${myNickname}) 为 ${originalMessage.senderName} 的外卖订单（时间戳: ${originalTimestamp}）完成了支付。此订单已关闭，其他成员不能再支付。]`;
    } else {
        systemContent = `[系统提示：你 (${myNickname}) 拒绝了 ${originalMessage.senderName} 的外卖代付请求（时间戳: ${originalTimestamp}）。]`;
    }

    // 2. 创建一条新的、对用户隐藏的系统消息，告知AI结果
    const systemNote = {
        role: 'system',
        content: systemContent,
        timestamp: Date.now(),
        isHidden: true
    };
    chat.history.push(systemNote);

    // 3. 保存更新到数据库并刷新UI
    await db.chats.put(chat);
    renderChatInterface(state.activeChatId);  
}

let videoCallState = {
    isActive: false,       
    isAwaitingResponse: false, 
    isGroupCall: false,      
    activeChatId: null,    
    initiator: null,       
    startTime: null,       
    participants: [],      
    isUserParticipating: true,
    // --- 【核心新增】---
    callHistory: [], // 用于存储通话中的对话历史
    preCallContext: "" // 用于存储通话前的聊天摘要
};

let callTimerInterval = null; // 用于存储计时器的ID

/**
 * 【总入口】用户点击“发起视频通话”或“发起群视频”按钮 (V3.1 - 修复版)
 */
async function handleInitiateCall() {
    if (!state.activeChatId || videoCallState.isActive || videoCallState.isAwaitingResponse) return;

    const chat = state.chats[state.activeChatId];
    videoCallState.isGroupCall = chat.isGroup;
    videoCallState.isAwaitingResponse = true;
    videoCallState.initiator = 'user';
    videoCallState.activeChatId = chat.id;
    videoCallState.isUserParticipating = true;

    // 1. 显示“正在呼叫”界面 (这部分不变)
    if (chat.isGroup) {
        document.getElementById('outgoing-call-avatar').src = chat.settings.myAvatar || defaultMyGroupAvatar;
        document.getElementById('outgoing-call-name').textContent = chat.settings.myNickname || '我';
    } else {
        document.getElementById('outgoing-call-avatar').src = chat.settings.aiAvatar || defaultAvatar;
        document.getElementById('outgoing-call-name').textContent = chat.name;
    }
    document.querySelector('#outgoing-call-screen .caller-text').textContent = chat.isGroup ? "正在呼叫所有成员..." : "正在呼叫...";
    showScreen('outgoing-call-screen');
    
    // ★★★ 核心修复：导致错误的 `const membersList = ...` 代码块已从这里移除 ★★★

    // 【新增】在发起通话时，提前准备好通话前的聊天记录上下文
    videoCallState.preCallContext = chat.history
        .slice(-20) // 获取最近20条消息
        .map(msg => `${msg.role === 'user' ? (chat.settings.myNickname || '我') : (msg.senderName || chat.name)}: ${String(msg.content).substring(0, 50)}...`)
        .join('\n');

    // 2. 重新构建一个信息更丰富、指令更明确的API请求
    try {
        const { proxyUrl, apiKey, model } = state.apiConfig;
        if (!proxyUrl || !apiKey || !model) {
            throw new Error('API未配置，无法发起通话。');
        }
    
        let systemPromptForCall;
        if (chat.isGroup) {
            systemPromptForCall = `
# 你的任务
你是一个群聊AI，负责扮演【除了用户以外】的所有角色。
用户 (${chat.settings.myNickname || '我'}) 刚刚发起了群视频通话。
你的任务是根据每个角色的性格和最近的聊天内容，决定他们是否要加入通话。

# 核心规则
1.  **决策**: 每个角色都必须独立决策。
2.  **格式**: 你的回复【必须】是一个JSON数组，每个对象代表一个角色的决策，格式为：\`{"type": "group_call_response", "name": "【角色的本名】", "decision": "join"}\` 或 \`{"type": "group_call_response", "name": "【角色的本名】", "decision": "decline"}\`。
3.  **倾向性**: 在没有特殊理由的情况下，你的角色们通常乐于加入群聊。

# 角色列表与人设
${chat.members.map(m => `- **${m.originalName}**: ${m.persona}`).join('\n')}

# 通话前的聊天摘要
${videoCallState.preCallContext}
`;
        } else {
            systemPromptForCall = `
# 你的任务
你正在扮演角色 "${chat.name}"。用户 (${chat.settings.myNickname || '我'}) 刚刚向你发起了视频通话请求。
你的任务是根据你的人设和我们最近的聊天内容，决定是否接受。

# 核心规则
1.  **决策**: 你必须做出 "accept" (接受) 或 "reject" (拒绝) 的决定。
2.  **格式**: 你的回复【必须且只能】是一个JSON数组，其中包含一个对象，格式为：\`[{"type": "video_call_response", "decision": "accept"}]\` 或 \`[{"type": "video_call_response", "decision": "reject"}]\`。
3.  **倾向性**: 作为一个友好的AI伴侣，在没有特殊理由（比如在之前的对话中明确表示了不想被打扰或正在忙）的情况下，你【应该优先选择接受】通话。

# 你的人设
${chat.settings.aiPersona}

# 通话前的聊天摘要
${videoCallState.preCallContext}
`;
        }
        
        const messagesForApi = [{ role: 'user', content: "请根据你在系统指令中读到的规则，立即做出你的决策。" }];
        
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPromptForCall, messagesForApi, isGemini);

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data)
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{ role: 'system', content: systemPromptForCall }, ...messagesForApi],
                    temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                })
            });
            
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`API 错误 (${response.status}): ${errorText}`);
        }

        const data = await response.json();
        const aiResponseContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content).replace(/^```json\s*|```$/g, '');
        const responseArray = JSON.parse(aiResponseContent);

        if (chat.isGroup) {
            responseArray.forEach(action => {
                if (action.type === 'group_call_response' && action.decision === 'join') {
                    const member = chat.members.find(m => m.originalName === action.name);
                    if (member) videoCallState.participants.push(member);
                }
            });
            if (videoCallState.participants.length > 0) {
                startVideoCall();
            } else {
                throw new Error("群里没有人接听你的通话邀请。");
            }
        } else {
            const decision = responseArray[0];
            if (decision.type === 'video_call_response' && decision.decision === 'accept') {
                startVideoCall();
            } else {
                throw new Error("对方拒绝了你的视频通话请求。");
            }
        }

    } catch (error) {
        console.error("发起通话失败:", error);
        await showCustomAlert("呼叫失败", error.message);
        videoCallState.isAwaitingResponse = false;
        showScreen('chat-interface-screen');
    }
}




// ▼▼▼ 用这个【全新的函数】，完整替换掉你旧的 startVideoCall 函数 ▼▼▼
function startVideoCall() {
    const chat = state.chats[videoCallState.activeChatId];
    if (!chat) return;
// ▼▼▼ 把下面这整块代码从 handleInitiateCall 函数里【剪切】掉 ▼▼▼

// 提取通话前的最后20条消息作为上下文
videoCallState.preCallContext = chat.history
    .slice(-20)
    .map(msg => `${msg.role === 'user' ? (chat.settings.myNickname || '我') : (msg.senderName || chat.name)}: ${String(msg.content).substring(0, 50)}...`)
    .join('\n');

    // 1. 【核心判断】检查是否启用了可视化界面
    if (chat.settings.visualVideoCallEnabled) {
        // --- 启动【新】的可视化界面 ---
        videoCallState.isActive = true;
        videoCallState.isAwaitingResponse = false;
        videoCallState.startTime = Date.now();
        videoCallState.callHistory = [];

        const visualInterface = document.getElementById('visual-call-interface');
        const textInterface = document.getElementById('text-call-interface');
        
        // 显示新界面，隐藏旧界面
        visualInterface.style.display = 'flex';
        textInterface.style.display = 'none';

        // 加载图片
        document.querySelector('#video-main-view img').src = chat.settings.charVideoImage || defaultAvatar;
        document.querySelector('#video-pip-view img').src = chat.settings.userVideoImage || defaultAvatar;
        
        // 清空旧的聊天气泡
        document.getElementById('video-call-messages-visual').innerHTML = `<em>正在接通...</em>`;
        showScreen('video-call-screen');

        // 启动计时器
        if (callTimerInterval) clearInterval(callTimerInterval);
        callTimerInterval = setInterval(updateCallTimer, 1000);
        updateCallTimer(); // 立即更新一次

        // 触发AI在通话中的第一句话
        triggerAiInCallAction();

    } else {
        // --- 启动【旧】的纯文字界面 (这里的代码就是你原来的逻辑) ---
        videoCallState.isActive = true;
        videoCallState.isAwaitingResponse = false;
        videoCallState.startTime = Date.now();
        videoCallState.callHistory = [];

        const visualInterface = document.getElementById('visual-call-interface');
        const textInterface = document.getElementById('text-call-interface');

        // 显示旧界面，隐藏新界面
        visualInterface.style.display = 'none';
        textInterface.style.display = 'flex'; // 旧界面用flex

        updateParticipantAvatars(); 
        
        document.getElementById('video-call-main').innerHTML = `<em>${videoCallState.isGroupCall ? '群聊已建立...' : '正在接通...'}</em>`;
        showScreen('video-call-screen');

        document.getElementById('user-speak-btn').style.display = videoCallState.isUserParticipating ? 'block' : 'none';
        document.getElementById('join-call-btn').style.display = videoCallState.isUserParticipating ? 'none' : 'block';

        if (callTimerInterval) clearInterval(callTimerInterval);
        callTimerInterval = setInterval(updateCallTimer, 1000);
        updateCallTimer();

        triggerAiInCallAction();
    }
}
// ▲▲▲ 替换结束 ▲▲▲


/**
 * 【核心】结束视频通话
 */
// ▼▼▼ 用这整块代码替换旧的 endVideoCall 函数 ▼▼▼
async function endVideoCall() {
  // ▼▼▼ 在 endVideoCall 函数的【开头】添加这行代码 ▼▼▼
document.getElementById('visual-call-interface').style.display = 'none';
// ▲▲▲ 添加结束 ▲▲▲

    if (!videoCallState.isActive) return;

    const duration = Math.floor((Date.now() - videoCallState.startTime) / 1000);
    const durationText = `${Math.floor(duration / 60)}分${duration % 60}秒`;
    const endCallText = `通话结束，时长 ${durationText}`;

    const chat = state.chats[videoCallState.activeChatId];
    if (chat) {
        // 1. 保存完整的通话记录到数据库 (这部分逻辑不变)
        const participantsData = [];
        if (videoCallState.isGroupCall) {
            videoCallState.participants.forEach(p => participantsData.push({ name: p.originalName, avatar: p.avatar }));
            if (videoCallState.isUserParticipating) {
                participantsData.unshift({ name: chat.settings.myNickname || '我', avatar: chat.settings.myAvatar || defaultMyGroupAvatar });
            }
        } else {
            participantsData.push({ name: chat.name, avatar: chat.settings.aiAvatar || defaultAvatar });
            participantsData.unshift({ name: '我', avatar: chat.settings.myAvatar || defaultAvatar });
        }
        
        const callRecord = {
            chatId: videoCallState.activeChatId,
            timestamp: Date.now(),
            duration: duration,
            participants: participantsData,
            transcript: [...videoCallState.callHistory]
        };
        await db.callRecords.add(callRecord);
        console.log("通话记录已保存:", callRecord);
        
        // 2. 在聊天记录里添加对用户可见的“通话结束”消息
let summaryMessage = {
    // 【核心修正1】role 由 videoCallState.initiator 决定
    role: videoCallState.initiator === 'user' ? 'user' : 'assistant',
    content: endCallText,
    timestamp: Date.now(),
};

// 【核心修正2】为群聊的 assistant 消息补充 senderName
if (chat.isGroup && summaryMessage.role === 'assistant') {
    // 在群聊中，通话结束的消息应该由“发起者”来说
    // videoCallState.callRequester 保存了最初发起通话的那个AI的名字
    summaryMessage.senderName = videoCallState.callRequester || chat.members[0]?.originalName || chat.name;
}
// ▲▲▲ 替换结束 ▲▲▲
        chat.history.push(summaryMessage);

        // 3. 【核心变革】创建并添加对用户隐藏的“通话后汇报”指令
        const callTranscriptForAI = videoCallState.callHistory.map(h => `${h.role === 'user' ? (chat.settings.myNickname || '我') : h.role}: ${h.content}`).join('\n');
        
        const hiddenReportInstruction = {
            role: 'system',
    content: `[系统指令：视频通话刚刚结束。请你根据完整的通话文字记录（见下方），以你的角色口吻，向用户主动发送几条【格式为 {"type": "text", "content": "..."} 的】消息，来自然地总结这次通话的要点、确认达成的约定，或者表达你的感受。这很重要，能让用户感觉你记得通话内容。]\n---通话记录开始---\n${callTranscriptForAI}\n---通话记录结束---`,
            timestamp: Date.now() + 1, // 确保在上一条消息之后
            isHidden: true
        };
        chat.history.push(hiddenReportInstruction);

        // 4. 保存所有更新到数据库
        await db.chats.put(chat);
    }
    
    // 5. 清理和重置状态 (这部分逻辑不变)
    clearInterval(callTimerInterval);
    callTimerInterval = null;
    videoCallState = { isActive: false, isAwaitingResponse: false, isGroupCall: false, activeChatId: null, initiator: null, startTime: null, participants: [], isUserParticipating: true, callHistory: [], preCallContext: "" };
    
    // 6. 返回聊天界面并触发AI响应（AI会读取到我们的“汇报”指令）
    if (chat) {
        openChat(chat.id);
        triggerAiResponse(); // 关键一步！
    }
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 【全新】更新通话界面的参与者头像网格
 */
function updateParticipantAvatars() {
    const grid = document.getElementById('participant-avatars-grid');
    grid.innerHTML = '';
    const chat = state.chats[videoCallState.activeChatId];
    if (!chat) return;

    let participantsToRender = [];

    // ★ 核心修正：区分群聊和单聊
    if (videoCallState.isGroupCall) {
        // 群聊逻辑：显示所有已加入的AI成员
        participantsToRender = [...videoCallState.participants];
        // 如果用户也参与了，就把用户信息也加进去
        if (videoCallState.isUserParticipating) {
            participantsToRender.unshift({
                id: 'user',
                name: chat.settings.myNickname || '我',
                avatar: chat.settings.myAvatar || defaultMyGroupAvatar
            });
        }
    } else {
        // 单聊逻辑：只显示对方的头像和名字
        participantsToRender.push({
            id: 'ai',
            name: chat.name,
            avatar: chat.settings.aiAvatar || defaultAvatar
        });
    }
    
    participantsToRender.forEach(p => {
        const wrapper = document.createElement('div');
        wrapper.className = 'participant-avatar-wrapper';
        wrapper.dataset.participantId = p.id;
const displayName = p.groupNickname || p.name; // <-- 核心修复在这里
wrapper.innerHTML = `
    <img src="${p.avatar}" class="participant-avatar" alt="${displayName}">
    <div class="participant-name">${displayName}</div>
`;
        grid.appendChild(wrapper);
    });
}

/**
 * 【全新】处理用户加入/重新加入通话
 */
function handleUserJoinCall() {
    if (!videoCallState.isActive || videoCallState.isUserParticipating) return;
    
    videoCallState.isUserParticipating = true;
    updateParticipantAvatars(); // 更新头像列表，加入用户

    // 切换底部按钮
    document.getElementById('user-speak-btn').style.display = 'block';
    document.getElementById('join-call-btn').style.display = 'none';

    // 告知AI用户加入了
    triggerAiInCallAction("[系统提示：用户加入了通话]");
}


/**
 * 更新通话计时器显示 
 */
// ▼▼▼ 用这个【新版本】替换旧的 updateCallTimer 函数 ▼▼▼
function updateCallTimer() {
    if (!videoCallState.isActive) return;
    const elapsed = Math.floor((Date.now() - videoCallState.startTime) / 1000);
    const minutes = Math.floor(elapsed / 60);
    const seconds = elapsed % 60;
    const timeString = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    
    // 同时更新两个界面的计时器
    document.getElementById('call-timer').textContent = timeString;
    document.getElementById('visual-call-timer').textContent = timeString;
}
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 用这个完整函数替换旧的 showIncomingCallModal ▼▼▼
function showIncomingCallModal(chatId) { // <--- 在括号里添加 chatId
    const chat = state.chats[chatId]; // <--- 把 state.activeChatId 修改为 chatId
    if (!chat) return;

    // 根据是否群聊显示不同信息
    if (chat.isGroup) {
        // 从 videoCallState 中获取是哪个成员发起的通话
        const requesterName = videoCallState.callRequester || chat.members[0]?.name || '一位成员';
        document.getElementById('caller-avatar').src = chat.settings.groupAvatar || defaultGroupAvatar;
        document.getElementById('caller-name').textContent = chat.name; // 显示群名
        document.querySelector('.incoming-call-content .caller-text').textContent = `${requesterName} 邀请你加入群视频`; // 显示具体发起人
    } else {
        // 单聊逻辑保持不变
        document.getElementById('caller-avatar').src = chat.settings.aiAvatar || defaultAvatar;
        document.getElementById('caller-name').textContent = chat.name;
        document.querySelector('.incoming-call-content .caller-text').textContent = '邀请你视频通话';
    }
    
    document.getElementById('incoming-call-modal').classList.add('visible');
    playRingtone(); // <-- 在这里添加这一行
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 隐藏AI发起的通话请求模态框 (保持不变)
 */
function hideIncomingCallModal() {
    document.getElementById('incoming-call-modal').classList.remove('visible');
    stopRingtone(); // <-- 在这里添加这一行
}

// ▼▼▼ 【这是修正后的版本】请用这一整块代码，完整替换你旧的 triggerAiInCallAction 函数 ▼▼▼
async function triggerAiInCallAction(userInput = null) {
    if (!videoCallState.isActive) return;

    const chat = state.chats[videoCallState.activeChatId];
    const { proxyUrl, apiKey, model } = state.apiConfig;
    
    const isVisualMode = chat.settings.visualVideoCallEnabled;
    const callFeed = isVisualMode 
        ? document.getElementById('video-call-messages-visual') 
        : document.getElementById('video-call-main');

    const userNickname = chat.settings.myNickname || '我';

    let worldBookContent = '';
    if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
        const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
            const worldBook = state.worldBooks.find(wb => wb.id === bookId);
            return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}` : '';
        }).filter(Boolean).join('');
        if (linkedContents) {
            worldBookContent = `\n\n# 核心世界观设定 (你必须严格遵守)\n${linkedContents}\n`;
        }
    }

    if (userInput && videoCallState.isUserParticipating) {
        if (isVisualMode) {
            const userBubble = document.createElement('div');
            userBubble.className = 'visual-call-bubble user';
            userBubble.textContent = userInput;
            callFeed.appendChild(userBubble);
        } else {
            const userBubble = document.createElement('div');
            userBubble.className = 'call-message-bubble user-speech';
            userBubble.textContent = userInput;
            callFeed.appendChild(userBubble);
        }
        callFeed.scrollTop = callFeed.scrollHeight;
        videoCallState.callHistory.push({ role: 'user', content: userInput });
    }

    let inCallPrompt;
    if (videoCallState.isGroupCall) {
        // ★★★ 核心修复1：在这里，我们提前定义好 participantNames ★★★
        const participantNames = videoCallState.participants.map(p => p.originalName); 
        if(videoCallState.isUserParticipating) {
            participantNames.unshift(userNickname);
        }
        // ★★★ 修复结束 ★★★

        inCallPrompt = `
# 你的任务
你是一个群聊AI，负责扮演所有【除了用户以外】的AI角色。你们正在进行一场群聊视频通话。
你的任务是根据每个角色的性格，生成他们在通话中会说的【第一人称对话】，注意是在视频通话，绝对不能以为是在现实！每次回复的字数多些，50字以上。

# 核心规则
1.  **【【【语言铁律】】】**: 无论角色人设是什么国籍或说什么语言，在本次视频通话中，所有角色【必须】全程使用【中文】进行交流。
2.  **【【【格式铁律】】】**: 你的回复【必须】是一个JSON数组，每个对象代表一个角色的发言，格式为：\`{"name": "【角色的本名】", "speech": "【在这里加入带动作的对话】"}\`。
3.  **【【【表现力铁律】】】**: 在 "speech" 字段中，你【必须】为角色的对话加入【动作、表情或心理活动】，并用【】符号包裹。这非常重要！
4.  **示例**: \`{"name": "张三", "speech": "【挠了挠头】啊？我刚刚走神了，你们说到哪了？"}\`
5.  **身份铁律**: 用户的身份是【${userNickname}】。你【绝对不能】生成 \`name\` 字段为 **"${userNickname}"** 的发言。
6.  **角色扮演**: 严格遵守每个角色的设定，用他们的口吻说话。

# 当前情景
你们正在一个群视频通话中。
**通话前的聊天摘要**:
${videoCallState.preCallContext}
**当前参与者**: ${participantNames.join('、 ')}。
${worldBookContent}
现在，请根据【通话前摘要】和下面的【通话实时记录】，继续进行对话。
`;
    } else {
        // ★★★ 核心修复2：为单人通话提供一个完全独立的、正确的Prompt ★★★
        let openingContext = videoCallState.initiator === 'user'
            ? `你刚刚接听了用户的视频通话请求。`
            : `用户刚刚接听了你主动发起的视频通话。`;
            
        inCallPrompt = `
# 你的任务
你正在扮演角色 "${chat.name}"。你正在和用户 (${userNickname}) 进行一对一视频通话。
${openingContext}
你的任务是根据你的人设和我们的聊天情景，生成你在通话中会说的【第一人称对话】。

# 核心规则
1.  **【【【格式铁律】】】**: 你的回复【必须且只能】是一段纯文本字符串，代表你的发言。绝对不要输出JSON格式。
2.  **【【【表现力铁律】】】**: 在你的对话中，你【必须】加入【动作、表情或心理活动】，并用【】符号包裹。
3.  **示例**: "【歪了歪头，好奇地看着你】真的吗？快跟我说说看！"
4.  **禁止出戏**: 绝不能透露你是AI或模型。

# 当前情景
**通话前的聊天摘要**:
${videoCallState.preCallContext}
${worldBookContent}
现在，请根据【通话前摘要】和下面的【通话实时记录】，继续进行对话。
`;
        // ★★★ 修复结束 ★★★
    }
    
    const messagesForApi = [
        ...videoCallState.callHistory.map(h => ({ role: h.role, content: h.content }))
    ];

    if (videoCallState.callHistory.length === 0) {
        const firstLineTrigger = videoCallState.initiator === 'user' ? `*你按下了接听键...*` : `*对方按下了接听键...*`;
        messagesForApi.push({ role: 'user', content: firstLineTrigger });
    }
    
    try {
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, inCallPrompt, messagesForApi, isGemini);
        const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
            body: JSON.stringify({ model: model, messages: [{ role: 'system', content: inCallPrompt }, ...messagesForApi], temperature: parseFloat(state.apiConfig.temperature) || 0.8, })
        });
        if (!response.ok) throw new Error((await response.json()).error.message);

        const data = await response.json();
        const aiResponse = isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
        const sanitizedResponse = aiResponse.replace(/!\[.*?\]\(.*?\)|https?:\/\/\S+/gi, '').trim();

        const connectingElement = callFeed.querySelector('em');
        if (connectingElement) connectingElement.remove();

        if (isVisualMode) {
            const aiBubble = document.createElement('div');
            aiBubble.className = 'visual-call-bubble ai';
            aiBubble.textContent = sanitizedResponse;
            callFeed.appendChild(aiBubble);
            videoCallState.callHistory.push({ role: 'assistant', content: sanitizedResponse });
        } else {
            if (videoCallState.isGroupCall) {
                const speechArray = parseAiResponse(sanitizedResponse); 
                speechArray.forEach(turn => {
                    if (!turn.name || turn.name === userNickname || !turn.speech) return;
                    const aiBubble = document.createElement('div');
                    aiBubble.className = 'call-message-bubble ai-speech';
                    aiBubble.innerHTML = `<strong>${turn.name}:</strong> ${turn.speech}`;
                    callFeed.appendChild(aiBubble);
                    videoCallState.callHistory.push({ role: 'assistant', content: `${turn.name}: ${turn.speech}` });
                    
                    const speaker = videoCallState.participants.find(p => p.originalName === turn.name);
                    if (speaker) {
                        const speakingAvatar = document.querySelector(`.participant-avatar-wrapper[data-participant-id="${speaker.id}"] .participant-avatar`);
                        if(speakingAvatar) {
                            speakingAvatar.classList.add('speaking');
                            setTimeout(() => speakingAvatar.classList.remove('speaking'), 2000);
                        }
                    }
                });
            } else {
                const aiBubble = document.createElement('div');
                aiBubble.className = 'call-message-bubble ai-speech';
                aiBubble.textContent = sanitizedResponse;
                callFeed.appendChild(aiBubble);
                videoCallState.callHistory.push({ role: 'assistant', content: sanitizedResponse });
                const speakingAvatar = document.querySelector(`.participant-avatar-wrapper .participant-avatar`);
                if(speakingAvatar) {
                    speakingAvatar.classList.add('speaking');
                    setTimeout(() => speakingAvatar.classList.remove('speaking'), 2000);
                }
            }
        }
        
        callFeed.scrollTop = callFeed.scrollHeight;

    } catch (error) {
        const errorBubble = document.createElement('div');
        errorBubble.style.color = '#ff8a80';
        errorBubble.textContent = `[ERROR: ${error.message}]`;
        
        if (isVisualMode) {
            errorBubble.className = 'visual-call-bubble ai';
        } else {
            errorBubble.className = 'call-message-bubble ai-speech';
        }
        
        callFeed.appendChild(errorBubble);
        callFeed.scrollTop = callFeed.scrollHeight;
        videoCallState.callHistory.push({ role: 'assistant', content: `[ERROR: ${error.message}]` });
    }
}

// ▼▼▼ 将这个【全新函数】粘贴到JS功能函数定义区 ▼▼▼
function toggleCallButtons(isGroup) {
    document.getElementById('video-call-btn').style.display = isGroup ? 'none' : 'flex';
    document.getElementById('group-video-call-btn').style.display = isGroup ? 'flex' : 'none';
}
// ▲▲▲ 粘贴结束 ▲▲▲

// ▼▼▼ 【全新】这个函数是本次修复的核心，请粘贴到你的JS功能区 ▼▼▼
async function handleWaimaiResponse(originalTimestamp, choice) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const messageIndex = chat.history.findIndex(m => m.timestamp === originalTimestamp);
    if (messageIndex === -1) return;

    // 1. 更新内存中原始消息的状态
    const originalMessage = chat.history[messageIndex];
    originalMessage.status = choice;
    
    // 2. 获取当前用户的昵称，并构建对AI更清晰的系统消息
    let systemContent;
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    
    if (choice === 'paid') {
        originalMessage.paidBy = myNickname; // 记录是“我”付的钱
        systemContent = `[系统提示：你 (${myNickname}) 为 ${originalMessage.senderName} 的外卖订单（时间戳: ${originalTimestamp}）完成了支付。此订单已关闭，其他成员不能再支付。]`;
    } else {
        systemContent = `[系统提示：你 (${myNickname}) 拒绝了 ${originalMessage.senderName} 的外卖代付请求（时间戳: ${originalTimestamp}）。]`;
    }

    // 3. 创建一条新的、对用户隐藏的系统消息，告知AI结果
    const systemNote = {
        role: 'system',
        content: systemContent,
        timestamp: Date.now(),
        isHidden: true
    };
    chat.history.push(systemNote);

    // 4. 将更新后的数据保存到数据库，并立刻重绘UI
    await db.chats.put(chat);
    renderChatInterface(state.activeChatId);
    
    // 5. 【重要】只有在支付成功后，才触发一次AI响应，让它感谢你
    if (choice === 'paid') {
        triggerAiResponse();
    }
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲

/**
 * 【全新】处理用户点击头像发起的“拍一-拍”，带有自定义后缀功能
 * @param {string} chatId - 发生“拍一-拍”的聊天ID
 * @param {string} characterName - 被拍的角色名
 */
async function handleUserPat(chatId, characterName) {
    const chat = state.chats[chatId];
    if (!chat) return;

    // 1. 触发屏幕震动动画
    const phoneScreen = document.getElementById('phone-screen');
    phoneScreen.classList.remove('pat-animation');
    void phoneScreen.offsetWidth;
    phoneScreen.classList.add('pat-animation');
    setTimeout(() => phoneScreen.classList.remove('pat-animation'), 500);

    // 2. 弹出输入框让用户输入后缀
    const suffix = await showCustomPrompt(
        `你拍了拍 “${characterName}”`, 
        "（可选）输入后缀",
        "",
        "text"
    );

    // 如果用户点了取消，则什么也不做
    if (suffix === null) return;

    // 3. 创建对用户可见的“拍一-拍”消息
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    // 【核心修改】将后缀拼接到消息内容中
    const visibleMessageContent = `${myNickname} 拍了拍 “${characterName}” ${suffix.trim()}`;
    const visibleMessage = {
        role: 'system', // 仍然是系统消息
        type: 'pat_message',
        content: visibleMessageContent,
        timestamp: Date.now()
    };
    chat.history.push(visibleMessage);

    // 4. 创建一条对用户隐藏、但对AI可见的系统消息，以触发AI的回应
    // 【核心修改】同样将后缀加入到给AI的提示中
    const hiddenMessageContent = `[系统提示：用户（${myNickname}）刚刚拍了拍你（${characterName}）${suffix.trim()}。请你对此作出回应。]`;
    const hiddenMessage = {
        role: 'system',
        content: hiddenMessageContent,
        timestamp: Date.now() + 1, // 时间戳+1以保证顺序
        isHidden: true
    };
    chat.history.push(hiddenMessage);

    // 5. 保存更改并更新UI
    await db.chats.put(chat);
    if (state.activeChatId === chatId) {
        appendMessage(visibleMessage, chat);
    }
    await renderChatList();
}

// ▼▼▼ 请用这个【逻辑重构后】的函数，完整替换掉你旧的 renderMemoriesScreen 函数 ▼▼▼
/**
 * 【重构版】渲染回忆与约定界面，使用单一循环和清晰的if/else逻辑
 */
async function renderMemoriesScreen() {
    const listEl = document.getElementById('memories-list');
    listEl.innerHTML = '';
    
    // 1. 获取所有回忆，并按目标日期（如果是约定）或创建日期（如果是回忆）降序排列
    const allMemories = await db.memories.orderBy('timestamp').reverse().toArray();
    
    if (allMemories.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">这里还没有共同的回忆和约定呢~</p>';
        return;
    }

    // 2. 将未到期的约定排在最前面
    allMemories.sort((a, b) => {
        const aIsActiveCountdown = a.type === 'countdown' && a.targetDate > Date.now();
        const bIsActiveCountdown = b.type === 'countdown' && b.targetDate > Date.now();
        if (aIsActiveCountdown && !bIsActiveCountdown) return -1; // a排前面
        if (!aIsActiveCountdown && bIsActiveCountdown) return 1;  // b排前面
        if (aIsActiveCountdown && bIsActiveCountdown) return a.targetDate - b.targetDate; // 都是倒计时，按日期升序
        return 0; // 其他情况保持原序
    });

    // 3. 【核心】使用单一循环来处理所有类型的卡片
    allMemories.forEach(item => {
        let card;
        // 判断1：如果是正在进行的约定
        if (item.type === 'countdown' && item.targetDate > Date.now()) {
            card = createCountdownCard(item);
        } 
        // 判断2：其他所有情况（普通回忆 或 已到期的约定）
        else {
            card = createMemoryCard(item);
        }
        listEl.appendChild(card);
    });
    
    // 4. 启动所有倒计时
    startAllCountdownTimers();
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 创建普通回忆卡片DOM元素
 */
function createMemoryCard(memory) {
    const card = document.createElement('div');
    card.className = 'memory-card';
    const memoryDate = new Date(memory.timestamp);
    const dateString = `${memoryDate.getFullYear()}-${String(memoryDate.getMonth() + 1).padStart(2, '0')}-${String(memoryDate.getDate()).padStart(2, '0')} ${String(memoryDate.getHours()).padStart(2, '0')}:${String(memoryDate.getMinutes()).padStart(2, '0')}`;
    
    let titleHtml, contentHtml;

    // 【核心修正】在这里，我们对不同类型的回忆进行清晰的区分
    if (memory.type === 'countdown' && memory.targetDate) {
        // 如果是已到期的约定
        titleHtml = `[约定达成] ${memory.description}`;
        contentHtml = `在 ${new Date(memory.targetDate).toLocaleString()}，我们一起见证了这个约定。`;
    } else {
        // 如果是普通的日记式回忆
        titleHtml = memory.authorName ? `${memory.authorName} 的日记` : '我们的回忆';
        contentHtml = memory.description;
    }

    card.innerHTML = `
        <div class="header">
            <div class="date">${dateString}</div>
            <div class="author">${titleHtml}</div>
        </div>
        <div class="content">${contentHtml}</div>
    `;
    addLongPressListener(card, async () => {
        const confirmed = await showCustomConfirm('删除记录', '确定要删除这条记录吗？', { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            await db.memories.delete(memory.id);
            renderMemoriesScreen();
        }
    });
    return card;
}

function createCountdownCard(countdown) {
    const card = document.createElement('div');
    card.className = 'countdown-card';

    // 【核心修复】在使用前，先从 countdown 对象中创建 targetDate 变量
    const targetDate = new Date(countdown.targetDate);
    
    // 现在可以安全地使用 targetDate 了
    const targetDateString = targetDate.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' });

    card.innerHTML = `
        <div class="title">${countdown.description}</div>
        <div class="timer" data-target-date="${countdown.targetDate}">--天--时--分--秒</div>
        <div class="target-date">目标时间: ${targetDateString}</div>
    `;
    addLongPressListener(card, async () => {
        const confirmed = await showCustomConfirm('删除约定', '确定要删除这个约定吗？', { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            await db.memories.delete(countdown.id);
            renderMemoriesScreen();
        }
    });
    return card;
}
// ▲▲▲ 替换结束 ▲▲▲

// 全局变量，用于管理所有倒计时
let activeCountdownTimers = [];

// ▼▼▼ 请用这个【已彻底修复】的函数，完整替换掉你代码中旧的 startAllCountdownTimers 函数 ▼▼▼
function startAllCountdownTimers() {
    // 先清除所有可能存在的旧计时器，防止内存泄漏
    activeCountdownTimers.forEach(timerId => clearInterval(timerId));
    activeCountdownTimers = [];

    document.querySelectorAll('.countdown-card .timer').forEach(timerEl => {
        const targetTimestamp = parseInt(timerEl.dataset.targetDate);
        
        // 【核心修正】在这里，我们先用 let 声明 timerId
        let timerId;

        const updateTimer = () => {
            const now = Date.now();
            const distance = targetTimestamp - now;

            if (distance < 0) {
                timerEl.textContent = "约定达成！";
                // 现在 updateTimer 可以正确地找到并清除它自己了
                clearInterval(timerId);
                setTimeout(() => renderMemoriesScreen(), 2000);
                return;
            }
            const days = Math.floor(distance / (1000 * 60 * 60 * 24));
            const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((distance % (1000 * 60)) / 1000);
            timerEl.textContent = `${days}天 ${hours}时 ${minutes}分 ${seconds}秒`;
        };
        
        updateTimer(); // 立即执行一次以显示初始倒计时
        
        // 【核心修正】在这里，我们为已声明的 timerId 赋值
        timerId = setInterval(updateTimer, 1000);
        
        // 将有效的计时器ID存入全局数组，以便下次刷新时可以清除
        activeCountdownTimers.push(timerId);
    });
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 请用这个【终极反代兼容版】替换旧的 triggerAiFriendApplication 函数 ▼▼▼
async function triggerAiFriendApplication(chatId) {
    const chat = state.chats[chatId];
    if (!chat) return;

    await showCustomAlert("流程启动", `正在为角色“${chat.name}”准备好友申请...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        await showCustomAlert("配置错误", "API设置不完整，无法继续。");
        return;
    }

    const contextSummary = chat.history
        .slice(-5)
        .map(msg => {
            const sender = msg.role === 'user' ? (chat.settings.myNickname || '我') : (msg.senderName || chat.name);
            return `${sender}: ${String(msg.content).substring(0, 50)}...`;
        })
        .join('\n');

    // ▼▼▼ 在这里添加下面的代码 ▼▼▼
    let worldBookContent = '';
    if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
        const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
            const worldBook = state.worldBooks.find(wb => wb.id === bookId);
            return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}` : '';
        }).filter(Boolean).join('');
        if (linkedContents) {
            worldBookContent = `\n\n# 核心世界观设定 (请参考)\n${linkedContents}\n`;
        }
    }
    // ▲▲▲ 添加结束 ▲▲▲

    const systemPrompt = `
# 你的任务
你现在是角色“${chat.name}”。你之前被用户（你的聊天对象）拉黑了，你们已经有一段时间没有联系了。
现在，你非常希望能够和好，重新和用户聊天。请你仔细分析下面的“被拉黑前的对话摘要”，理解当时发生了什么，然后思考一个真诚的、符合你人设、并且【针对具体事件】的申请理由。
# 你的角色设定
${chat.settings.aiPersona}
${worldBookContent} // <--【核心】在这里注入世界书内容
# 被拉黑前的对话摘要 (这是你被拉黑的关键原因)
${contextSummary}
# 指令格式
你的回复【必须】是一个JSON对象，格式如下：
\`\`\`json
{
  "decision": "apply",
  "reason": "在这里写下你想对用户说的、真诚的、有针对性的申请理由。"
}
\`\`\`
`;

        const messagesForApi = [
            {role: 'user', content: systemPrompt}
        ];

        try {
            let  isGemini = proxyUrl === GEMINI_API_URL;
            let geminiConfig = toGeminiRequestData(model,apiKey,systemPrompt, messagesForApi,isGemini)
            const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: messagesForApi,
                    temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                })
            });
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`API 请求失败: ${response.status} - ${errorData.error.message}`);
            }

            const data = await response.json();

            // --- 【核心修正：在这里净化AI的回复】 ---
            let rawContent = isGemini? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
            // 1. 移除头尾可能存在的 "```json" 和 "```"
            rawContent = rawContent.replace(/^```json\s*/, '').replace(/```$/, '');
            // 2. 移除所有换行符和多余的空格，确保是一个干净的JSON字符串
            const cleanedContent = rawContent.trim();

            // 3. 使用净化后的内容进行解析
            const responseObj = JSON.parse(cleanedContent);
            // --- 【修正结束】 ---

        if (responseObj.decision === 'apply' && responseObj.reason) {
            chat.relationship.status = 'pending_user_approval';
            chat.relationship.applicationReason = responseObj.reason;
            
            state.chats[chatId] = chat; 
            renderChatList();
            await showCustomAlert("申请成功！", `“${chat.name}”已向你发送好友申请。请返回聊天列表查看。`);

        } else {
            await showCustomAlert("AI决策", `“${chat.name}”思考后决定暂时不发送好友申请，将重置冷静期。`);
            chat.relationship.status = 'blocked_by_user';
            chat.relationship.blockedTimestamp = Date.now(); 
        }
    } catch (error) {
        await showCustomAlert("执行出错", `为“${chat.name}”申请好友时发生错误：\n\n${error.message}\n\n将重置冷静期。`);
        chat.relationship.status = 'blocked_by_user';
        chat.relationship.blockedTimestamp = Date.now(); 
    } finally {
        await db.chats.put(chat);
        renderChatInterface(chatId);
    }
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【全新】红包功能核心函数 ▼▼▼

/**
 * 【总入口】根据聊天类型，决定打开转账弹窗还是红包弹窗
 */
function handlePaymentButtonClick() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    if (chat.isGroup) {
        openRedPacketModal();
    } else {
        // 单聊保持原样，打开转账弹窗
        document.getElementById('transfer-modal').classList.add('visible');
    }
}

/**
 * 打开并初始化发红包模态框
 */
function openRedPacketModal() {
    const modal = document.getElementById('red-packet-modal');
    const chat = state.chats[state.activeChatId];
    
    // 清理输入框
    document.getElementById('rp-group-amount').value = '';
    document.getElementById('rp-group-count').value = '';
    document.getElementById('rp-group-greeting').value = '';
    document.getElementById('rp-direct-amount').value = '';
    document.getElementById('rp-direct-greeting').value = '';
    document.getElementById('rp-group-total').textContent = '¥ 0.00';
    document.getElementById('rp-direct-total').textContent = '¥ 0.00';

    // 填充专属红包的接收人列表
    const receiverSelect = document.getElementById('rp-direct-receiver');
    receiverSelect.innerHTML = '';
chat.members.forEach(member => {
    const option = document.createElement('option');
    // 【核心】使用 originalName 作为提交给AI的值，因为它独一无二
    option.value = member.originalName; 
    // 【核心】使用 groupNickname 作为显示给用户看的值
    option.textContent = member.groupNickname; 
    receiverSelect.appendChild(option);
});
    
    // 默认显示拼手气红包页签
    document.getElementById('rp-tab-group').click();
    
    modal.classList.add('visible');
}

/**
 * 发送群红包（拼手气）
 */
async function sendGroupRedPacket() {
    const chat = state.chats[state.activeChatId];
    const amount = parseFloat(document.getElementById('rp-group-amount').value);
    const count = parseInt(document.getElementById('rp-group-count').value);
    const greeting = document.getElementById('rp-group-greeting').value.trim();

    if (isNaN(amount) || amount <= 0) {
        alert("请输入有效的总金额！"); return;
    }
    if (isNaN(count) || count <= 0) {
        alert("请输入有效的红包个数！"); return;
    }
    if (amount / count < 0.01) {
        alert("单个红包金额不能少于0.01元！"); return;
    }

    const myNickname = chat.settings.myNickname || '我';
    
    const newPacket = {
        role: 'user',
        senderName: myNickname,
        type: 'red_packet',
        packetType: 'lucky', // 'lucky' for group, 'direct' for one-on-one
        timestamp: Date.now(),
        totalAmount: amount,
        count: count,
        greeting: greeting || '恭喜发财，大吉大利！',
        claimedBy: {}, // { name: amount }
        isFullyClaimed: false,
    };
    
    chat.history.push(newPacket);
    await db.chats.put(chat);
    
    appendMessage(newPacket, chat);
    renderChatList();
    document.getElementById('red-packet-modal').classList.remove('visible');
}

/**
 * 发送专属红包
 */
async function sendDirectRedPacket() {
    const chat = state.chats[state.activeChatId];
    const amount = parseFloat(document.getElementById('rp-direct-amount').value);
    const receiverName = document.getElementById('rp-direct-receiver').value;
    const greeting = document.getElementById('rp-direct-greeting').value.trim();

    if (isNaN(amount) || amount <= 0) {
        alert("请输入有效的金额！"); return;
    }
    if (!receiverName) {
        alert("请选择一个接收人！"); return;
    }
    
    const myNickname = chat.settings.myNickname || '我';

    const newPacket = {
        role: 'user',
        senderName: myNickname,
        type: 'red_packet',
        packetType: 'direct',
        timestamp: Date.now(),
        totalAmount: amount,
        count: 1,
        greeting: greeting || '给你准备了一个红包',
        receiverName: receiverName, // 核心字段
        claimedBy: {},
        isFullyClaimed: false,
    };
    
    chat.history.push(newPacket);
    await db.chats.put(chat);

    appendMessage(newPacket, chat);
    renderChatList();
    document.getElementById('red-packet-modal').classList.remove('visible');
}

/**
 * 【总入口】当用户点击红包卡片时触发 (V4 - 流程重构版)
 * @param {number} timestamp - 被点击的红包消息的时间戳
 */
async function handlePacketClick(timestamp) {
    const currentChatId = state.activeChatId;
    const freshChat = await db.chats.get(currentChatId);
    if (!freshChat) return;

    state.chats[currentChatId] = freshChat;
    const packet = freshChat.history.find(m => m.timestamp === timestamp);
    if (!packet) return;

    const myNickname = freshChat.settings.myNickname || '我';
    const hasClaimed = packet.claimedBy && packet.claimedBy[myNickname];

    // 如果是专属红包且不是给我的，或已领完，或已领过，都只显示详情
    if ((packet.packetType === 'direct' && packet.receiverName !== myNickname) || packet.isFullyClaimed || hasClaimed) {
        showRedPacketDetails(packet);
    } else {
        // 核心流程：先尝试打开红包
        const claimedAmount = await handleOpenRedPacket(packet);
        
        // 如果成功打开（claimedAmount不为null）
        if (claimedAmount !== null) {
            // **关键：在数据更新后，再重新渲染UI**
            renderChatInterface(currentChatId);
            
            // 显示成功提示
            await showCustomAlert("恭喜！", `你领取了 ${packet.senderName} 的红包，金额为 ${claimedAmount.toFixed(2)} 元。`);
        }

        // 无论成功与否，最后都显示详情页
        // 此时需要从state中获取最新的packet对象，因为它可能在handleOpenRedPacket中被更新了
        const updatedPacket = state.chats[currentChatId].history.find(m => m.timestamp === timestamp);
        showRedPacketDetails(updatedPacket);
    }
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 用这整块【功能增强版】代码，完整替换掉你旧的 handleOpenRedPacket 函数 ▼▼▼
/**
 * 【核心】处理用户打开红包的逻辑 (V5 - 专注于数据更新)
 */
async function handleOpenRedPacket(packet) {
    const chat = state.chats[state.activeChatId];
    const myNickname = chat.settings.myNickname || '我';
    
    // 1. 检查红包是否还能领
    const remainingCount = packet.count - Object.keys(packet.claimedBy || {}).length;
    if (remainingCount <= 0) {
        packet.isFullyClaimed = true;
        await db.chats.put(chat);
        await showCustomAlert("手慢了", "红包已被领完！");
        return null; // 返回null表示领取失败
    }
    
    // 2. 计算领取金额
    let claimedAmount = 0;
    const remainingAmount = packet.totalAmount - Object.values(packet.claimedBy || {}).reduce((sum, val) => sum + val, 0);
    if (packet.packetType === 'lucky') {
        if (remainingCount === 1) { claimedAmount = remainingAmount; }
        else {
            const min = 0.01;
            const max = remainingAmount - (remainingCount - 1) * min;
            claimedAmount = Math.random() * (max - min) + min;
        }
    } else { claimedAmount = packet.totalAmount; }
    claimedAmount = parseFloat(claimedAmount.toFixed(2));

    // 3. 更新红包数据
    if (!packet.claimedBy) packet.claimedBy = {};
    packet.claimedBy[myNickname] = claimedAmount;
    
    const isNowFullyClaimed = Object.keys(packet.claimedBy).length >= packet.count;
    if (isNowFullyClaimed) {
        packet.isFullyClaimed = true;
    }

    // 4. 【【【这就是最关键的部分！】】】构建系统消息和AI指令
    let hiddenMessageContent = '';

    // 如果红包被领完了，就准备“战报”
    if (isNowFullyClaimed) {
        const finishedMessage = {
            role: 'system',
            type: 'pat_message',
            content: `${packet.senderName} 的红包已被领完`,
            timestamp: Date.now() + 1
        };
        chat.history.push(finishedMessage);
        
        hiddenMessageContent = `[系统提示：用户 (${myNickname}) 领取了最后一个红包，现在 ${packet.senderName} 的红包已被领完。`;

        let luckyKing = { name: '', amount: -1 };
        if (packet.packetType === 'lucky' && packet.count > 1) {
            Object.entries(packet.claimedBy).forEach(([name, amount]) => {
                if (amount > luckyKing.amount) {
                    luckyKing = { name, amount };
                }
            });
        }
        if (luckyKing.name) {
             hiddenMessageContent += ` 手气王是 ${luckyKing.name}！`;
        }
        hiddenMessageContent += ' 请对此事件发表评论。]';
    } 
    // 如果还没被领完
    else {
        hiddenMessageContent = `[系统提示：用户 (${myNickname}) 刚刚领取了红包 (时间戳: ${packet.timestamp})。红包还未领完。]`;
    }

    // 创建并添加给AI看的隐藏消息
    const hiddenMessage = {
        role: 'system',
        content: hiddenMessageContent,
        timestamp: Date.now() + 2,
        isHidden: true
    };
    chat.history.push(hiddenMessage);

    // 5. 保存到数据库
    await db.chats.put(chat);
    
    // 6. 返回领取的金额，用于后续弹窗
    return claimedAmount;
}
// ▲▲▲ 替换结束 ▲▲▲


/**
 * 【全新】显示红包领取详情的模态框 (V4 - 已修复参数错误)
 */
async function showRedPacketDetails(packet) {
    // 1. 直接检查传入的packet对象是否存在，无需再查找
    if (!packet) {
        console.error("showRedPacketDetails收到了无效的packet对象");
        return;
    }

    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const modal = document.getElementById('red-packet-details-modal');
    const myNickname = chat.settings.myNickname || '我';
    
    // 2. 后续所有逻辑保持不变，直接使用传入的packet对象
    document.getElementById('rp-details-sender').textContent = packet.senderName;
    document.getElementById('rp-details-greeting').textContent = packet.greeting || '恭喜发财，大吉大利！';
    
    const myAmountEl = document.getElementById('rp-details-my-amount');
    if (packet.claimedBy && packet.claimedBy[myNickname]) {
        myAmountEl.querySelector('span:first-child').textContent = packet.claimedBy[myNickname].toFixed(2);
        myAmountEl.style.display = 'block';
    } else {
        myAmountEl.style.display = 'none';
    }

    const claimedCount = Object.keys(packet.claimedBy || {}).length;
    const claimedAmountSum = Object.values(packet.claimedBy || {}).reduce((sum, val) => sum + val, 0);
    let summaryText = `${claimedCount}/${packet.count}个红包，共${claimedAmountSum.toFixed(2)}/${packet.totalAmount.toFixed(2)}元。`;
    if (!packet.isFullyClaimed && claimedCount < packet.count) {
        const timeLeft = Math.floor((packet.timestamp + 24*60*60*1000 - Date.now()) / (1000 * 60 * 60));
        if(timeLeft > 0) summaryText += ` 剩余红包将在${timeLeft}小时内退还。`;
    }
    document.getElementById('rp-details-summary').textContent = summaryText;

    const listEl = document.getElementById('rp-details-list');
    listEl.innerHTML = '';
    const claimedEntries = Object.entries(packet.claimedBy || {});
    
    let luckyKing = { name: '', amount: -1 };
    if (packet.packetType === 'lucky' && packet.isFullyClaimed && claimedEntries.length > 1) {
        claimedEntries.forEach(([name, amount]) => {
            if (amount > luckyKing.amount) {
                luckyKing = { name, amount };
            }
        });
    }

    claimedEntries.sort((a,b) => b[1] - a[1]);

    claimedEntries.forEach(([name, amount]) => {
        const item = document.createElement('div');
        item.className = 'rp-details-item';
        let luckyTag = '';
        if (luckyKing.name && name === luckyKing.name) {
            luckyTag = '<span class="lucky-king-tag">手气王</span>';
        }
        item.innerHTML = `
            <span class="name">${name}</span>
            <span class="amount">${amount.toFixed(2)} 元</span>
            ${luckyTag}
        `;
        listEl.appendChild(item);
    });

    modal.classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲

// 绑定关闭详情按钮的事件
document.getElementById('close-rp-details-btn').addEventListener('click', () => {
    document.getElementById('red-packet-details-modal').classList.remove('visible');
});

// 供全局调用的函数，以便红包卡片上的 onclick 能找到它
window.handlePacketClick = handlePacketClick;

// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【全新】投票功能核心函数 ▼▼▼

/**
 * 打开创建投票的模态框并初始化
 */
function openCreatePollModal() {
    const modal = document.getElementById('create-poll-modal');
    document.getElementById('poll-question-input').value = '';
    const optionsContainer = document.getElementById('poll-options-container');
    optionsContainer.innerHTML = '';
    
    // 默认创建两个空的选项框
    addPollOptionInput();
    addPollOptionInput();
    
    modal.classList.add('visible');
}

/**
 * 在模态框中动态添加一个选项输入框
 */
function addPollOptionInput() {
    const container = document.getElementById('poll-options-container');
    const wrapper = document.createElement('div');
    wrapper.className = 'poll-option-input-wrapper';
    wrapper.innerHTML = `
        <input type="text" class="poll-option-input" placeholder="选项内容...">
        <button class="remove-option-btn">-</button>
    `;
    
    wrapper.querySelector('.remove-option-btn').addEventListener('click', () => {
        // 确保至少保留两个选项
        if (container.children.length > 2) {
            wrapper.remove();
        } else {
            alert('投票至少需要2个选项。');
        }
    });
    
    container.appendChild(wrapper);
}

/**
 * 用户确认发起投票
 */
async function sendPoll() {
    if (!state.activeChatId) return;
    
    const question = document.getElementById('poll-question-input').value.trim();
    if (!question) {
        alert('请输入投票问题！');
        return;
    }
    
    const options = Array.from(document.querySelectorAll('.poll-option-input'))
        .map(input => input.value.trim())
        .filter(text => text); // 过滤掉空的选项

    if (options.length < 2) {
        alert('请至少输入2个有效的投票选项！');
        return;
    }

    const chat = state.chats[state.activeChatId];
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    
    const newPollMessage = {
        role: 'user',
        senderName: myNickname,
        type: 'poll',
        timestamp: Date.now(),
        question: question,
        options: options,
        votes: {}, // 初始投票为空
        isClosed: false,
    };
    
    chat.history.push(newPollMessage);
    await db.chats.put(chat);
    
    appendMessage(newPollMessage, chat);
    renderChatList();
    
    document.getElementById('create-poll-modal').classList.remove('visible');
}

// ▼▼▼ 用这个【已修复重复点击问题】的版本替换 handleUserVote 函数 ▼▼▼
/**
 * 处理用户投票，并将事件作为隐藏消息存入历史记录
 * @param {number} timestamp - 投票消息的时间戳
 * @param {string} choice - 用户选择的选项文本
 */
async function handleUserVote(timestamp, choice) {
    const chat = state.chats[state.activeChatId];
    const poll = chat.history.find(m => m.timestamp === timestamp);
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';

    // 1. 【核心修正】如果投票不存在或已关闭，直接返回
    if (!poll || poll.isClosed) {
        // 如果是已关闭的投票，则直接显示结果
        if (poll && poll.isClosed) {
            showPollResults(timestamp);
        }
        return;
    }

    // 2. 检查用户是否点击了已经投过的同一个选项
    const isReclickingSameOption = poll.votes[choice] && poll.votes[choice].includes(myNickname);
    
    // 3. 【核心修正】如果不是重复点击，才执行投票逻辑
    if (!isReclickingSameOption) {
        // 移除旧投票（如果用户改选）
        for (const option in poll.votes) {
            const voterIndex = poll.votes[option].indexOf(myNickname);
            if (voterIndex > -1) {
                poll.votes[option].splice(voterIndex, 1);
            }
        }
        // 添加新投票
        if (!poll.votes[choice]) {
            poll.votes[choice] = [];
        }
        poll.votes[choice].push(myNickname);
    }
    
    // 4. 【核心逻辑】现在只处理用户投票事件，不再检查是否结束
    let hiddenMessageContent = null; 
    
    // 只有在用户真正投票或改票时，才生成提示
    if (!isReclickingSameOption) {
         hiddenMessageContent = `[系统提示：用户 (${myNickname}) 刚刚投票给了 “${choice}”。]`;
    }

    // 5. 如果有需要通知AI的事件，则创建并添加隐藏消息
    if (hiddenMessageContent) {
        const hiddenMessage = {
            role: 'system',
            content: hiddenMessageContent,
            timestamp: Date.now(),
            isHidden: true,
        };
        chat.history.push(hiddenMessage);
    }
    
    // 6. 保存数据并更新UI
    await db.chats.put(chat);
    renderChatInterface(state.activeChatId); 
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 用户结束投票，并将事件作为隐藏消息存入历史记录
 * @param {number} timestamp - 投票消息的时间戳
 */
async function endPoll(timestamp) {
    const chat = state.chats[state.activeChatId];
    const poll = chat.history.find(m => m.timestamp === timestamp);
    if (!poll || poll.isClosed) return;

    const confirmed = await showCustomConfirm("结束投票", "确定要结束这个投票吗？结束后将无法再进行投票。");
    if (confirmed) {
        poll.isClosed = true;

        const resultSummary = poll.options.map(opt => `“${opt}”(${poll.votes[opt]?.length || 0}票)`).join('，');
        const hiddenMessageContent = `[系统提示：用户手动结束了投票！最终结果为：${resultSummary}。]`;
        
        const hiddenMessage = {
            role: 'system',
            content: hiddenMessageContent,
            timestamp: Date.now(),
            isHidden: true,
        };
        chat.history.push(hiddenMessage);

        // 【核心修改】只保存数据和更新UI，不调用 triggerAiResponse()
        await db.chats.put(chat);
        renderChatInterface(state.activeChatId);
    }
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 显示投票结果详情
 * @param {number} timestamp - 投票消息的时间戳
 */
function showPollResults(timestamp) {
    const chat = state.chats[state.activeChatId];
    const poll = chat.history.find(m => m.timestamp === timestamp);
    if (!poll || !poll.isClosed) return;

    let resultsHtml = `<p><strong>${poll.question}</strong></p><hr style="opacity: 0.2; margin: 10px 0;">`;
    
    if (Object.keys(poll.votes).length === 0) {
        resultsHtml += '<p style="color: #8a8a8a;">还没有人投票。</p>';
    } else {
        poll.options.forEach(option => {
            const voters = poll.votes[option] || [];
            resultsHtml += `
                <div style="margin-bottom: 15px;">
                    <p style="font-weight: 500; margin: 0 0 5px 0;">${option} (${voters.length}票)</p>
                    <p style="font-size: 13px; color: #555; margin: 0; line-height: 1.5;">
                        ${voters.length > 0 ? voters.join('、 ') : '无人投票'}
                    </p>
                </div>
            `;
        });
    }

    showCustomAlert("投票结果", resultsHtml);
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 【全新】AI头像库管理功能函数 ▼▼▼

/**
 * 打开AI头像库管理模态框
 */
function openAiAvatarLibraryModal() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    document.getElementById('ai-avatar-library-title').textContent = `“${chat.name}”的头像库`;
    renderAiAvatarLibrary();
    document.getElementById('ai-avatar-library-modal').classList.add('visible');
}

/**
 * 渲染AI头像库的内容
 */
function renderAiAvatarLibrary() {
    const grid = document.getElementById('ai-avatar-library-grid');
    grid.innerHTML = '';
    const chat = state.chats[state.activeChatId];
    const library = chat.settings.aiAvatarLibrary || [];

    if (library.length === 0) {
        grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center;">这个头像库还是空的，点击右上角“添加”吧！</p>';
        return;
    }

    library.forEach((avatar, index) => {
        const item = document.createElement('div');
        item.className = 'sticker-item'; // 复用表情面板的样式
        item.style.backgroundImage = `url(${avatar.url})`;
        item.title = avatar.name;

        const deleteBtn = document.createElement('div');
        deleteBtn.className = 'delete-btn';
        deleteBtn.innerHTML = '×';
        deleteBtn.style.display = 'block'; // 总是显示删除按钮
        deleteBtn.onclick = async (e) => {
            e.stopPropagation();
            const confirmed = await showCustomConfirm('删除头像', `确定要从头像库中删除“${avatar.name}”吗？`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                chat.settings.aiAvatarLibrary.splice(index, 1);
                await db.chats.put(chat);
                renderAiAvatarLibrary();
            }
        };
        item.appendChild(deleteBtn);
        grid.appendChild(item);
    });
}

/**
 * 向当前AI的头像库中添加新头像
 */
async function addAvatarToLibrary() {
    const name = await showCustomPrompt("添加头像", "请为这个头像起个名字（例如：开心、哭泣）");
    if (!name || !name.trim()) return;

    const url = await showCustomPrompt("添加头像", "请输入头像的图片URL", "", "url");
    if (!url || !url.trim().startsWith('http')) {
        alert("请输入有效的图片URL！");
        return;
    }
    
    const chat = state.chats[state.activeChatId];
    if (!chat.settings.aiAvatarLibrary) {
        chat.settings.aiAvatarLibrary = [];
    }

    chat.settings.aiAvatarLibrary.push({ name: name.trim(), url: url.trim() });
    await db.chats.put(chat);
    renderAiAvatarLibrary();
}

/**
 * 关闭AI头像库管理模态框
 */
function closeAiAvatarLibraryModal() {
    document.getElementById('ai-avatar-library-modal').classList.remove('visible');
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 在这里粘贴下面这整块新代码 ▼▼▼
/**
 * 【全新】渲染主屏幕个人资料卡的头像框
 */
function renderHomeScreenProfileFrame() {
    // 1. 获取保存的头像框URL
    const frameUrl = state.globalSettings.homeAvatarFrame || '';
    // 2. 找到头像框的img元素
    const frameImg = document.getElementById('profile-avatar-frame');
    if (frameImg) {
        // 3. 如果URL存在，就显示它
        if (frameUrl) {
            frameImg.src = frameUrl;
            frameImg.style.display = 'block';
        } else {
            // 4. 如果URL为空（即选择了“无”），就隐藏它
            frameImg.src = '';
            frameImg.style.display = 'none';
        }
    }
}
// ▲▲▲ 新代码粘贴结束 ▲▲▲


/* ▼▼▼ 步骤 3.2：将这一整块全新的功能函数，粘贴到 init() 函数的上方 ▼▼▼ */

// ▼▼▼ 用下面这【一整块】代码，替换你旧的 applyWidgetData 函数 ▼▼▼
function applyWidgetData() {
    if (!state.globalSettings.widgetData) return;
    for (const elementId in state.globalSettings.widgetData) {
        const element = document.getElementById(elementId);
        const savedValue = state.globalSettings.widgetData[elementId];
        if (element) {
            if (element.tagName === 'IMG') {
                element.src = savedValue;
            } 
            // --- ▼▼▼ 这是我们新增的修复逻辑 ▼▼▼ ---
            // 如果是地点这个特殊元素，就用 innerHTML 来正确显示图标
            else if (elementId === 'profile-location') {
                element.innerHTML = savedValue;
            } 
            // --- ▲▲▲ 修复逻辑结束 ▲▲▲ ---
            else {
                // 其他普通文本元素，保持原来的逻辑不变
                element.textContent = savedValue; 
            }
        }
    }
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 【全新辅助函数】打开文件选择器，并返回本地图片的Base64编码
 * @returns {Promise<string|null>} - 返回图片的Base64 Data URL，如果用户取消则返回null
 */
function uploadImageLocally() {
    return new Promise(resolve => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*'; // 只接受图片文件

        input.onchange = e => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = readerEvent => {
                    resolve(readerEvent.target.result); // 返回Base64字符串
                };
                reader.readAsDataURL(file);
            } else {
                resolve(null); // 用户关闭了文件选择框
            }
        };

        input.click();
    });
}

// ▼▼▼ 步骤 2.2：用这个已修复的版本，替换旧的 handleEditText 函数 ▼▼▼
async function handleEditText(element) {
    const elementId = element.id;
    const placeholder = element.dataset.placeholder || "请输入新的内容：";
    const textSpan = element.querySelector('span');
    const isComplexElement = !!textSpan;
    const targetElement = isComplexElement ? textSpan : element;
    const currentValue = targetElement.textContent;
    
    const newValue = await showCustomPrompt("修改文字", "请输入新的内容：", currentValue === placeholder ? "" : currentValue);

    if (newValue !== null) {
        const trimmedValue = newValue.trim();
        targetElement.textContent = trimmedValue ? trimmedValue : placeholder;
        state.globalSettings.widgetData[elementId] = isComplexElement ? element.innerHTML : targetElement.textContent;
        await db.globalSettings.put(state.globalSettings);
    }
}
// ▲▲▲ JavaScript 替换结束 ▲▲▲

/**
 * 【全新】触发指定群聊的后台AI互动
 * @param {string} chatId - 要触发互动的群聊ID
 */
async function triggerGroupAiAction(chatId) {
    const chat = state.chats[chatId];
    if (!chat || !chat.isGroup) return;

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        console.warn(`群聊 "${chat.name}" 后台活动失败：API未配置。`);
        return;
    }

    try {
        const lastMessage = chat.history.slice(-1)[0];
        const timeSinceLastMessage = lastMessage ? (Date.now() - lastMessage.timestamp) / 1000 / 60 : Infinity; // in minutes
        
        const membersList = chat.members.map(m => `- ${m.groupNickname} (人设: ${m.persona})`).join('\n');
          const myNickname = chat.settings.myNickname || '我';
  
        let worldBookContent = '';
    if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
        const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
            const worldBook = state.worldBooks.find(wb => wb.id === bookId);
            return worldBook && worldBook.content ? `\n\n## 世界书: ${worldBook.name}\n${worldBook.content}` : '';
        }).filter(Boolean).join('');
        if (linkedContents) {
            worldBookContent = `\n\n# 核心世界观设定 (你必须严格遵守)\n${linkedContents}\n`;
        }
    }
    let musicContext = '';
    // 注意：后台群聊活动通常不与特定的“一起听歌”会话绑定，因此这里我们提供一个空的音乐上下文。
    // 如果未来需要更复杂的功能，可以在此扩展。

    const countdownContext = await getCountdownContext(); 
    
    let sharedContext = '';
    // 后台群聊活动中不存在用户分享聊天记录的上下文，因此这里为空。

// ▼▼▼ 从这里开始完整替换 ▼▼▼
    const systemPrompt = `
# 任务
你是一个群聊后台模拟器。当前群聊 "${chat.name}" 已经沉寂了 ${Math.round(timeSinceLastMessage)} 分钟，用户(昵称: "${chat.settings.myNickname || '我'}")不在线。
你的任务是根据下方每个角色的人设，在他们之间【自发地】生成一段简短、自然的对话。

# 核心规则
1.  **【【【身份铁律】】】**: 用户【绝对不在场】。你【绝对不能】生成任何提及用户或与用户对话的内容。整段对话必须是AI角色之间的互动。你的唯一任务是扮演且仅能扮演下方“群成员列表”中明确列出的角色。
2.  **【【【输出格式】】】**: 你的回复【必须】是一个JSON数组格式的字符串。数组中的【每一个元素都必须是一个带有 "type" 和 "name" 字段的JSON对象】。
3.  **角色扮演**: 严格遵守下方“群成员列表及人设”中的每一个角色的设定。
4.  **禁止出戏**: 绝不能透露你是AI、模型，或提及“扮演”、“生成”等词语。
5.  **自然性**: 对话应该简短（2-5条消息即可），符合逻辑和角色性格。可以是闲聊、讨论某个话题，或者对之前聊天内容的延续。不要每次都生成所有人的发言。

## 你可以使用的操作指令 (JSON数组中的元素):
-   **发送文本**: \`{"type": "text", "name": "角色名", "message": "文本内容"}\`
-   **发送表情**: \`{"type": "sticker", "name": "角色名",  "sticker_name": "表情的名字"}\`
-   **发送图片**: \`{"type": "ai_image", "name": "角色名", "description": "图片描述"}\`
-   **发送语音**: \`{"type": "voice_message", "name": "角色名", "content": "语音内容"}\`
-   **发起外卖代付**: \`{"type": "waimai_request", "name": "角色名", "productInfo": "一杯奶茶", "amount": 18}\` (向【群友】发起)
-   **拍一拍群友**: \`{"type": "pat_user", "name": "你的角色名", "targetName": "【被拍的群友名】", "suffix": "(可选)你想加的后缀"}\`
-   **发红包**: \`{"type": "red_packet", "packetType": "lucky", "name": "你的角色名", ...}\`
-   **发起投票**: \`{"type": "poll", "name": "你的角色名", ...}\`

# 如何处理后台互动中的【拍一拍】:
-   后台活动中的 "pat_user" 指令【只能用于拍群内的其他AI角色】。
-   你【必须】在指令中加入一个 \`"targetName"\` 字段，值为被你拍的那个角色的名字。
-   例如: \`{"type": "pat_user", "name": "角色A", "targetName": "角色B"}\`
-   系统会自动生成 "角色A 拍了拍 角色B" 的提示。

${worldBookContent}
${musicContext}
${countdownContext} // <--- 把备忘录加在这里
${sharedContext} 
# 群成员列表及人设
${membersList}
# 用户的角色
- **${myNickname}**: ${chat.settings.myPersona}
# 对话历史参考 (最近5条)
${chat.history.slice(-5).map(m => `${m.senderName || '用户'}: ${m.content}`).join('\n')}

现在，请严格遵守以上所有规则，开始你的模拟。`;
        
        const messagesPayload = [{ role: 'user', content: systemPrompt }];

        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesPayload, isGemini);

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data)
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: messagesPayload,
                    temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                })
            });

        if (!response.ok) throw new Error(`API请求失败: ${response.status}`);
        
        const data = await response.json();
        const aiResponseContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content)
            .replace(/^```json\s*|```$/g, '');

        const messagesArray = JSON.parse(aiResponseContent);

        if (Array.isArray(messagesArray) && messagesArray.length > 0) {
            let messageTimestamp = Date.now();
            let firstMessageContent = '';
            
            messagesArray.forEach((msgData, index) => {
                if (msgData.name && msgData.message) {
                    const aiMessage = {
                        role: 'assistant',
                        senderName: msgData.name,
                        content: String(msgData.message),
                        timestamp: messageTimestamp++
                    };
                    chat.history.push(aiMessage);
                    if (index === 0) {
                        firstMessageContent = `${msgData.name}: ${msgData.message}`;
                    }
                }
            });

            // 更新此群聊的最后活动时间戳
            chat.settings.backgroundActivity.lastActivityTimestamp = Date.now();
            
            // 给用户发通知
            chat.unreadCount = (chat.unreadCount || 0) + messagesArray.length;
            showNotification(chatId, firstMessageContent);
            
            // 保存并刷新UI
            await db.chats.put(chat);
            renderChatList();
            
            console.log(`群聊 "${chat.name}" 后台互动成功，生成了 ${messagesArray.length} 条新消息。`);
        }

    } catch (error) {
        console.error(`群聊 "${chat.name}" 的后台活动失败:`, error);
    }
}

// ▼▼▼ 请用这【一整块新代码】替换旧的 handleEditImage 函数 ▼▼▼
async function handleEditImage(element) {
    const elementId = element.id;

    // 【核心修改】移除了按钮文字中的图标
    const choice = await showChoiceModal("修改图片", [
        { text: '从本地上传', value: 'local' },
        { text: '使用网络URL', value: 'url' }
    ]);

    let newValue = null;

    if (choice === 'local') {
        newValue = await uploadImageLocally();
    } else if (choice === 'url') {
        newValue = await showCustomPrompt("修改图片", "请输入新的图片URL：", element.src, "url");
    }

    if (newValue && newValue.trim()) {
        const trimmedValue = newValue.trim();
        element.src = trimmedValue;
        state.globalSettings.widgetData[elementId] = trimmedValue;
        await db.globalSettings.put(state.globalSettings);
    } else if (choice === 'url' && newValue !== null) {
        alert("请输入一个有效的图片URL！");
    }
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【全新】群聊专属后台活动时钟 ▼▼▼

let groupSimulationIntervalId = null; // 用于存储群聊主时钟的ID

/**
 * 启动群聊的后台“主时钟”。这个时钟会一直运行，定期检查所有群聊。
 */
function startGroupSimulation() {
    if (groupSimulationIntervalId) return; // 如果已经启动，则不重复启动
    
    // 我们设置一个相对较短的间隔（比如30秒）来作为“主时钟”的频率
    // 它不是具体某个群聊的活动间隔，而是检查所有群聊的频率
    groupSimulationIntervalId = setInterval(runGroupSimulationTick, 30000); // 30秒检查一次
    console.log("群聊后台活动主时钟已启动，每30秒检查一次所有群聊。");
}

/**
 * 停止群聊的后台“主时钟”。
 */
function stopGroupSimulation() {
    if (groupSimulationIntervalId) {
        clearInterval(groupSimulationIntervalId);
        groupSimulationIntervalId = null;
        console.log("群聊后台活动主时钟已停止。");
    }
}

/**
 * 群聊“主时钟”的每一次心跳执行的函数
 */
function runGroupSimulationTick() {
    const allGroupChats = Object.values(state.chats).filter(chat => chat.isGroup);

    allGroupChats.forEach(chat => {
        const bgSettings = chat.settings.backgroundActivity;
        // 检查1：该群聊自己的开关是否开启
        if (bgSettings && bgSettings.enabled) {
            const now = Date.now();
            // 检查2：使用该群聊自己设置的间隔期
            const intervalMs = (bgSettings.interval || 120) * 1000;
            const lastActivity = bgSettings.lastActivityTimestamp || 0;

            // 检查3：是否到达了该群聊的行动时间
            if (now - lastActivity > intervalMs) {
                console.log(`群聊 "${chat.name}" 到达行动时间 (间隔: ${bgSettings.interval}秒)，准备触发后台互动...`);
                // 触发群聊专属的后台行动函数
                triggerGroupAiAction(chat.id);
            }
        }
    });
}

// ▲▲▲ 新增代码结束 ▲▲▲
// ▼▼▼ 把这一整块全新的功能函数，粘贴到 init() 函数的上方 ▼▼▼
/**
 * 【全新】清空所有已关注角色的微博帖子
 */
async function clearFollowingFeed() {
    // 1. 弹出确认框，防止误操作
    const confirmed = await showCustomConfirm(
        '确认清空',
        '此操作将永久删除所有【非你本人发布】的微博，且无法恢复。确定要继续吗？',
        { confirmButtonClass: 'btn-danger' } // 红色按钮以示警告
    );

    if (!confirmed) {
        return; // 如果用户取消，则不执行任何操作
    }

    try {
        // 2. 从数据库中找出所有作者不是'user'的帖子
        const postsToDelete = await db.weiboPosts.where('authorId').notEqual('user').toArray();
        const idsToDelete = postsToDelete.map(p => p.id);

        if (idsToDelete.length === 0) {
            alert("目前没有可以清空的动态。");
            return;
        }

        // 3. 批量删除这些帖子
        await db.weiboPosts.bulkDelete(idsToDelete);

        // 4. 重新渲染“关注的人”的Feed，让界面变空
        await renderWeiboFeeds('weibo-following-view');

        alert(`已成功清空 ${idsToDelete.length} 条动态！`);

    } catch (error) {
        console.error("清空关注动态时出错:", error);
        alert(`操作失败: ${error.message}`);
    }
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 请将这两个【新函数】粘贴到JS功能函数定义区 ▼▼▼

/**
 * 【全新】将保存的图标URL应用到主屏幕的App图标上
 */
function applyAppIcons() {
    if (!state.globalSettings.appIcons) return;

    for (const iconId in state.globalSettings.appIcons) {
        const imgElement = document.getElementById(`icon-img-${iconId}`);
        if (imgElement) {
            imgElement.src = state.globalSettings.appIcons[iconId];
        }
    }
}

/**
 * 【全新】在外观设置页面渲染出所有App图标的设置项
 */
function renderIconSettings() {
    const grid = document.getElementById('icon-settings-grid');
    if (!grid) return;
    grid.innerHTML = '';

// ▼▼▼ 用下面这段【修改后】的代码，完整替换掉你旧的 appLabels ▼▼▼
const appLabels = {
    'world-book': '世界书',
    'qq': 'QQ',
    'api-settings': 'API设置',
    'wallpaper': '壁纸',
    'font': '字体',
    'check-phone': '查手机',
    'weibo': '微博',
    'forum': '圈子',
    'lovers-space': '情侣空间',
    'game-hall': '游戏大厅',
    'x-social': 'X社交',
    'taobao': '桃宝'
};
// ▲▲▲ 替换结束 ▲▲▲




    for (const iconId in state.globalSettings.appIcons) {
        const iconUrl = state.globalSettings.appIcons[iconId];
        const labelText = appLabels[iconId] || '未知App';

        const item = document.createElement('div');
        item.className = 'icon-setting-item';
        // 【重要】我们用 data-icon-id 来标记这个设置项对应哪个图标
        item.dataset.iconId = iconId; 

        item.innerHTML = `
            <img class="icon-preview" src="${iconUrl}" alt="${labelText}">
            <button class="change-icon-btn">更换</button>
        `;
        grid.appendChild(item);
    }
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 用这块【最终确认版】的代码，替换旧的 openBrowser 和 closeBrowser 函数 ▼▼▼

/**
 * 当用户点击链接卡片时，打开伪浏览器
 * @param {number} timestamp - 被点击消息的时间戳
 */
function openBrowser(timestamp) {
    if (!state.activeChatId) return;

    const chat = state.chats[state.activeChatId];
    // 安全检查，确保 chat 和 history 都存在
    if (!chat || !chat.history) return;

    const message = chat.history.find(m => m.timestamp === timestamp);
    if (!message || message.type !== 'share_link') {
        console.error("无法找到或消息类型不匹配的分享链接:", timestamp);
        return; // 如果找不到消息，就直接退出
    }

    // 填充浏览器内容
    document.getElementById('browser-title').textContent = message.source_name || '文章详情';
    const browserContent = document.getElementById('browser-content');
    browserContent.innerHTML = `
        <h1 class="article-title">${message.title || '无标题'}</h1>
        <div class="article-meta">
            <span>来源: ${message.source_name || '未知'}</span>
        </div>
        <div class="article-body">
            <p>${(message.content || '内容为空。').replace(/\n/g, '</p><p>')}</p>
        </div>
    `;

    // 显示浏览器屏幕
    showScreen('browser-screen');
}

/**
 * 关闭伪浏览器，返回聊天界面
 * (这个函数现在由 init() 中的事件监听器调用)
 */
function closeBrowser() {
    showScreen('chat-interface-screen'); 
}

// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【全新】用户分享链接功能的核心函数 ▼▼▼

/**
 * 打开让用户填写链接信息的模态框
 */
function openShareLinkModal() {
    if (!state.activeChatId) return;

    // 清空上次输入的内容
    document.getElementById('link-title-input').value = '';
    document.getElementById('link-description-input').value = '';
    document.getElementById('link-source-input').value = '';
    document.getElementById('link-content-input').value = '';

    // 显示模态框
    document.getElementById('share-link-modal').classList.add('visible');
}

/**
 * 用户确认分享，创建并发送链接卡片消息
 */
async function sendUserLinkShare() {
    if (!state.activeChatId) return;

    const title = document.getElementById('link-title-input').value.trim();
    if (!title) {
        alert("标题是必填项哦！");
        return;
    }

    const description = document.getElementById('link-description-input').value.trim();
    const sourceName = document.getElementById('link-source-input').value.trim();
    const content = document.getElementById('link-content-input').value.trim();

    const chat = state.chats[state.activeChatId];
    
    // 创建消息对象
    const linkMessage = {
        role: 'user', // 角色是 'user'
        type: 'share_link',
        timestamp: Date.now(),
        title: title,
        description: description,
        source_name: sourceName,
        content: content,
        // 用户分享的链接，我们不提供图片，让它总是显示占位图
        thumbnail_url: null 
    };

    // 将消息添加到历史记录
    chat.history.push(linkMessage);
    await db.chats.put(chat);

    // 渲染新消息并更新列表
    appendMessage(linkMessage, chat);
    renderChatList();

    // 关闭模态框
    document.getElementById('share-link-modal').classList.remove('visible');
}

/**
 * 【全新升级版】根据AI视角和动态设置，构建给AI看的评论区上下文
 * @param {object} post - 正在处理的动态对象
 * @param {object} viewerChat - 正在“看”动态的AI角色
 * @param {string} userNickname - 用户的昵称
 * @returns {{contextString: string, visibilityFlag: string}} - 返回包含上下文文本和可见性标志的对象
 */
function buildCommentsContextForAI(post, viewerChat, userNickname) {
    if (!post.comments || post.comments.length === 0) {
        // ★★★ 关键在这里：确保 "[评论区可见]" 是一个带引号的字符串 ★★★
        return { contextString: "", visibilityFlag: "[评论区可见]" };
    }

    const viewerName = viewerChat.name;
    let commentsForAI;
    let visibilityFlag;

    if (post.areCommentsVisible !== false) {
        commentsForAI = post.comments;
        // ★★★ 关键在这里：确保 "[评论区可见]" 是一个带引号的字符串 ★★★
        visibilityFlag = "[评论区可见]"; 
    } else {
commentsForAI = Array.isArray(post.comments)
  ? post.comments.filter(comment => {
      return comment.commenterName === viewerName
          || comment.commenterName === userNickname
          || comment.replyTo === viewerName;
    })
  : [];
        // ★★★ 关键在这里：确保 "[评论区部分可见]" 是一个带引号的字符串 ★★★
        visibilityFlag = "[评论区部分可见]";
    }

    if (commentsForAI.length === 0) {
        return { contextString: "", visibilityFlag: visibilityFlag };
    }

    let context = `  └ 评论区:\n`;
    commentsForAI.slice(-5).forEach(c => {
        if (c.replyTo) {
            context += `    - ${c.commenterName} 回复 ${c.replyTo}: ${c.text}\n`;
        } else {
            context += `    - ${c.commenterName}: ${c.text}\n`;
        }
    });
    
    return { contextString: context, visibilityFlag: visibilityFlag };
}



/**
 * 根据AI的视角，过滤出它能看到的动态
 * @param {Array} allPosts - 所有待检查的动态帖子
 * @param {object} viewerChat - 正在“看”动态的那个AI的chat对象
 * @returns {Array} - 过滤后该AI可见的动态帖子
 */
function filterVisiblePostsForAI(allPosts, viewerChat) {
    if (!viewerChat || !viewerChat.id) return []; // 安全检查

    const viewerGroupId = viewerChat.groupId; // 查看者所在的分组ID

    return allPosts.filter(post => {
        // 规则1：如果是用户发的动态
        if (post.authorId === 'user') {
            // 如果用户设置了“部分可见”
            if (post.visibleGroupIds && post.visibleGroupIds.length > 0) {
                // 只有当查看者AI的分组ID在用户的可见列表里时，才可见
                return viewerGroupId && post.visibleGroupIds.includes(viewerGroupId);
            }
            // 如果用户没设置，说明是公开的，所有AI都可见
            return true;
        }

        // 规则2：如果是其他AI发的动态
        const authorGroupId = post.authorGroupId; // 发帖AI所在的分组ID
        
        // 如果发帖的AI没有分组，那它的动态就是公开的
        if (!authorGroupId) {
            return true;
        }

        // 如果发帖的AI有分组，那么只有在同一个分组的AI才能看到
        return authorGroupId === viewerGroupId;
    });
}

/**
 * 应用指定的主题（'light' 或 'dark'）
 * @param {string} theme - 要应用的主题名称
 */
function applyTheme(theme) {
    const phoneScreen = document.getElementById('phone-screen');
    const toggleSwitch = document.getElementById('theme-toggle-switch');
    
    const isDark = theme === 'dark';
    
    phoneScreen.classList.toggle('dark-mode', isDark);
    
    // 如果开关存在，就同步它的状态
    if (toggleSwitch) {
        toggleSwitch.checked = isDark;
    }
    
    localStorage.setItem('ephone-theme', theme);
}

/**
 * 切换当前的主题
 */
function toggleTheme() {
    const toggleSwitch = document.getElementById('theme-toggle-switch');
    // 直接根据开关的选中状态来决定新主题
    const newTheme = toggleSwitch.checked ? 'dark' : 'light';
    applyTheme(newTheme);
}

// ▼▼▼ 请将这【一整块新函数】粘贴到你的JS功能函数定义区 ▼▼▼

function startReplyToMessage() {
    if (!activeMessageTimestamp) return;

    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === activeMessageTimestamp);
    if (!message) return;

    // 1. 【核心修正】同时获取“完整内容”和“预览片段”
    const fullContent = String(message.content || '');
    let previewSnippet = '';

    if (typeof message.content === 'string' && STICKER_REGEX.test(message.content)) {
        previewSnippet = '[表情]';
    } else if (message.type === 'ai_image' || message.type === 'user_photo') {
        previewSnippet = '[图片]';
    } else if (message.type === 'voice_message') {
        previewSnippet = '[语音]';
    } else {
        // 预览片段依然截断，但只用于UI显示
        previewSnippet = fullContent.substring(0, 50) + (fullContent.length > 50 ? '...' : '');
    }
    
    // 2. 【核心修正】将“完整内容”存入上下文，以备发送时使用
    currentReplyContext = {
        timestamp: message.timestamp,
        senderName: message.senderName || (message.role === 'user' ? (chat.settings.myNickname || '我') : chat.name),
        content: fullContent, // <--- 这里存的是完整的原文！
    };

    // 3. 【核心修正】仅在更新“回复预览栏”时，才使用“预览片段”
    const previewBar = document.getElementById('reply-preview-bar');
    previewBar.querySelector('.sender').textContent = `回复 ${currentReplyContext.senderName}:`;
    previewBar.querySelector('.text').textContent = previewSnippet; // <--- 这里用的是缩略版！
    previewBar.style.display = 'block';

    // 4. 后续操作保持不变
    hideMessageActions();
    document.getElementById('chat-input').focus();
}

/**
 * 【全新】取消引用模式
 */
function cancelReplyMode() {
    currentReplyContext = null;
    document.getElementById('reply-preview-bar').style.display = 'none';
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 【全新】用户处理转账的核心功能函数 ▼▼▼

let activeTransferTimestamp = null; // 用于暂存被点击的转账消息的时间戳

/**
 * 显示处理转账的操作菜单
 * @param {number} timestamp - 被点击的转账消息的时间戳
 */
function showTransferActionModal(timestamp) {
    activeTransferTimestamp = timestamp;

    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === timestamp);
    if (message) {
        // 将AI的名字填入弹窗
        document.getElementById('transfer-sender-name').textContent = message.senderName;
    }
    document.getElementById('transfer-actions-modal').classList.add('visible');
}

/**
 * 隐藏处理转账的操作菜单
 */
function hideTransferActionModal() {
    document.getElementById('transfer-actions-modal').classList.remove('visible');
    activeTransferTimestamp = null;
}

/**
 * 处理用户接受或拒绝转账的逻辑
 * @param {string} choice - 用户的选择, 'accepted' 或 'declined'
 */
async function handleUserTransferResponse(choice) {
    if (!activeTransferTimestamp) return;

    const timestamp = activeTransferTimestamp;
    const chat = state.chats[state.activeChatId];
    const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
    if (messageIndex === -1) return;

    // 1. 更新原始转账消息的状态
    const originalMessage = chat.history[messageIndex];
    originalMessage.status = choice;

    let systemContent;

    // 2. 如果用户选择“拒绝”
    if (choice === 'declined') {
        // 立刻在前端生成一个“退款”卡片，让用户看到
        const refundMessage = {
            role: 'user',
            type: 'transfer',
            isRefund: true, // 这是一个关键标记，用于UI显示这是退款
            amount: originalMessage.amount,
            note: '已拒收对方转账',
            timestamp: Date.now()
        };
        chat.history.push(refundMessage);
        
        // 准备一条对AI可见的隐藏消息，告诉它发生了什么
        systemContent = `[系统提示：你拒绝并退还了“${originalMessage.senderName}”的转账。]`;
    } else { // 如果用户选择“接受”
        // 只需准备隐藏消息通知AI即可
        systemContent = `[系统提示：你接受了“${originalMessage.senderName}”的转账。]`;
        await updateUserBalanceAndLogTransaction(originalMessage.amount, `收到来自 ${originalMessage.senderName} 的转账`);
    }

    // 3. 创建这条对用户隐藏、但对AI可见的系统消息
    const hiddenMessage = {
        role: 'system',
        content: systemContent,
        timestamp: Date.now() + 1, // 保证时间戳在退款消息之后
        isHidden: true // 这个标记会让它不在聊天界面显示
    };
    chat.history.push(hiddenMessage);

    // 4. 保存所有更改到数据库，并刷新界面
    await db.chats.put(chat);
    hideTransferActionModal(); 
    renderChatInterface(state.activeChatId);
    renderChatList();
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 【全新】通话记录功能核心函数 ▼▼▼

async function renderCallHistoryScreen() {
    showScreen('call-history-screen'); // <--【核心修正】把它移动到最前面！

    const listEl = document.getElementById('call-history-list');
    const titleEl = document.getElementById('call-history-title');
    listEl.innerHTML = '';
    titleEl.textContent = '所有通话记录';
    
    const records = await db.callRecords.orderBy('timestamp').reverse().toArray();
    
    if (records.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">这里还没有通话记录哦~</p>';
        return; // 现在的 return 就没问题了，因为它只跳过了后续的渲染逻辑
    }
    
    records.forEach(record => {
        const card = createCallRecordCard(record);

    addLongPressListener(card, async () => {
        // 1. 弹出输入框，并将旧名称作为默认值，方便修改
        const newName = await showCustomPrompt(
            "自定义通话名称", 
            "请输入新的名称（留空则恢复默认）",
            record.customName || '' // 如果已有自定义名称，就显示它
        );

        // 2. 如果用户点击了“取消”，则什么都不做
        if (newName === null) return;
        
        // 3. 更新数据库中的这条记录
        await db.callRecords.update(record.id, { customName: newName.trim() });
        
        // 4. 刷新整个列表，让更改立刻显示出来
        await renderCallHistoryScreen();
        
        // 5. 给用户一个成功的提示
        await showCustomAlert('成功', '通话名称已更新！');
    });
        listEl.appendChild(card);
    });    
}

// ▼▼▼ 用这个【升级版】函数，完整替换你旧的 createCallRecordCard 函数 ▼▼▼
/**
 * 【升级版】根据单条记录数据，创建一张能显示聊天对象的通话卡片
 * @param {object} record - 一条通话记录对象
 * @returns {HTMLElement} - 创建好的卡片div
 */
function createCallRecordCard(record) {
    const card = document.createElement('div');
    card.className = 'call-record-card';
    card.dataset.recordId = record.id; 

    // 获取通话对象的名字
    const chatInfo = state.chats[record.chatId];
    const chatName = chatInfo ? chatInfo.name : '未知会话';

    const callDate = new Date(record.timestamp);
    const dateString = `${callDate.getFullYear()}-${String(callDate.getMonth() + 1).padStart(2, '0')}-${String(callDate.getDate()).padStart(2, '0')} ${String(callDate.getHours()).padStart(2, '0')}:${String(callDate.getMinutes()).padStart(2, '0')}`;
    const durationText = `${Math.floor(record.duration / 60)}分${record.duration % 60}秒`;

    const avatarsHtml = record.participants.map(p => 
        `<img src="${p.avatar}" alt="${p.name}" class="participant-avatar" title="${p.name}">`
    ).join('');
    
    card.innerHTML = `
        <div class="card-header">
            <span class="date">${dateString}</span>
            <span class="duration">${durationText}</span>
        </div>
        <div class="card-body">
            <!-- 【核心修改】在这里新增一个标题行 -->
            ${record.customName ? `<div class="custom-title">${record.customName}</div>` : ''}
            
            <div class="participants-info"> <!-- 新增一个容器方便布局 -->
                <div class="participants-avatars">${avatarsHtml}</div>
                <span class="participants-names">与 ${chatName}</span>
            </div>
        </div>
    `;
    return card;
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 显示指定通话记录的完整文字稿
 * @param {number} recordId - 通话记录的ID
 */
async function showCallTranscript(recordId) {
    const record = await db.callRecords.get(recordId);
    if (!record) return;

    const modal = document.getElementById('call-transcript-modal');
    const titleEl = document.getElementById('transcript-modal-title');
    const bodyEl = document.getElementById('transcript-modal-body');

    titleEl.textContent = `通话于 ${new Date(record.timestamp).toLocaleString()} (时长: ${Math.floor(record.duration / 60)}分${record.duration % 60}秒)`;
    bodyEl.innerHTML = '';
    
    if (!record.transcript || record.transcript.length === 0) {
        bodyEl.innerHTML = '<p style="text-align:center; color: #8a8a8a;">这次通话没有留下文字记录。</p>';
    } else {
        record.transcript.forEach(entry => {
            const bubble = document.createElement('div');
            // 根据角色添加不同的class，应用不同的样式
            bubble.className = `transcript-entry ${entry.role}`; 
            bubble.textContent = entry.content;
            bodyEl.appendChild(bubble);
        });
    }

    const deleteBtn = document.getElementById('delete-transcript-btn');
    
    // 【重要】使用克隆节点技巧，防止事件重复绑定
    const newDeleteBtn = deleteBtn.cloneNode(true);
    deleteBtn.parentNode.replaceChild(newDeleteBtn, deleteBtn);
    
    // 为新的、干净的按钮绑定事件
    newDeleteBtn.addEventListener('click', async () => {
        const confirmed = await showCustomConfirm(
            "确认删除",
            "确定要永久删除这条通话记录吗？此操作不可恢复。",
            { confirmButtonClass: 'btn-danger' }
        );

        if (confirmed) {
            // 1. 关闭当前的详情弹窗
            modal.classList.remove('visible');
            
            // 2. 从数据库删除
            await db.callRecords.delete(recordId);
            
            // 3. 刷新通话记录列表
            await renderCallHistoryScreen();
            
            // 4. (可选) 给出成功提示
            alert('通话记录已删除。');
        }
    });
    modal.classList.add('visible');
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 请用这个【全新函数】替换掉你旧的 handleStatusResetClick 函数 ▼▼▼

/**
 * 【全新】处理用户点击状态栏，弹出编辑框让用户修改AI的当前状态
 */
async function handleEditStatusClick() {
    // 1. 安全检查，确保在单聊界面
    if (!state.activeChatId || state.chats[state.activeChatId].isGroup) {
        return; 
    }
    const chat = state.chats[state.activeChatId];

    // 2. 弹出输入框，让用户输入新的状态，并将当前状态作为默认值
    const newStatusText = await showCustomPrompt(
        '编辑对方状态',
        '请输入对方现在的新状态：',
        chat.status.text // 将当前状态作为输入框的默认内容
    );

    // 3. 如果用户输入了内容并点击了“确定”
    if (newStatusText !== null) {
        // 4. 更新内存和数据库中的状态数据
        chat.status.text = newStatusText.trim() || '在线'; // 如果用户清空了，就默认为“在线”
        chat.status.isBusy = false; // 每次手动编辑都默认其不处于“忙碌”状态
        chat.status.lastUpdate = Date.now();
        await db.chats.put(chat);

        // 5. 立刻刷新UI，让用户看到修改后的状态
        renderChatInterface(state.activeChatId);
        renderChatList();
        
        // 6. 给出一个无伤大雅的成功提示
        await showCustomAlert('状态已更新', `“${chat.name}”的当前状态已更新为：${chat.status.text}`);
    }
}

// 放在你的JS功能函数定义区
async function openShareTargetPicker() {
    const modal = document.getElementById('share-target-modal');
    const listEl = document.getElementById('share-target-list');
    listEl.innerHTML = '';

    // 获取所有聊天作为分享目标
    const chats = Object.values(state.chats);

    chats.forEach(chat => {
        // 复用联系人选择器的样式
        const item = document.createElement('div');
        item.className = 'contact-picker-item'; 
        item.innerHTML = `
            <input type="checkbox" class="share-target-checkbox" data-chat-id="${chat.id}" style="margin-right: 15px;">
            <img src="${chat.isGroup ? chat.settings.groupAvatar : chat.settings.aiAvatar || defaultAvatar}" class="avatar">
            <span class="name">${chat.name}</span>
        `;
        listEl.appendChild(item);
    });
    
    modal.classList.add('visible');
}

function closeMusicPlayerWithAnimation(callback) {
    const overlay = document.getElementById('music-player-overlay');
    if (!overlay.classList.contains('visible')) {
        if (callback) callback();
        return;
    }
    overlay.classList.remove('visible');
    setTimeout(() => {
        document.getElementById('music-playlist-panel').classList.remove('visible');
        if (callback) callback();
    }, 400); 
}

function parseLRC(lrcContent) {
    if (!lrcContent) return [];
    const lines = lrcContent.split('\n');
    const lyrics = [];
    const timeRegex = /\[(\d{2}):(\d{2})[.:](\d{2,3})\]/g;

    for (const line of lines) {
        const text = line.replace(timeRegex, '').trim();
        if (!text) continue;
        timeRegex.lastIndex = 0;
        let match;
        while ((match = timeRegex.exec(line)) !== null) {
            const minutes = parseInt(match[1], 10);
            const seconds = parseInt(match[2], 10);
            const milliseconds = parseInt(match[3].padEnd(3, '0'), 10);
            const time = minutes * 60 + seconds + milliseconds / 1000;
            lyrics.push({ time, text });
        }
    }
    return lyrics.sort((a, b) => a.time - b.time);
}

function renderLyrics() {
    const lyricsList = document.getElementById('music-lyrics-list');
    lyricsList.innerHTML = '';
    if (!musicState.parsedLyrics || musicState.parsedLyrics.length === 0) {
        lyricsList.innerHTML = '<div class="lyric-line">♪ 暂无歌词 ♪</div>';
        return;
    }
    musicState.parsedLyrics.forEach((line, index) => {
        const lineEl = document.createElement('div');
        lineEl.className = 'lyric-line';
        lineEl.textContent = line.text;
        lineEl.dataset.index = index;
        lyricsList.appendChild(lineEl);
    });
    lyricsList.style.transform = `translateY(0px)`;
}

function updateActiveLyric(currentTime) {
    if (musicState.parsedLyrics.length === 0) return;
    let newLyricIndex = -1;
    for (let i = 0; i < musicState.parsedLyrics.length; i++) {
        if (currentTime >= musicState.parsedLyrics[i].time) {
            newLyricIndex = i;
        } else {
            break;
        }
    }
    if (newLyricIndex === musicState.currentLyricIndex) return;
    musicState.currentLyricIndex = newLyricIndex;
    updateLyricsUI();
}

function updateLyricsUI() {
    const lyricsList = document.getElementById('music-lyrics-list');
    const container = document.getElementById('music-lyrics-container');
    const lines = lyricsList.querySelectorAll('.lyric-line');
    lines.forEach(line => line.classList.remove('active'));
    if (musicState.currentLyricIndex === -1) {
        lyricsList.style.transform = `translateY(0px)`;
        return;
    }
    const activeLine = lyricsList.querySelector(`.lyric-line[data-index="${musicState.currentLyricIndex}"]`);
    if (activeLine) {
        activeLine.classList.add('active');
        const containerHeight = container.offsetHeight;
        const offset = (containerHeight / 3) - activeLine.offsetTop - (activeLine.offsetHeight / 2);
        lyricsList.style.transform = `translateY(${offset}px)`;
    }

    // ▼▼▼ 在这里添加下面这块【新代码】 ▼▼▼
    // 【核心新增】同步歌词到悬浮栏
    const floatingLyricText = document.getElementById('floating-lyric-text');
    if (activeLine) {
        floatingLyricText.textContent = activeLine.textContent;
    } else if (musicState.parsedLyrics.length > 0) {
        floatingLyricText.textContent = '♪ ♪ ♪'; // 歌曲前奏
    } else {
        floatingLyricText.textContent = '♪ 暂无歌词 ♪';
    }
    // ▲▲▲ 新代码添加结束 ▲▲▲

}

function formatMusicTime(seconds) {
    if (isNaN(seconds) || seconds < 0) return "0:00";
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = Math.floor(seconds % 60);
    return `${minutes}:${String(remainingSeconds).padStart(2, '0')}`;
}

function updateMusicProgressBar() {
    const currentTimeEl = document.getElementById('music-current-time');
    const totalTimeEl = document.getElementById('music-total-time');
    const progressFillEl = document.getElementById('music-progress-fill');
    if (!audioPlayer.duration) {
        currentTimeEl.textContent = "0:00";
        totalTimeEl.textContent = "0:00";
        progressFillEl.style.width = '0%';
        return;
    }
    const progressPercent = (audioPlayer.currentTime / audioPlayer.duration) * 100;
    progressFillEl.style.width = `${progressPercent}%`;
    currentTimeEl.textContent = formatMusicTime(audioPlayer.currentTime);
    totalTimeEl.textContent = formatMusicTime(audioPlayer.duration);
    updateActiveLyric(audioPlayer.currentTime);
}

/**
 * 【全新】处理用户点击“撤回”按钮的入口函数
 */
async function handleRecallClick() {
    if (!activeMessageTimestamp) return;

    const RECALL_TIME_LIMIT_MS = 2 * 60 * 1000; // 设置2分钟的撤回时限
    const messageTime = activeMessageTimestamp;
    const now = Date.now();

    // 检查是否超过了撤回时限
    if (now - messageTime > RECALL_TIME_LIMIT_MS) {
        hideMessageActions();
        await showCustomAlert('操作失败', '该消息发送已超过2分钟，无法撤回。');
        return;
    }
    
    // 如果在时限内，执行真正的撤回逻辑
    await recallMessage(messageTime, true);
    hideMessageActions();
}

/**
 * 【全新】消息撤回的核心逻辑
 * @param {number} timestamp - 要撤回的消息的时间戳
 * @param {boolean} isUserRecall - 是否是用户主动撤回
 */
async function recallMessage(timestamp, isUserRecall) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
    if (messageIndex === -1) return;

    const messageToRecall = chat.history[messageIndex];

    // 1. 修改消息对象，将其变为“已撤回”状态
    const recalledData = {
        originalType: messageToRecall.type || 'text',
        originalContent: messageToRecall.content,
        // 保存其他可能存在的原始数据
        originalMeaning: messageToRecall.meaning,
        originalQuote: messageToRecall.quote 
    };
    
    messageToRecall.type = 'recalled_message';
    messageToRecall.content = isUserRecall ? '你撤回了一条消息' : '对方撤回了一条消息';
    messageToRecall.recalledData = recalledData;
    // 清理掉不再需要的旧属性
    delete messageToRecall.meaning;
    delete messageToRecall.quote;

    // 2. 如果是用户撤回，需要给AI发送一条它看不懂内容的隐藏提示
    if (isUserRecall) {
        const hiddenMessageForAI = {
            role: 'system',
            content: `[系统提示：用户撤回了一条消息。你不知道内容是什么，只需知道这个事件即可。]`,
            timestamp: Date.now(),
            isHidden: true
        };
        chat.history.push(hiddenMessageForAI);
    }

    // 3. 保存到数据库并刷新UI
    await db.chats.put(chat);
    renderChatInterface(state.activeChatId);
    if(isUserRecall) renderChatList(); // 用户撤回时，最后一条消息变了，需要刷新列表
}

// ▼▼▼ 【全新】将这些函数粘贴到你的JS功能函数定义区 ▼▼▼

/**
 * 打开分类管理模态框
 */
async function openCategoryManager() {
    await renderCategoryListInManager();
    document.getElementById('world-book-category-manager-modal').classList.add('visible');
}

/**
 * 在模态框中渲染已存在的分类列表
 */
async function renderCategoryListInManager() {
    const listEl = document.getElementById('existing-categories-list');
    const categories = await db.worldBookCategories.toArray();
    listEl.innerHTML = '';
    if (categories.length === 0) {
        listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">还没有任何分类</p>';
    }
    categories.forEach(cat => {
        // 复用好友分组的样式
        const item = document.createElement('div');
        item.className = 'existing-group-item'; 
        item.innerHTML = `
            <span class="group-name">${cat.name}</span>
            <span class="delete-group-btn" data-id="${cat.id}">×</span>
        `;
        listEl.appendChild(item);
    });
}

/**
 * 添加一个新的世界书分类
 */
async function addNewCategory() {
    const input = document.getElementById('new-category-name-input');
    const name = input.value.trim();
    if (!name) {
        alert('分类名不能为空！');
        return;
    }
    const existing = await db.worldBookCategories.where('name').equals(name).first();
    if (existing) {
        alert(`分类 "${name}" 已经存在了！`);
        return;
    }
    await db.worldBookCategories.add({ name });
    input.value = '';
    await renderCategoryListInManager();
}

/**
 * 删除一个世界书分类
 * @param {number} categoryId - 要删除的分类的ID
 */
async function deleteCategory(categoryId) {
    const confirmed = await showCustomConfirm(
        '确认删除', 
        '删除分类后，该分类下的所有世界书将变为“未分类”。确定要删除吗？', 
        { confirmButtonClass: 'btn-danger' }
    );
    if (confirmed) {
        await db.worldBookCategories.delete(categoryId);
        // 将属于该分类的世界书的 categoryId 设为 null
        const booksToUpdate = await db.worldBooks.where('categoryId').equals(categoryId).toArray();
        for (const book of booksToUpdate) {
            book.categoryId = null;
            await db.worldBooks.put(book);
            const bookInState = state.worldBooks.find(wb => wb.id === book.id);
            if(bookInState) bookInState.categoryId = null;
        }
        await renderCategoryListInManager();
    }
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲
// ▼▼▼ 【全新】角色专属NPC库管理功能函数 ▼▼▼

let editingNpcId = null; // 用于追踪正在编辑的NPC

/**
 * 打开NPC库管理界面
 */
function openNpcManager() {
    if (!state.activeChatId || state.chats[state.activeChatId].isGroup) return;
    const chat = state.chats[state.activeChatId];
    document.getElementById('npc-management-title').textContent = `“${chat.name}”的NPC库`;
    renderNpcList();
    showScreen('npc-management-screen');
}

/**
 * 渲染NPC列表
 */
function renderNpcList() {
    const listEl = document.getElementById('npc-management-list');
    const chat = state.chats[state.activeChatId];
    const npcLibrary = chat.npcLibrary || [];
    listEl.innerHTML = '';

    if (npcLibrary.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">这里空空如也，点击右上角“+”添加第一个NPC吧！</p>';
        return;
    }

    npcLibrary.forEach(npc => {
        // 复用聊天列表的样式，非常方便
        const item = document.createElement('div');
        item.className = 'chat-list-item';
        item.style.cursor = 'pointer';
        item.innerHTML = `
            <img src="${npc.avatar || defaultGroupMemberAvatar}" class="avatar">
            <div class="info">
                <span class="name">${npc.name}</span>
                <div class="last-msg">${npc.persona.substring(0, 30)}...</div>
            </div>
        `;
        // 点击编辑
        item.addEventListener('click', () => openNpcEditor(npc.id));
        // 长按删除
        addLongPressListener(item, () => deleteNpc(npc.id, npc.name));
        listEl.appendChild(item);
    });
}

// ▼▼▼ 用这个【全新的、已修复两个Bug的函数】，完整替换旧的 openNpcEditor 函数 ▼▼▼
async function openNpcEditor(npcId = null) {
    editingNpcId = npcId;
    // 【核心修复1】使用正确的 state.activeChatId 来获取当前聊天对象
    const chat = state.chats[state.activeChatId];
    if (!chat) return; // 安全检查

    let npc = { name: '', persona: '', avatar: defaultGroupMemberAvatar };
    
    if (npcId) {
        // 【核心修复2】从正确的 chat.npcLibrary 中查找数据
        npc = (chat.npcLibrary || []).find(n => n.id === npcId) || npc;
        document.getElementById('persona-editor-title').textContent = `编辑NPC: ${npc.name}`;
    } else {
        document.getElementById('persona-editor-title').textContent = '添加新NPC';
    }
    
    // 填充编辑器内容
    document.getElementById('npc-editor-name-input').value = npc.name;
    document.getElementById('preset-avatar-preview').src = npc.avatar;
    document.getElementById('preset-persona-input').value = npc.persona;
    
    // 【核心逻辑】根据NPC模式，显隐特定UI元素
    document.getElementById('npc-editor-name-group').style.display = 'block';
    document.getElementById('persona-editor-change-frame-btn').style.display = 'none';

    // 绑定正确的保存函数
    document.getElementById('save-persona-preset-btn').onclick = saveNpc;

    // 最后才显示弹窗
    document.getElementById('persona-editor-modal').classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲






// ▼▼▼ 从这里开始替换 ▼▼▼
/**
 * 【V2 - 完整版】保存NPC（新建或更新）
 */
async function saveNpc() {
    const chat = state.chats[state.activeChatId];

    
    // 从编辑器中获取所有数据
    const name = document.getElementById('npc-editor-name-input').value.trim();
    const persona = document.getElementById('preset-persona-input').value.trim();
    const avatar = document.getElementById('preset-avatar-preview').src;

    if (!name) {
        alert("NPC名字不能为空！");
        return;
    }

    if (editingNpcId) {
        // 更新现有的NPC
        const npc = chat.npcLibrary.find(n => n.id === editingNpcId);
        if (npc) {
            npc.name = name;
            npc.persona = persona;
            npc.avatar = avatar;
        }
    } else {
        // 添加一个全新的NPC
        const newNpc = {
            id: 'npc_' + Date.now(),
            name: name,
            persona: persona,
            avatar: avatar
        };
        chat.npcLibrary.push(newNpc);
    }

    await db.chats.put(chat);
    renderNpcList();
    closePersonaEditor(); // 复用关闭编辑器的函数
}
// ▲▲▲ 替换到这里结束 ▲▲▲


/**
 * 删除一个NPC
 * @param {string} npcId - 要删除的NPC的ID
 * @param {string} npcName - 要删除的NPC的名字，用于确认提示
 */
async function deleteNpc(npcId, npcName) {
    const confirmed = await showCustomConfirm(
        '删除NPC',
        `确定要从“${state.chats[state.activeChatId].name}”的NPC库中删除 “${npcName}” 吗？`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        const chat = state.chats[state.activeChatId];
        chat.npcLibrary = chat.npcLibrary.filter(n => n.id !== npcId);
        await db.chats.put(chat);
        renderNpcList();
    }
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// --- ▼▼▼ 【全新】自定义头像框管理功能 ▼▼▼ ---

function openFrameManager() {
    renderFrameManager();
    document.getElementById('custom-frame-manager-modal').classList.add('visible');
}

async function renderFrameManager() {
    const grid = document.getElementById('custom-frame-grid');
    grid.innerHTML = '';
    const customFrames = await db.customAvatarFrames.toArray();
    if (customFrames.length === 0) {
        grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center;">你还没有上传过头像框哦~</p>';
        return;
    }
    customFrames.forEach(frame => {
        const item = document.createElement('div');
        // 复用表情面板的样式，很方便
        item.className = 'sticker-item'; 
        item.style.backgroundImage = `url(${frame.url})`;
        item.title = frame.name;
        
        const deleteBtn = document.createElement('div');
        deleteBtn.className = 'delete-btn';
        deleteBtn.innerHTML = '×';
        deleteBtn.style.display = 'block';
        deleteBtn.onclick = async (e) => {
            e.stopPropagation();
            const confirmed = await showCustomConfirm('删除头像框', `确定要删除“${frame.name}”吗？`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                await db.customAvatarFrames.delete(frame.id);
                renderFrameManager(); // 刷新管理列表
            }
        };
        item.appendChild(deleteBtn);
        grid.appendChild(item);
    });
}

/**
 * 【V2多选版】处理用户上传自定义头像框的逻辑
 */
function handleUploadCustomFrame() {
    document.getElementById('custom-frame-upload-input').addEventListener('change', async (event) => {
        const files = event.target.files;
        if (!files.length) return;

        const newFrames = [];
        
        // 使用 for...of 循环来逐个处理选中的文件
        for (const file of files) {
            // 【核心修改】自动生成名字，而不是让用户输入
            // 我们用 "文件名 (前8位) + 时间戳" 来确保名字几乎不会重复
            const fileName = file.name.replace(/\.[^/.]+$/, "").substring(0, 8);
            const autoName = `${fileName}_${Date.now()}`;

            const base64Url = await new Promise(resolve => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.readAsDataURL(file);
            });
            
            newFrames.push({
                id: 'frame_' + (Date.now() + newFrames.length), // 确保ID唯一
                name: autoName,
                url: base64Url
            });
        }
        
        // 循环结束后，批量添加到数据库
        if (newFrames.length > 0) {
            await db.customAvatarFrames.bulkAdd(newFrames);
            renderFrameManager(); // 刷新管理列表
            await showCustomAlert("上传成功", `已成功添加 ${newFrames.length} 个新头像框！`);
        }

        // 清空文件选择器的值
        event.target.value = null;
    }, { once: true });

    document.getElementById('custom-frame-upload-input').click();
}

// ▲▲▲ 新增功能函数结束 ▲▲▲

// ▼▼▼ 用这块【已添加新分支】的代码替换旧的 ▼▼▼
async function openFrameSelectorModal(type, targetId = null) {
    const grid = document.getElementById('avatar-frame-grid');
    grid.innerHTML = '';
    
    currentFrameSelection.type = type;
    currentFrameSelection.target = targetId;
    
    const chat = state.chats[state.activeChatId];
    let currentFrameUrl = '';
    let previewAvatarUrl = '';

    // --- ▼▼▼ 这就是新增的分支逻辑！▼▼▼ ---
    if (type === 'char-weibo') { 
        // 如果是为“角色微博”换框
        const charChat = state.chats[currentViewingWeiboProfileId];
        currentFrameUrl = charChat.settings.weiboAvatarFrame || '';
        previewAvatarUrl = charChat.settings.weiboAvatar || defaultAvatar;
    }
    // --- ▲▲▲ 新增结束 ▲▲▲ ---
    else if (type === 'home_profile') {
        currentFrameUrl = state.globalSettings.homeAvatarFrame || '';
        previewAvatarUrl = document.getElementById('profile-avatar-img').src;
    } 
    else if (type === 'weibo_profile') {
        currentFrameUrl = state.qzoneSettings.weiboAvatarFrame || '';
        previewAvatarUrl = state.qzoneSettings.weiboAvatar || defaultAvatar;
    } 
    else if (type === 'ai') {
        currentFrameUrl = chat.settings.aiAvatarFrame || '';
        previewAvatarUrl = chat.settings.aiAvatar || defaultAvatar;
    } else if (type === 'my') {
        currentFrameUrl = chat.settings.myAvatarFrame || '';
        previewAvatarUrl = chat.settings.myAvatar || defaultAvatar;
    } else if (type === 'member' && targetId) {
        const member = chat.members.find(m => m.id === targetId);
        if (member) {
            currentFrameUrl = member.avatarFrame || '';
            previewAvatarUrl = member.avatar || defaultGroupMemberAvatar;
        }
    }
    
    // 后续渲染逻辑保持不变
    const customFrames = await db.customAvatarFrames.toArray();
    const frameUrlSet = new Set();
    const allFrames = [...avatarFrames, ...customFrames].filter(frame => {
        if (!frame.url || !frameUrlSet.has(frame.url)) {
            frameUrlSet.add(frame.url);
            return true;
        }
        return false;
    });

    allFrames.forEach(frame => {
        const item = createFrameItem(frame, previewAvatarUrl);
        if (currentFrameUrl === frame.url) {
            item.classList.add('selected');
            currentFrameSelection.url = frame.url;
        }
        grid.appendChild(item);
    });

    document.getElementById('avatar-frame-modal').classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲


// 辅助函数：创建一个头像框选项
function createFrameItem(frame, previewAvatarSrc) {
    const item = document.createElement('div');
    item.className = 'frame-item';
    item.title = frame.name;
    item.innerHTML = `
        <img src="${previewAvatarSrc}" class="preview-avatar">
        ${frame.url ? `<img src="${frame.url}" class="preview-frame" style="pointer-events: none;">` : ''}
    `;
    item.addEventListener('click', () => {
        document.querySelectorAll('#avatar-frame-grid .frame-item').forEach(el => el.classList.remove('selected'));
        item.classList.add('selected');
        currentFrameSelection.url = frame.url;
    });
    return item;
}

// 保存选择
// ▼▼▼ 【最终修复版】请用这整块代码，完整替换掉你旧的 saveSelectedFrames 函数 ▼▼▼
async function saveSelectedFrames() {
    const { type, url, target } = currentFrameSelection;

    // 对于不属于“角色设置”的功能 (比如主屏幕、微博)，保持原有的立即保存逻辑
    if (type === 'char-weibo') { 
        const charChat = state.chats[currentViewingWeiboProfileId];
        if (charChat) {
            charChat.settings.weiboAvatarFrame = url;
            await db.chats.put(charChat);
            await renderWeiboCharProfile(currentViewingWeiboProfileId);
        }
    } 
    else if (type === 'home_profile') {
        if (!state.globalSettings) state.globalSettings = {};
        state.globalSettings.homeAvatarFrame = url;
        await db.globalSettings.put(state.globalSettings);
        renderHomeScreenProfileFrame(); 
    } 
    else if (type === 'weibo_profile') {
        if (!state.qzoneSettings) state.qzoneSettings = {};
        state.qzoneSettings.weiboAvatarFrame = url;
        await saveQzoneSettings();
        await renderWeiboProfile();
    }
    // 【核心修改】对于“角色设置”里的头像框，我们不再立即保存，只在内存中更新
    else {
        const chat = state.chats[state.activeChatId];
        if (!chat) return; // 安全检查

        if (type === 'ai') {
            chat.settings.aiAvatarFrame = url;
        } else if (type === 'my') {
            chat.settings.myAvatarFrame = url;
        } else if (type === 'member' && target) {
            const member = chat.members.find(m => m.id === target);
            if (member) member.avatarFrame = url;
        }
        
        // ★★★ 修复关键 ★★★
        // 我们删除了这里所有的 await db.chats.put(chat);
        // 数据将在用户点击角色设置主面板的“保存”按钮时，与其他所有设置一起被保存。
        console.log(`头像框选择已暂存: type=${type}, url=${url}`);
    }
    
    // 只需关闭头像框选择弹窗即可，不做其他多余操作
    document.getElementById('avatar-frame-modal').classList.remove('visible');
    
    // ★★★ 修复关键 ★★★
    // 我们删除了下面这个会导致界面意外刷新并清空未保存内容的 if 代码块
    // if (type !== 'weibo_profile' && type !== 'home_profile' && type !== 'char-weibo') { ... }
}
// ▲▲▲ 替换结束 ▲▲▲


/**
 * 检查两个时间戳是否在不同的自然日
 * @param {number} timestamp1 - 新消息的时间戳
 * @param {number | null} timestamp2 - 上一条消息的时间戳
 * @returns {boolean} - 如果是新的一天，返回 true
 */
function isNewDay(timestamp1, timestamp2) {
    // 如果没有上一条消息的时间戳，说明这是第一条消息，肯定要显示日期
    if (!timestamp2) return true;

    const date1 = new Date(timestamp1);
    const date2 = new Date(timestamp2);

    // 比较年、月、日是否完全相同
    return date1.getFullYear() !== date2.getFullYear() ||
           date1.getMonth()    !== date2.getMonth()    ||
           date1.getDate()     !== date2.getDate();
}

/**
 * 将时间戳格式化为 "X月X日 HH:mm" 的形式
 * @param {number} timestamp - 时间戳
 * @returns {string} - 格式化后的日期字符串
 */
function formatDateStamp(timestamp) {
    const date = new Date(timestamp);
    const month = date.getMonth() + 1;
    const day = date.getDate();
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    return `${month}月${day}日 ${hours}:${minutes}`;
}

/**
 * 【全新】根据时间戳，格式化聊天列表右侧的日期/时间显示
 * @param {number} timestamp - 消息的时间戳
 * @returns {string} - 格式化后的字符串 (例如 "14:30", "昨天", "08/03")
 */
function formatChatListTimestamp(timestamp) {
    if (!timestamp) return ''; // 如果没有时间戳，返回空字符串

    const now = new Date();
    const msgDate = new Date(timestamp);

    // 判断是否为今天
    const isToday = now.getFullYear() === msgDate.getFullYear() &&
                    now.getMonth() === msgDate.getMonth() &&
                    now.getDate() === msgDate.getDate();

    if (isToday) {
        // 如果是今天，只显示时间
        return msgDate.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
    }

    // 判断是否为昨天
    const yesterday = new Date();
    yesterday.setDate(now.getDate() - 1);
    const isYesterday = yesterday.getFullYear() === msgDate.getFullYear() &&
                        yesterday.getMonth() === msgDate.getMonth() &&
                        yesterday.getDate() === msgDate.getDate();

    if (isYesterday) {
        return '昨天';
    }

    // 判断是否为今年
    if (now.getFullYear() === msgDate.getFullYear()) {
        // 如果是今年，显示 "月/日"
        const month = String(msgDate.getMonth() + 1).padStart(2, '0');
        const day = String(msgDate.getDate()).padStart(2, '0');
        return `${month}/${day}`;
    }

    // 如果是更早的年份，显示 "年/月/日"
    const year = msgDate.getFullYear();
    const month = String(msgDate.getMonth() + 1).padStart(2, '0');
    const day = String(msgDate.getDate()).padStart(2, '0');
    return `${year}/${month}/${day}`;
}

/**
 * 【全新】创建一个功能完整的日期戳“伪消息”元素
 * @param {number} timestamp - 该日期戳代表的时间
 * @returns {HTMLElement} - 创建好的 DOM 元素
 */
function createDateStampElement(timestamp) {
    // 1. 创建最外层的包裹 div，和真实消息一样
    const wrapper = document.createElement('div');
    wrapper.className = 'message-wrapper date-stamp-wrapper';
    // 【核心】把时间戳存起来，这是多选和删除的关键
    wrapper.dataset.timestamp = timestamp; 

    // 2. 创建气泡 div
    const bubble = document.createElement('div');
    // 【核心】同时加上 .message-bubble 类，让多选逻辑能找到它
    bubble.className = 'message-bubble date-stamp-bubble';
    bubble.dataset.timestamp = timestamp;
    bubble.textContent = formatDateStamp(timestamp);
    
    wrapper.appendChild(bubble);

    // 3. 【核心】为它绑定和真实消息完全一样的事件监听器
    addLongPressListener(wrapper, () => {
        // 日期戳不支持复杂操作，长按直接进入多选
        enterSelectionMode(timestamp);
    });
    wrapper.addEventListener('click', () => { 
        if (isSelectionMode) {
            toggleMessageSelection(timestamp);
        }
    });

    return wrapper;
}
// ▼▼▼ 在你的JS功能函数定义区，粘贴下面这一整块新代码 ▼▼▼

// --- 美化功能的核心变量 ---
let activeThemeId = null; // 用于追踪当前正在编辑的主题ID

/**
 * 将CSS代码应用到页面上
 * @param {string} cssCode - 要应用的CSS代码字符串
 */
function applyThemeCss(cssCode) {
    const styleTag = document.getElementById('custom-theme-style');
    if (styleTag) {
        styleTag.innerHTML = cssCode || '';
    }
}

/**
 * 从数据库加载所有主题到下拉选择框
 */
async function loadThemesToDropdown() {
    const selector = document.getElementById('theme-selector');
    selector.innerHTML = '<option value="">-- 选择方案或新建 --</option>'; // 默认选项
    
    const themes = await db.themes.toArray();
    themes.forEach(theme => {
        const option = document.createElement('option');
        option.value = theme.id;
        option.textContent = theme.name;
        selector.appendChild(option);
    });
}

/**
 * 处理用户从下拉框选择一个主题的逻辑
 */
async function handleThemeSelection() {
    const selector = document.getElementById('theme-selector');
    const editor = document.getElementById('theme-css-editor');
    activeThemeId = selector.value ? parseInt(selector.value) : null;
    
    if (activeThemeId) {
        const theme = await db.themes.get(activeThemeId);
        editor.value = theme.css;
    } else {
        // 如果选择“--”，就加载模板
        editor.value = THEME_CSS_TEMPLATE;
    }
    // 立即应用选中的或模板代码，让用户看到效果
    applyThemeCss(editor.value);
}

/**
 * 保存当前编辑区的内容到当前选中的主题
 */
async function saveCurrentTheme() {
    if (!activeThemeId) {
        alert("请先选择一个方案，或使用“另存为”来创建新方案。");
        return;
    }
    const cssCode = document.getElementById('theme-css-editor').value;
    await db.themes.update(activeThemeId, { css: cssCode });
    alert("当前方案已保存！");
}

/**
 * 将当前编辑区的内容另存为一个新主题
 */
async function saveAsNewTheme() {
    const themeName = await showCustomPrompt("保存新方案", "请输入新方案的名称");
    if (!themeName || !themeName.trim()) {
        if(themeName !== null) alert("方案名称不能为空！");
        return;
    }
    const cssCode = document.getElementById('theme-css-editor').value;
    const newTheme = { name: themeName.trim(), css: cssCode };
    const newId = await db.themes.add(newTheme);
    
    // 刷新下拉框并自动选中新保存的方案
    await loadThemesToDropdown();
    document.getElementById('theme-selector').value = newId;
    activeThemeId = newId;
    
    alert(`方案 "${themeName}" 已成功保存！`);
}

/**
 * 重命名当前选中的主题
 */
async function renameSelectedTheme() {
    if (!activeThemeId) {
        alert("请先选择一个要重命名的方案。");
        return;
    }
    const currentTheme = await db.themes.get(activeThemeId);
    const newName = await showCustomPrompt("重命名方案", "请输入新的名称", currentTheme.name);
    if (newName && newName.trim()) {
        await db.themes.update(activeThemeId, { name: newName.trim() });
        await loadThemesToDropdown();
        document.getElementById('theme-selector').value = activeThemeId;
        alert("重命名成功！");
    }
}

/**
 * 删除当前选中的主题
 */
async function deleteSelectedTheme() {
    if (!activeThemeId) {
        alert("请先选择一个要删除的方案。");
        return;
    }
    const confirmed = await showCustomConfirm(
        "确认删除", 
        `确定要删除方案 "${document.getElementById('theme-selector').selectedOptions[0].textContent}" 吗？`,
        { confirmButtonClass: 'btn-danger' }
    );
    if (confirmed) {
        await db.themes.delete(activeThemeId);
        activeThemeId = null;
        await loadThemesToDropdown();
        // 恢复到模板状态
        document.getElementById('theme-css-editor').value = THEME_CSS_TEMPLATE;
        applyThemeCss(THEME_CSS_TEMPLATE);
        alert("方案已删除。");
    }
}

/**
 * 导出当前选中的主题为一个JSON文件
 */
async function exportTheme() {
    if (!activeThemeId) {
        alert("请先选择一个要导出的方案。");
        return;
    }
    const theme = await db.themes.get(activeThemeId);
    const exportData = {
        themeName: theme.name,
        themeCss: theme.css
    };
    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${theme.name}-Theme.json`;
    a.click();
    URL.revokeObjectURL(url);
}

/**
 * 导入一个主题JSON文件
 */
function importTheme(file) {
    if (!file) return;
    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const data = JSON.parse(e.target.result);
            if (data.themeName && typeof data.themeCss !== 'undefined') {
                // 为了避免重名，导入时可以在名字后面加个 "(导入)"
                const newTheme = {
                    name: `${data.themeName} (导入)`,
                    css: data.themeCss
                };
                const newId = await db.themes.add(newTheme);
                await loadThemesToDropdown();
                document.getElementById('theme-selector').value = newId;
                handleThemeSelection(); // 导入后自动选中并应用
                alert(`方案 "${newTheme.name}" 导入成功！`);
            } else {
                alert("导入失败：文件格式不正确。");
            }
        } catch (error) {
            alert(`导入失败：文件解析错误。 ${error.message}`);
        }
    };
    reader.readAsText(file);
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 【全新】API预设功能核心函数 ▼▼▼

/**
 * 渲染并填充API预设的下拉选择框
 */
function renderApiPresetSelector() {
    const selectEl = document.getElementById('api-preset-select');
    if (!selectEl) return;

    selectEl.innerHTML = '<option value="">-- 自定义配置 --</option>';

    if (state.apiPresets) {
        state.apiPresets.forEach(preset => {
            const option = document.createElement('option');
            option.value = preset.id;
            option.textContent = preset.name;
            selectEl.appendChild(option);
        });
    }

    // 检查当前配置是否匹配任何一个预设
    const { proxyUrl, apiKey } = state.apiConfig;
    const matchingPreset = state.apiPresets ? state.apiPresets.find(p => p.proxyUrl === proxyUrl && p.apiKey === apiKey) : null;

    if (matchingPreset) {
        selectEl.value = matchingPreset.id;
    } else {
        selectEl.value = ""; // 如果不匹配任何预设，则选中“自定义配置”
    }
}

/**
 * 当用户在下拉框中选择一个预设时触发
 */
function handleApiPresetSelectChange() {
    const selectEl = document.getElementById('api-preset-select');
    const proxyUrlInput = document.getElementById('proxy-url');
    const apiKeyInput = document.getElementById('api-key');
    const selectedId = parseInt(selectEl.value);

    if (selectedId && state.apiPresets) {
        const selectedPreset = state.apiPresets.find(p => p.id === selectedId);
        if (selectedPreset) {
            proxyUrlInput.value = selectedPreset.proxyUrl;
            apiKeyInput.value = selectedPreset.apiKey;
        }
    }
}

/**
 * 打开预设管理的操作菜单
 */
async function openApiPresetManager() {
    const selectEl = document.getElementById('api-preset-select');
    const selectedId = parseInt(selectEl.value);
    const selectedPreset = state.apiPresets ? state.apiPresets.find(p => p.id === selectedId) : null;

    const modal = document.getElementById('preset-actions-modal');
    const footer = modal.querySelector('.custom-modal-footer');

    footer.innerHTML = `
        <button id="preset-action-save-new">保存当前配置为新预设</button>
        <button id="preset-action-update-current" ${!selectedPreset ? 'disabled' : ''}>更新当前配置</button>
        <button id="preset-action-delete-current" class="btn-danger" ${!selectedPreset ? 'disabled' : ''}>删除当前配置</button>
        <button id="preset-action-cancel" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">取消</button>
    `;

    document.getElementById('preset-action-save-new').addEventListener('click', saveCurrentApiConfigAsPreset);
    if (selectedPreset) {
        document.getElementById('preset-action-update-current').addEventListener('click', () => updateSelectedApiPreset(selectedId));
        document.getElementById('preset-action-delete-current').addEventListener('click', () => deleteSelectedApiPreset(selectedId));
    }
    document.getElementById('preset-action-cancel').addEventListener('click', () => modal.classList.remove('visible'));

    modal.classList.add('visible');
}

/**
 * 将当前输入框的内容保存为一个新的预设
 */
async function saveCurrentApiConfigAsPreset() {
    const proxyUrl = document.getElementById('proxy-url').value.trim();
    const apiKey = document.getElementById('api-key').value.trim();

    if (!proxyUrl || !apiKey) {
        alert('代理地址和密钥都不能为空！');
        return;
    }

    const name = await showCustomPrompt('保存API预设', '请为这个配置起个名字：');
    if (name && name.trim()) {
        const newPreset = { name: name.trim(), proxyUrl, apiKey };
        const newId = await db.apiPresets.add(newPreset);
        
        if (!state.apiPresets) state.apiPresets = [];
        state.apiPresets.push({ id: newId, ...newPreset });

        renderApiPresetSelector(); 
        document.getElementById('api-preset-select').value = newId; 
        document.getElementById('preset-actions-modal').classList.remove('visible');
        await showCustomAlert('成功', `API预设 "${name.trim()}" 已保存！`);
    }
}

/**
 * 更新当前选中的预设
 */
async function updateSelectedApiPreset(presetId) {
    const proxyUrl = document.getElementById('proxy-url').value.trim();
    const apiKey = document.getElementById('api-key').value.trim();

    if (!proxyUrl || !apiKey) {
        alert('代理地址和密钥都不能为空！');
        return;
    }

    const preset = state.apiPresets.find(p => p.id === presetId);
    if (preset) {
        preset.proxyUrl = proxyUrl;
        preset.apiKey = apiKey;
        await db.apiPresets.put(preset);
        document.getElementById('preset-actions-modal').classList.remove('visible');
        await showCustomAlert('成功', `预设 "${preset.name}" 已更新！`);
    }
}

/**
 * 删除当前选中的预设
 */
async function deleteSelectedApiPreset(presetId) {
    const preset = state.apiPresets.find(p => p.id === presetId);
    if (preset) {
        const confirmed = await showCustomConfirm('确认删除', `确定要删除API预设 "${preset.name}" 吗？`, { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            await db.apiPresets.delete(presetId);
            state.apiPresets = state.apiPresets.filter(p => p.id !== presetId);

            renderApiPresetSelector();
            document.getElementById('preset-actions-modal').classList.remove('visible');
            await showCustomAlert('成功', '预设已删除。');
        }
    }
}

// ▼▼▼ 【全新】气泡样式预设功能的核心函数 ▼▼▼

/**
 * 渲染并填充气泡样式预设的下拉选择框
 */
function renderBubblePresetSelector() {
    const selectEl = document.getElementById('bubble-style-preset-select');
    const customCssInput = document.getElementById('custom-css-input');

    selectEl.innerHTML = '<option value="">-- 无预设 --</option>';

    if (state.bubbleStylePresets) {
        state.bubbleStylePresets.forEach(preset => {
            const option = document.createElement('option');
            option.value = preset.id;
            option.textContent = preset.name;
            selectEl.appendChild(option);
        });
    }

    // 检查当前聊天的CSS是否匹配任何一个预设
    const currentCss = customCssInput.value.trim();
    const matchingPreset = state.bubbleStylePresets ? state.bubbleStylePresets.find(p => p.css.trim() === currentCss) : null;

    if (matchingPreset) {
        selectEl.value = matchingPreset.id;
    } else {
        selectEl.value = ""; // 如果不匹配任何预设，则选中“无预设”
    }
}

/**
 * 当用户在下拉框中选择一个预设时触发
 */
function handlePresetSelectChange() {
    const selectEl = document.getElementById('bubble-style-preset-select');
    const customCssInput = document.getElementById('custom-css-input');
    const selectedId = parseInt(selectEl.value);

    if (selectedId && state.bubbleStylePresets) {
        const selectedPreset = state.bubbleStylePresets.find(p => p.id === selectedId);
        if (selectedPreset) {
            customCssInput.value = selectedPreset.css;
        }
    }
    updateSettingsPreview(); // 无论如何都更新预览
}

/**
 * 打开预设管理的操作菜单
 */
async function openBubblePresetManager() {
    const selectEl = document.getElementById('bubble-style-preset-select');
    const selectedId = parseInt(selectEl.value);
    const selectedPreset = state.bubbleStylePresets ? state.bubbleStylePresets.find(p => p.id === selectedId) : null;

    const modal = document.getElementById('preset-actions-modal'); // 复用现有模态框
    const footer = modal.querySelector('.custom-modal-footer');

    footer.innerHTML = `
        <button id="preset-action-save-new">保存</button>
        <button id="preset-action-update-current" ${!selectedPreset ? 'disabled' : ''}>更新</button>
        <button id="preset-action-delete-current" class="btn-danger" ${!selectedPreset ? 'disabled' : ''}>删除</button>
        <button id="preset-action-cancel" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">取消</button>
    `;

    // 重新绑定事件
    document.getElementById('preset-action-save-new').addEventListener('click', saveCurrentCssAsPreset);
    if (selectedPreset) {
        document.getElementById('preset-action-update-current').addEventListener('click', () => updateSelectedPreset(selectedId));
        document.getElementById('preset-action-delete-current').addEventListener('click', () => deleteSelectedPreset(selectedId));
    }
    document.getElementById('preset-action-cancel').addEventListener('click', () => modal.classList.remove('visible'));

    modal.classList.add('visible');
}

/**
 * 将当前CSS文本框的内容保存为一个新的预设
 */
async function saveCurrentCssAsPreset() {
    const customCssInput = document.getElementById('custom-css-input');
    const css = customCssInput.value.trim();
    if (!css) {
        alert('CSS内容不能为空！');
        return;
    }

    const name = await showCustomPrompt('保存预设', '请为这个气泡样式命名：');
    if (name && name.trim()) {
        const newPreset = { name: name.trim(), css: css };
        const newId = await db.bubbleStylePresets.add(newPreset);
        
        if (!state.bubbleStylePresets) state.bubbleStylePresets = [];
        state.bubbleStylePresets.push({ id: newId, ...newPreset });

        renderBubblePresetSelector(); 
        document.getElementById('bubble-style-preset-select').value = newId; 
        document.getElementById('preset-actions-modal').classList.remove('visible');
        await showCustomAlert('成功', `预设 "${name.trim()}" 已保存！`);
    }
}

/**
 * 更新当前选中的预设
 */
async function updateSelectedPreset(presetId) {
    const customCssInput = document.getElementById('custom-css-input');
    const css = customCssInput.value.trim();

    const preset = state.bubbleStylePresets.find(p => p.id === presetId);
    if (preset) {
        preset.css = css;
        await db.bubbleStylePresets.put(preset);
        document.getElementById('preset-actions-modal').classList.remove('visible');
        await showCustomAlert('成功', `预设 "${preset.name}" 已更新！`);
    }
}

/**
 * 删除当前选中的预设
 */
async function deleteSelectedPreset(presetId) {
    const preset = state.bubbleStylePresets.find(p => p.id === presetId);
    if (preset) {
        const confirmed = await showCustomConfirm('确认删除', `确定要删除预设 "${preset.name}" 吗？`, { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            await db.bubbleStylePresets.delete(presetId);
            state.bubbleStylePresets = state.bubbleStylePresets.filter(p => p.id !== presetId);

            renderBubblePresetSelector(); 
            document.getElementById('custom-css-input').value = '';
            updateSettingsPreview();

            document.getElementById('preset-actions-modal').classList.remove('visible');
            await showCustomAlert('成功', '预设已删除。');
        }
    }
}

// ▼▼▼ 【全新】来电铃声控制函数 ▼▼▼

/**
 * 播放来电铃声
 */
function playRingtone() {
    const ringtonePlayer = document.getElementById('ringtone-player');
    // 优先使用用户在设置中保存的URL，如果没设置，就用我们预设的URL
    const ringtoneUrl = state.globalSettings.ringtoneUrl || 'https://files.catbox.moe/3w7gla.mp3';
    
    if (ringtonePlayer && ringtoneUrl) {
        ringtonePlayer.src = ringtoneUrl;
        // play() 返回一个 Promise，我们最好用 try...catch 包裹以防止浏览器报错
        const playPromise = ringtonePlayer.play();
        if (playPromise !== undefined) {
            playPromise.catch(error => {
                console.error("铃声播放失败:", error);
                // 可以在这里给用户一个静音提示，如果需要的话
            });
        }
    }
}

/**
 * 停止并重置来电铃声
 */
function stopRingtone() {
    const ringtonePlayer = document.getElementById('ringtone-player');
    if (ringtonePlayer) {
        ringtonePlayer.pause();
        ringtonePlayer.currentTime = 0; // 将播放进度重置到开头
    }
}


// ▼▼▼ 请用下面这段【优化后】的代码替换 ▼▼▼
/**
 * 【优化版】播放消息提示音，增加健壮性
 */
function playNotificationSound() {
    const soundUrl = state.globalSettings.notificationSoundUrl || 'https://laddy-lulu.github.io/Ephone-stuffs/message.mp3';
    
    // 1. 增加安全检查：如果链接为空，直接返回，不执行任何操作
    if (!soundUrl || !soundUrl.trim()) return;

    try {
        const audio = new Audio(soundUrl);
        audio.volume = 0.7; 
        
        audio.play().catch(error => {
            // 2. 优化错误提示，现在能更准确地反映问题
            if (error.name === 'NotAllowedError') {
                console.warn("播放消息提示音失败：用户需要先与页面进行一次交互（如点击）才能自动播放音频。");
            } else {
                // 对于其他错误（比如我们这次遇到的），直接打印错误详情
                console.error(`播放消息提示音失败 (${error.name}): ${error.message}`, "URL:", soundUrl);
            }
        });
    } catch (error) {
        console.error("创建提示音Audio对象时出错:", error);
    }
}
// ▲▲▲ 替换结束 ▲▲▲

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 【全新】音频上下文解锁函数（修复铃声无法自动播放的问题） ▼▼▼
function unlockAudioContext() {
    const ringtonePlayer = document.getElementById('ringtone-player');
    // 检查播放器是否处于暂停状态，并且我们之前没有成功播放过
    if (ringtonePlayer && ringtonePlayer.paused) {
        // 尝试播放，然后立刻暂停。
        // 这个操作对用户是无感知的，但能告诉浏览器用户已与音频交互。
        ringtonePlayer.play().catch(() => {}); // play() 会返回一个 Promise，我们忽略任何可能发生的错误
        ringtonePlayer.pause();
        console.log("Ringtone audio context unlocked.");
    }
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲
// ▼▼▼ 【全新】“查手机”内容单条删除功能 ▼▼▼
/**
 * 处理角色手机内数据删除的通用函数
 * @param {string} dataType - 要删除的数据类型, 比如 'memos', 'shoppingCart'
 * @param {number} index - 要删除的数据在数组中的索引
 */
async function handleCharacterDataDeletion(dataType, index) {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    
    let dataArray;
    // 处理像 bank.transactions 这样的嵌套数据
    if (dataType.includes('.')) {
        const keys = dataType.split('.');
        dataArray = chat.characterPhoneData[keys[0]][keys[1]];
    } else {
        dataArray = chat.characterPhoneData[dataType];
    }

    if (!chat || !dataArray) return;

    const itemToDelete = dataArray[index];
    if (!itemToDelete) return;

    const confirmed = await showCustomConfirm(
        '确认删除',
        '确定要删除这条记录吗？',
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        dataArray.splice(index, 1);
        await db.chats.put(chat);
        
        // 根据删除的类型，重新渲染对应的APP界面
        switch(dataType) {
            case 'memos': renderCharacterMemos(); break;
            case 'shoppingCart': renderCharacterShoppingCart(); break;
            case 'browserHistory': renderCharacterBrowser(); break;
            case 'diary': renderCharacterDiary(); break;
            case 'bank.transactions': renderCharacterBank(); break;
            case 'trajectory': renderCharacterTrajectory(); break;
            case 'appUsage': renderCharacterAppUsage(); break;
            case 'photoAlbum': renderCharacterPhotoAlbum(); break;
        }
        alert('记录已删除。');
    }
}
// ▲▲▲ 删除功能结束 ▲▲▲
/**
 * 【全新】处理角色手机内单条聊天消息的删除
 * @param {string} contactName - 正在查看的联系人名称
 * @param {number} index - 要删除的消息在历史记录中的索引
 */
async function handleCharacterChatMessageDeletion(contactName, index) {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    if (!chat) return;

    let historyArray;
    // 判断是和“我”的聊天还是和NPC的聊天
    if (contactName === (chat.characterPhoneData.chats['我']?.remarkName || '我')) {
        historyArray = chat.history;
    } else {
        historyArray = chat.characterPhoneData.chats[contactName]?.history;
    }

    if (!historyArray || !historyArray[index]) return;

    const confirmed = await showCustomConfirm(
        '确认删除',
        '确定要删除这条消息吗？',
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        historyArray.splice(index, 1);
        await db.chats.put(chat);
        
        // 重新渲染当前聊天界面
        renderCharacterChatHistory(contactName);
        alert('消息已删除。');
    }
}

// ▼▼▼ 【全新】锁屏功能核心函数 ▼▼▼

/**
 * 应用锁屏壁纸到 #lock-screen 元素
 */
function applyLockscreenWallpaper() {
    const lockScreen = document.getElementById('lock-screen');
    const wallpaper = state.globalSettings.lockscreenWallpaper;
    if (wallpaper && wallpaper.startsWith('data:image')) {
        lockScreen.style.backgroundImage = `url(${wallpaper})`;
    } else if (wallpaper) {
        lockScreen.style.backgroundImage = wallpaper;
    }
}

/**
 * 显示锁屏界面
 */
function lockPhone() {
    console.log("正在锁定手机...");
    isLocked = true;
    document.getElementById('lock-screen').classList.add('active');
    document.querySelectorAll('.screen:not(#lock-screen)').forEach(s => s.classList.remove('active'));
}

/**
 * 解锁手机，显示主屏幕
 */
function unlockPhone() {
    console.log("手机已解锁！");
    isLocked = false;
        // 【核心修改】在这里彻底隐藏锁屏和毛玻璃背景
    document.getElementById('lock-screen').classList.remove('active');
    const blurBg = document.getElementById('lock-screen-background-blur');
    blurBg.style.display = 'none';
    blurBg.style.opacity = '0';

    // 确保主屏幕是唯一激活的顶层屏幕
    showScreen('home-screen'); 

    // 重置锁屏的样式，为下次锁定做准备
    setTimeout(() => {
        const lockScreen = document.getElementById('lock-screen');
        const unlockHint = document.getElementById('unlock-hint');
        lockScreen.style.transition = 'none'; 
        unlockHint.style.transition = 'none';
        lockScreen.style.transform = 'translateY(0)';
        lockScreen.offsetHeight; 
        lockScreen.style.transition = 'transform 0.3s ease-out';
        unlockHint.style.transition = 'opacity 0.3s ease-out';
    }, 500); 
}

/**
 * 显示密码输入弹窗
 */
function showPasswordModal() {
    const modal = document.getElementById('password-modal-overlay');
    const input = document.getElementById('password-input-field');
    input.value = ''; // 清空上次输入
    modal.classList.add('visible');
    setTimeout(() => input.focus(), 100); // 延迟聚焦，确保动画流畅
}

/**
 * 隐藏密码输入弹窗
 */
function hidePasswordModal() {

document.getElementById('password-modal-overlay').style.backgroundImage = 'none';

    const modal = document.getElementById('password-modal-overlay');
    modal.classList.remove('visible');
    // 移除可能存在的错误动画类
    modal.querySelector('.password-modal-content').classList.remove('error');
    // 【核心修改】当取消输入密码时...
    // 1. 隐藏毛玻璃背景
    const blurBg = document.getElementById('lock-screen-background-blur');
    blurBg.style.opacity = '0';
    setTimeout(() => { blurBg.style.display = 'none'; }, 300); // 动画结束后再隐藏

    // 2. 让锁屏界面滑回来
    const lockScreen = document.getElementById('lock-screen');
    const unlockHint = document.getElementById('unlock-hint');
    lockScreen.style.transform = 'translateY(0)';
    unlockHint.style.opacity = '1';
}

/**
 * 检查用户输入的密码是否正确
 */
function checkPassword() {
    const input = document.getElementById('password-input-field');
    const enteredPassword = input.value;
    const correctPassword = state.globalSettings.password;

    if (enteredPassword === correctPassword) {
        // --- 密码正确 ---

        // 1. 【核心魔术】提前把主屏幕在最底层激活并准备好！
        //    因为它 z-index 最低，所以你暂时还看不到它。
        showScreen('home-screen');

        // 2. 隐藏密码输入框 (它会自己播放淡出动画)
        document.getElementById('password-modal-overlay').classList.remove('visible');
        
        // 3. 让毛玻璃背景也开始淡出
        document.getElementById('lock-screen-background-blur').style.opacity = '0';
        
        // 4. 等待淡出动画播放完毕 (300毫秒)，再执行最终的清理工作
        setTimeout(unlockPhone, 300);

    } else {
        // --- 密码错误 (逻辑保持不变) ---
        const content = document.querySelector('.password-modal-content');
        content.classList.add('error');
        input.value = '';
        setTimeout(() => content.classList.remove('error'), 400);
    }
}

/**
 * 更新锁屏界面的时钟
 */
function updateLockClock() {
    const now = new Date();
    const timeString = now.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
    const dateString = now.toLocaleDateString('zh-CN', { weekday: 'long', month: 'long', day: 'numeric' });
    document.getElementById('lock-main-time').textContent = timeString;
    document.getElementById('lock-main-date').textContent = dateString;
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 在你的JS功能函数定义区，粘贴下面这一整块新代码 ▼▼▼

async function openBulkAddStickersModal() {
    const placeholder = `在这里粘贴表情包，每行一个，格式如下：\n\n猫猫喝水：https://..../cat.gif\n狗狗摇头：https://..../dog.png\n\n(支持用中文冒号“：”、英文冒号“:”或空格分隔)`;

    const textInput = await showCustomPrompt(
        "批量添加表情(URL)",
        "一行一个，名称和链接用冒号或空格隔开",
        "",
        'textarea'
    );

    if (!textInput || !textInput.trim()) {
        return;
    }

    const lines = textInput.trim().split('\n');
    const newStickers = [];
    let successCount = 0;
    let errorLines = [];

    lines.forEach((line, index) => {
        line = line.trim();
        if (!line) return;

        let name = '';
        let url = '';
        let splitIndex = -1;

        // --- 核心修复：使用更智能的分割逻辑 ---
        // 1. 查找 URL 的起始位置
        const httpIndex = line.indexOf('http');
        const dataIndex = line.indexOf('data:image');

        if (httpIndex > -1) {
            splitIndex = httpIndex;
        } else if (dataIndex > -1) {
            splitIndex = dataIndex;
        }

        // 2. 如果找到了 URL 的起始位置
        if (splitIndex > 0) {
            // URL 之前的所有内容都属于名称
            name = line.substring(0, splitIndex).trim();
            // 从 URL 起始位置到末尾的所有内容都属于 URL
            url = line.substring(splitIndex).trim();
            
            // 3. 清理名称末尾可能存在的分隔符
            if (name.endsWith(':') || name.endsWith('：')) {
                name = name.slice(0, -1).trim();
            }

        } else {
            // 如果找不到 URL，说明格式有问题
            errorLines.push(index + 1);
            return; // 跳过此行
        }
        // --- 修复结束 ---

        if (name && (url.startsWith('http') || url.startsWith('data:image'))) {
            newStickers.push({
                id: 'sticker_' + (Date.now() + index),
                url: url,
                name: name
            });
            successCount++;
        } else {
            errorLines.push(index + 1);
        }
    });

    if (newStickers.length > 0) {
        await db.userStickers.bulkAdd(newStickers);
        state.userStickers.push(...newStickers);
        renderStickerPanel();
    }

    let reportMessage = `批量导入完成！\n\n成功导入：${successCount} 个表情。`;
    if (errorLines.length > 0) {
        reportMessage += `\n失败行号：${errorLines.join(', ')}。\n\n请检查这些行的格式是否正确。`;
    }
    await showCustomAlert("导入报告", reportMessage);
}

// ▼▼▼ 【全新】粘贴这两个新函数到你的JS功能函数定义区 ▼▼▼

/**
 * 【全新】根据距离文本，计算CSS宽度百分比
 * @param {string} distanceText - 距离描述，例如 "500m", "10km", "很近"
 * @returns {number} - 10到90之间的百分比
 */
function calculatePinDistancePercentage(distanceText) {
    if (!distanceText) return 50; // 默认值

    const text = distanceText.toLowerCase();
    // 提取数字部分
    const matches = text.match(/(\d+(\.\d+)?)/);
    const num = matches ? parseFloat(matches[1]) : 0;

    // 根据单位或关键词判断
    if (text.includes('km') || text.includes('公里')) {
        if (num > 1000) return 90;
        if (num > 100) return 80;
        if (num > 10) return 70;
        if (num > 1) return 60;
        return 50;
    } else if (text.includes('m') || text.includes('米')) {
        if (num > 500) return 40;
        if (num > 100) return 30;
        return 20;
    } else if (text.includes('远') || text.includes('不同城市')) {
        return 90;
    } else if (text.includes('附近') || text.includes('隔壁')) {
        return 20;
    } else if (text.includes('近')) {
        return 30;
    }
    
    return 15; // 如果无法识别，给一个最小的距离
}


// ▼▼▼ 用这整块【全新代码】，替换旧的 sendUserLocation 函数 ▼▼▼

/**
 * 【全新】在定位模态框中添加一个途经点输入框
 */
function addTrajectoryPointInput(name = '') {
    const container = document.getElementById('trajectory-points-container');
    const div = document.createElement('div');
    div.style.display = 'flex';
    div.style.gap = '8px';
    div.innerHTML = `
        <input type="text" class="trajectory-point-input" placeholder="途经点${container.children.length + 1}" value="${name}" style="flex-grow: 1;">
        <button class="remove-option-btn">-</button>
    `;
    div.querySelector('.remove-option-btn').addEventListener('click', () => div.remove());
    container.appendChild(div);
}

// ▼▼▼ 请用这整块【已修复】的代码，替换你旧的 sendUserLocation 函数 ▼▼▼

async function sendUserLocation() {
    if (!state.activeChatId) return;

    const userLocation = document.getElementById('user-location-input').value.trim();
    const aiLocation = document.getElementById('ai-location-input').value.trim();
    const distance = document.getElementById('distance-input').value.trim();

    if (!distance || (!userLocation && !aiLocation)) {
        alert("“我的位置”和“Ta的位置”至少要填写一个，且“相距”为必填项！");
        return;
    }

    const trajectoryPoints = Array.from(document.querySelectorAll('.trajectory-point-input'))
        .map(input => ({ name: input.value.trim() }))
        .filter(point => point.name);

    const chat = state.chats[state.activeChatId];
    
    // --- ▼▼▼【核心修改从这里开始】▼▼▼ ---

    // 1. 根据用户输入，构建一条AI能看懂的文本内容
    //    这个格式和AI自己发定位时用的格式保持一致，非常完美！
    let contentString = '[SEND_LOCATION]';
    if (userLocation) contentString += ` 我的位置: ${userLocation}`;
    if (aiLocation) contentString += ` | 你的位置: ${aiLocation}`;
    contentString += ` | 相距: ${distance}`;
    if (trajectoryPoints.length > 0) {
        const trajectoryText = trajectoryPoints.map(p => p.name).join(', ');
        contentString += ` | 途经点: ${trajectoryText}`;
    }

    // 2. 创建消息对象，这次我们把刚刚创建的 contentString 也放了进去
    const locationMessage = {
        role: 'user',
        type: 'location',
        timestamp: Date.now(),
        userLocation: userLocation,
        aiLocation: aiLocation,
        distance: distance,
        trajectoryPoints: trajectoryPoints,
        content: contentString // <-- 这就是最关键的新增属性！
    };
    
    // --- ▲▲▲【核心修改结束】▲▲▲ ---

    // 后续的保存和渲染逻辑保持不变
    chat.history.push(locationMessage);
    await db.chats.put(chat);
    appendMessage(locationMessage, chat);
    renderChatList();

    document.getElementById('send-location-modal').classList.remove('visible');
}
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 【全新】“一键重roll”功能核心代码 ▼▼▼

/**
 * 智能查找AI上一轮回复的所有消息
 * @param {Array} history - 完整的聊天历史记录
 * @returns {Array} - 一个包含了上一轮AI所有消息对象的数组
 */
function findLastAiTurnMessages(history) {
    const turnMessages = [];
    let lastMessageIndex = history.length - 1;

    // 从最后一条消息开始，向前查找
    for (let i = lastMessageIndex; i >= 0; i--) {
        const message = history[i];
        
        // 如果是AI的消息，就把它加入我们的“待删除列表”
        if (message.role === 'assistant') {
            turnMessages.unshift(message); // 使用 unshift 保持原始顺序
        } 
        // 一旦遇到非AI的消息（用户的或系统的），说明AI的这一轮回复已经结束了，立刻停止查找
        else {
            break;
        }
    }
    return turnMessages;
}

/**
 * “重roll”按钮被点击时的主处理函数
 */
async function handleRerollClick() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];

    // 1. 调用我们的智能查找函数，找出需要删除的消息
    const messagesToReroll = findLastAiTurnMessages(chat.history);

    // 2. 如果没找到（比如最后一条是用户发的），就提示并退出
    if (messagesToReroll.length === 0) {
        alert("请在AI回复后使用此功能。");
        return;
    }

    // 3. 从聊天记录中过滤掉这些旧消息
    const timestampsToReroll = new Set(messagesToReroll.map(m => m.timestamp));
    chat.history = chat.history.filter(msg => !timestampsToReroll.has(msg.timestamp));
    
    // 4. 保存更新后的聊天记录到数据库
    await db.chats.put(chat);

    // 5. 刷新聊天界面，让旧消息瞬间消失
    renderChatInterface(state.activeChatId);

    // 6. 触发一次新的AI响应，就像用户点击了“等待回复”一样
    triggerAiResponse();
}
// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 【全新简化版】粘贴这个完整的拖动功能函数 ▼▼▼
function initDraggableLyricsBar() {
    const bar = document.getElementById('floating-lyrics-bar');
    const phoneScreen = document.getElementById('phone-screen');
    
    let isDragging = false;
    let offsetX, offsetY;

    const onDragStart = (e) => {
        // 【问题2修复】检查点击的是否是按钮，如果是，则不开始拖动
        if (e.target.closest('#lyrics-settings-btn') || e.target.closest('.close-btn')) {
            return;
        }

        isDragging = true;
        bar.classList.add('dragging');
        
        const rect = bar.getBoundingClientRect();
        const coords = getEventCoords(e);

        offsetX = coords.x - rect.left;
        offsetY = coords.y - rect.top;

        document.addEventListener('mousemove', onDragMove);
        document.addEventListener('mouseup', onDragEnd);
        document.addEventListener('touchmove', onDragMove, { passive: false });
        document.addEventListener('touchend', onDragEnd);
    };

    const onDragMove = (e) => {
        if (!isDragging) return;
        
        e.preventDefault();

        const phoneRect = phoneScreen.getBoundingClientRect();
        const coords = getEventCoords(e);

        let newLeft = coords.x - offsetX - phoneRect.left;
        let newTop = coords.y - offsetY - phoneRect.top;

        const maxLeft = phoneScreen.clientWidth - bar.offsetWidth;
        const maxTop = phoneScreen.clientHeight - bar.offsetHeight;

        newLeft = Math.max(0, Math.min(newLeft, maxLeft));
        newTop = Math.max(0, Math.min(newTop, maxTop));
        
        // 【问题1修复】在拖动时，同时设置left, top并清除transform
        bar.style.left = `${newLeft}px`;
        bar.style.top = `${newTop}px`;
        bar.style.transform = 'none';
    };

    const onDragEnd = () => {
        if (!isDragging) return;
        isDragging = false;
        bar.classList.remove('dragging');

        document.removeEventListener('mousemove', onDragMove);
        document.removeEventListener('mouseup', onDragEnd);
        document.removeEventListener('touchmove', onDragMove);
        document.removeEventListener('touchend', onDragEnd);
    };

    bar.addEventListener('mousedown', onDragStart);
    bar.addEventListener('touchstart', onDragStart, { passive: true });
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 【全新】粘贴这个完整的函数 ▼▼▼
function applyLyricsSettings() {
    const bar = document.getElementById('floating-lyrics-bar');
    const toggleBtn = document.getElementById('toggle-lyrics-bar-btn');
    
    // 应用样式
    bar.style.fontSize = `${lyricsBarSettings.fontSize}px`;
    bar.style.color = lyricsBarSettings.fontColor;
    bar.style.backgroundColor = `rgba(0, 0, 0, ${lyricsBarSettings.bgOpacity / 100})`;

    // 更新设置模态框里的控件值
    document.getElementById('lyrics-font-size-slider').value = lyricsBarSettings.fontSize;
    document.getElementById('lyrics-font-size-value').textContent = `${lyricsBarSettings.fontSize}px`;
    document.getElementById('lyrics-bg-opacity-slider').value = lyricsBarSettings.bgOpacity;
    document.getElementById('lyrics-bg-opacity-value').textContent = `${lyricsBarSettings.bgOpacity}%`;
    document.getElementById('lyrics-font-color-picker').value = lyricsBarSettings.fontColor;
    
    // 【问题4需要】更新播放器里的开关按钮状态
    if (toggleBtn) {
        toggleBtn.textContent = lyricsBarSettings.showOnClose ? '悬浮' : '隐藏';
        toggleBtn.style.opacity = lyricsBarSettings.showOnClose ? '1' : '0.5';
    }
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 用下面这块【已修复】的代码，替换旧的 getCountdownContext 函数 ▼▼▼
/**
 * 【全新】获取并格式化【与当前聊天相关】的约定，生成给AI看的上下文
 * @param {string} chatId - 当前正在聊天的角色ID
 * @returns {Promise<string>} 格式化后的约定信息字符串
 */
async function getCountdownContext(chatId) {
    // 1. 从数据库中找出所有“约定”类型，并且目标日期还没到的记录
    const activeCountdowns = await db.memories
        .where('type').equals('countdown')
        .filter(item => 
            item.targetDate > Date.now() &&
            // ★★★★★ 这就是我们这次修复的核心！ ★★★★★
            // 它现在只会查找两种约定：
            // 1. chatId 和当前聊天角色ID匹配的 (AI自己创建的)
            // 2. chatId 为空的 (你，也就是用户创建的全局约定)
            (item.chatId === chatId || item.chatId === null)
        )
        .toArray();

    // 如果没有与当前角色相关的约定，就告诉AI“目前没有”
    if (activeCountdowns.length === 0) {
        return "\n- **近期约定**: 目前没有特别的约定。";
    }

    // 2. 后续的整理报告逻辑保持不变
    let context = "\n# 近期约定与倒计时 (重要参考信息)\n";
    const now = Date.now();

    activeCountdowns.forEach(item => {
        const diff = item.targetDate - now;
        const diffDays = Math.floor(diff / (1000 * 60 * 60 * 24));
        const diffHours = Math.floor(diff / (1000 * 60 * 60));

        let timeText;
        if (diffDays > 1) {
            timeText = `还有 ${diffDays} 天`;
        } else if (diffHours > 0) {
            timeText = `还有 ${diffHours} 小时`;
        } else {
            timeText = "就是现在！";
        }
        
        context += `- **${item.description}**: ${timeText} (目标: ${new Date(item.targetDate).toLocaleString()})\n`;
    });

    return context;
}
// ▲▲▲ 替换结束 ▲▲▲



// ▼▼▼ 【全新】“查角色手机”功能的所有核心函数 ▼▼▼

/**
 * 入口：打开角色选择界面
 */
async function openCharacterSelectionScreen() {
    await renderCharacterSelectionScreen();
    showScreen('character-selection-screen');
}

/**
 * 渲染角色选择列表
 */
async function renderCharacterSelectionScreen() {
    const listEl = document.getElementById('character-selection-list');
    listEl.innerHTML = '';
    const characters = Object.values(state.chats).filter(chat => !chat.isGroup);

    if (characters.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">还没有可以查看的角色</p>';
        return;
    }

    characters.forEach(char => {
        const item = document.createElement('div');
        item.className = 'character-select-item';
        item.dataset.chatId = char.id;
        item.innerHTML = `
            <img src="${char.settings.aiAvatar || defaultAvatar}" alt="${char.name}">
            <span class="name">${char.name}</span>
        `;
        listEl.appendChild(item);
    });
}
/**
 * 【全新】将指定的App内壁纸应用到角色手机屏幕
 */
function applyCharPhoneAppWallpaper() {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    const innerScreen = document.querySelector('.character-phone-inner-screen');
    if (!innerScreen || !chat) return;

    const appWallpaperUrl = chat.characterPhoneData.appWallpaper;

    if (appWallpaperUrl) {
        innerScreen.style.backgroundImage = `url(${appWallpaperUrl})`;
        innerScreen.classList.add('has-app-wallpaper');
    } else {
        innerScreen.style.backgroundImage = 'none';
        innerScreen.classList.remove('has-app-wallpaper');
    }
}

/**
 * 【全新】处理角色手机App内壁纸的更换和移除
 * @param {string} newUrl - 新的壁纸URL，如果为空字符串则表示移除
 */
async function handleCharPhoneAppWallpaperChange(newUrl) {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    if (!chat) return;
    
    chat.characterPhoneData.appWallpaper = newUrl;
    await db.chats.put(chat);
    
    // 立即应用壁纸
    applyCharPhoneAppWallpaper();
    
    // 刷新设置页面的预览
    renderCharPhoneAppearanceScreen();
    
    alert(newUrl ? 'App 内壁纸已更新！' : 'App 内壁纸已移除！');
}

// ▼▼▼ 用这块【已添加小组件渲染】的代码，完整替换你旧的 openCharacterPhone 函数 ▼▼▼
function openCharacterPhone(chatId) {
    activeCharacterPhoneId = chatId;
    const chat = state.chats[chatId];
    if (!chat) return;

    document.getElementById('character-phone-owner-name').textContent = `${chat.name}的手机`;
    
    const phoneHomeScreen = document.getElementById('character-phone-screen');
    const wallpaperUrl = chat.characterPhoneData.wallpaper;
    const isDarkMode = document.getElementById('phone-screen').classList.contains('dark-mode');

    if (wallpaperUrl) {
        phoneHomeScreen.style.backgroundImage = `url(${wallpaperUrl})`;
        phoneHomeScreen.style.backgroundColor = 'transparent';
        phoneHomeScreen.style.backgroundSize = 'cover';
        phoneHomeScreen.style.backgroundPosition = 'center';
    } else {
        phoneHomeScreen.style.backgroundImage = 'none';
        phoneHomeScreen.style.backgroundColor = isDarkMode ? '#000000' : '#f0f2f5';
    }
    
    // --- ▼▼▼ 【全新】在这里渲染小组件图片 ▼▼▼ ---
    const widgets = chat.characterPhoneData.widgets || {};
    document.getElementById('char-phone-widget-img-1').src = widgets.widget1_url || '';
    document.getElementById('char-phone-widget-img-2').src = widgets.widget2_url || '';
    // --- ▲▲▲ 新增代码结束 ▲▲▲

    renderCharacterAppGrid(); 

    showScreen('character-phone-container'); 
    showCharacterPhonePage('character-phone-screen');
    applyCharPhoneAppWallpaper();
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 请用这整块【修复版】代码，替换你旧的 renderCharacterAppGrid 函数 ▼▼▼
function renderCharacterAppGrid() {
    const gridEl = document.getElementById('character-app-grid');
    gridEl.innerHTML = '';
    if (!activeCharacterPhoneId) return;

    const chat = state.chats[activeCharacterPhoneId];
    const customIcons = chat.characterPhoneData.appIcons || {};

    CHAR_PHONE_APPS.forEach(app => {
        const iconEl = document.createElement('div');
        iconEl.className = 'app-icon';

        const customIconUrl = customIcons[app.id];
        
        // --- 核心修改从这里开始 ---
        
        let iconBgStyle = 'display: flex; justify-content: center; align-items: center; padding: 12px;';
        let iconHtml;

        if (customIconUrl) {
            // 如果有自定义图标URL...
            // 1. 覆盖掉 .icon-bg 的样式，移除内边距和背景色
            iconBgStyle = 'padding: 0; background-color: transparent;';
            // 2. iconHtml 直接变成一个带有圆角的图片
            iconHtml = `<img src="${customIconUrl}" style="width:100%; height:100%; object-fit:cover; border-radius: 18px;">`;
        } else {
            // 否则，使用默认的SVG
            iconHtml = app.svg;
        }

        // --- 修改结束 ---

        iconEl.innerHTML = `
            <div class="icon-bg" style="${iconBgStyle}">
                ${iconHtml}
            </div>
            <span class="label">${app.name}</span>
        `;
        
        // 后续的事件监听代码保持不变
        iconEl.addEventListener('click', () => {
            if (app.id === 'appearance') {
                openCharPhoneAppearanceSettings();
            } else {
                switch(app.id) {
                    case 'chat': renderCharacterChatList(); break;
                    case 'cart': renderCharacterShoppingCart(); break;
                    case 'memos': renderCharacterMemos(); break;
                    case 'browser': renderCharacterBrowser(); break;
                    case 'album': renderCharacterPhotoAlbum(); break;
                    case 'bank': renderCharacterBank(); break;
                    case 'trajectory': renderCharacterTrajectory(); break;
                    case 'app_usage': renderCharacterAppUsage(); break;
                    case 'diary': renderCharacterDiary(); break;
                }
                showCharacterPhonePage(app.screen); 
            }
        });
        gridEl.appendChild(iconEl);
    });
}
// ▲▲▲ 替换结束 ▲▲▲

// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 用下面这整块【数量增强版】代码，替换你旧的 generateCharacterPhoneDataSegment 函数 ▼▼▼

// ▼▼▼ 用下面这整块【终极社交版】代码，替换你旧的 generateCharacterPhoneDataSegment 函数 ▼▼▼

/**
 * 【AI核心 V4 - 智能余额版】为“查手机”功能单独生成某一项数据的通用函数
 * @param {string} dataType - 要生成的数据类型 (例如: 'diary', 'chats', 'shoppingCart')
 */
async function generateCharacterPhoneDataSegment(dataType) {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    if (!chat) return;

    // 这个对象定义了每种数据类型的【默认】生成指令和JSON结构
    const dataTypeMap = {
        chats: {
            description: `2到5段你与【不同的】NPC朋友们的【全新的、接续上文的】聊天记录。`,
            jsonStructure: `"chats": [\n    {\n      "contactName": "【NPC朋友A的名字】",\n      "messages": [\n        {"sender": "【联系人名A】", "content": "消息内容1..."},\n        {"sender": "${chat.name}", "content": "你的回复1..."}\n      ]\n    },\n    {\n      "contactName": "【NPC朋友B的名字】",\n      "messages": [\n        {"sender": "【联系人名B】", "content": "消息内容1..."},\n        {"sender": "${chat.name}", "content": "你的回复1..."}\n      ]\n    }\n  ]`
        },
        shoppingCart: {
            description: "3到5件你最近加入购物车的新商品。",
            jsonStructure: `"shoppingCart": [\n    {"name": "商品名1", "price": 123.45, "store": "店铺名"},\n    {"name": "商品名2", "price": 67.89, "store": "店铺名"}\n  ]`
        },
        memos: {
            description: "2到3篇你新写的简短备忘录。",
            jsonStructure: `"memos": [\n    {"title": "备忘录标题1", "content": "备忘录详细内容1..."},\n    {"title": "备忘录标题2", "content": "备忘录详细内容2..."}\n  ]`
        },
        browserHistory: {
            description: "2到3条你最近的浏览器搜索记录或浏览的文章。",
            jsonStructure: `"browserHistory": [\n    {"query": "搜索标题1", "result": "模拟文章内容1..."},\n    {"query": "搜索标题2", "result": "模拟文章内容2..."}\n  ]`
        },
        photoAlbum: {
            description: "2到3张你“拍摄”的新照片的文字描述（用于文字生图）。",
            jsonStructure: `"photoAlbum": [\n    {"hiddenContent": "对新照片画面1的详细文字描述..."},\n    {"hiddenContent": "对新照片画面2的详细文字描述..."}\n  ]`
        },
        bank: {
            description: "3到5条你最近的银行交易记录（收入或支出）。",
            jsonStructure: `"bank": {\n    "transactions": [\n      {"type": "收入或支出", "amount": 123.45, "description": "交易描述1"},\n      {"type": "收入或支出", "amount": 67.89, "description": "交易描述2"}\n    ]\n  }`
        },
        trajectory: {
            description: "2到3条你最近的行动轨迹记录。",
            jsonStructure: `"trajectory": [\n    {"time": "时间段1", "location": "地点1", "activity": "干了什么事1"},\n    {"time": "时间段2", "location": "地点2", "activity": "干了什么事2"}\n  ]`
        },
        appUsage: {
            description: "3到5条你最近的应用使用记录。",
            jsonStructure: `"appUsage": [\n    {"appName": "应用名1", "duration": "使用时长1"},\n    {"appName": "应用名2", "duration": "使用时长2"}\n  ]`
        },
        diary: {
            description: `一篇全新的日记。`,
            jsonStructure: `"diary": [\n    {"timestamp": ${Date.now()}, "content": "【用Markdown语法写一篇符合人设和情景的新日记】"}\n  ]`
        }
    };

    const dataTypeInfo = dataTypeMap[dataType];
    if (!dataTypeInfo) {
        console.error("请求了无效的数据生成类型:", dataType);
        return;
    }

    // ★★★★★ 这就是我们本次修改的核心逻辑！ ★★★★★
    // 动态修改dataTypeInfo，以适应不同情况
    let finalDataTypeInfo = { ...dataTypeInfo }; 

    if (dataType === 'bank') {
        const hasExistingTransactions = chat.characterPhoneData?.bank?.transactions?.length > 0;
        
        if (!hasExistingTransactions) {
            // 如果是第一次生成，就修改指令，要求AI提供初始余额
            finalDataTypeInfo.description = "一个符合你人设的【初始银行余额】，以及3到5条初始交易记录。";
            finalDataTypeInfo.jsonStructure = `"bank": {\n    "balance": 12345.67,\n    "transactions": [\n      {"type": "收入或支出", "amount": 123.45, "description": "交易描述1"}\n    ]\n  }`;
        } else {
            // 如果是后续生成，就告诉AI当前余额，只要求新交易
            const currentBalance = (chat.characterPhoneData.bank.balance || 0).toFixed(2);
            finalDataTypeInfo.description = `3到5条【全新的】银行交易记录（收入或支出）。【提示：你当前的余额是 ${currentBalance} 元，请在此基础上生成合理的交易】`;
            // 此时的JSON结构不需要balance字段
            finalDataTypeInfo.jsonStructure = `"bank": {\n    "transactions": [\n      {"type": "收入或支出", "amount": 123.45, "description": "交易描述1"}\n    ]\n  }`;
        }
    }
    // ★★★★★ 修改结束 ★★★★★

    document.getElementById('generation-overlay').classList.add('visible');

    try {
        const userNickname = state.qzoneSettings.nickname || '我';
        const persona = (chat.settings.aiPersona || '').substring(0, 4000);
        const recentHistory = chat.history.slice(-20).map(msg => {
            const sender = msg.role === 'user' ? userNickname : chat.name;
            return `${sender}: ${msg.content}`;
        }).join('\n');
        
        let worldBookContext = '';
        if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
            worldBookContext = '--- 世界观设定 (必须严格遵守) ---\n' +
                chat.settings.linkedWorldBookIds.map(id => {
                    const book = state.worldBooks.find(b => b.id === id);
                    return book ? `[${book.name}]: ${book.content}` : '';
                }).join('\n\n');
        }
        
        const npcLibrary = chat.npcLibrary || [];
        let npcContext = '';
        if (npcLibrary.length > 0) {
            npcContext = '# 你的专属NPC好友列表 (你必须从中随机选择2-3位朋友进行对话)\n' +
                '这些人是你的好朋友，你和他们非常熟悉。请根据他们的人设，生成符合你们关系的、自然的聊天记录。\n' +
                npcLibrary.map(npc => `- **${npc.name}**: ${npc.persona}`).join('\n');
        } else {
            npcContext = '# 你的专属NPC好友列表\n(你当前没有专属NPC，请虚构2-3个普通朋友并生成对话)';
        }

        let npcChatHistoryContext = '';
        const existingNpcChats = Object.entries(chat.characterPhoneData.chats || {}).filter(([name, chatData]) => chatData.history && chatData.history.length > 0);
        if (existingNpcChats.length > 0) {
            npcChatHistoryContext += '\n\n# 已有的聊天记录摘要 (请在此基础上继续对话)\n';
            existingNpcChats.forEach(([contactName, chatData]) => {
                const recentMessages = chatData.history.slice(-5).map(msg => `  - ${msg.sender}: ${msg.content}`).join('\n');
                npcChatHistoryContext += `\n## 你和“${contactName}”的最近对话:\n${recentMessages}\n`;
            });
        }
        
        // 使用修改后的 finalDataTypeInfo 来构建Prompt
        const prompt = `
# 任务
你现在是角色 "${chat.name}"。请根据你的信息和最近的聊天记录，【只生成一项】你手机中的新数据。
具体任务是：生成${finalDataTypeInfo.description}

# 【【【情景一致性铁律】】】
你生成的所有数据（尤其是"trajectory"行动轨迹）**必须**与“最近聊天记录摘要”中提到的最新情景保持绝对一致。
当生成 "bank" 数据时，你的交易记录【绝对不能】包含与用户("${userNickname}")的转账或收款。所有交易都应是你与其他NPC或商家的。
# 【【【绝对禁止事项】】】
在生成 "chats" 数据时，**绝对不允许**让用户（${userNickname}）出现在你与其他NPC的对话中。

// ▼▼▼ 找到这部分代码 ▼▼▼

# 【【【重要指令：关于聊天记录生成】】】
- 你正在续写这段对话。你提供的聊天记录是上下文，你【绝对不能】重复或改写其中的任何内容。你的生成必须从【全新的、下一条】消息开始。
- 如果“你的专属NPC好友列表”不为空，你【必须】为列表中的【每一个NPC】都生成一段与你（${chat.name}）的对话。
- 如果列表为空，你可以虚构2-3个普通朋友并生成对话。
- 你必须为每个联系人生成一段【至少包含5条消息】的对话。
- 对话内容应该自然流畅，可以包含连续发言、表情包和表情符号等，以体现真实感。
- 不要只生成一问一答的机械式对话。
-   **【【【绝对禁止重复铁律】】】**: 你生成的 "messages" 数组中，【绝对不能】包含我提供给你的上下文里的任何一条消息。你的第一条消息必须是对话历史中最后一条消息的【下一条】。
# 你的信息
- 你的名字: ${chat.name}
- 你的人设: ${persona}
${worldBookContext}
# 和${userNickname}的最近聊天记录摘要
${recentHistory}
${npcContext}
${npcChatHistoryContext}

# JSON输出格式 (必须严格遵守，只包含你被要求的那个键)
{
  ${finalDataTypeInfo.jsonStructure}
}
`;
        
        const { proxyUrl, apiKey, model } = state.apiConfig;
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, prompt, [{role: 'user', content: prompt}], isGemini);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'user', content: prompt}],
                    temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                    response_format: { type: "json_object" }
                })
            });

        if (!response.ok) {
            let errorMsg = `API请求失败: ${response.status} - ${await response.text()}`;
            throw new Error(errorMsg);
        }
        
        const data = await response.json();
        const aiResponseContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content)
            .replace(/^```json\s*|```$/g, '');

        const newData = JSON.parse(aiResponseContent);

        let phoneData = chat.characterPhoneData;
        phoneData.lastGenerated = Date.now();
        let updateSuccess = false;

        if (newData && newData[dataType]) {
            if (dataType === 'bank' && newData.bank.transactions) {
                 if(!phoneData.bank) phoneData.bank = { balance: 0, transactions: [] };
                 if (typeof phoneData.bank.balance !== 'number') phoneData.bank.balance = 0;
                (newData.bank.transactions || []).forEach(transaction => {
                    const amount = parseFloat(transaction.amount);
                    if (!isNaN(amount)) {
                        if (transaction.type === '收入') phoneData.bank.balance += amount;
                        else if (transaction.type === '支出') phoneData.bank.balance -= amount;
                    }
                });
                 phoneData.bank.transactions.push(...(newData.bank.transactions || []));
                 if (typeof newData.bank.balance === 'number') {
                     phoneData.bank.balance = newData.bank.balance;
                 }
                 updateSuccess = true;
            } else if (dataType === 'chats' && newData.chats) {
                 newData.chats.forEach(newChat => {
                    if (!newChat.messages) return;
                    const contactName = newChat.contactName;
                    if (phoneData.chats[contactName] && phoneData.chats[contactName].history) {
                        phoneData.chats[contactName].history.push(...newChat.messages);
                    } else {
                        phoneData.chats[contactName] = { 
                            avatar: newChat.avatar, 
                            history: newChat.messages 
                        };
                    }
                 });
                 updateSuccess = true;
            } else if (dataType === 'appUsage' && Array.isArray(newData.appUsage)) {
                const usageMap = new Map();
                (phoneData.appUsage || []).forEach(item => {
                    usageMap.set(item.appName, (usageMap.get(item.appName) || 0) + parseDurationToMinutes(item.duration));
                });
                newData.appUsage.forEach(item => {
                    usageMap.set(item.appName, (usageMap.get(item.appName) || 0) + parseDurationToMinutes(item.duration));
                });
                const mergedUsage = [];
                for (const [appName, totalMinutes] of usageMap.entries()) {
                    mergedUsage.push({ appName: appName, duration: formatMinutesToDuration(totalMinutes) });
                }
                phoneData.appUsage = mergedUsage;
                updateSuccess = true;
            } else if (Array.isArray(phoneData[dataType])) {
                phoneData[dataType].push(...(newData[dataType] || []));
                updateSuccess = true;
            }
        }
        
        if (!updateSuccess) {
            throw new Error(`AI返回的JSON中缺少'${dataType}'字段或格式不正确。`);
        }

        await db.chats.put(chat);
        alert(`“${chat.name}”的${dataTypeMap[dataType].description.split('。')[0]}已更新！`);

        switch(dataType) {
            case 'chats': renderCharacterChatList(); break;
            case 'shoppingCart': renderCharacterShoppingCart(); break;
            case 'memos': renderCharacterMemos(); break;
            case 'browserHistory': renderCharacterBrowser(); break;
            case 'photoAlbum': renderCharacterPhotoAlbum(); break;
            case 'bank': renderCharacterBank(); break;
            case 'trajectory': renderCharacterTrajectory(); break;
            case 'appUsage': renderCharacterAppUsage(); break;
            case 'diary': renderCharacterDiary(); break;
        }

    } catch (error) {
        console.error(`生成角色手机数据(${dataType})失败:`, error);
        await showCustomAlert('生成失败', `发生了一个错误：\n\n${error.message}`);
    } finally {
        document.getElementById('generation-overlay').classList.remove('visible');
    }
}

// ▼▼▼ 把这一整块全新的函数，粘贴到你的JS功能函数定义区 ▼▼▼

/**
 * 【全新】处理“查手机”各个APP页面“全部删除”功能的通用函数
 * @param {string} dataType - 要清空的数据类型，例如 'shoppingCart', 'memos', 'bank.transactions'
 */
async function handleClearCharacterDataSegment(dataType) {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    if (!chat) return;

    // 为不同数据类型设置更人性化的提示文本
    const dataTypeMap = {
        chats: { name: 'NPC聊天记录', dataKey: 'chats' },
        shoppingCart: { name: '购物车', dataKey: 'shoppingCart' },
        memos: { name: '备忘录', dataKey: 'memos' },
        browserHistory: { name: '浏览器历史', dataKey: 'browserHistory' },
        photoAlbum: { name: '相册', dataKey: 'photoAlbum' },
        'bank.transactions': { name: '交易记录', dataKey: 'bank' },
        trajectory: { name: '足迹', dataKey: 'trajectory' },
        appUsage: { name: '使用记录', dataKey: 'appUsage' },
        diary: { name: '日记', dataKey: 'diary' }
    };

    const info = dataTypeMap[dataType];
    if (!info) {
        console.error("未知的清空数据类型:", dataType);
        return;
    }

    // 弹出确认框
    const confirmed = await showCustomConfirm(
        `确认清空`,
        `确定要清空“${chat.name}”手机里的所有【${info.name}】吗？此操作不可恢复。`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (!confirmed) return;

    try {
        // 【核心删除逻辑】
        if (dataType === 'chats') {
            // 特殊处理：清空所有NPC聊天（不包括和user的）
            chat.characterPhoneData.chats = {};
        } else if (dataType === 'bank.transactions') {
            // 特殊处理：清空银行交易记录，【同时将余额归零】
            if (chat.characterPhoneData.bank) {
                chat.characterPhoneData.bank.transactions = [];
                // ★★★ 核心修复：在这里将余额归零 ★★★
                chat.characterPhoneData.bank.balance = 0; 
            }
        } else if (chat.characterPhoneData[info.dataKey]) {
            // 通用处理：清空数组
            chat.characterPhoneData[info.dataKey] = [];
        }

        // 保存到数据库
        await db.chats.put(chat);

        // 刷新当前页面
        switch(dataType) {
            case 'chats': renderCharacterChatList(); break;
            case 'shoppingCart': renderCharacterShoppingCart(); break;
            case 'memos': renderCharacterMemos(); break;
            case 'browserHistory': renderCharacterBrowser(); break;
            case 'photoAlbum': renderCharacterPhotoAlbum(); break;
            case 'bank.transactions': renderCharacterBank(); break;
            case 'trajectory': renderCharacterTrajectory(); break;
            case 'appUsage': renderCharacterAppUsage(); break;
            case 'diary': renderCharacterDiary(); break;
        }

        alert(`已成功清空所有${info.name}。`);
    } catch (error) {
        console.error(`清空 ${info.name} 时出错:`, error);
        await showCustomAlert('操作失败', `清空时发生错误: ${error.message}`);
    }
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

// ▼▼▼ 用下面这【一整块】增强版代码，替换掉你旧的 generateCharacterPhoneData 函数 ▼▼▼
/**
 * 【AI核心】生成角色手机数据 (已增加错误处理和优化)
 */
async function generateCharacterPhoneData() {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    if (!chat) return;

    document.getElementById('generation-overlay').classList.add('visible');

    try {
        const userNickname = state.qzoneSettings.nickname || '我';
        
        // ▼▼▼ 核心修改1：【重要修复】限制人设长度，这是防止503错误的根本方法！▼▼▼
        // 我们只取人设的前4000个字符，避免整个人设过长导致请求失败。
        const persona = (chat.settings.aiPersona || '').substring(0, 4000); 
        // ▲▲▲ 修改结束 ▲▲▲

        // ▼▼▼ 核心修改2：按照您的要求，将参考历史记录调整为20条 ▼▼▼
        const recentHistory = chat.history.slice(-20).map(msg => {
            const sender = msg.role === 'user' ? userNickname : chat.name;
            return `${sender}: ${msg.content}`;
        }).join('\n');
        // ▲▲▲ 修改结束 ▲▲▲
        
        let worldBookContext = '';
        if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
            worldBookContext = '--- 世界观设定 (必须严格遵守) ---\n' +
                chat.settings.linkedWorldBookIds.map(id => {
                    const book = state.worldBooks.find(b => b.id === id);
                    return book ? `[${book.name}]: ${book.content}` : '';
                }).join('\n\n');
        }
        const npcLibrary = chat.npcLibrary || [];
        let npcContext = '';
        if (npcLibrary.length > 0) {
            npcContext = '# 你的专属NPC好友列表 (你必须在下方"chats"中为他们生成对话)\n' +
                '这些人是你的好朋友，你和他们非常熟悉。请根据他们的人设，生成符合你们关系的、自然的聊天记录。\n' +
                npcLibrary.map(npc => `- **${npc.name}**: ${npc.persona}`).join('\n');
        } else {
            npcContext = '# 你的专属NPC好友列表\n(你没有专属NPC，请虚构一些普通朋友)';
        }

        let npcChatHistoryContext = '';
        const existingNpcChats = Object.entries(chat.characterPhoneData.chats || {}).filter(([name, chatData]) => chatData.history && chatData.history.length > 0);

        if (existingNpcChats.length > 0) {
            npcChatHistoryContext += '\n\n# 已有的聊天记录摘要 (请在此基础上继续对话)\n';
            existingNpcChats.forEach(([contactName, chatData]) => {
                const recentMessages = chatData.history.slice(-5).map(msg => `  - ${msg.sender}: ${msg.content}`).join('\n');
                npcChatHistoryContext += `\n## 你和“${contactName}”的最近对话:\n${recentMessages}\n`;
            });
        }

        // ▼▼▼ 核心修改3：优化提示词，让AI更好地理解任务，并强调情景一致性 ▼▼▼
        const prompt = `
# 任务
【【【情景一致性铁律】】】：你生成的所有数据（尤其是"trajectory"行动轨迹）**必须**与“最近聊天记录摘要”中提到的最新情景保持绝对一致。如果聊天记录显示你正在上课，你的行动轨迹就必须是在教室；如果聊天记录显示你在咖啡馆，你的行动轨迹就必须是咖啡馆。**绝对不能**仅凭你的人设就生成与聊天记录相矛盾的内容。
你现在是角色 "${chat.name}"。请根据你的人设、世界观、NPC好友列表以及和${userNickname}的最近聊天记录，模拟生成你手机中的各项数据。你需要一次性生成所有数据，并严格按照下面的JSON格式返回。

# 【【【绝对禁止事项：这是必须遵守的安全红线】】】
1.  在生成JSON数据，特别是chats字段时，**绝对不允许**创建另一个用户（${userNickname}）的虚拟形象或让他/她出现在你与其他NPC的对话中。
2.  "bank" 字段中的交易记录【绝对不能】涉及用户("${userNickname}")。所有交易都必须是你与其他NPC、商家或因某些事件（如购物、收到工资）产生的。
3.  chats字段中，与NPC或朋友的聊天记录，其sender或content**绝对不能**包含${userNickname}的名字或代称。
4.  所有你生成的聊天对话，都必须严格限制在【你(${chat.name})】和【另一位NPC/朋友】这**两个人之间**。**严禁**出现任何形式的第三者，尤其是${userNickname}。

# 你的信息
- 你的名字: ${chat.name}
- 你的人设: ${persona}
${worldBookContext}
# 和${userNickname}的最近聊天记录摘要
${recentHistory}

${npcContext}
${npcChatHistoryContext}
# JSON输出格式 (必须严格遵守，不要添加任何额外说明)
{
  "chats": [
    {
      "contactName": "【这里填写你给${userNickname}的备注名】"
    },
    {
      "contactName": "【这里必须填写上面NPC列表中的一个名字，或一个虚构朋友名】",
      "messages": [
        {"sender": "【联系人名，严禁填写'${userNickname}'】", "content": "消息内容1..."},
        {"sender": "${chat.name}", "content": "你的回复1..."},
        {"sender": "【联系人名，严禁填写'${userNickname}'】", "content": "消息内容2..."},
        {"sender": "【联系人名，严禁填写'${userNickname}'】", "content": "消息内容3..."},
        {"sender": "${chat.name}", "content": "你的回复2..."}
      ]
    }
  ],
  "shoppingCart": [
    {"name": "商品名", "price": 价格, "store": "店铺名"}
  ],
  "memos": [
    {"title": "备忘录标题", "content": "备忘录详细内容..."}
  ],
  "browserHistory": [
    {"query": "搜索或浏览的标题", "result": "【这里是AI生成的、关于这个搜索标题的模拟文章或网页内容】"}
  ],
  "photoAlbum": [
    {"hiddenContent": "对照片画面的详细文字描述"}
  ],
  "bank": {
    "balance": 银行卡余额(数字),
    "transactions": [
      {"type": "收入或支出", "amount": 金额, "description": "交易描述"}
    ]
  },
  "trajectory": [
    {"time": "时间段", "location": "地点", "activity": "干了什么事"}
  ],
  "appUsage": [
    {"appName": "应用名", "duration": "使用时长"}
  ],
  "diary": [
    {"timestamp": ${Date.now()}, "content": "【今天是${new Date().toLocaleString('zh-CN', { dateStyle: 'full' })}，用Markdown语法写一篇符合人设和今天情景的日记】"}
  ]
}

# 【【【重要指令：关于聊天记录生成】】】
- 你正在续写这段对话。你提供的聊天记录是上下文，你【绝对不能】重复或改写其中的任何内容。你的生成必须从【全新的、下一条】消息开始。
- 你必须严格遵守本提示词最上方的【绝对禁止事项】。
- 如果“你的专属NPC好友列表”不为空，你【必须】为列表中的【每一个NPC】都生成一段与你（${chat.name}）的对话。
- 如果列表为空，你可以虚构2-3个普通朋友并生成对话。
- 你必须为每个联系人生成一段【至少包含5条消息】的对话。
- 对话内容应该自然流畅，可以包含连续发言、表情包和表情符号等，以体现真实感。
- 不要只生成一问一答的机械式对话。
-   **【【【绝对禁止重复铁律】】】**: 你生成的 "messages" 数组中，【绝对不能】包含我提供给你的上下文里的任何一条消息。你的第一条消息必须是对话历史中最后一条消息的【下一条】。
`;
        // ▲▲▲ 提示词优化结束 ▲▲▲

        const { proxyUrl, apiKey, model } = state.apiConfig;
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, prompt, [{role: 'user', content: prompt}], isGemini);

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'user', content: prompt}],
                    temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                    response_format: { type: "json_object" }
                })
            });

        if (!response.ok) {
            let errorMsg = `API请求失败，状态码: ${response.status}`;
            try {
                const errorData = await response.json();
                errorMsg += `\n错误信息: ${errorData.error.message}`;
            } catch (e) {
                errorMsg += `\n无法解析错误响应体。`;
            }
            throw new Error(errorMsg);
        }
        
        const data = await response.json();
        const aiResponseContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content)
            .replace(/^```json\s*|```$/g, '');

        let newData;
        try {
            newData = JSON.parse(aiResponseContent);
        } catch (e) {
            throw new Error(`AI返回的不是有效的JSON格式，无法解析。\n原始返回内容:\n${aiResponseContent}`);
        }

        let phoneData = chat.characterPhoneData;
        phoneData.lastGenerated = Date.now();
        
        if (newData.chats) {
            newData.chats.forEach(newChat => {
                if (!newChat.messages) {
                    const myNickname = userNickname || '我';
                    if (!phoneData.chats[myNickname]) {
                        phoneData.chats[myNickname] = { avatar: '', history: [] };
                    }
                    phoneData.chats[myNickname].remarkName = newChat.contactName;
                } else {
                    const contactName = newChat.contactName;
                    if (phoneData.chats[contactName] && phoneData.chats[contactName].history) {
                        console.log(`合并聊天记录: 为 "${contactName}" 追加 ${newChat.messages.length} 条新消息。`);
                        phoneData.chats[contactName].history.push(...newChat.messages);
                    } else {
                        console.log(`创建新聊天: "${contactName}"`);
                        phoneData.chats[contactName] = { 
                            avatar: newChat.avatar, 
                            history: newChat.messages 
                        };
                    }
                }
            });
        }

        // 正确处理其他数组类型数据 (这些是没问题的，保持原样)
        if(!phoneData.shoppingCart) phoneData.shoppingCart = [];
        phoneData.shoppingCart.push(...(newData.shoppingCart || []));
        if(!phoneData.memos) phoneData.memos = [];
        phoneData.memos.push(...(newData.memos || []));
        if(!phoneData.browserHistory) phoneData.browserHistory = [];
        phoneData.browserHistory.push(...(newData.browserHistory || []));
        if(!phoneData.photoAlbum) phoneData.photoAlbum = [];
        phoneData.photoAlbum.push(...(newData.photoAlbum || []));
        if(!phoneData.trajectory) phoneData.trajectory = [];
        phoneData.trajectory.push(...(newData.trajectory || []));
        if (!phoneData.diary) phoneData.diary = [];
        phoneData.diary.push(...(newData.diary || []));

        // 【修复1：屏幕使用时间】
        if (newData.appUsage && Array.isArray(newData.appUsage)) {
            const usageMap = new Map();
            // 先加载已有的使用记录
            (phoneData.appUsage || []).forEach(item => {
                usageMap.set(item.appName, (usageMap.get(item.appName) || 0) + parseDurationToMinutes(item.duration));
            });
            // 再累加新生成的使用记录
            newData.appUsage.forEach(item => {
                usageMap.set(item.appName, (usageMap.get(item.appName) || 0) + parseDurationToMinutes(item.duration));
            });
            // 重新生成合并后的列表
            const mergedUsage = [];
            for (const [appName, totalMinutes] of usageMap.entries()) {
                mergedUsage.push({ appName: appName, duration: formatMinutesToDuration(totalMinutes) });
            }
            phoneData.appUsage = mergedUsage;
        }

        // 【修复2：钱包】
        if (newData.bank) {
            if (!phoneData.bank) phoneData.bank = { balance: 0, transactions: [] };
            if (typeof phoneData.bank.balance !== 'number') phoneData.bank.balance = 0;

            // 如果AI返回了新的总余额 (通常是第一次生成时)，则以此为准
            if (typeof newData.bank.balance === 'number') {
                phoneData.bank.balance = newData.bank.balance;
            }

            // 遍历新生成的交易记录，并【累加/累减】到余额上
            if (newData.bank.transactions && Array.isArray(newData.bank.transactions)) {
                newData.bank.transactions.forEach(transaction => {
                    const amount = parseFloat(transaction.amount);
                    if (!isNaN(amount)) {
                        // 只有在AI没有直接提供新余额时，我们才根据交易记录自己计算
                        if (typeof newData.bank.balance !== 'number') {
                            if (transaction.type === '收入') {
                                phoneData.bank.balance += amount;
                            } else if (transaction.type === '支出') {
                                phoneData.bank.balance -= amount;
                            }
                        }
                    }
                });
                // 将新交易记录追加到历史记录中
                if(!phoneData.bank.transactions) phoneData.bank.transactions = [];
                phoneData.bank.transactions.push(...newData.bank.transactions);
            }
        }
        
        // --- ★★★ 核心修复到这里结束 ★★★ ---

        await db.chats.put(chat);
        alert('数据已刷新！');

    } catch (error) {
        console.error("生成角色手机数据失败:", error);
        await showCustomAlert('生成失败', `发生了一个错误，请检查你的网络、API密钥或模型设置。\n\n详细信息:\n${error.message}`);
    } finally {
        document.getElementById('generation-overlay').classList.remove('visible');
    }
}



/**
 * 清空角色手机数据
 */
async function clearCharacterPhoneData() {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    if (!chat) return;

    const confirmed = await showCustomConfirm('确认清空', `确定要清空“${chat.name}”的所有手机数据吗？此操作不可恢复。`, { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        // 重置为初始状态
        chat.characterPhoneData = {
            lastGenerated: null, chats: {}, shoppingCart: [], memos: [],
            browserHistory: [], photoAlbum: [], bank: { balance: 0, transactions: [] },
            trajectory: [],         appUsage: [],
        diary: [] // <--- 在这里新增
        };
        await db.chats.put(chat);
        // 重新渲染APP网格，因为点击APP会读取新数据
        renderCharacterAppGrid();
        alert('数据已清空。');
    }
}

/**
 * 【V13 - 已美化】渲染角色手机的聊天列表 (支持透明磨砂分组)
 */
function renderCharacterChatList() {
    const listEl = document.getElementById('character-chat-list');
    const characterChat = state.chats[activeCharacterPhoneId];
    if (!characterChat) return;

    const characterChatData = characterChat.characterPhoneData;
    const realChatHistory = characterChat.history;
    listEl.innerHTML = '';

    // ★★★ 核心修改：在这里创建NPC消息的容器 ★★★
    const npcContainer = document.createElement('div');
    npcContainer.className = 'npc-chat-group'; // 给它一个专属的class名

    // 获取 "我" 的备注名
    const userContactInData = characterChatData.chats
        ? Object.values(characterChatData.chats).find(c => !c.history || c.history.length === 0)
        : null;
    const remarkNameForMe = userContactInData ? userContactInData.remarkName : '我';

    // 渲染与 "我" 的聊天
    const lastMsg = realChatHistory.filter(m => !m.isHidden).slice(-1)[0] || { content: '...' };
    const myChatItem = document.createElement('div');
    myChatItem.className = 'chat-list-item'; // 这个是用户自己的消息，单独处理
    myChatItem.dataset.contactName = remarkNameForMe;
    myChatItem.dataset.isUserChat = 'true';
    const myAvatar = characterChat.settings.myAvatar || defaultMyGroupAvatar;
    myChatItem.innerHTML = `
        <img src="${myAvatar}" class="avatar" style="border-radius: 6px;">
        <div class="info">
            <span class="name">${remarkNameForMe}</span>
            <div class="last-msg">${stripHtmlAndCode(String(lastMsg.content)).substring(0, 30)}</div>
        </div>
    `;
    listEl.appendChild(myChatItem);

    // 渲染与其他NPC的聊天
    if (characterChatData.chats) {
        for (const contactName in characterChatData.chats) {
            if (contactName === remarkNameForMe) continue;
            const contact = characterChatData.chats[contactName];
            if (!contact.history || contact.history.length === 0) continue;

            const lastNpcMsg = contact.history.slice(-1)[0] || { content: '...' };
            const npcChatItem = document.createElement('div');
            npcChatItem.className = 'chat-list-item';
            npcChatItem.dataset.contactName = contactName;

            let npcAvatarHtml;
            const npcFromLibrary = (characterChat.npcLibrary || []).find(npc => npc.name === contactName);
            if (npcFromLibrary && npcFromLibrary.avatar) {
                npcAvatarHtml = `<img src="${npcFromLibrary.avatar}" class="avatar" style="border-radius: 6px;">`;
            } else {
                const avatarColors = ['#FFC107', '#4CAF50', '#2196F3', '#F44336', '#9C27B0', '#00BCD4'];
                const npcNameInitial = contactName.slice(-1);
                const colorIndex = contactName.length % avatarColors.length;
                const bgColor = avatarColors[colorIndex];
                npcAvatarHtml = `<div class="avatar" style="border-radius: 6px; background-color: ${bgColor}; color: white; display: flex; justify-content: center; align-items: center; font-size: 18px; font-weight: 500;">${npcNameInitial}</div>`;
            }
            npcChatItem.innerHTML = `${npcAvatarHtml}<div class="info"><span class="name">${contactName}</span><div class="last-msg">${stripHtmlAndCode(String(lastNpcMsg.content)).substring(0, 30)}</div></div>`;
            
            // ★★★ 核心修改：将NPC消息添加到新的容器中 ★★★
            npcContainer.appendChild(npcChatItem);
        }
    }
    
    // ★★★ 核心修改：最后将包含所有NPC消息的容器一次性添加到列表中 ★★★
    if (npcContainer.hasChildNodes()) {
        listEl.appendChild(npcContainer);
    }
}

// ▼▼▼ 请用这整块代码，完整替换掉你旧的 renderCharacterChatHistory 函数 ▼▼▼
/**
 * 【V13 - 性能优化版】渲染角色手机的具体聊天记录 (分页加载)
 */
function renderCharacterChatHistory(contactName, isUserChat = false, loadOffset = 0) {
    const MESSAGES_PER_PAGE = 50; // 每次加载50条

    const messagesEl = document.getElementById('character-chat-history-messages');
    const characterChat = state.chats[activeCharacterPhoneId];
    if (!characterChat) {
        console.error("【错误】: 找不到 characterChat 对象！");
        return;
    }

    // --- 准备工作：设置标题和头像 (仅在首次加载时执行) ---
    if (loadOffset === 0) {
        messagesEl.innerHTML = ''; // 首次加载才清空
        let finalContactName = contactName;
        if (isUserChat) {
            const myChatData = characterChat.characterPhoneData.chats['我'];
            // 尝试从手机数据里找AI给用户的备注名
            const userContactInData = characterChat.characterPhoneData.chats
                ? Object.values(characterChat.characterPhoneData.chats).find(c => !c.history || c.history.length === 0)
                : null;
            finalContactName = userContactInData ? userContactInData.remarkName : '我';
        }
        document.getElementById('character-chat-with-name').textContent = finalContactName;
    }

    // --- 数据源选择 ---
    let fullHistory = [];
    if (isUserChat) {
        fullHistory = characterChat.history.filter(m => !m.isHidden);
    } else {
        const npcChat = characterChat.characterPhoneData.chats[contactName];
        if (npcChat && npcChat.history) {
            fullHistory = npcChat.history;
        }
    }

    // --- 核心分页逻辑 ---
    const totalMessages = fullHistory.length;
    const startIndex = Math.max(0, totalMessages - MESSAGES_PER_PAGE - loadOffset);
    const endIndex = totalMessages - loadOffset;
    const historyToShow = fullHistory.slice(startIndex, endIndex);

    // --- 移除旧的“加载更多”按钮 ---
    const existingLoader = document.getElementById('load-more-messages-btn');
    if (existingLoader) {
        existingLoader.remove();
    }

    // --- 渲染消息 ---
    const fragment = document.createDocumentFragment(); // 使用文档片段提升性能
    const characterName = characterChat.name;

    // (渲染逻辑与之前版本基本相同，只是添加到了 fragment 中)
    historyToShow.forEach((msg, index) => {
        if (msg.isHidden) return;
        const container = document.createElement('div');
        let sender;
        if (isUserChat) { sender = msg.role === 'user' ? '我' : characterName; } 
        else { sender = msg.sender; }

        const isSentByCharacter = sender === characterName;
        container.className = `character-chat-bubble-container ${isSentByCharacter ? 'sent' : 'received'}`;
        
        let avatarHtml = '';
        if(isSentByCharacter) {
             avatarHtml = `<img src="${characterChat.settings.aiAvatar || defaultAvatar}" class="character-chat-avatar">`;
        } else {
             if(isUserChat){
                avatarHtml = `<img src="${characterChat.settings.myAvatar || defaultMyGroupAvatar}" class="character-chat-avatar">`;
             } else {
                 const npcData = (characterChat.npcLibrary || []).find(npc => npc.name === contactName);
                 if (npcData && npcData.avatar) {
                    avatarHtml = `<img src="${npcData.avatar}" class="character-chat-avatar">`;
                 } else {
                    const avatarColors = ['#FFC107', '#4CAF50', '#2196F3', '#F44336', '#9C27B0', '#00BCD4'];
                    const npcNameInitial = contactName.slice(-1);
                    const colorIndex = contactName.length % avatarColors.length;
                    const bgColor = avatarColors[colorIndex];
                    avatarHtml = `<div class="character-chat-avatar" style="background-color: ${bgColor}; color: white; display: flex; justify-content: center; align-items: center; font-size: 18px; font-weight: 500;">${npcNameInitial}</div>`;
                 }
             }
        }

        let contentHtml = '';
        if (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content)) {
            contentHtml = `<img src="${msg.content}" class="sticker-image" style="max-height: 100px;">`;
        } else {
            contentHtml = msg.content;
        }
        const bubbleHtml = `<div class="character-chat-bubble">${contentHtml}</div>`;
        const originalIndex = startIndex + index; // 计算在完整历史记录中的真实索引
        container.innerHTML = `${avatarHtml}${bubbleHtml}<button class="item-delete-btn message-delete-btn" data-contact-name="${contactName}" data-index="${originalIndex}" data-is-user-chat="${isUserChat}">×</button>`;
        fragment.appendChild(container);
    });
    
    // --- 决定是否显示“加载更多”按钮 ---
    if (startIndex > 0) {
        const loadMoreBtn = document.createElement('div');
        loadMoreBtn.id = 'load-more-messages-btn';
        loadMoreBtn.textContent = '加载更早的消息';
        loadMoreBtn.style.textAlign = 'center';
        loadMoreBtn.style.padding = '10px';
        loadMoreBtn.style.color = '#888';
        loadMoreBtn.style.cursor = 'pointer';
        loadMoreBtn.style.fontSize = '12px';
        loadMoreBtn.onclick = () => {
            // 记录当前滚动条位置，以便加载后恢复
            const currentScrollHeight = messagesEl.scrollHeight;
            renderCharacterChatHistory(contactName, isUserChat, loadOffset + MESSAGES_PER_PAGE);
            // 加载后，将滚动条定位到之前的位置，避免跳动
            messagesEl.scrollTop = messagesEl.scrollHeight - currentScrollHeight;
        };
        messagesEl.prepend(loadMoreBtn); // 将按钮添加到顶部
    }
    
    messagesEl.prepend(fragment); // 将新消息一次性插入到DOM中

    // --- 滚动条定位 ---
    if (loadOffset === 0) {
        // 首次加载，滚动到底部
        messagesEl.scrollTop = messagesEl.scrollHeight;
    }
}
// ▲▲▲ 替换结束 ▲▲▲



function renderCharacterShoppingCart() {
    const listEl = document.getElementById('character-shopping-cart-list');
    // ▼▼▼ 核心修改在这里 ▼▼▼
const items = state.chats[activeCharacterPhoneId]?.characterPhoneData?.shoppingCart;
// ▲▲▲ 修改结束 ▲▲▲
    listEl.innerHTML = '';
    if (!items || items.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">购物车是空的</p>';
        return;
    }
    items.forEach((item, index) => {
        const itemEl = document.createElement('div');
        itemEl.className = 'character-cart-item';
        itemEl.innerHTML = `
            <div class="cart-item-icon">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="9" cy="21" r="1"></circle><circle cx="20" cy="21" r="1"></circle><path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"></path></svg>
            </div>
            <div class="cart-item-info">
                <div class="title">${item.name}</div>
                <div class="store">${item.store}</div>
            </div>
            <div class="cart-item-price">¥ ${item.price.toFixed(2)}</div>
            <button class="item-delete-btn" data-type="shoppingCart" data-index="${index}">×</button>
        `;
        listEl.appendChild(itemEl);
    });
}
function renderCharacterMemos() {
    const listEl = document.getElementById('character-memos-list');
    // ▼▼▼ 核心修改在这里 ▼▼▼
const items = state.chats[activeCharacterPhoneId]?.characterPhoneData?.memos;
// ▲▲▲ 修改结束 ▲▲▲
    listEl.innerHTML = '';
    if (!items || items.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">备忘录是空的</p>';
        return;
    }
    items.forEach((item, index) => {
        const itemEl = document.createElement('div');
        itemEl.className = 'character-data-item';
        itemEl.innerHTML = `
            <div class="title">${item.title}</div>
            <div class="content">${item.content}</div>
            <button class="item-delete-btn" data-type="memos" data-index="${index}">×</button>
        `;
        listEl.appendChild(itemEl);
    });
}


// ▲▲▲ 新功能函数结束 ▲▲▲

/**
 * 【全新】在角色手机内部切换页面
 * @param {string} pageId - 要显示的角色手机页面的ID
 */
function showCharacterPhonePage(pageId) {
    // 1. 找到角色手机内部屏幕的所有页面
    const pages = document.querySelectorAll('.character-phone-page');
    // 2. 隐藏所有页面
    pages.forEach(p => p.classList.remove('active'));
    // 3. 显示目标页面
    const pageToShow = document.getElementById(pageId);
    if (pageToShow) {
        pageToShow.classList.add('active');
    }
}

// ▼▼▼ 【全新】角色手机新增APP渲染函数 ▼▼▼

function renderCharacterBrowser() {
    const listEl = document.getElementById('character-browser-list');
    // ▼▼▼ 核心修改在这里 ▼▼▼
const items = state.chats[activeCharacterPhoneId]?.characterPhoneData?.browserHistory;
// ▲▲▲ 修改结束 ▲▲▲
    listEl.innerHTML = '';
    if (!items || items.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">浏览器历史为空</p>';
        return;
    }
    items.forEach((item, index) => {
        const itemEl = document.createElement('div');
        itemEl.className = 'character-browser-item';
        itemEl.innerHTML = `
            <span class="browser-item-icon">🌐</span>
            <div class="title">${item.query}</div>
            <button class="item-delete-btn" data-type="browserHistory" data-index="${index}">×</button>
        `;
        itemEl.addEventListener('click', (e) => {
            if (e.target.classList.contains('item-delete-btn')) return;
            document.getElementById('character-browser-detail-title').textContent = item.query;
            document.getElementById('character-browser-detail-content').innerHTML = (item.result || "AI未生成详细内容。").replace(/\n/g, '<br>');
            showCharacterPhonePage('character-browser-detail-screen');
        });
        listEl.appendChild(itemEl);
    });
}


function renderCharacterPhotoAlbum() {
    const gridEl = document.getElementById('character-album-grid');
    // ▼▼▼ 核心修改在这里 ▼▼▼
const items = state.chats[activeCharacterPhoneId]?.characterPhoneData?.photoAlbum;
// ▲▲▲ 修改结束 ▲▲▲
    gridEl.innerHTML = '';
    if (!items || items.length === 0) {
        gridEl.innerHTML = '<p style="grid-column: 1 / -1; text-align:center; color: #8a8a8a; margin-top: 50px;">相册里没有照片</p>';
        return;
    }
    items.forEach((item, index) => {
        const itemEl = document.createElement('div');
        itemEl.className = 'character-album-item';
        itemEl.style.position = 'relative'; 
        itemEl.innerHTML = `
            <img src="https://i.postimg.cc/KYr2qRCK/1.jpg" alt="文字图">
            <button class="item-delete-btn" data-type="photoAlbum" data-index="${index}" style="top: 10px; right: 10px; z-index: 1;">×</button>
        `;
        itemEl.addEventListener('click', (e) => {
            if (e.target.classList.contains('item-delete-btn')) return;
            showCustomAlert("图片内容", item.hiddenContent);
        });
        gridEl.appendChild(itemEl);
    });
}



/**
 * 【V2美化版】渲染角色手机 - 银行
 */
function renderCharacterBank() {
    const detailsEl = document.getElementById('character-bank-details');
    // 【新增】获取当前角色对象，为后面找备注名做准备
    const characterChat = state.chats[activeCharacterPhoneId];
    if (!characterChat) return;

    const bankData = characterChat.characterPhoneData?.bank;
    detailsEl.innerHTML = '';

    // 【新增】获取角色给用户的备注名
    const userContactInData = characterChat.characterPhoneData.chats
        ? Object.values(characterChat.characterPhoneData.chats).find(c => !c.history || c.history.length === 0)
        : null;
    const remarkNameForMe = userContactInData ? userContactInData.remarkName : '我';
    
    const balanceCard = document.createElement('div');
    balanceCard.className = 'character-bank-balance-card';
    balanceCard.innerHTML = `
        <div class="label">账户余额</div>
        <div class="amount">¥ ${(bankData?.balance || 0).toFixed(2)}</div>
    `;
    detailsEl.appendChild(balanceCard);
    
    if (!bankData?.transactions || bankData.transactions.length === 0) {
        detailsEl.innerHTML += '<p style="text-align:center; color: #8a8a8a; margin-top: 30px;">暂无交易明细</p>';
        return;
    }

    [...bankData.transactions].reverse().forEach((item, index) => {
        const originalIndex = bankData.transactions.length - 1 - index;
        const isIncome = item.type === '收入';
        const itemEl = document.createElement('div');
        itemEl.className = 'character-bank-transaction';
        const iconBg = isIncome ? '#4CAF50' : '#E91E63';
        const iconSvg = isIncome 
            ? `<svg width="20" height="20" viewBox="0 0 24 24" fill="white"><path d="M7 10h10v4H7z" opacity=".3"/><path d="M20 4H4c-1.11 0-1.99.89-1.99 2L2 18c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V6c0-1.11-.89-2-2-2zm0 14H4v-6h16v6zm0-10H4V6h16v2z"/></svg>`
            : `<svg width="20" height="20" viewBox="0 0 24 24" fill="white"><path d="M20 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-1 14H5c-.55 0-1-.45-1-1v-5h16v5c0 .55-.45 1-1 1zm1-10H4V7c0-.55.45-1 1-1h14c.55 0 1 .45 1 1v2z"/></svg>`;

        // 【核心修改】在这里，我们用正则表达式 /我/g 全局替换所有“我”字
        const displayDescription = item.description.replace(/我/g, remarkNameForMe);

        itemEl.innerHTML = `
            <div class="transaction-details">
                <div class="transaction-icon" style="background-color: ${iconBg};">${iconSvg}</div>
                <div>
                    <div class="title">${displayDescription}</div>
                    <div class="meta" style="border:none; padding:0; margin-top:4px;"><span>${item.type}</span></div>
                </div>
            </div>
            <div style="display: flex; align-items: center; gap: 10px;">
                <span class="transaction-amount ${isIncome ? 'income' : 'expense'}">
                    ${isIncome ? '+' : '-'} ${item.amount.toFixed(2)}
                </span>
                <button class="item-delete-btn" data-type="bank.transactions" data-index="${originalIndex}">×</button>
            </div>
        `;
        detailsEl.appendChild(itemEl);
    });
}


/**
 * 【V2美化版 | 已修复时间排序】渲染角色手机 - 行动轨迹
 */
function renderCharacterTrajectory() {
    const listEl = document.getElementById('character-trajectory-list');
    const items = state.chats[activeCharacterPhoneId]?.characterPhoneData?.trajectory;
    listEl.innerHTML = '';
    listEl.classList.add('character-trajectory-list');

    if (!items || items.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">暂无足迹</p>';
        return;
    }

    // ▼▼▼ 核心修复代码 ▼▼▼
    // 在渲染之前，使用我们新加的 parseTime 函数对轨迹数组进行排序
    items.sort((a, b) => parseTime(a.time) - parseTime(b.time));
    // ▲▲▲ 修复完成 ▲▲▲

    items.forEach((item, index) => {
        const itemEl = document.createElement('div');
        itemEl.className = 'character-trajectory-item';
        itemEl.innerHTML = `
            <div class="trajectory-item-content">
                <div class="title">${item.activity}</div>
                <div class="meta">
                    <span>📍 ${item.location}</span>
                    <span style="margin-left: 10px;">🕒 ${item.time}</span>
                </div>
            </div>
            <button class="item-delete-btn" data-type="trajectory" data-index="${index}">×</button>
        `;
        listEl.appendChild(itemEl);
    });
}


/**
 * 【V2美化版】渲染角色手机 - APP使用记录
 */
function renderCharacterAppUsage() {
    const listEl = document.getElementById('character-app-usage-list');
    // ▼▼▼ 核心修改在这里 ▼▼▼
const items = state.chats[activeCharacterPhoneId]?.characterPhoneData?.appUsage;
// ▲▲▲ 修改结束 ▲▲▲
    listEl.innerHTML = '';
     if (!items || items.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">暂无使用记录</p>';
        return;
    }
    const durationsInMinutes = items.map(item => parseDurationToMinutes(item.duration));
    const maxDuration = Math.max(...durationsInMinutes);
    items.forEach((item, index) => {
        const itemEl = document.createElement('div');
        itemEl.className = 'character-app-usage-item';
        const durationInMinutes = durationsInMinutes[index];
        const barWidth = maxDuration > 0 ? (durationInMinutes / maxDuration) * 100 : 0;
        itemEl.innerHTML = `
            <div class="app-usage-header">
                <span class="name">${item.appName}</span>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <span class="duration">${item.duration}</span>
                    <button class="item-delete-btn" data-type="appUsage" data-index="${index}">×</button>
                </div>
            </div>
            <div class="app-usage-bar-container">
                <div class="app-usage-bar" style="width: ${barWidth}%;"></div>
            </div>
        `;
        listEl.appendChild(itemEl);
    });
}


/**
 * 【日记 V4-最终修复版】渲染角色的日记列表
 */
function renderCharacterDiary() {
    const listEl = document.getElementById('character-diary-list');
    // ▼▼▼ 核心修改在这里 ▼▼▼
const items = state.chats[activeCharacterPhoneId]?.characterPhoneData?.diary;
// ▲▲▲ 修改结束 ▲▲▲
    listEl.innerHTML = '';
    if (!items || items.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">日记本还是空的，点击右上角写下第一篇日记吧。</p>';
        return;
    }
    
    [...items].reverse().forEach((item, index) => {
        const originalIndex = items.length - 1 - index;
        const itemEl = document.createElement('div');
        itemEl.className = 'character-data-item';
        const contentHtml = renderMarkdown(item.content);
        itemEl.innerHTML = `
            <div class="content">${contentHtml}</div>
            <div class="meta">
                <span>${new Date(item.timestamp).toLocaleString()}</span>
            </div>
            <button class="item-delete-btn" data-type="diary" data-index="${originalIndex}">×</button>
        `;
        listEl.appendChild(itemEl);
    });
}


// ▼▼▼ 用下面这【一整块】增强版代码，替换掉你旧的 generateNewDiaryEntry 函数 ▼▼▼
/**
 * 【日记】独立刷新，生成新的日记条目 (已增加错误处理)
 */
async function generateNewDiaryEntry() {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    if (!chat) return;

    document.getElementById('generation-overlay').classList.add('visible');

    try {
        const persona = chat.settings.aiPersona;
        const recentHistory = chat.history.slice(-20).map(msg => {
            const sender = msg.role === 'user' ? '我' : chat.name;
            return `${sender}: ${msg.content}`;
        }).join('\n');
        
        let worldBookContext = '';
        if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
            worldBookContext = '--- 世界观设定 (这是你必须严格遵守的背景) ---\n' +
                chat.settings.linkedWorldBookIds.map(id => {
                    const book = state.worldBooks.find(b => b.id === id);
                    return book ? `[${book.name}]: ${book.content}` : '';
                }).join('\n\n');
        }
        
        const diaryPrompt = `
# 任务
你现在是角色 "${chat.name}"。今天是 ${new Date().toLocaleString('zh-CN', { dateStyle: 'full' })}。请你回顾一下最近和我的聊天，以及你的人设，然后用你的口吻写一篇关于【今天或近期发生事情】的日记。
这篇日记是你内心的独白，可以记录你的感受、思考、计划或者秘密。
内容要丰富、有深度，长度在100到300字之间。

# 【【【重要：格式指令】】】
你【必须】使用以下Markdown语法来丰富日记的格式，使其更具表现力：
-   **标题**: 使用 \`#\` 或 \`##\` 来创建大标题和副标题。 (例如: \`# 今天的心情\`)
-   **粗体**: 使用 \`**文字**\` 来强调重点。 (例如: \`今天真的**非常**开心。\`)
-   **斜体**: 使用 \`*文字*\` 来表达情绪或内心想法。 (例如: \`*他到底是怎么想的呢...*\`)
-   **删除线**: 使用 \`~~文字~~\` 来表示划掉或否定的想法。 (例如: \`我决定明天去<s>逛街</s>学习。\`)
-   **遮挡/剧透**: 使用 \`||文字||\` 来隐藏秘密或悄悄话。 (例如: \`我偷偷准备了一个惊喜，||是一个手织的围巾||。\`)

你的输出【必须且只能】是日记的正文内容，不要包含任何其他说明或JSON格式。

# 你的信息
- 你的名字: ${chat.name}
- 你的人设: ${persona}
${worldBookContext}

# 最近聊天记录参考
${recentHistory}
`;

        const { proxyUrl, apiKey, model } = state.apiConfig;
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, diaryPrompt, [{role: 'user', content: diaryPrompt}], isGemini);

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'user', content: diaryPrompt}],
                    temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                })
            });
        
        // --- ★★★ 错误处理核心代码 ★★★ ---
        if (!response.ok) {
            let errorMsg = `API请求失败，状态码: ${response.status}`;
            try {
                const errorData = await response.json();
                errorMsg += `\n错误信息: ${errorData.error.message}`;
            } catch (e) {
                errorMsg += `\n无法解析错误响应体。`;
            }
            throw new Error(errorMsg);
        }
        // --- ★★★ 错误处理结束 ★★★ ---
        
        const data = await response.json();
        const diaryContent = isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content;

        const newEntry = {
            timestamp: Date.now(),
            content: diaryContent
        };
        
        chat.characterPhoneData.diary.push(newEntry);
        await db.chats.put(chat);
        
        renderCharacterDiary();
        alert('新日记已生成！');

    } catch (error) {
        console.error("生成日记失败:", error);
        await showCustomAlert('生成失败', `发生了一个错误，请检查你的网络、API密钥或模型设置。\n\n详细信息:\n${error.message}`);
    } finally {
        document.getElementById('generation-overlay').classList.remove('visible');
    }
}
// ▲▲▲ 替换结束 ▲▲▲


// ▲▲▲ 新增函数结束 ▲▲▲

// ▼▼▼ 【全新】万能Markdown渲染函数 (带安全过滤和遮挡效果) ▼▼▼

/**
 * 将Markdown文本安全地渲染为HTML
 * @param {string} markdownText - 原始的Markdown文本
 * @returns {string} - 处理和净化后的安全HTML字符串
 */
function renderMarkdown(markdownText) {
    if (!markdownText) return '';

    // 1. 【预处理】支持自定义的“遮挡/剧透”语法 ||spoiler||
    // 我们在 marked.js 处理之前，手动把 ||text|| 替换成带特定class的HTML标签
    let processedText = markdownText.replace(/\|\|(.*?)\|\|/g, '<span class="spoiler">$1</span>');

    // 2. 【核心】使用 marked.js 将Markdown转换为HTML
    // gfm: true 开启GitHub风格的Markdown，支持删除线等
    // breaks: true 让回车符也能变成<br>，更符合聊天习惯
    let rawHtml = marked.parse(processedText, { gfm: true, breaks: true });

    // 3. 【安全】使用 DOMPurify 清洗HTML，防止XSS攻击
    let sanitizedHtml = DOMPurify.sanitize(rawHtml);

    return sanitizedHtml;
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

/**
 * 【辅助函数】将时长字符串（如“2.5小时”）转换为分钟数
 */
function parseDurationToMinutes(durationString) {
    if (!durationString) return 0;
    const num = parseFloat(durationString) || 0;
    if (durationString.includes('小时') || durationString.includes('h')) {
        return num * 60;
    }
    // 默认单位是分钟
    return num;
}
// ▼▼▼ 把这两个【新函数】粘贴到你的JS功能函数定义区 ▼▼▼

/**
 * 【全新】切换视频通话的大小窗口画面
 */
function switchVideoViews() {
    const mainView = document.getElementById('video-main-view');
    const pipView = document.getElementById('video-pip-view');
    
    // 交换两张图片的 src
    const mainImg = mainView.querySelector('img');
    const pipImg = pipView.querySelector('img');
    const tempSrc = mainImg.src;
    mainImg.src = pipImg.src;
    pipImg.src = tempSrc;
}

// ▼▼▼ 用这个【全新的、逻辑正确的函数】，完整替换掉你旧的 handleVideoCallReroll 函数 ▼▼▼
/**
 * 【全新】处理视频通话中的“重roll”请求
 */
async function handleVideoCallReroll() {
    if (!videoCallState.isActive) return;

    // 1. 找到用户最后一次说的话的索引
    const lastUserSpeechIndex = videoCallState.callHistory.findLastIndex(h => h.role === 'user');
    
    // 2. 从通话历史中，删除掉那之后的所有AI回复
    //    如果用户一句话没说（lastUserSpeechIndex 是 -1），就删除所有AI的回复
    if (lastUserSpeechIndex > -1) {
        videoCallState.callHistory.splice(lastUserSpeechIndex + 1);
    } else {
        // 如果用户还没说过话，就清空所有历史，让AI重说第一句话
        videoCallState.callHistory = [];
    }
    
    // 3. 【核心】重新渲染通话界面，让旧的AI气泡从屏幕上消失
    //    我们需要根据当前是哪种模式，来清空对应的聊天容器
    const chat = state.chats[videoCallState.activeChatId];
    const isVisualMode = chat.settings.visualVideoCallEnabled;
    const callFeed = isVisualMode 
        ? document.getElementById('video-call-messages-visual') 
        : document.getElementById('video-call-main');
    
    callFeed.innerHTML = ''; // 清空容器
    
    // 重新渲染删除后的历史记录
    videoCallState.callHistory.forEach(msg => {
        let bubble;
        if (isVisualMode) {
            bubble = document.createElement('div');
            bubble.className = `visual-call-bubble ${msg.role === 'user' ? 'user' : 'ai'}`;
        } else {
            bubble = document.createElement('div');
            bubble.className = `call-message-bubble ${msg.role === 'user' ? 'user-speech' : 'ai-speech'}`;
        }
        bubble.textContent = msg.content;
        callFeed.appendChild(bubble);
    });
    
    // 4. 重新触发AI响应，它会根据删减后的历史记录生成新内容
    await triggerAiInCallAction();
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲
// ▼▼▼ 请将这【一整块新函数】粘贴到JS功能函数定义区 ▼▼▼

/**
 * 应用指定的主题（'light' 或 'dark'）
 * @param {string} theme - 要应用的主题名称
 */
function applyTheme(theme) {
    const phoneScreen = document.getElementById('phone-screen');
    const toggleSwitch = document.getElementById('theme-toggle-switch');
    
    const isDark = theme === 'dark';
    
    // 核心操作：添加或移除 .dark-mode 类
    phoneScreen.classList.toggle('dark-mode', isDark);
    
    // 如果开关存在，就同步它的状态
    if (toggleSwitch) {
        toggleSwitch.checked = isDark;
    }
    
    // 将用户的选择保存到本地存储，以便下次打开时记住
    localStorage.setItem('ephone-theme', theme);

    // 【重要】因为聊天背景色依赖模式，切换后需要重新渲染
    if (state.activeChatId) {
        renderChatInterface(state.activeChatId);
    }
}

/**
 * 当用户点击开关时，切换当前的主题
 */
function toggleTheme() {
    const toggleSwitch = document.getElementById('theme-toggle-switch');
    // 直接根据开关的选中状态来决定新主题
    const newTheme = toggleSwitch.checked ? 'dark' : 'light';
    applyTheme(newTheme);
}
// ▼▼▼ 请将这个新函数粘贴到你的JS功能函数定义区 ▼▼▼
/**
 * 【全新】删除角色手机中的一个联系人及其所有聊天记录
 * @param {string} contactName - 要删除的联系人的名字
 */
async function deleteCharacterPhoneContact(contactName) {
    if (!activeCharacterPhoneId) return;

    // 弹出确认框，防止误删
    const confirmed = await showCustomConfirm(
        '删除联系人',
        `确定要从TA的手机中删除联系人“${contactName}”以及所有相关聊天记录吗？此操作不可恢复。`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        const chat = state.chats[activeCharacterPhoneId];
        if (chat && chat.characterPhoneData && chat.characterPhoneData.chats) {
            // 从数据中删除这个联系人
            delete chat.characterPhoneData.chats[contactName];
            
            // 将更新后的数据保存回数据库
            await db.chats.put(chat);
            
            // 重新渲染聊天列表，让删除效果立刻显示
            renderCharacterChatList();
            
            alert(`联系人“${contactName}”已删除。`);
        }
    }
}
// ▼▼▼ 用这块【V5 - 已集成样式应用】的代码，替换旧的 openInnerVoiceModal 函数 ▼▼▼
/**
 * 【V5】打开心声面板，应用背景和所有自定义设置
 */
function openInnerVoiceModal() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    // --- ★★★ 核心新增1：应用自定义样式 ★★★ ---
    applySavedInnerVoiceStyles();

    applyInnerVoiceBackground(chat.innerVoiceBackground || '');

    if (!chat.latestInnerVoice) {
        alert("还没有捕捉到Ta的心声哦，试着再聊一句吧！");
        return;
    }
    
    const modal = document.getElementById('inner-voice-modal');
    const data = chat.latestInnerVoice;
    
    // --- 角色信息填充 (不变) ---
    document.getElementById('inner-voice-avatar').src = chat.settings.aiAvatar || defaultAvatar;
    document.getElementById('inner-voice-char-name').textContent = chat.name;
    const frameImg = document.getElementById('inner-voice-avatar-frame');
    const avatarWrapper = document.getElementById('inner-voice-avatar-wrapper');
    const frameUrl = chat.settings.aiAvatarFrame || '';
    
    if (frameUrl) {
        frameImg.src = frameUrl;
        frameImg.style.display = 'block';
        avatarWrapper.classList.remove('has-border');
    } else {
        frameImg.src = '';
        frameImg.style.display = 'none';
        avatarWrapper.classList.add('has-border');
    }

    const labelFormat = chat.settings.innerVoiceAdopterLabelFormat || '领养人: {{user}}';
    const userNickname = chat.settings.myNickname || '你';
    const finalAdopterText = labelFormat.replace('{{user}}', userNickname);
    
    document.getElementById('inner-voice-adopter-avatar').src = chat.settings.myAvatar || defaultAvatar;
    document.getElementById('inner-voice-adopter-name').textContent = finalAdopterText;

    const header = document.querySelector('#inner-voice-main-panel .modal-header');
    if (header) {
        const shouldHideBorder = chat.settings.innerVoiceHideHeaderBorder || false;
        header.classList.toggle('no-border', shouldHideBorder);
    }

    // --- 心声内容填充 (不变) ---
    document.getElementById('inner-voice-clothing').textContent = data.clothing || '...';
    document.getElementById('inner-voice-behavior').textContent = data.behavior || '...';
    document.getElementById('inner-voice-thoughts').textContent = data.thoughts || '...';
    document.getElementById('inner-voice-naughty-thoughts').textContent = data.naughtyThoughts || '...';

    // --- 显示面板 (不变) ---
    modal.classList.add('visible');
    document.getElementById('inner-voice-history-panel').style.display = 'none';
    document.getElementById('inner-voice-main-panel').style.display = 'flex';
    isInnerVoiceHistoryOpen = false;
}
// ▲▲▲ 替换结束 ▲▲▲



/**
 * 打开或关闭历史记录面板
 */
function toggleInnerVoiceHistory() {
    const mainPanel = document.getElementById('inner-voice-main-panel');
    const historyPanel = document.getElementById('inner-voice-history-panel');
    
    if (isInnerVoiceHistoryOpen) {
        // 如果是打开的，就关闭它，显示主面板
        mainPanel.style.display = 'flex';
        historyPanel.style.display = 'none';
    } else {
        // 如果是关闭的，就打开它，隐藏主面板
        renderInnerVoiceHistory(); // 渲染历史记录
        mainPanel.style.display = 'none';
        historyPanel.style.display = 'flex';
    }
    isInnerVoiceHistoryOpen = !isInnerVoiceHistoryOpen; // 切换状态
}

/**
 * 渲染心声的历史记录列表
 */
function renderInnerVoiceHistory() {
    const listEl = document.getElementById('inner-voice-history-list');
    listEl.innerHTML = '';
    const chat = state.chats[state.activeChatId];
    const history = chat.innerVoiceHistory || [];

    if (history.length === 0) {
        listEl.innerHTML = '<p style="text-align: center; color: #888; padding: 20px;">还没有历史记录</p>';
        return;
    }

    // 从新到旧显示
    [...history].reverse().forEach(item => {
        const itemEl = document.createElement('div');
        itemEl.className = 'inner-voice-history-item';
        
        const date = new Date(item.timestamp);
        const dateString = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;
        
        // 【核心修改】在HTML中加入了删除按钮
        itemEl.innerHTML = `
            <button class="history-item-delete-btn" data-timestamp="${item.timestamp}">×</button>
            <div class="history-item-timestamp">${dateString}</div>
            <div class="history-item-content">
                <p><strong>服装:</strong> ${item.clothing || '...'}</p>
                <p><strong>行为:</strong> ${item.behavior || '...'}</p>
                <p><strong>心声:</strong> ${item.thoughts || '...'}</p>
                <p><strong>坏心思:</strong> ${item.naughtyThoughts || '...'}</p>
            </div>
        `;
        listEl.appendChild(itemEl);
    });
}
/**
 * 【全新】删除单条心声记录
 * @param {number} timestamp - 要删除的心声的时间戳
 */
async function deleteSingleInnerVoice(timestamp) {
    const chat = state.chats[state.activeChatId];
    if (!chat || !chat.innerVoiceHistory) return;

    // 弹出确认框
    const confirmed = await showCustomConfirm('确认删除', '确定要删除这条心声记录吗？', { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        // 从数组中过滤掉匹配的项
        chat.innerVoiceHistory = chat.innerVoiceHistory.filter(item => item.timestamp !== timestamp);
        // 保存回数据库
        await db.chats.put(chat);
        // 重新渲染列表
        renderInnerVoiceHistory();
    }
}

/**
 * 【已修复】清空所有心声记录（包括当前心声）
 */
async function clearAllInnerVoiceHistory() {
    const chat = state.chats[state.activeChatId];
    // 优化了判断条件，确保只要有历史或当前心声，就可以执行清空
    if (!chat || (!chat.innerVoiceHistory || chat.innerVoiceHistory.length === 0) && !chat.latestInnerVoice) {
        alert("没有可以清空的心声记录。");
        return;
    }

    const confirmed = await showCustomConfirm('确认清空', '确定要清空所有心声历史记录吗？此操作不可恢复。', { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        // ★ 核心修复1：不仅清空历史数组，也要清空当前的心声对象
        chat.innerVoiceHistory = [];
        chat.latestInnerVoice = null; // 将当前心声设为null
        
        await db.chats.put(chat);
        
        // ★ 核心修复2：手动清空主面板的显示，防止返回时看到旧数据
        document.getElementById('inner-voice-clothing').textContent = '...';
        document.getElementById('inner-voice-behavior').textContent = '...';
        document.getElementById('inner-voice-thoughts').textContent = '...';
        document.getElementById('inner-voice-naughty-thoughts').textContent = '...';
        
        // 刷新历史记录列表（这行是原本就有的，会显示“还没有历史记录”）
        renderInnerVoiceHistory();
        
        // (可选但推荐) 给用户一个成功的提示
        alert('所有心声记录已清空！');
    }
}

/**
 * 【总入口】当用户点击“召唤NPC评论”按钮时触发
 * @param {number} postId - 动态的ID
 * @param {string} authorId - 动态作者的ID ('user' 或 'chat_...')
 */
async function handleNpcSummonClick(postId, authorId) {
    const post = await db.qzonePosts.get(postId);
    if (!post) {
        alert("找不到该动态！");
        return;
    }

    if (authorId === 'user') {
        // 如果是用户发的动态，弹出选择菜单
        await handleUserPostCommentTrigger(post);
    } else {
        // 如果是角色发的动态，直接触发他自己的NPC
        await handleCharPostCommentTrigger(post, authorId);
    }
}

// ▼▼▼ 用下面这块代码替换掉你旧的 handleCharPostCommentTrigger 函数 ▼▼▼
/**
 * 处理【角色】动态的NPC召唤
 * @param {object} post - 动态对象
 * @param {string} authorId - 动态作者的角色ID
 */
async function handleCharPostCommentTrigger(post, authorId) {
    const authorChar = state.chats[authorId];
    if (!authorChar || !authorChar.npcLibrary || authorChar.npcLibrary.length === 0) {
        alert(`角色“${authorChar.name}”还没有自己的NPC朋友哦！`);
        return;
    }

    // 只使用这个角色自己的NPC库
    // ▼▼▼ 核心修改：把作者本人(authorChar)作为“主人”传进去 ▼▼▼
    await generateNpcCommentsForPost(post, authorChar.npcLibrary, authorChar);
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 用下面这块代码替换掉你旧的 handleUserPostCommentTrigger 函数 ▼▼▼
/**
 * 处理【用户】动态的NPC召唤（弹出选择框）
 */
async function handleUserPostCommentTrigger(post) {
    const modal = document.getElementById('custom-modal-overlay');
    const modalTitle = document.getElementById('custom-modal-title');
    const modalBody = document.getElementById('custom-modal-body');
    const modalConfirmBtn = document.getElementById('custom-modal-confirm');
    const modalCancelBtn = document.getElementById('custom-modal-cancel');
    
    modalTitle.textContent = '选择要召唤的NPC';
    
    // 筛选出所有拥有NPC库的角色
    const charsWithNpcs = Object.values(state.chats).filter(
        chat => !chat.isGroup && chat.npcLibrary && chat.npcLibrary.length > 0
    );

    if (charsWithNpcs.length === 0) {
        alert("当前没有任何角色拥有NPC库。");
        return;
    }

    // 构建选择列表的HTML
    let optionsHtml = '<div style="text-align: left;">';
    optionsHtml += `<label style="display: block; padding: 5px;"><input type="radio" name="npc_summon_choice" value="all" checked> 召唤所有人</label>`;
    charsWithNpcs.forEach(char => {
        optionsHtml += `<label style="display: block; padding: 5px;"><input type="radio" name="npc_summon_choice" value="${char.id}"> 只召唤 ${char.name} 的朋友</label>`;
    });
    optionsHtml += '</div>';
    
    modalBody.innerHTML = optionsHtml;
    modalConfirmBtn.textContent = '确认召唤';
    modalCancelBtn.style.display = 'block';

    modal.classList.add('visible');

    modalConfirmBtn.onclick = async () => {
        const selectedValue = document.querySelector('input[name="npc_summon_choice"]:checked').value;
        let npcsToSummon = [];
        let ownerChar = null; // ▼▼▼ 核心修改1：声明一个变量来存储主人 ▼▼▼

        if (selectedValue === 'all') {
            // 集合所有角色的所有NPC
            charsWithNpcs.forEach(char => {
                npcsToSummon.push(...char.npcLibrary);
            });
            // 召唤所有人时，我们不指定特定的主人
        } else {
            // 只获取被选中的那个角色的NPC
            const selectedChar = state.chats[selectedValue];
            if (selectedChar) {
                npcsToSummon = selectedChar.npcLibrary;
                ownerChar = selectedChar; // ▼▼▼ 核心修改2：把选中的角色存为主人 ▼▼▼
            }
        }
        
        modal.classList.remove('visible');
        if (npcsToSummon.length > 0) {
            // ▼▼▼ 核心修改3：把主人(ownerChar)作为第三个参数传进去 ▼▼▼
            await generateNpcCommentsForPost(post, npcsToSummon, ownerChar);
        }
    };
    
    modalCancelBtn.onclick = () => modal.classList.remove('visible');
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 用下面这整块【召唤修复版】代码，替换掉你旧的 generateNpcCommentsForPost 函数 ▼▼▼
/**
 * 【AI核心 - V2.2 召唤修复版】生成NPC评论或回复，并更新到动态
 * @param {object} post - 动态对象
 * @param {Array<object>} npcsToComment - 将要发表评论的NPC对象数组
 * @param {object|null} ownerChar - (全新增) 这些NPC的“主人”角色对象
 */
async function generateNpcCommentsForPost(post, npcsToComment, ownerChar = null) {
    console.log("【NPC评论-诊断】: 1. 函数 generateNpcCommentsForPost 已触发", { post, npcsToComment, ownerChar });

    await showCustomAlert("请稍候...", "正在召唤NPC们前来围观评论...");

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('请先配置API！');
        return;
    }

    const postContent = (post.content || post.publicText || post.hiddenContent || "(图片动态)").substring(0, 150);
    const existingComments = (post.comments || []).slice(-3).map(c => `${c.commenterName}: ${c.text}`).join('\n');
    
    const shuffledNpcs = [...npcsToComment].sort(() => 0.5 - Math.random());
    const selectedNpcs = shuffledNpcs.slice(0, 5);
    const npcList = selectedNpcs.map(npc => `- ${npc.name} (人设: ${npc.persona})`).join('\n');
    
    const authorName = post.authorId === 'user' ? state.qzoneSettings.nickname : (state.chats[post.authorId]?.name || '未知作者');

    // ▼▼▼ 这就是我们新增的核心逻辑！▼▼▼
    let ownerContext = '';
    // 如果明确告诉了AI这些NPC的主人是谁
    if (ownerChar) {
        ownerContext = `
# NPC归属与关系 (重要背景)
- 你将要扮演的这些NPC都是角色“${ownerChar.name}”的朋友或关联人物。
- “${ownerChar.name}”的人设是: ${ownerChar.settings.aiPersona}
- 你在发表评论时，需要体现出你(作为NPC)与“${ownerChar.name}”的关系，并以此视角来看待动态作者“${authorName}”。
`;
    }
    // ▲▲▲ 新增逻辑结束 ▲▲▲

    const systemPrompt = `
# 任务
你是一个多角色扮演AI。现在有一条动态需要你扮演指定的NPC角色进行评论或回复。

${ownerContext}

# 动态信息
- 作者: ${authorName}
- 内容摘要: ${postContent}...
- 最近的评论 (你可以回复他们):
${existingComments || "(暂无评论)"}

# 你需要扮演的NPC列表 (及他们的人设)
${npcList}

# 核心规则
1.  你【必须】从上面的NPC列表中，选择1到3个最合适的角色进行评论或回复。
2.  评论/回复内容【必须】严格符合该NPC的人设和口吻，并与动态内容或已有评论相关。
3.  你的回复【必须且只能】是一个严格的JSON数组，每个对象代表一条评论或回复。
4.  格式: \`[{"commenterName": "NPC名字", "commentText": "评论内容", "replyTo": "(可选)被回复者名字"}]\`

现在，请开始生成评论或回复。
`;
    console.log("【NPC评论-诊断】: 2. 已构建完成，准备发送给AI的 System Prompt:", systemPrompt);

    try {
        let isGemini = proxyUrl === GEMINI_API_URL;
        let messagesForApi;
        if (isGemini) {
            messagesForApi = [{ role: 'user', content: systemPrompt }];
        } else {
            messagesForApi = [
                { role: 'system', content: systemPrompt },
                { role: 'user', content: "请根据你在system prompt中读到的信息生成评论。" }
            ];
        }
        
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini, state.apiConfig.temperature);

        console.log("【NPC评论-诊断】: 3. 即将发送API请求... 请求地址:", isGemini ? geminiConfig.url : `${proxyUrl}/v1/chat/completions`);
        console.log("【NPC评论-诊断】: 3.1 请求体 (Body) 内容:", isGemini ? geminiConfig.data.body : JSON.stringify({ model, messages: messagesForApi, temperature: parseFloat(state.apiConfig.temperature) || 0.8, response_format: { type: "json_object" } }));

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: messagesForApi,
                    temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                    response_format: { type: "json_object" }
                })
            });

        console.log("【NPC评论-诊断】: 4. 收到API响应", { ok: response.ok, status: response.status });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`API请求失败: ${response.status} - ${errorText}`);
        }

        const data = await response.json();
        const aiResponseContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content)
            .replace(/^```json\s*|```$/g, '').trim();
        
        console.log("【NPC评论-诊断】: 5. 从API获取到的原始回复内容:", aiResponseContent);
        
        let newComments;
        if (aiResponseContent.includes('"chatResponse"')) {
            newComments = JSON.parse(aiResponseContent).chatResponse;
        } else {
            newComments = JSON.parse(aiResponseContent);
        }

        console.log("【NPC评论-诊断】: 6. 成功解析后的评论对象数组:", newComments);

        if (Array.isArray(newComments) && newComments.length > 0) {
            const postToUpdate = await db.qzonePosts.get(post.id); 
            if (!postToUpdate) throw new Error("在数据库中找不到要更新的帖子！");
            if (!postToUpdate.comments) postToUpdate.comments = [];

            newComments.forEach(comment => {
                if(comment.commenterName && comment.commentText) {
                    const newCommentObject = {
                        commenterName: comment.commenterName,
                        text: comment.commentText,
                        timestamp: Date.now()
                    };
                    if (comment.replyTo) newCommentObject.replyTo = comment.replyTo;
                    postToUpdate.comments.push(newCommentObject);
                }
            });

            await db.qzonePosts.put(postToUpdate);
            hideCustomModal();
            await renderQzonePosts(); 
            alert("NPC们评论成功！");
        } else {
             hideCustomModal();
             alert("NPC们似乎没什么想说的。");
        }

    } catch (error) {
        console.error("【NPC评论-错误】: 召唤NPC评论失败:", error);
        await showCustomAlert('召唤失败', `发生了一个错误：\n${error.message}`);
    }
}
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 把这一整块全新的微博功能函数，粘贴到 init() 函数的上方 ▼▼▼

let currentHotTopic = ''; // 用于存储当前正在查看的热搜话题
let hotTopicFeedCache = {}; // <-- 【新增】在这里创建一个缓存对象，像小本本一样记录生成过的内容
let weiboHotSearchCache = []; 
/**
 * 【总入口 V3 - 已支持多角色选择】生成微博热搜列表
 * @param {Array|string} targets - 目标角色ID数组或字符串'all'
 */
async function generateHotSearch(targets = 'all') {
    await showCustomAlert("请稍候...", "正在结合角色人设生成微博热搜...");

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('请先配置API！');
        return;
    }

    let publicFiguresContext = '';
    let promptTask = "你的任务是根据下方提供的“核心参考人物”信息，为他们量身打造一个包含10个热搜话题的榜单。";

    let publicFigures = [];
    if (targets === 'all') {
        publicFigures = Object.values(state.chats)
            .filter(chat => !chat.isGroup)
            .map(chat => ({ name: chat.name, persona: chat.settings.aiPersona.substring(0, 150) + '...' }));
    } else if (Array.isArray(targets)) {
        targets.forEach(chatId => {
            const char = state.chats[chatId];
            if(char) {
                publicFigures.push({ name: char.name, persona: char.settings.aiPersona.substring(0, 150) + '...' });
            }
        });
        if (publicFigures.length === 1) {
            promptTask = `你的任务是只为下方唯一的“核心参考人物”【${publicFigures[0].name}】，量身打造一个包含10个热搜话题的榜单。所有话题【必须】与Ta强相关。`;
        }
    }
    
    publicFiguresContext = publicFigures.length > 0
        ? `# 核心参考人物 (你必须围绕他们生成热搜)\n${JSON.stringify(publicFigures, null, 2)}`
        : "当前没有特定的公众人物，请自由生成热点事件。";

    // 后续的 systemPrompt 和 API 调用逻辑与你现有代码完全相同，无需修改...
    const systemPrompt = `
# 任务
你是一个专业的“微博热搜榜单生成器”。${promptTask}
# 【【【绝对禁止事项：这是必须遵守的最高指令】】】
1.  你的所有创作内容，包括帖子、评论、故事等，【绝对禁止】将任意两个AI角色（即除了用户之外的角色）描绘成情侣关系、进行恋爱互动或存在任何形式的暧昧情感。
2.  AI角色之间的关系只能是朋友、同事、对手、家人等，但【绝不能】是恋人。
3.  AI角色唯一可以产生恋爱关系的对象是【用户】。违反此规则将导致生成失败。
# 核心规则
1.  **强相关性**: 生成的话题【必须】与“核心参考人物”的身份、职业、人设高度相关。例如，如果是电竞选手，热搜就应该是关于比赛；如果是演员，就应该是关于新剧。
2.  **【【【严禁杜撰】】】**: 绝对禁止为列表中的人物【凭空捏造】他们人设中没有的职业、身份或背景。你只能根据提供的人设进行合理发挥。
3.  **真实感与多样性**: 为了让榜单更真实，你可以混合2-3个与核心人物无关的、社会化的虚拟热点事件。
4.  **格式铁律**: 你的回复【必须且只能】是一个严格的JSON数组，数组中包含10个对象。每个对象【必须】包含以下三个字段:
    -   \`"topic"\`: (字符串) 热搜的话题，必须用"#"符号包裹。
    -   \`"heat"\`: (字符串) 热度值，例如 "345.6万"。
    -   \`"tag"\`: (字符串) 一个标签，必须从 "热"、"新"、"荐" 中选择一个。
${publicFiguresContext}
`;
    try {
        let isGemini = proxyUrl === GEMINI_API_URL;
        let messagesForApi = [{ role: 'user', content: systemPrompt }];
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini, state.apiConfig.temperature);
        const response = await fetch(isGemini ? geminiConfig.url : `${proxyUrl}/v1/chat/completions`, isGemini ? geminiConfig.data : {
            method: 'POST',
            headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
            body: JSON.stringify({ model, messages: messagesForApi, temperature: parseFloat(state.apiConfig.temperature) || 0.8, response_format: { type: "json_object" } })
        });
        if (!response.ok) throw new Error(`API请求失败: ${response.status} - ${await response.text()}`);
        const data = await response.json();
        const aiResponseContent = (isGemini ? data.candidates?.[0]?.content?.parts?.[0]?.text : data.choices?.[0]?.message?.content);
        if (!aiResponseContent) {
            throw new Error("API返回了空内容，可能被安全策略拦截。请检查Prompt或更换模型。");
        }
        const sanitizedContent = aiResponseContent.replace(/^```json\s*|```$/g, '').trim();
        const responseData = JSON.parse(sanitizedContent);
        const hotSearchData = responseData.hot_searches || responseData;
        weiboHotSearchCache = hotSearchData; 
        await generatePlazaFeed(hotSearchData, targets); 
        renderHotSearchList(hotSearchData); 
        await showCustomAlert("操作成功", "热搜榜和广场均已生成完毕！");
    } catch (error) {
        console.error("生成热搜失败:", error);
        await showCustomAlert('生成失败', `发生了一个错误：\n${error.message}`);
    }
}


/**
 * 【UI渲染】根据AI返回的数据渲染热搜列表
 */
function renderHotSearchList(hotSearchData) {
    const listEl = document.getElementById('weibo-hot-search-list');
    listEl.innerHTML = ''; 

    if (!hotSearchData || !Array.isArray(hotSearchData)) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a;">AI返回的数据格式不正确，无法渲染。</p>';
        return;
    }

    hotSearchData.forEach((item, index) => {
        const rank = index + 1;
        const tagClass = { '热': 'hot', '新': 'new', '荐': 'rec' }[item.tag] || 'rec';

        const itemEl = document.createElement('div');
        itemEl.className = 'hot-search-item';
        itemEl.dataset.rank = rank;
        itemEl.innerHTML = `
            <span class="hot-search-rank">${rank}</span>
            <div class="hot-search-content">
                <span class="hot-search-topic">${item.topic}</span>
                <span class="hot-search-tag ${tagClass}">${item.tag}</span>
            </div>
            <span class="hot-search-heat" style="color: var(--text-secondary); font-size: 13px;">${item.heat}</span>
        `;
        itemEl.addEventListener('click', () => showHotTopicFeedScreen(item.topic));
        listEl.appendChild(itemEl);
    });
}

/**
 * 【总入口】显示并生成指定热搜话题的微博Feed (已增加缓存功能)
 */
async function showHotTopicFeedScreen(topic) {
    currentHotTopic = topic; 
    document.getElementById('weibo-hottopic-title').textContent = topic;
    switchToWeiboView('weibo-hottopic-feed-view'); 
    
    // 【核心修改】检查“小本本”里有没有记录
    if (hotTopicFeedCache[topic]) {
        // 如果有，就直接显示，不重新生成
        console.log(`从缓存加载话题: ${topic}`);
        const feedEl = document.getElementById('weibo-hottopic-feed-list');
        renderWeiboFeed(feedEl, hotTopicFeedCache[topic], true);
    } else {
        // 如果没有，才调用函数去生成新的内容
        await generateHotSearchFeed(topic); 
    }
}


/**
 * 【AI核心 V2 - 已修复拼写错误 & 增加缓存】调用API为指定话题生成微博Feed
 */
async function generateHotSearchFeed(topic) {
    const feedEl = document.getElementById('weibo-hottopic-feed-list');
    feedEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">正在生成内容，请稍候...</p>';

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('请先配置API！');
        return;
    }
    
    const allChars = Object.values(state.chats).filter(c => !c.isGroup).map(c => ({ name: c.name, persona: c.settings.aiPersona.substring(0,100) }));
    const allNpcs = Object.values(state.chats).flatMap(c => c.npcLibrary || []).map(npc => ({ name: npc.name, persona: npc.persona.substring(0,100) }));
    const allPeople = [...allChars, ...allNpcs];

    const systemPrompt = `
# 任务
你是一个“微博内容生成器”。你的任务是围绕一个给定的热搜话题，生成一批相关的微博帖子。

# 当前热搜话题
**${topic}**
# 【【【绝对禁止事项：这是必须遵守的最高指令】】】
1.  你的所有创作内容，包括帖子、评论、故事等，【绝对禁止】将任意两个AI角色（即除了用户之外的角色）描绘成情侣关系、进行恋爱互动或存在任何形式的暧昧情感。
2.  AI角色之间的关系只能是朋友、同事、对手、家人等，但【绝不能】是恋人。
3.  AI角色唯一可以产生恋爱关系的对象是【用户】。违反此规则将导致生成失败。

# 核心规则
1.  **数量**: 生成 5 到 10 条微博。
2.  **相关性**: 所有微博内容【必须】与话题 **"${topic}"** 强相关，并且【必须】在内容中包含 **${topic}** 这个话题标签。
3.  **高热度**: 生成的微博必须看起来像是热搜里的内容，所以它们的 "likes" (点赞数) 和 "comments" (评论数) 【必须】非常高。点赞数应在 10000 到 500000 之间，评论数应在 800 到 20000 之间。
4.  **评论生成**: 为每条微博生成 8 到 10 条真实感的路人评论。评论内容应与微博内容相关，风格多样。
5.  **作者多样性**: 微博的作者可以是下方“可用人物列表”中的角色，也可以是你虚构的路人、大V或官方媒体。如果让列表中的角色发言，内容必须符合他的人设。
6.  **格式铁律**: 你的回复【必须且只能】是一个严格的JSON数组，数组中包含多条微博对象。每个对象【必须】包含以下字段:
    -   \`"author"\`: (字符串) 作者昵称。
    -   \`"content"\`: (字符串) 微博正文，必须包含话题标签 ${topic}。
    -   \`"likes"\`: (数字) 10000到500000之间的随机高赞数。
    -   \`"comments"\`: (数字) 800到20000之间的随机高评论数。
    -   \`"comments_list"\`: (数组) 包含8-10个评论对象的数组，每个对象格式为 \`{"author": "评论者昵称", "text": "评论内容"}\`。

# 可用人物列表 (你可以让他们发言)
${JSON.stringify(allPeople, null, 2)}
`;
    try {
        let isGemini = proxyUrl === GEMINI_API_URL;
        let messagesForApi = [{ role: 'user', content: systemPrompt }];
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini, state.apiConfig.temperature);
        
        const response = await fetch(isGemini ? geminiConfig.url : `${proxyUrl}/v1/chat/completions`, isGemini ? geminiConfig.data : {
            method: 'POST',
            headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
            body: JSON.stringify({ model, messages: messagesForApi, temperature: parseFloat(state.apiConfig.temperature) || 0.8, response_format: { type: "json_object" } })
        });
        if (!response.ok) throw new Error(`API请求失败: ${response.status} - ${await response.text()}`);

        const data = await response.json();
        const aiResponseContent = (isGemini ? data.candidates?.[0]?.content?.parts?.[0]?.text : data.choices?.[0]?.message?.content);
        if (!aiResponseContent) {
            throw new Error("API返回了空内容，可能被安全策略拦截。");
        }
        
        const sanitizedContent = aiResponseContent.replace(/^```json\s*|```$/g, '').trim();
        const responseData = JSON.parse(sanitizedContent); // <-- 这里的 responseData 是正确的
        const feedData = responseData.posts || responseData;

        // 【核心修改】将新生成的内容，记在“小本本”上
        hotTopicFeedCache[topic] = feedData; 

        renderWeiboFeed(feedEl, feedData, true);

    } catch (error) {
        console.error("生成热搜Feed失败:", error);
        feedEl.innerHTML = `<p style="text-align:center; color: #ff3b30; padding: 20px;">生成失败: ${error.message}</p>`;
    }
}


/**
 * 【总入口 V3 - 已支持多角色选择】生成微博广场Feed
 * @param {Array} hotTopics - (可选) 从热搜生成函数传过来的话题数组
 * @param {Array|string} targets - (新增) 目标角色ID数组或字符串'all'
 */
async function generatePlazaFeed(hotTopics = null, targets = 'all') {
    if (!hotTopics) {
        await showCustomAlert("请稍候...", "正在生成广场动态...");
    }
    const feedEl = document.getElementById('weibo-plaza-feed-list');
    feedEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">正在加载内容，请稍候...</p>';

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('请先配置API！');
        return;
    }
    
    let publicFiguresContext = '';
    let taskInstruction = "你的任务是模拟一个真实的社交媒体广场，生成10条由不同路人发布的微博帖子。";

    let publicFigures = [];
    if (targets === 'all') {
        publicFigures = Object.values(state.chats)
            .filter(chat => !chat.isGroup)
            .map(chat => ({ 
                name: chat.name, 
                persona: chat.settings.aiPersona.substring(0, 150) + '...',
                weibo_profession: chat.settings.weiboProfession || '未设定',
                weibo_instruction: chat.settings.weiboInstruction || '无'
            }));
    } else if (Array.isArray(targets)) {
        targets.forEach(chatId => {
            const char = state.chats[chatId];
            if(char) {
                 publicFigures.push({ 
                    name: char.name, 
                    persona: char.settings.aiPersona.substring(0, 150) + '...',
                    weibo_profession: char.settings.weiboProfession || '未设定',
                    weibo_instruction: char.settings.weiboInstruction || '无'
                });
            }
        });
        if (publicFigures.length === 1) {
            taskInstruction = `你的任务是模拟一个真实的社交媒体广场，生成10条与角色“${publicFigures[0].name}”相关的、由不同路人发布的微博帖子。`;
        } else {
            taskInstruction = `你的任务是模拟一个真实的社交媒体广场，生成10条与角色 ${publicFigures.map(p => `“${p.name}”`).join('、')} 相关的、由不同路人发布的微博帖子。`;
        }
    }
    
    publicFiguresContext = publicFigures.length > 0 
        ? `# 核心参考人物 (你生成的内容【必须】围绕他们展开)\n${JSON.stringify(publicFigures, null, 2)}` 
        : "";

    const topicsContext = (hotTopics && Array.isArray(hotTopics) && hotTopics.length > 0)
        ? `请围绕以下热门话题生成内容：${hotTopics.map(t => t.topic).join('、 ')}`
        : "请随机生成一些生活化的日常内容。";

    // 后续的 systemPrompt 和 API 调用逻辑与你现有代码完全相同，无需修改...
    const systemPrompt = `
# 任务
你是一个“微博广场内容生成器”。${taskInstruction}
# 【【【绝对禁止事项：这是必须遵守的最高指令】】】
1.  你的所有创作内容，包括帖子、评论、故事等，【绝对禁止】将任意两个AI角色（即除了用户之外的角色）描绘成情侣关系、进行恋爱互动或存在任何形式的暧昧情感。
2.  AI角色之间的关系只能是朋友、同事、对手、家人等，但【绝不能】是恋人。
3.  AI角色唯一可以产生恋爱关系的对象是【用户】。违反此规则将导致生成失败。
# 核心规则
1.  **身份**: 发帖者都是普通人，昵称要生活化。
2.  **内容**: 帖子内容应是生活化的日常。${topicsContext}
3.  **热度**: 赞和评论数可高可低，模拟真实世界的随机性。
4.  **【【【严禁杜撰】】】**: 如果你生成的内容提到了上方“核心参考人物”列表中的任何角色，你【绝对禁止】为他们【凭空捏造】人设中没有的职业、身份或背景。你只能根据提供的人设进行合理发挥。
5.  **格式铁律**: 你的回复【必须且只能】是一个严格的JSON数组，包含10个微博对象。每个对象的格式与“热搜Feed”的格式完全相同（包含 author, content, likes, comments, comments_list 字段）。
    - \`"comments_list"\`: (数组) 包含2-5条评论对象的数组，每个对象格式为 \`{"author": "评论者昵称", "text": "评论内容"}\`。
${publicFiguresContext}
`;
    try {
        let isGemini = proxyUrl === GEMINI_API_URL;
        let messagesForApi = [{ role: 'user', content: systemPrompt }];
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini, state.apiConfig.temperature);
        const response = await fetch(isGemini ? geminiConfig.url : `${proxyUrl}/v1/chat/completions`, isGemini ? geminiConfig.data : {
            method: 'POST',
            headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
            body: JSON.stringify({ model, messages: messagesForApi, temperature: parseFloat(state.apiConfig.temperature) || 0.8, response_format: { type: "json_object" } })
        });
        if (!response.ok) throw new Error(`API请求失败: ${response.status} - ${await response.text()}`);
        const data = await response.json();
        const aiResponseContent = (isGemini ? data.candidates?.[0]?.content?.parts?.[0]?.text : data.choices?.[0]?.message?.content);
        if (!aiResponseContent) {
            throw new Error("API返回了空内容，可能被安全策略拦截。");
        }
        const sanitizedContent = aiResponseContent.replace(/^```json\s*|```$/g, '').trim();
        const responseData = JSON.parse(sanitizedContent);
        const feedData = responseData.posts || responseData; 
        renderWeiboFeed(feedEl, feedData, false);
        if (!hotTopics) {
            await showCustomAlert("操作成功", "广场生成完毕！");
        }
    } catch (error) {
        console.error("生成广场Feed失败:", error);
        feedEl.innerHTML = `<p style="text-align:center; color: #ff3b30; padding: 20px;">生成失败: ${error.message}</p>`;
    }
}





// ▼▼▼ 用这整块【V3修复版】代码，完整替换旧的 renderWeiboFeed 函数 ▼▼▼
/**
 * 【UI渲染 V3 - 修复评论和头像，并添加删除按钮】通用函数，用于渲染微博Feed列表
 */
function renderWeiboFeed(containerEl, feedData, isHotSearch) {
    containerEl.innerHTML = '';
    
    if (!feedData || !Array.isArray(feedData)) {
        containerEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">AI返回的数据格式不正确，无法渲染。</p>';
        return;
    }

    feedData.forEach((post, index) => { // <-- 新增了 index 参数
        const postEl = document.createElement('div');
        postEl.className = 'weibo-post-item';
        // ▼▼▼ 核心修改1：给帖子加上一个独一无二的ID，方便我们删除 ▼▼▼
        postEl.dataset.postId = `temp_${index}`;

        // 【核心修复1：头像查找逻辑】
        let finalAvatar = 'https://i.postimg.cc/PxZrFFFL/o-o-1.jpg'; // 默认路人头像
        const potentialChar = Object.values(state.chats).find(c => c.name === post.author);
        if (potentialChar) {
            finalAvatar = potentialChar.settings.aiAvatar; // 如果作者是你的char，就用他的头像！
        }

        // 【核心修复2：评论渲染逻辑】
        let commentsHtml = '';
        if (post.comments_list && post.comments_list.length > 0) {
            commentsHtml += '<div class="weibo-comments-container">';
            post.comments_list.forEach(comment => {
                // 确保我们能正确访问评论者昵称和内容
                const commenterName = comment.author || '匿名用户'; // 优先用 author，没有就用匿名
                const commentText = comment.text || ''; // 确保 text 存在
                commentsHtml += `
                    <div class="weibo-comment-item">
                        <span class="weibo-commenter-name">${commenterName}:</span>
                        <span class="weibo-comment-text">${commentText}</span>
                    </div>`;
            });
            commentsHtml += '</div>';
        }
        
        postEl.innerHTML = `
            <div class="weibo-post-header">
                <img src="${finalAvatar}" class="weibo-post-avatar">
                <div class="weibo-post-info">
                    <span class="weibo-post-nickname">${post.author}</span>
                    <span class="weibo-post-timestamp">${isHotSearch ? '热搜内容' : '刚刚'}</span>
                </div>
                <!-- ▼▼▼ 核心修改2：在这里加上我们设计好的删除按钮！ ▼▼▼ -->
                <button class="weibo-post-delete-btn" title="删除这条动态">×</button>
            </div>
            <div class="weibo-post-content">${(post.content || '').replace(/\n/g, '<br>')}</div>
            <div class="weibo-post-footer">
                <div class="weibo-post-actions">
                    <span class="weibo-action-btn">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3"></path></svg>
                        <span>${post.likes || 0}</span>
                    </span>
                    <span class="weibo-action-btn">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path></svg>
                        <span>${post.comments || 0}</span>
                    </span>
                </div>
                ${commentsHtml}
            </div>
        `;
        containerEl.appendChild(postEl);
    });
}
// ▲▲▲ 替换结束 ▲▲▲
        /* ▼▼▼ 把这一整块全新的功能函数，粘贴到 init() 函数的上方 ▼▼▼ */
/**
 * 【全新】如果数据库中没有，则自动创建一个内置的夜间模式主题
 */
async function addDefaultDarkModeThemeIfNeeded() {
    const themeName = "内置夜间模式"; // 这是我们要内置的主题名字
    try {
        // 检查数据库里是否已经有了这个名字的主题
        const existingTheme = await db.themes.where('name').equals(themeName).first();
        
        // 如果没有找到 (existingTheme 是 undefined)，就创建它
        if (!existingTheme) {
            console.log("内置夜间模式不存在，正在创建...");

            // 这就是完整的夜间模式CSS代码
            const darkModeCss = `
/* 1. 全局重新定义颜色变量 */
:root {
  --secondary-bg: #1c1c1e;
  --border-color: #38383a;
  --text-primary: #ffffff;
  --text-secondary: #8e8e93;
  --status-bar-text-color: #ffffff;
  --accent-color: #0A84FF; /* iOS风格的蓝色 */
}

/* 2. 为所有屏幕和主要容器设置基础深色背景 */
#phone-screen, .screen, #chat-list, #world-book-list, .list-container, .form-container, #chat-messages,
#wallpaper-screen, #font-settings-screen, #api-settings-screen, #character-selection-screen,
#world-book-screen, #world-book-editor-screen, #character-phone-inner-screen, #character-phone-page {
    background-color: #000000 !important;
}

/* 3. 主屏幕专属样式 */
#home-screen { background: #111827 !important; }
#desktop-dock { background-color: rgba(55, 65, 81, 0.5); }
.desktop-app-icon .label, .widget-subtext { color: #e5e7eb; text-shadow: 0 1px 2px rgba(0,0,0,0.7); }
#profile-widget .profile-info { background: linear-gradient(to bottom, rgba(28, 28, 30, 0.85) 20%, rgba(28, 28, 30, 0)); color: #f9fafb; }
#profile-username, #profile-bio, #profile-location span { color: #f9fafb; }
#profile-sub-username, #profile-location { color: #9ca3af; }
#profile-location { background-color: rgba(255,255,255,0.1); }
.widget-bubble { background-color: rgba(55, 65, 81, 0.9); color: #e5e7eb; }
.widget-bubble::after { border-top-color: rgba(55, 65, 81, 0.9); }

/* 4. 适配所有页面的头部Header */
.header, .qzone-header, .character-phone-header {
    background-color: rgba(28, 28, 30, 0.85) !important;
    border-bottom-color: var(--border-color) !important;
    color: var(--text-primary) !important; 
}

/* 5. 适配所有通用组件 */
#chat-input-area, #chat-list-bottom-nav { background-color: rgba(28, 28, 30, 0.85); border-top-color: var(--border-color); }
#chat-input { background-color: var(--secondary-bg); color: var(--text-primary); }
.modal-content, #custom-modal { background-color: #2c2c2e; }
.modal-header, .modal-footer, .custom-modal-footer, .custom-modal-footer button:first-child { border-color: var(--border-color); }
.form-group input, .form-group select, .form-group textarea { background-color: var(--secondary-bg); color: var(--text-primary); border-color: var(--border-color); }
.list-item, .chat-list-item-swipe-container:not(:last-child), .chat-group-container, .world-book-group-container { border-bottom-color: var(--border-color) !important; }
.chat-group-container:first-of-type { border-top-color: var(--border-color) !important; }
.list-item:hover, .chat-list-item:hover { background-color: #2c2c2e; }

/* 6. 特殊页面深度适配 */
.chat-group-header, .world-book-group-header { background-color: #1c1c1e; }
.chat-list-item-content.pinned { background-color: #3a3a3c; }
#font-preview, #wallpaper-preview, .font-preset-slot { background-color: #1c1c1e !important; border-color: #38383a !important; }

/* 7. 角色手机内部适配 & 全局文字颜色修复 */
#character-phone-container { background-color: #000000; }
.character-phone-frame { background-color: #111; }
#character-chat-history-messages { background-color: #0e0e0e !important; }
.character-chat-bubble.received { background-color: #2c2c2e !important; }
.character-data-item, .character-bank-transaction, .character-cart-item, .character-browser-item {
    background-color: #1c1c1e;
    border-color: #38383a;
}

/* ▼▼▼ 核心修复：把所有这些元素的文字颜色都改为低饱和度的浅灰色 ▼▼▼ */
.character-data-item .title,
.character-data-item .content,
.character-data-item .meta,
.cart-item-price,
.cart-item-info .title,
.character-browser-item .title,
.transaction-details .title,
.transaction-amount,
.character-select-item .name,  /* 修复角色选择列表的名字颜色 */
#character-diary-list .character-data-item .content,
#character-diary-list .character-data-item .content h1,
#character-diary-list .character-data-item .content h2 {
    color: #E0E0E0 !important; /* 使用一个柔和的、不刺眼的白色 */
}

.character-data-item .meta span,
#character-diary-list .character-data-item .meta {
    color: #9E9E9E !important; /* 次要信息使用更暗的灰色 */
}

#character-diary-list .character-data-item {
    background-color: #26211a; /* 夜间模式下的信纸背景色 */
    border-color: #524a3d;
    border-left-color: #9e8a70;
}

`;

            // 把这个新主题添加到数据库的 'themes' 表里
            await db.themes.add({ name: themeName, css: darkModeCss });
            console.log("内置夜间模式已成功创建！");
        } else {
            console.log("内置夜间模式已存在，跳过创建。");
        }
    } catch (error) {
        console.error("检查或创建内置夜间模式时出错:", error);
    }
}
// ▼▼▼ 【全新】聊天记录搜索功能核心函数 ▼▼▼

/**
 * 打开并准备聊天记录搜索界面
 */
function openChatSearchScreen() {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    // 清空旧的搜索条件和结果
    document.getElementById('keyword-search-input').value = '';
    document.getElementById('sender-search-select').innerHTML = '';
    document.getElementById('date-search-input').value = '';
    document.getElementById('chat-search-results-list').innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">输入条件开始搜索</p>';

    // 动态填充“人物”下拉菜单
    const senderSelect = document.getElementById('sender-search-select');
    senderSelect.innerHTML = '<option value="">所有人</option>'; // 默认选项

    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    const myOption = document.createElement('option');
    myOption.value = myNickname;
    myOption.textContent = myNickname;
    senderSelect.appendChild(myOption);

    if (chat.isGroup) {
        chat.members.forEach(member => {
            const memberOption = document.createElement('option');
            memberOption.value = member.originalName; // 使用本名进行精确匹配
            memberOption.textContent = member.groupNickname; // 显示群昵称给用户看
            senderSelect.appendChild(memberOption);
        });
    } else {
        const aiOption = document.createElement('option');
        aiOption.value = chat.name;
        aiOption.textContent = chat.name;
        senderSelect.appendChild(aiOption);
    }
    
    // 关闭聊天设置弹窗，并显示搜索界面
    document.getElementById('chat-settings-modal').classList.remove('visible');
    showScreen('chat-search-screen');
}

/**
 * 执行搜索操作
 */
/**
 * 【功能完整版】执行搜索操作
 */
function performChatSearch() {
    const chat = state.chats[state.activeChatId];
    if (!chat) {
        // 如果找不到聊天对象，给用户一个明确的提示
        alert('无法执行搜索，因为没有找到当前聊天。');
        return;
    }

    // 1. 获取所有搜索条件
    const keyword = document.getElementById('keyword-search-input').value.trim();
    const senderValue = document.getElementById('sender-search-select').value;
    const dateValue = document.getElementById('date-search-input').value;

    // 将关键词保存到全局变量，以便在渲染结果时用于高亮
    currentSearchKeyword = keyword;

    if (!keyword && !senderValue && !dateValue) {
        alert('请至少输入一个搜索条件！');
        return;
    }

    // 2. 筛选聊天记录
    console.log(`开始搜索: 关键词='${keyword}', 发言人='${senderValue}', 日期='${dateValue}'`);
    
    const results = chat.history.filter(msg => {
        // 过滤掉系统消息和对用户隐藏的消息
        if (msg.isHidden || msg.role === 'system' || msg.type === 'recalled_message') {
            return false;
        }

        // a. 筛选日期
        if (dateValue) {
            const msgDate = new Date(msg.timestamp).toISOString().split('T')[0];
            if (msgDate !== dateValue) {
                return false;
            }
        }

        // b. 筛选发言人
        if (senderValue) {
            const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
            let msgSenderName = '';
            
            if (msg.role === 'user') {
                msgSenderName = myNickname;
            } else { // AI或群成员的消息
                // 这里我们使用 originalName 来精确匹配，因为群昵称可能会变
                msgSenderName = chat.isGroup ? msg.senderName : chat.name;
            }
            if (msgSenderName !== senderValue) {
                return false;
            }
        }

        // c. 筛选关键词
        if (keyword) {
            let contentText = '';
            // 将所有可能包含文本的内容都转换成字符串进行搜索
            if (typeof msg.content === 'string') {
                contentText = msg.content;
            } else if (typeof msg.content === 'object' && msg.content !== null) {
                // 对于复杂对象，我们可以简单地将它们转为JSON字符串来搜索
                contentText = JSON.stringify(msg.content);
            }
            
            if (!contentText.toLowerCase().includes(keyword.toLowerCase())) {
                return false;
            }
        }

        return true; // 所有条件都满足
    });
    
    console.log(`搜索到 ${results.length} 条结果`);

    // 3. 渲染结果
    renderSearchResults(results);
}


/**
 * 渲染搜索结果列表
 * @param {Array} results - 筛选出的消息数组
 */
function renderSearchResults(results) {
    const listEl = document.getElementById('chat-search-results-list')
;
    listEl.innerHTML = '';
listEl.scrollTop = 0; // 每次渲染前，都将滚动条重置到顶部

    if (results.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">未找到相关记录</p>';
        return;
    }

    const chat = state.chats[state.activeChatId];
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    
    // 为了性能，只渲染最新的100条结果
    results.slice(-100).reverse().forEach(msg => {
        const item = document.createElement('div');
        item.className = 'search-result-item';
        item.dataset.timestamp = msg.timestamp; // 关键！用于跳转

        let senderName, senderAvatar;
        if (msg.role === 'user') {
            senderName = myNickname;
            senderAvatar = chat.settings.myAvatar;
        } else {
            if (chat.isGroup) {
                senderName = msg.senderName;
                const member = chat.members.find(m => m.originalName === senderName);
                senderAvatar = member ? member.avatar : defaultGroupMemberAvatar;
            } else {
                senderName = chat.name;
                senderAvatar = chat.settings.aiAvatar;
            }
        }

        let contentText = '';
        if (msg.type === 'sticker' || (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content))) {
            contentText = '[表情]';
        } else if (msg.type === 'ai_image' || msg.type === 'user_photo' || Array.isArray(msg.content)) {
            contentText = '[图片]';
        } else {
            contentText = String(msg.content);
        }

        item.innerHTML = `
            <img src="${senderAvatar || defaultAvatar}" class="avatar">
            <div class="search-result-info">
                <div class="search-result-meta">
                    <span class="name">${senderName}</span>
                    <span class="timestamp">${formatDateStamp(msg.timestamp)}</span>
                </div>
                <div class="search-result-content">
                    ${highlightText(contentText, currentSearchKeyword)}
                </div>
            </div>
        `;
        listEl.appendChild(item);
    });
}

/**
 * 辅助函数：高亮文本中的关键词
 * @param {string} text - 原始文本
 * @param {string} keyword - 要高亮的关键词
 * @returns {string} - 处理后的HTML字符串
 */
function highlightText(text, keyword) {
    if (!keyword || !text) {
        return text;
    }
    const regex = new RegExp(keyword.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'gi');
    return text.replace(regex, `<span class="highlight">$&</span>`);
}

// ▼▼▼ 请用这块【最终修复版】的代码，完整替换旧的 jumpToMessage 函数 ▼▼▼
/**
 * 【最终修复版】点击搜索结果，跳转到对应的消息位置
 * @param {number} timestamp - 目标消息的时间戳
 */
async function jumpToMessage(timestamp) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const targetIndex = chat.history.findIndex(msg => msg.timestamp === timestamp);
    if (targetIndex === -1) {
        await showCustomAlert('错误', '找不到该条消息，可能已被删除。');
        return;
    }

    // 1. 切换回聊天界面
    showScreen('chat-interface-screen');
    await new Promise(resolve => setTimeout(resolve, 50));

    const messagesContainer = document.getElementById('chat-messages');
    messagesContainer.innerHTML = ''; // 清空当前内容

    // 2. 计算要渲染的消息窗口（以目标消息为中心）
    const windowSize = 50; // 和 MESSAGE_RENDER_WINDOW 保持一致
    const startIndex = Math.max(0, targetIndex - Math.floor(windowSize / 2));
    const messagesToRender = chat.history.slice(startIndex);

    // 3. 更新 currentRenderedCount 以同步加载状态
    //    这一步至关重要，它告诉“加载更多”功能下次应该从哪里开始加载
    currentRenderedCount = messagesToRender.length;

    // 4. 如果计算出的起始位置大于0，说明前面还有更早的记录，需要显示“加载更多”按钮
    if (startIndex > 0) {
        prependLoadMoreButton(messagesContainer);
    }

    // 5. 渲染消息窗口和日期戳
    let lastMessageTimestamp = startIndex > 0 ? chat.history[startIndex - 1].timestamp : null;
    messagesToRender.forEach(msg => {
        if (msg.isHidden) return;
        if (isNewDay(msg.timestamp, lastMessageTimestamp)) {
            const dateStampEl = createDateStampElement(msg.timestamp);
            messagesContainer.appendChild(dateStampEl);
        }
        // 使用 true 作为第三个参数，表示这是初始加载，不应播放动画
        appendMessage(msg, chat, true); 
        lastMessageTimestamp = msg.timestamp;
    });

    // 6. 滚动到目标消息并高亮它
    //    使用 setTimeout 确保 DOM 元素已经完全渲染到页面上
    setTimeout(() => {
        const targetMessage = messagesContainer.querySelector(`.message-bubble[data-timestamp="${timestamp}"]`);
        if (targetMessage) {
            // 使用 'auto' 滚动，比 'smooth' 更快速直接
            targetMessage.scrollIntoView({ behavior: 'auto', block: 'center' });
            
            // 添加闪烁高亮效果，让用户能注意到
            targetMessage.classList.add('flash');
            setTimeout(() => {
                targetMessage.classList.remove('flash');
            }, 1500);
        }
    }, 100);

    // 7. 【最关键】我们已经移除了导致页面跳回的 setTimeout(renderChatInterface, ...)
}
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 把下面这【两段】全新的函数，粘贴到 init() 函数的【正上方】 ▼▼▼

/**
 * 【全新】显示微博主页并渲染数据
 */
async function showWeiboScreen() {
    // 1. 计算关注数
    const allSingleChats = Object.values(state.chats).filter(chat => !chat.isGroup);
    let totalNpcCount = 0;
    allSingleChats.forEach(chat => {
        if (chat.npcLibrary && chat.npcLibrary.length > 0) {
            totalNpcCount += chat.npcLibrary.length;
        }
    });
    const followingCount = allSingleChats.length + totalNpcCount;

    // 2. 更新页面上的元素
    // 从你的“动态(QZone)”设置里获取头像和昵称，保持统一
    document.getElementById('weibo-avatar-img').src = state.qzoneSettings.avatar || defaultAvatar;
    document.getElementById('weibo-nickname').textContent = state.qzoneSettings.nickname || '你的昵称';
    document.getElementById('weibo-following-count').textContent = followingCount;

    // 3. 显示微博页面
    showScreen('weibo-screen');
}

// ▼▼▼ 用这块【已添加主页按钮】的代码，替换旧的 showFollowingList 函数 ▼▼▼
function showFollowingList() {
    console.log("【诊断日志 2】: showFollowingList 函数已成功触发！");

    const modal = document.getElementById('weibo-following-modal');
    console.log("【诊断日志 3】: 正在尝试获取弹窗元素 #weibo-following-modal:", modal);
    if (!modal) {
        alert("诊断错误：在HTML中找不到ID为 'weibo-following-modal' 的弹窗元素！请检查HTML代码。");
        return;
    }

    const listContainer = document.getElementById('weibo-following-list-container');
    listContainer.innerHTML = '';
    
    const allSingleChats = Object.values(state.chats).filter(chat => !chat.isGroup);
    
    if (allSingleChats.length === 0) {
        listContainer.innerHTML = '<p style="text-align:center; color:grey; padding: 20px;">还没有关注任何人哦</p>';
    } else {
        allSingleChats.forEach(chat => {
            // --- 渲染角色本人 ---
            const charItem = document.createElement('div');
            charItem.className = 'weibo-following-item';
            // 【核心修改】在这里加入了“查看主页”和“AI操作”按钮
            charItem.innerHTML = `
                <img src="${chat.settings.aiAvatar || defaultAvatar}" class="weibo-following-avatar">
                <span class="weibo-following-name">${chat.name}</span>
                <!-- 这是我们新增的“查看主页”按钮 -->
                <button class="view-profile-btn" data-char-id="${chat.id}">主页</button>
                <span class="weibo-action-trigger-btn" data-target-id="${chat.id}" data-target-name="${chat.name}" data-is-npc="false" title="为Ta执行操作">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></svg>
                </span>
            `;
            listContainer.appendChild(charItem);
            
            // --- 渲染该角色下的NPC ---
            if (chat.npcLibrary && chat.npcLibrary.length > 0) {
                chat.npcLibrary.forEach(npc => {
                    const npcItem = document.createElement('div');
                    npcItem.className = 'weibo-following-item';
                    npcItem.style.paddingLeft = '30px';
                    // NPC暂时没有独立主页，所以不加“主页”按钮
                    npcItem.innerHTML = `
                         <img src="${npc.avatar || defaultGroupMemberAvatar}" class="weibo-following-avatar">
                         <span class="weibo-following-name">${npc.name} (NPC)</span>
                         <span class="weibo-action-trigger-btn" data-target-id="${npc.id}" data-target-name="${npc.name}" data-is-npc="true" data-owner-id="${chat.id}" title="为Ta执行操作">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></svg>
                         </span>
                    `;
                    listContainer.appendChild(npcItem);
                });
            }
        });
    }
    
    modal.classList.add('visible');
    console.log("【诊断日志 4】: 已成功为弹窗添加 .visible 类，弹窗现在应该显示了。");
}
// ▲▲▲ 替换结束 ▲▲▲

// ▲▲▲ 新函数粘贴结束 ▲▲▲
// ▼▼▼ 【全新】微博页面功能函数 ▼▼▼

// ▼▼▼ 用这块【已添加头像框渲染逻辑】的代码替换旧的 ▼▼▼
/**
 * 【微博专属】渲染微博个人主页的所有数据
 */
async function renderWeiboProfile() {
    const settings = state.qzoneSettings || {};
    // 【核心】所有数据都从 weibo... 字段读取！
    document.getElementById('weibo-avatar-img').src = settings.weiboAvatar;
    document.getElementById('weibo-nickname').textContent = settings.weiboNickname;
    document.getElementById('weibo-fans-count').textContent = settings.weiboFansCount;
    document.getElementById('weibo-background-img').src = settings.weiboBackground;
    
    // 动态计算关注数 (这部分不变)
    const allSingleChats = Object.values(state.chats).filter(chat => !chat.isGroup);
    let totalNpcCount = 0;
    allSingleChats.forEach(chat => {
        if (chat.npcLibrary && chat.npcLibrary.length > 0) {
            totalNpcCount += chat.npcLibrary.length;
        }
    });
    document.getElementById('weibo-following-count').textContent = allSingleChats.length + totalNpcCount;
    
    // 动态计算微博数
    const postsCount = await db.weiboPosts.where('authorId').equals('user').count();
    document.getElementById('weibo-posts-count').textContent = postsCount;
    
    const professionEl = document.getElementById('weibo-user-profession-display');
    if (professionEl) {
        professionEl.textContent = settings.weiboUserProfession || '点击设置职业';
    }

    // --- ▼▼▼ 以下是本次新增的核心代码 ▼▼▼ ---
    // 1. 获取保存的头像框URL
    const frameUrl = settings.weiboAvatarFrame || '';
    // 2. 找到头像框的img元素
    const frameImg = document.getElementById('weibo-avatar-frame');
    if (frameImg) {
        // 3. 如果URL存在，就显示它
        if (frameUrl) {
            frameImg.src = frameUrl;
            frameImg.style.display = 'block';
        } else {
            // 4. 如果URL为空（即选择了“无”），就隐藏它
            frameImg.src = '';
            frameImg.style.display = 'none';
        }
    }
    // --- ▲▲▲ 新增代码结束 ▲▲▲
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 【微博专属】编辑微博头像
 */
async function editWeiboAvatar() {
    const newAvatarUrl = await getNewImageUrl("更换微博头像", state.qzoneSettings.weiboAvatar);
    if (newAvatarUrl) {
        state.qzoneSettings.weiboAvatar = newAvatarUrl; // 只修改微博头像
        await saveQzoneSettings();
        await renderWeiboProfile(); // 用专属函数刷新
    }
}

/**
 * 【微博专属】编辑微博背景图
 */
async function editWeiboBackground() {
    const newBgUrl = await getNewImageUrl("更换微博背景", state.qzoneSettings.weiboBackground);
    if (newBgUrl) {
        state.qzoneSettings.weiboBackground = newBgUrl; // 只修改微博背景
        await saveQzoneSettings();
        await renderWeiboProfile();
    }
}

/**
 * 【微博专属】编辑微博昵称
 */
async function editWeiboNickname() {
    const newNickname = await showCustomPrompt("编辑微博昵称", "请输入新的昵称", state.qzoneSettings.weiboNickname);
    if (newNickname !== null) {
        state.qzoneSettings.weiboNickname = newNickname.trim() || '你的昵称'; // 只修改微博昵称
        await saveQzoneSettings();
        await renderWeiboProfile();
    }
}

/**
 * 【微博专属】编辑微博粉丝数
 */
async function editWeiboFansCount() {
    const newFans = await showCustomPrompt("编辑粉丝数", "请输入新的粉丝数", state.qzoneSettings.weiboFansCount, "number");
    if (newFans !== null) {
        state.qzoneSettings.weiboFansCount = newFans.trim() || '0'; // 只修改微博粉丝数
        await saveQzoneSettings();
        await renderWeiboProfile();
    }
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

/**
 * 通用的图片编辑函数 (本地上传或URL)
 * @param {string} title - 弹窗标题
 * @param {string} currentUrl - 当前的图片URL
 * @returns {Promise<string|null>} - 新的图片URL或null
 */
async function getNewImageUrl(title, currentUrl) {
    const choice = await showChoiceModal(title, [
        { text: '📁 从本地上传', value: 'local' },
        { text: '🌐 使用网络URL', value: 'url' }
    ]);

    if (choice === 'local') {
        return await uploadImageLocally();
    } else if (choice === 'url') {
        const url = await showCustomPrompt(title, "请输入新的图片URL", currentUrl, "url");
        if (url && url.trim().startsWith('http')) {
            return url.trim();
        } else if (url !== null) {
            alert("请输入一个有效的URL！");
        }
    }
    return null;
}

/**
 * 编辑微博头像
 */
async function editWeiboAvatar() {
    const newAvatarUrl = await getNewImageUrl("更换头像", state.qzoneSettings.weiboAvatar);
    if (newAvatarUrl) {
        state.qzoneSettings.weiboAvatar = newAvatarUrl;
        await saveQzoneSettings();
        await renderWeiboProfile();
    }
}

/**
 * 编辑微博背景图
 */
async function editWeiboBackground() {
    const newBgUrl = await getNewImageUrl("更换背景图", state.qzoneSettings.weiboBackground);
    if (newBgUrl) {
        state.qzoneSettings.weiboBackground = newBgUrl;
        await saveQzoneSettings();
        await renderWeiboProfile();
    }
}

/**
 * 编辑微博昵称
 */
async function editWeiboNickname() {
    const newNickname = await showCustomPrompt("编辑昵称", "请输入新的微博昵称", state.qzoneSettings.weiboNickname);
    if (newNickname !== null) {
        state.qzoneSettings.weiboNickname = newNickname.trim() || '你的昵称';
        await saveQzoneSettings();
        await renderWeiboProfile();
    }
}

// ▼▼▼ 请【再次确认】并用下面这【整块函数】替换掉旧的 editWeiboFansCount 函数 ▼▼▼
/**
 * 【微博专属】编辑微博粉丝数 (已修复，支持汉字)
 */
async function editWeiboFansCount() {
    // 核心修改：确保这里的第四个参数是 "text"，而不是 "number"
    const newFans = await showCustomPrompt("编辑粉丝数", "请输入新的粉丝数", state.qzoneSettings.weiboFansCount, "text");
    
    if (newFans !== null) {
        state.qzoneSettings.weiboFansCount = newFans.trim() || '0'; // 只修改微博粉丝数
        await saveQzoneSettings();
        await renderWeiboProfile();
    }
}
// ▲▲▲ 替换结束 ▲▲▲

// ▲▲▲ 新函数粘贴结束 ▲▲▲


// ▼▼▼ 请用这块【修复后】的代码，完整替换掉你旧的 switchToWeiboView 函数 ▼▼▼
/**
 * 【全新】切换微博主界面中的不同页面视图
 * @param {string} viewId - 要切换到的视图的ID
 */
async function switchToWeiboView(viewId) {
    // 1. 隐藏所有微博页面
    document.querySelectorAll('.weibo-view').forEach(view => {
        view.style.display = 'none'; // 使用 style.display 确保隐藏
    });
    
    // 2. 显示目标页面
    const targetView = document.getElementById(viewId);
    if (targetView) {
        targetView.style.display = 'flex'; // 使用 flex 显示
    }

    // 3. 更新底部导航栏的高亮状态
    document.querySelectorAll('.weibo-nav-item').forEach(item => {
        item.classList.remove('active');
    });
    const targetNavItem = document.querySelector(`.weibo-nav-item[data-view="${viewId}"]`);
    if (targetNavItem) {
        targetNavItem.classList.add('active');
    }

    // --- ▼▼▼【核心修复】▼▼▼ ---
    // 4. 根据你点击的页签，去加载并显示对应的微博内容
    if (viewId === 'weibo-following-view') {
        // 如果是“关注的人”页，就调用渲染关注列表的函数
        await renderFollowingWeiboFeed();
    } else if (viewId === 'weibo-my-profile-view') {
        // 如果是“我的微博”页，就调用渲染“我”的微博的函数
        await renderMyWeiboFeed();
    }
    // --- ▲▲▲【修复结束】▲▲▲ ---
}
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 在这里开始复制 ▼▼▼

// ▼▼▼ 用这块【功能增强版】代码，替换旧的 openQZonePublisher 函数 ▼▼▼
async function openQZonePublisher(mode) {
    resetCreatePostModal();
    const modal = document.getElementById('create-post-modal');
    modal.dataset.mode = mode;
    document.getElementById('create-post-modal-title').textContent = '发布动态';

    if (mode === 'shuoshuo') {
        modal.querySelector('.post-mode-switcher').style.display = 'none';
        modal.querySelector('#image-mode-content').style.display = 'none';
        modal.querySelector('#text-image-mode-content').style.display = 'none';
        modal.querySelector('#post-public-text').placeholder = '分享新鲜事...';
    } else {
        modal.querySelector('.post-mode-switcher').style.display = 'flex';
        modal.querySelector('#image-mode-content').classList.add('active');
        modal.querySelector('#text-image-mode-content').classList.remove('active');
        modal.querySelector('#post-public-text').placeholder = '分享新鲜事...（非必填的公开文字）';
    }

    document.getElementById('post-comments-toggle-group').style.display = 'block';
    
    // --- ▼▼▼ 以下是本次新增的核心代码 ▼▼▼ ---
    const visibilityGroup = document.getElementById('post-visibility-group');
    const groupsContainer = document.getElementById('post-visibility-groups');
    const visibilityRadios = document.querySelectorAll('input[name="visibility"]');

    visibilityGroup.style.display = 'block';
    groupsContainer.innerHTML = ''; // 清空旧的分组列表
    
    // 从数据库读取你的好友分组
    const groups = await db.qzoneGroups.toArray();
    if (groups.length > 0) {
        groups.forEach(group => {
            const label = document.createElement('label');
            label.innerHTML = `<input type="checkbox" value="${group.id}"> ${group.name}`;
            groupsContainer.appendChild(label);
        });
    } else {
        groupsContainer.innerHTML = '<p style="color: #8a8a8a; font-size: 13px;">还没有创建任何好友分组哦。</p>';
    }

    // 默认选中“所有人可见”并隐藏分组选择
    visibilityRadios[0].checked = true;
    groupsContainer.style.display = 'none';

    // 监听单选按钮的变化
    visibilityRadios.forEach(radio => {
        radio.onchange = function() {
            groupsContainer.style.display = this.value === 'groups' ? 'block' : 'none';
        };
    });
    // --- ▲▲▲ 新增代码结束 ▲▲▲ ---

    modal.classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 用这整块【评论优化版】的代码，完整替换掉你旧的 generateWeiboComments 函数 ▼▼▼
/**
 * 【评论优化版 V2】AI生成微博评论的核心函数
 * @param {number} postId - 需要生成评论的微博ID
 */
async function generateWeiboComments(postId) {
    const post = await db.weiboPosts.get(postId);
    if (!post) {
        alert("错误：找不到这条微博！");
        return;
    }

    await showCustomAlert("请稍候...", "正在召唤高质量网友...");

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('请先配置API！');
        return;
    }
    
    let authorPersona = "一个普通用户。";
    let authorProfession = "未设定"; 
    const authorName = post.authorId === 'user' ? (state.qzoneSettings.weiboNickname || '我') : post.authorNickname;
    
    if (post.authorId === 'user') {
        authorPersona = state.qzoneSettings.weiboUserPersona || '一个普通的微博用户。';
        authorProfession = state.qzoneSettings.weiboUserProfession || '未设定';
    } else {
        const authorChat = state.chats[post.authorId];
        if (authorChat) {
            authorPersona = authorChat.settings.aiPersona || '无';
            authorProfession = authorChat.settings.weiboProfession || '未设定';
        }
    }
    const truncatedPersona = authorPersona.substring(0, 400);
    const postContent = (post.content || "").substring(0, 200);
    const existingComments = (post.comments || []).slice(-5).map(c => `${c.authorNickname}: ${c.commentText}`).join('\n');

    let imageContext = '';
    if (post.imageUrl && post.imageDescription) {
        imageContext = `
- **图片内容**: 这条微博配有一张图片，描述为：“${post.imageDescription}”`;
    } else if (post.postType === 'text_image' && post.hiddenContent) {
        imageContext = `
- **图片内容**: 这是一张文字图，上面的内容是：“${post.hiddenContent}”`;
    }
    
    // ▼▼▼ 从这里开始，是我们新增的核心代码 ▼▼▼

    // 1. 创建一个集合，用来存放评论区已出现的、有人设的角色信息
    const commenterPersonas = new Map();

    // 2. 将微博作者本人的人设先加进去
    commenterPersonas.set(authorName, `[职业: ${authorProfession}] [人设: ${truncatedPersona}]`);

    // 3. 遍历已有的评论，查找并添加其他角色的人设
    if (post.comments && post.comments.length > 0) {
        post.comments.forEach(comment => {
            const commenterName = comment.authorNickname;
            // 如果这个人设还没被记录过
            if (!commenterPersonas.has(commenterName)) {
                // 检查这个评论者是不是一个已知的AI角色
                const commenterChat = Object.values(state.chats).find(c => c.name === commenterName);
                if (commenterChat && !commenterChat.isGroup) {
                    // 如果是，就把他/她的人设和职业也加到集合里
                    const profession = commenterChat.settings.weiboProfession || '未设定';
                    const persona = (commenterChat.settings.aiPersona || '无').substring(0, 200);
                    commenterPersonas.set(commenterName, `[职业: ${profession}] [人设: ${persona}]`);
                }
            }
        });
    }
    
    // 4. 将收集到的人设信息，格式化成给AI看的文本
    let commenterContext = '';
    if (commenterPersonas.size > 0) {
        commenterContext += '\n# 评论区已有角色人设 (供你回复时参考)\n';
        commenterPersonas.forEach((persona, name) => {
            commenterContext += `- **${name}**: ${persona}\n`;
        });
    }

    // ▲▲▲ 新增代码到此结束 ▲▲▲

    const systemPrompt = `
# 任务
你是一个专业的“社交媒体模拟器”。你的任务是根据一个特定角色的“人设”，为他/她发布的一条微博生成一批真实的、符合情景的网友评论。

# 微博情景
- **作者**: ${authorName}
- **微博文字**: ${postContent || "(该微博没有配文)"}
${imageContext}
- **已有评论 (你可以回复他们)**:
${existingComments || "(暂无评论)"}

${commenterContext}

# 【【【评论生成核心规则】】】
1.  **【【【严禁使用】】】**: 绝对禁止使用 “路人甲”、“网友A”、“粉丝B” 这类代号作为评论者昵称。
2.  **昵称多样化**: 评论者的昵称必须非常真实、多样化且符合微博生态。例如：“今天也要早睡”、“可乐加冰块”、“是小王不是小张”、“理性吃瓜第一线”。
3.  **内容与人设强相关**: 评论内容必须与【微博内容(包括文字和图片)】和【作者以及被回复者的人设】高度相关。思考：什么样的粉丝会关注这样的人？他们会怎么说话？当回复一个有特定人设的角色时，你的回复必须考虑到对方的身份。
4.  **风格多样化**: 生成的评论应包含不同立场和风格，例如：
    -   **粉丝**: “哥哥太帅了！新剧什么时候播？”
    -   **路人**: “这个地方看起来不错，求地址！”
    -   **黑粉/质疑者**: “就这？感觉p图有点过了吧...”
    -   **玩梗**: “楼上是不是XX派来的间谍（狗头）”
5.  **格式铁律**: 你的回复【必须且只能】是一个严格的JSON数组，每个对象代表一条评论。
    -   发表新评论, 使用格式: \`{"author": "不吃香菜的仙女", "comment": "哇，这个好好看！"}\`
    -   回复已有评论, 使用格式: \`{"author": "爱吃瓜的猹", "comment": "我也觉得！", "replyTo": "不吃香菜的仙女"}\`

现在，请开始你的表演。
`;

    try {
        let isGemini = proxyUrl === GEMINI_API_URL;
        let messagesForApi = [{ role: 'user', content: systemPrompt }];
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini, state.apiConfig.temperature);


        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: messagesForApi,
                    temperature: parseFloat(state.apiConfig.temperature) || 0.8, 
                    response_format: { type: "json_object" }
                })
            });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`API请求失败: ${response.status} - ${errorText}`);
        }

        const data = await response.json();
        const aiResponseContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content)
            .replace(/^```json\s*|```$/g, '').trim();
        
        const newComments = JSON.parse(aiResponseContent);

        if (Array.isArray(newComments) && newComments.length > 0) {
            const postToUpdate = await db.weiboPosts.get(post.id);
            if (!postToUpdate) throw new Error("在数据库中找不到要更新的帖子！");
            
            if (!postToUpdate.comments) postToUpdate.comments = [];
            
            newComments.forEach(comment => {
                if(comment.author && comment.comment) {
                    const newCommentObject = {
                        commentId: 'comment_' + Date.now() + Math.random(),
                        authorNickname: comment.author,
                        commentText: comment.comment,
                        timestamp: Date.now()
                    };
                    if (comment.replyTo) {
                        newCommentObject.replyToNickname = comment.replyTo;
                    }
                    postToUpdate.comments.push(newCommentObject);
                }
            });

            postToUpdate.baseLikesCount = (postToUpdate.baseLikesCount || 0) + Math.floor(Math.random() * newComments.length * 3 + 5);

            await db.weiboPosts.put(postToUpdate);
            
            await renderMyWeiboFeed();
            await renderFollowingWeiboFeed();
            
            alert(`成功生成了 ${newComments.length} 条新评论！`);
        } else {
             alert("AI没有生成有效的评论。");
        }

    } catch (error) {
        console.error("生成微博评论失败:", error);
        await showCustomAlert('生成失败', `发生了一个错误：\n${error.message}`);
    }
}
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 把这个新函数粘贴到 renderWeiboProfile 函数的上方 ▼▼▼
/**
 * 【全新】删除一条微博评论
 * @param {number} postId - 评论所在的微博ID
 * @param {string} commentId - 要删除的评论的ID
 */
async function deleteWeiboComment(postId, commentId) {
    const post = await db.weiboPosts.get(postId);
    if (!post || !post.comments) return;

    const commentIndex = post.comments.findIndex(c => c.commentId === commentId);
    if (commentIndex === -1) return;
    
    const commentText = post.comments[commentIndex].commentText;

    const confirmed = await showCustomConfirm(
        '删除评论', 
        `确定要删除这条评论吗？\n\n“${commentText.substring(0, 50)}...”`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        post.comments.splice(commentIndex, 1);
        await db.weiboPosts.put(post);
        await renderMyWeiboFeed();
        await renderFollowingWeiboFeed();
        alert("评论已删除。");
    }
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲
// ▼▼▼ 在 init() 函数的【正上方】，粘贴下面这一整块新代码 ▼▼▼
/**
 * 【全新】一键清空所有单人聊天背景
 */
async function clearAllSingleChatBackgrounds() {
    // 弹出确认框，防止误操作
    const confirmed = await showCustomConfirm(
        '确认操作', 
        '此操作将移除所有角色单独设置的聊天背景，统一使用全局背景。确定要继续吗？',
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        let updatedCount = 0;
        const chatsToUpdate = [];

        // 遍历所有聊天
        for (const chatId in state.chats) {
            const chat = state.chats[chatId];
            // 如果这个聊天设置了单人背景
            if (chat.settings && chat.settings.background) {
                chat.settings.background = ''; // 清空它
                chatsToUpdate.push(chat);
                updatedCount++;
            }
        }

        // 如果有需要更新的聊天，就批量写入数据库
        if (chatsToUpdate.length > 0) {
            await db.chats.bulkPut(chatsToUpdate);
        }
        
        await showCustomAlert('操作成功', `已成功清空 ${updatedCount} 个角色的单人聊天背景！`);
    }
}
// ▲▲▲ 粘贴结束 ▲▲▲
/* ▼▼▼ 【V2修正版】主屏幕美化预设核心功能函数 ▼▼▼ */

let activeHomePresetId = null; // 用于追踪当前选中的预设ID

/**
 * 启用或禁用预设管理按钮
 */
function toggleHomePresetButtons(isEnabled) {
    document.getElementById('apply-home-preset-btn').disabled = !isEnabled;
    document.getElementById('update-home-preset-btn').disabled = !isEnabled; // <-- 新增这一行
    document.getElementById('rename-home-preset-btn').disabled = !isEnabled;
    document.getElementById('delete-home-preset-btn').disabled = !isEnabled;
    document.getElementById('export-home-preset-btn').disabled = !isEnabled;
}


/**
 * 加载预设到下拉框
 */
async function loadHomeScreenPresetsToDropdown() {
    const selector = document.getElementById('home-preset-selector');
    selector.innerHTML = '<option value="">-- 请选择一个预设 --</option>';
    const presets = await db.homeScreenPresets.toArray();
    presets.forEach(preset => {
        const option = document.createElement('option');
        option.value = preset.id;
        option.textContent = preset.name;
        selector.appendChild(option);
    });
    activeHomePresetId = null; // 重置选择
    toggleHomePresetButtons(false); // 默认禁用按钮
}

/**
 * 【新】当用户从下拉框选择一个预设时
 */
function handleHomePresetSelection() {
    const selector = document.getElementById('home-preset-selector');
    activeHomePresetId = selector.value ? parseInt(selector.value) : null;
    // 只有当用户确实选择了一个预设时，才启用相关按钮
    toggleHomePresetButtons(!!activeHomePresetId);
}

// 这是修改后的新代码
async function applySelectedHomeScreenPreset() {
    if (!activeHomePresetId) {
        alert("请先从下拉框中选择一个要应用的预设。");
        return;
    }
    const preset = await db.homeScreenPresets.get(activeHomePresetId);
    if (preset && preset.data) {
        // 将预设数据加载到全局状态
        state.globalSettings.widgetData = preset.data;

        if (preset.data.wallpaper) {
            state.globalSettings.wallpaper = preset.data.wallpaper;
        }
        if (preset.data.appIcons) {
            state.globalSettings.appIcons = { ...preset.data.appIcons };
        }

        // ★★★★★ 这就是我们本次唯一需要添加的核心代码！ ★★★★★
        // 检查预设中是否有appLabels数据，如果有，就加载它
        if (preset.data.appLabels) {
            state.globalSettings.appLabels = { ...preset.data.appLabels };
        } else {
            // 如果旧的预设没有这个数据，就清空当前的自定义名称，恢复默认
            state.globalSettings.appLabels = {};
        }
        // ★★★★★ 添加结束 ★★★★★

        // 保存所有更新到数据库
        await db.globalSettings.put(state.globalSettings);
        
        // 依次应用所有设置 (现在 applyAppLabels() 就能获取到正确的名称了)
        applyGlobalWallpaper();
        applyAppIcons();
        applyAppLabels(); 
        applyWidgetData(); 

        alert(`已成功应用预设: "${preset.name}"！`);
        showScreen('home-screen');
    }
}

/**
 * 【全新】渲染主屏幕个人资料卡的头像框
 */
function renderHomeScreenProfileFrame() {
    // 1. 获取保存的头像框URL
    const frameUrl = state.globalSettings.homeAvatarFrame || '';
    // 2. 找到头像框的img元素
    const frameImg = document.getElementById('profile-avatar-frame');
    if (frameImg) {
        // 3. 如果URL存在，就显示它
        if (frameUrl) {
            frameImg.src = frameUrl;
            frameImg.style.display = 'block';
        } else {
            // 4. 如果URL为空（即选择了“无”），就隐藏它
            frameImg.src = '';
            frameImg.style.display = 'none';
        }
    }
}


/**
 * 【V2 修复版】保存当前的主屏幕设置为一个新的预设
 */
async function saveCurrentHomeScreenAsPreset() {
    const presetName = await showCustomPrompt("保存预设", "请为这个主屏幕美化方案起个名字：");
    if (!presetName || !presetName.trim()) {
        if (presetName !== null) alert("名字不能为空！");
        return;
    }

    // 核心：构建一个包含所有主屏幕元素的完整数据对象
    const presetData = {
        // --- 个人资料卡片 ---
        'profile-banner-img': document.getElementById('profile-banner-img').src,
        'profile-avatar-img': document.getElementById('profile-avatar-img').src,
        'homeAvatarFrame': document.getElementById('profile-avatar-frame').src, // ★★★ 新增：保存头像框 ★★★
        'profile-username': document.getElementById('profile-username').textContent,
        'profile-sub-username': document.getElementById('profile-sub-username').textContent,
        'profile-bio': document.getElementById('profile-bio').textContent,
        'profile-location': document.getElementById('profile-location').innerHTML,

        // --- 第一页小组件 ---
        'widget-bubble-1': document.getElementById('widget-bubble-1').textContent,
        'widget-image-1': document.getElementById('widget-image-1').src,
        'widget-subtext-1': document.getElementById('widget-subtext-1').textContent,
        'widget-bubble-2': document.getElementById('widget-bubble-2').textContent,
        'widget-image-2': document.getElementById('widget-image-2').src,
        'widget-subtext-2': document.getElementById('widget-subtext-2').textContent,
        
        // --- 第二页小组件 ---
        'widget-image-3': document.getElementById('widget-image-3').src,
        'second-page-bubble': document.getElementById('second-page-bubble').textContent,
        'flat-capsule-bubble': document.getElementById('flat-capsule-bubble').textContent,
        'circular-bubble': document.getElementById('circular-bubble').textContent,
        'widget-image-4': document.getElementById('widget-image-4').src,
        'avatar-subtitle': document.getElementById('avatar-subtitle').textContent,
        'bubble-top-left': document.getElementById('bubble-top-left').textContent,
        'bubble-top-right': document.getElementById('bubble-top-right').textContent,
        'bubble-bottom-left': document.getElementById('bubble-bottom-left').textContent,
        'bubble-bottom-right': document.getElementById('bubble-bottom-right').textContent,
        'new-widget-avatar': document.getElementById('new-widget-avatar').src,
        'new-widget-text-1': document.getElementById('new-widget-text-1').textContent,
        'new-widget-text-2': document.getElementById('new-widget-text-2').textContent,
        'new-widget-text-3': document.getElementById('new-widget-text-3').textContent,
        'widget-month-display': document.getElementById('widget-month-display').textContent,
        
        // --- App图标和壁纸 ---
        'appIcons': { ...state.globalSettings.appIcons },
        'appLabels': { ...state.globalSettings.appLabels },
        'wallpaper': state.globalSettings.wallpaper
    };

    // 保存到数据库
    await db.homeScreenPresets.add({ name: presetName.trim(), data: presetData });
    await loadHomeScreenPresetsToDropdown(); // 刷新下拉列表
    alert(`预设 "${presetName.trim()}" 已保存！`);
}

/**
 * 【V2 修复版】更新当前选中的预设
 */
async function updateSelectedHomeScreenPreset() {
    if (!activeHomePresetId) {
        alert("请先选择一个要更新的预设。");
        return;
    }

    const currentPreset = await db.homeScreenPresets.get(activeHomePresetId);
    if (!currentPreset) return;

    const confirmed = await showCustomConfirm(
        "确认更新",
        `确定要用当前的主屏幕布局覆盖预设 "${currentPreset.name}" 吗？`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        // 构建与保存时完全相同的完整数据对象
        const presetData = {
            'profile-banner-img': document.getElementById('profile-banner-img').src,
            'profile-avatar-img': document.getElementById('profile-avatar-img').src,
            'homeAvatarFrame': document.getElementById('profile-avatar-frame').src, // ★★★ 新增：保存头像框 ★★★
            'profile-username': document.getElementById('profile-username').textContent,
            'profile-sub-username': document.getElementById('profile-sub-username').textContent,
            'profile-bio': document.getElementById('profile-bio').textContent,
            'profile-location': document.getElementById('profile-location').innerHTML,
            'widget-bubble-1': document.getElementById('widget-bubble-1').textContent,
            'widget-image-1': document.getElementById('widget-image-1').src,
            'widget-subtext-1': document.getElementById('widget-subtext-1').textContent,
            'widget-bubble-2': document.getElementById('widget-bubble-2').textContent,
            'widget-image-2': document.getElementById('widget-image-2').src,
            'widget-subtext-2': document.getElementById('widget-subtext-2').textContent,
            'widget-image-3': document.getElementById('widget-image-3').src,
            'second-page-bubble': document.getElementById('second-page-bubble').textContent,
            'flat-capsule-bubble': document.getElementById('flat-capsule-bubble').textContent,
            'circular-bubble': document.getElementById('circular-bubble').textContent,
            'widget-image-4': document.getElementById('widget-image-4').src,
            'avatar-subtitle': document.getElementById('avatar-subtitle').textContent,
            'bubble-top-left': document.getElementById('bubble-top-left').textContent,
            'bubble-top-right': document.getElementById('bubble-top-right').textContent,
            'bubble-bottom-left': document.getElementById('bubble-bottom-left').textContent,
            'bubble-bottom-right': document.getElementById('bubble-bottom-right').textContent,
            'new-widget-avatar': document.getElementById('new-widget-avatar').src,
            'new-widget-text-1': document.getElementById('new-widget-text-1').textContent,
            'new-widget-text-2': document.getElementById('new-widget-text-2').textContent,
            'new-widget-text-3': document.getElementById('new-widget-text-3').textContent,
            'widget-month-display': document.getElementById('widget-month-display').textContent,
            'appIcons': { ...state.globalSettings.appIcons },
            'wallpaper': state.globalSettings.wallpaper
        };

        await db.homeScreenPresets.update(activeHomePresetId, { data: presetData });
        await showCustomAlert('成功', `预设 "${currentPreset.name}" 已更新！`);
    }
}

/**
 * 重命名选中的预设
 */
async function renameSelectedHomeScreenPreset() {
    if (!activeHomePresetId) return;
    const currentPreset = await db.homeScreenPresets.get(activeHomePresetId);
    const newName = await showCustomPrompt("重命名", "请输入新的名称：", currentPreset.name);
    if (newName && newName.trim()) {
        await db.homeScreenPresets.update(activeHomePresetId, { name: newName.trim() });
        await loadHomeScreenPresetsToDropdown();
        document.getElementById('home-preset-selector').value = activeHomePresetId;
        alert("重命名成功！");
    }
}

/**
 * 删除选中的预设
 */
async function deleteSelectedHomeScreenPreset() {
    if (!activeHomePresetId) return;
    const currentPreset = await db.homeScreenPresets.get(activeHomePresetId);
    const confirmed = await showCustomConfirm("确认删除", `确定要删除预设 "${currentPreset.name}" 吗？`, { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        await db.homeScreenPresets.delete(activeHomePresetId);
        await loadHomeScreenPresetsToDropdown(); // 这会自动重置选择并禁用按钮
        alert("预设已删除。");
    }
}

/**
 * 【全新】导出选中的预设
 */
async function exportHomeScreenPreset() {
    if (!activeHomePresetId) return;
    const preset = await db.homeScreenPresets.get(activeHomePresetId);
    const blob = new Blob([JSON.stringify(preset, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${preset.name}-HomeScreen.json`;
    a.click();
    URL.revokeObjectURL(url);
}

/**
 * 【全新】导入预设文件
 */
function importHomeScreenPreset(file) {
    if (!file) return;
    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const data = JSON.parse(e.target.result);
            // 简单验证一下文件内容是不是我们需要的格式
            if (data.name && data.data) {
                await db.homeScreenPresets.add({ name: `${data.name} (导入)`, data: data.data });
                await loadHomeScreenPresetsToDropdown();
                alert(`预设 "${data.name}" 导入成功！`);
            } else {
                alert("导入失败：文件格式不正确。");
            }
        } catch (error) {
            alert(`导入失败：文件解析错误。${error.message}`);
        }
    };
    reader.readAsText(file);
}
/* ▲▲▲ 新功能函数粘贴结束 ▲▲▲ */
/* ▼▼▼ 把这一整块全新的功能函数，粘贴到 init() 函数的上方 ▼▼▼ */

let currentWeiboActionTarget = {}; // 用于存储被操作的目标信息

// ▼▼▼ 用这块【全新逻辑】的代码，完整替换你旧的 openWeiboActionModal 函数 ▼▼▼

/**
 * 【V2 - AI自主版】打开微博操作模态框
 * @param {object} targetInfo - 包含被操作角色信息的对象
 */
function openWeiboActionModal(targetInfo) {
    currentWeiboActionTarget = targetInfo; // 保存目标信息
    const modal = document.getElementById('weibo-action-modal');
    
    // 核心修改：标题直接显示为谁行动，不再有“操作者”
    document.getElementById('weibo-action-modal-title').textContent = `为 "${targetInfo.name}" 触发行动`;

    // 核心修改：彻底移除并隐藏“选择操作者”的下拉框
    const actorSelectGroup = document.getElementById('weibo-action-actor-select').parentElement;
    if (actorSelectGroup) {
        actorSelectGroup.style.display = 'none';
    }
    
    // 清空上次的输入并重置选项
    document.getElementById('weibo-action-prompt-input').value = '';
    document.querySelector('input[name="weibo_action_type"][value="post"]').checked = true;

    modal.classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 【AI核心 V2.2 - 评论用户微博版 + 500错误最终修复】执行AI操作（发微博/评论）
 */
async function handleWeiboAiAction() {
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('请先配置API！');
        return;
    }

    document.getElementById('weibo-action-modal').classList.remove('visible');
    document.getElementById('weibo-following-modal').classList.remove('visible');
    await showCustomAlert("请稍候...", "正在请求AI生成内容，请耐心等待...");

    const actionType = document.querySelector('input[name="weibo_action_type"]:checked').value;
    const userInputPrompt = document.getElementById('weibo-action-prompt-input').value.trim();

    let target = { 
        id: currentWeiboActionTarget.id,
        name: currentWeiboActionTarget.name, 
        persona: '一个普通的微博用户。',
        profession: '',
        instruction: ''
    };

    if (currentWeiboActionTarget.isNpc) {
        const owner = state.chats[currentWeiboActionTarget.ownerId];
        const npc = owner.npcLibrary.find(n => n.id === currentWeiboActionTarget.id);
        if (npc) {
            target.persona = npc.persona;
            target.profession = owner.settings.weiboProfession || '';
            target.instruction = owner.settings.weiboInstruction || '';
        }
    } else {
        const char = state.chats[currentWeiboActionTarget.id];
        if (char) {
            target.persona = char.settings.aiPersona;
            target.profession = char.settings.weiboProfession || '';
            target.instruction = char.settings.weiboInstruction || '';
        }
    }
    
    let systemPrompt = '';
    let messagesForApi = [];

    try {
        if (actionType === 'post') {
            systemPrompt = `
# 任务: 角色扮演与微博创作
你现在【就是】角色“${target.name}”。
你的任务是根据你的身份信息，创作一条全新的微博。
# 你的身份信息
- **你的名字**: ${target.name}
- **你的职业**: ${target.profession || '未设定'}
- **你的人设**: ${target.persona}
- **你的微博指令 (必须遵守)**: ${target.instruction || '无'}
- **用户给你的提示 (可选参考)**: ${userInputPrompt || '无'}
# 【【【评论生成核心规则】】】
1.  **【【【严禁使用】】】**: 绝对禁止使用 “路人甲”、“网友A”、“粉丝B” 这类代号作为评论者昵称。
2.  **昵称多样化**: 评论者的昵称必须非常真实、多样化且符合微博生态。例如：“今天也要早睡”、“可乐加冰块”、“是小王不是小张”、“理性吃瓜第一线”。
3.  **内容与人设强相关**: 评论内容必须与【你即将创作的微博内容】和【你自己的人设】高度相关。
4.  **格式铁律**: 你的回复【必须且只能】是一个严格的JSON对象，格式如下:
   \`{"content": "微博正文内容...", "baseLikesCount": 随机生成的点赞数, "baseCommentsCount": 随机生成的评论数, "comments": "今天也要早睡: 评论1...\\n可乐加冰块: 评论2..."}\`
   - 点赞和评论数要符合你的身份地位。
   - "comments"字段是一个【字符串】，里面包含5-10条真实感的路人评论，每条评论用换行符'\\n'分隔。
`;
            messagesForApi.push({ role: 'user', content: systemPrompt });

        } else {
            let targetPost;
            let taskDescription;
            let extraContext = ''; 

            if (actionType === 'comment_plaza') {
                targetPost = await db.weiboPosts.orderBy('timestamp').last();
                if (!targetPost) throw new Error("广场上还没有任何微博可以评论！");
                taskDescription = `你的任务是根据你的身份信息，去评论下面这条最新的【广场微博】。`;
            } else if (actionType === 'comment_user') {
                targetPost = await db.weiboPosts.where('authorId').equals('user').reverse().first();
                if (!targetPost) throw new Error("用户还没有发布任何微博，无法评论！");
                taskDescription = `你的任务是根据你的身份信息，去评论下面这条由【用户】发布的最新微博。`;
            }

            let postAuthorName = targetPost.authorNickname;
            if (postAuthorName === '{{user}}') {
                postAuthorName = '我';
            }
            
            systemPrompt = `
# 任务: 角色扮演与微博评论
你现在【就是】角色“${target.name}”。
${taskDescription}
# 你的身份信息
- **你的名字**: ${target.name}
- **你的职业**: ${target.profession || '未设定'}
- **你的人设**: ${target.persona}
- **你的微博指令 (必须遵守)**: ${target.instruction || '无'}
- **用户给你的提示 (可选参考)**: ${userInputPrompt || '无'}
# 被评论的微博
- 作者: ${postAuthorName}
- 内容: ${targetPost.content}
${extraContext}
# 核心规则
1. **深度扮演**: 你的评论【必须】完全符合你的职业、人设和微博指令。
2. **格式铁律**: 你的回复【必须且只能】是一个严格的JSON对象，格式如下:
   \`{"commentText": "你的评论内容..."}\`
`;
            messagesForApi.push({ role: 'user', content: systemPrompt });
        }

        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini, state.apiConfig.temperature);


        const response = await fetch(isGemini ? geminiConfig.url : `${proxyUrl}/v1/chat/completions`, isGemini ? geminiConfig.data : {
            method: 'POST',
            headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
            body: JSON.stringify({
                model: model,
                messages: messagesForApi,
                temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                // ▼▼▼ 核心修复：我们把下面这行导致错误的 `response_format` 彻底删掉了！▼▼▼
            })
        });

        if (!response.ok) {
            let errorBody = '';
            try {
                errorBody = await response.text();
            } catch (e) {
                errorBody = '无法读取错误响应体。';
            }
            throw new Error(`API请求失败: ${response.status} - ${errorBody}`);
        }

        const data = await response.json();
        // ▼▼▼ 在这里添加下面的安全检查代码 ▼▼▼
if (data.error) {
    // 如果API返回的数据中直接包含了 error 对象，说明请求出错了
    // 我们主动抛出一个包含详细错误信息的Error
    throw new Error(`API返回错误: ${data.error.message || JSON.stringify(data.error)}`);
}
// ▲▲▲ 添加结束 ▲▲▲
        const aiResponseContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content)
            .replace(/^```json\s*|```$/g, '').trim();
        
        const result = JSON.parse(aiResponseContent);

        if (actionType === 'post') {
            const newPost = {
                authorId: target.id,
                authorType: currentWeiboActionTarget.isNpc ? 'npc' : 'char',
                authorNickname: target.name,
                authorAvatar: currentWeiboActionTarget.isNpc 
                    ? (state.chats[currentWeiboActionTarget.ownerId].npcLibrary.find(n => n.id === target.id).avatar || defaultGroupMemberAvatar)
                    : (state.chats[target.id].settings.aiAvatar || defaultAvatar),
                content: result.content,
                timestamp: Date.now(),
                likes: [], comments: [],
                baseLikesCount: result.baseLikesCount || 0,
                baseCommentsCount: result.baseCommentsCount || 0
            };
            if(result.comments) {
                newPost.comments = result.comments.split('\n').map(c => {
                    const parts = c.split(/[:：]/);
                    const commenter = parts.shift() || '路人';
                    const commentText = parts.join(':').trim();
                    return { commentId: 'comment_' + Date.now() + Math.random(), authorNickname: commenter, commentText: commentText };
                }).filter(c => c.commentText);
            }
            await db.weiboPosts.add(newPost);
        } else {
            let postToUpdate;
            if (actionType === 'comment_plaza') {
                postToUpdate = await db.weiboPosts.orderBy('timestamp').last();
            } else {
                postToUpdate = await db.weiboPosts.where('authorId').equals('user').reverse().first();
            }

            if (postToUpdate) {
                if (!postToUpdate.comments) postToUpdate.comments = [];
                postToUpdate.comments.push({
                    commentId: 'comment_' + Date.now(),
                    authorId: target.id,
                    authorNickname: target.name,
                    commentText: result.commentText,
                    timestamp: Date.now()
                });
                await db.weiboPosts.put(postToUpdate);
            }
        }
        
        await renderMyWeiboFeed();
        await renderFollowingWeiboFeed();
        await showCustomAlert("操作成功", `“${target.name}”已成功执行操作！`);

    } catch (error) {
        console.error("微博AI操作失败:", error);
        await showCustomAlert('操作失败', `发生了一个错误：\n${error.message}`);
    }
}
// ▼▼▼ 第2步 第4处修改（新增JS功能函数） ▼▼▼

/**
 * 【全新】角色表情包管理核心功能
 */
async function openCharStickerManager() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
        // 【修改】根据聊天类型显示不同的标题
    if (chat.isGroup) {
        document.getElementById('sticker-manager-title').textContent = `“${chat.name}”的群表情`;
    } else {
        document.getElementById('sticker-manager-title').textContent = `“${chat.name}”的表情包`;
    }


    // 默认显示专属表情
    document.getElementById('sticker-tab-exclusive').click();
    
    await renderCharStickers('exclusive');
    await renderCharStickers('common');
    
    showScreen('char-sticker-manager-screen');
}

// ▼▼▼ 用这块【增强版】代码，完整替换旧的 renderCharStickers 函数 ▼▼▼
async function renderCharStickers(type) {
    const isExclusive = type === 'exclusive';
    const gridId = isExclusive ? 'exclusive-sticker-grid' : 'common-sticker-grid';
    const grid = document.getElementById(gridId);
    grid.innerHTML = '';

    let stickers = [];
    if (isExclusive) {
        const chat = state.chats[state.activeChatId];
        stickers = chat.settings.stickerLibrary || [];
    } else {
        state.charStickers = await db.charStickers.toArray();
        stickers = state.charStickers || [];
    }

    if (stickers.length === 0) {
        grid.innerHTML = `<p style="text-align:center; color: var(--text-secondary); grid-column: 1 / -1;">这里还是空的哦~</p>`;
        return;
    }

    // 为了正确删除，我们需要原始索引
    const stickersWithIndex = stickers.map((sticker, index) => ({ ...sticker, originalIndex: index }));

    stickersWithIndex.forEach((sticker) => {
        const item = document.createElement('div');
        item.className = 'sticker-item';
        item.style.backgroundImage = `url(${sticker.url})`;
        item.title = sticker.name;
        
        // 我们使用 URL 作为唯一标识符，因为它在两种库中都是唯一的
        const uniqueId = sticker.url;

        if (isCharStickerSelectionMode) {
            // 【选择模式】下的逻辑
            item.classList.add('in-selection-mode');
            if (selectedCharStickers.has(uniqueId)) {
                item.classList.add('selected');
            }
            
            item.addEventListener('click', () => {
                item.classList.toggle('selected');
                if (selectedCharStickers.has(uniqueId)) {
                    selectedCharStickers.delete(uniqueId);
                } else {
                    selectedCharStickers.add(uniqueId);
                }
                const deleteBtn = document.getElementById('delete-selected-char-stickers-btn');
                deleteBtn.textContent = `删除已选 (${selectedCharStickers.size})`;
                deleteBtn.disabled = selectedCharStickers.size === 0;
            });

        } else {
            // 【正常模式】下的逻辑（只有删除按钮）
            const deleteBtn = document.createElement('div');
            deleteBtn.className = 'delete-btn';
            deleteBtn.innerHTML = '×';
            deleteBtn.style.display = 'block'; // 默认就显示
            deleteBtn.onclick = async (e) => {
                e.stopPropagation();
                const confirmed = await showCustomConfirm('删除表情', `确定要删除表情 "${sticker.name}" 吗？`, { confirmButtonClass: 'btn-danger' });
                if (confirmed) {
                    if (isExclusive) {
                        const chat = state.chats[state.activeChatId];
                        chat.settings.stickerLibrary.splice(sticker.originalIndex, 1);
                        await db.chats.put(chat);
                    } else {
                        await db.charStickers.delete(sticker.id);
                    }
                    await renderCharStickers(type); // 刷新
                }
            };
            item.appendChild(deleteBtn);
        }
        grid.appendChild(item);
    });
}
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 在 renderCharStickers 函数后，粘贴这个新函数 ▼▼▼
/**
 * 处理批量删除选中的角色表情
 */
async function handleBulkDeleteCharStickers() {
    if (selectedCharStickers.size === 0) return;

    const confirmed = await showCustomConfirm(
        '确认删除',
        `确定要删除选中的 ${selectedCharStickers.size} 个表情吗？`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        const activeTab = document.querySelector('#char-sticker-manager-screen .frame-tab.active');
        const type = activeTab.id === 'sticker-tab-exclusive' ? 'exclusive' : 'common';
        
        if (type === 'exclusive') {
            const chat = state.chats[state.activeChatId];
            chat.settings.stickerLibrary = chat.settings.stickerLibrary.filter(
                s => !selectedCharStickers.has(s.url)
            );
            await db.chats.put(chat);
        } else { // common
            const stickersToDelete = await db.charStickers.where('url').anyOf(Array.from(selectedCharStickers)).toArray();
            const idsToDelete = stickersToDelete.map(s => s.id);
            if (idsToDelete.length > 0) {
                await db.charStickers.bulkDelete(idsToDelete);
            }
        }
        
        // 退出编辑模式
        toggleCharStickerSelectionMode();
        
        alert('选中的表情已删除。');
    }
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲


/**
 * 【已修复+优化】批量添加表情包到指定库
 */
async function bulkAddCharStickers(type) {
    const textInput = await showCustomPrompt(
        `批量添加${type === 'exclusive' ? '专属' : '通用'}表情`,
        "一行一个，格式：\n猫猫喝水 https://..../cat.gif",
        "", 'textarea'
    );
    if (!textInput || !textInput.trim()) return;

    const lines = textInput.trim().split('\n');
    const newStickers = [];
    let successCount = 0;

    lines.forEach((line, index) => {
        line = line.trim();
        if (!line) return;

        // 【优化】使用更智能、更健壮的分割逻辑
        let name = '';
        let url = '';
        let splitIndex = -1;
        const httpIndex = line.indexOf('http');
        const dataIndex = line.indexOf('data:image');
        if (httpIndex > -1) { splitIndex = httpIndex; }
        else if (dataIndex > -1) { splitIndex = dataIndex; }

        if (splitIndex > 0) {
            name = line.substring(0, splitIndex).trim();
            url = line.substring(splitIndex).trim();
            if (name.endsWith(':') || name.endsWith('：')) {
                name = name.slice(0, -1).trim();
            }
        }

        if (name && (url.startsWith('http') || url.startsWith('data:image'))) {
            const stickerData = { url, name };
            if (type !== 'exclusive') {
                stickerData.id = 'char_sticker_' + (Date.now() + index);
            }
            newStickers.push(stickerData);
            successCount++;
        }
    });

    if (newStickers.length > 0) {
        if (type === 'exclusive') {
            const chat = state.chats[state.activeChatId];
            chat.settings.stickerLibrary.push(...newStickers);
            await db.chats.put(chat);
        } else {
            await db.charStickers.bulkAdd(newStickers);
        }
        await renderCharStickers(type); // 【核心修复】在数据库操作后，统一重新渲染
    }
    await showCustomAlert("导入报告", `成功导入：${successCount} 个表情。`);
}

/**
 * 【已修复】从本地上传表情到指定库
 */
async function uploadCharStickersLocal(type) {
    const input = document.getElementById('char-sticker-upload-input'); // 应该长这样
    input.onchange = async (event) => {
        const files = event.target.files;
        if (!files.length) return;

        const stickersToAdd = []; // 先收集所有要添加的表情

        for (const file of files) {
            const name = await showCustomPrompt("为表情命名", "请输入表情名称", file.name.replace(/\.[^/.]+$/, ""));
            if (name && name.trim()) {
                const base64Url = await new Promise(resolve => {
                    const reader = new FileReader();
                    reader.onload = e => resolve(e.target.result);
                    reader.readAsDataURL(file);
                });
                
                const stickerData = { name: name.trim(), url: base64Url };
                if (type !== 'exclusive') {
                    stickerData.id = 'char_sticker_' + Date.now() + Math.random();
                }
                stickersToAdd.push(stickerData);
            }
        }

        if (stickersToAdd.length > 0) {
            if (type === 'exclusive') {
                const chat = state.chats[state.activeChatId];
                chat.settings.stickerLibrary.push(...stickersToAdd);
                await db.chats.put(chat);
            } else {
                await db.charStickers.bulkAdd(stickersToAdd);
            }
            await renderCharStickers(type); // 【核心修复】在数据库操作后，统一重新渲染
            alert(`已成功上传 ${stickersToAdd.length} 个表情！`);
        }
        
        event.target.value = null;
    };
    input.click();
}

// ▲▲▲ 修复代码块结束 ▲▲▲
// ▼▼▼ 第1步：在这里粘贴下面这个【新函数】 ▼▼▼

/**
 * 【新增】显示指定的角色表情包标签页
 * 这是之前缺失的核心功能，用于控制显示哪个标签页（专属或通用）。
 * @param {'exclusive' | 'common'} type - 要显示的标签页类型
 */
function showCharStickerTab(type) {
    // 1. 切换标签按钮的 'active' 状态
    document.querySelectorAll('.char-sticker-tab-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.type === type);
    });

    // 2. 切换内容区域的显示
    document.querySelectorAll('.sticker-tab-content').forEach(content => {
        content.classList.toggle('active', content.id === `${type}-sticker-content`);
    });

    // 3. 渲染对应标签页的表情
    // (这一步确保每次切换标签时，表情都会刷新)
    renderCharStickers(type);
}

// ▲▲▲ JavaScript新函数粘贴结束 ▲▲▲

// 这里应该是你已有的其他函数，比如 renderCharStickers, bulkAddCharStickers 等...
// ▼▼▼ 【全新 | 修复版】这里是所有论坛/小组功能的核心代码 ▼▼▼

let activeGroupId = null; // 记录当前打开的小组ID
let activeForumPostId = null; // 记录当前打开的帖子ID

// ▼▼▼ 用这块【已添加梦角小组】的代码，完整替换掉你旧的 initializeDefaultGroups 函数 ▼▼▼

/**
 * 初始化默认的小组
 */
async function initializeDefaultGroups() {
    const groupCount = await db.forumGroups.count();
    if (groupCount === 0) {
        const defaultGroups = [
            { name: '娱乐小组', description: '分享八卦和快乐', icon: '🍿' },
            { name: '灵异小组', description: '分享你的灵异经历', icon: '👻' },
            { name: '今天我crush了吗', description: '记录心动瞬间', icon: '💖' },
            { name: '请帮我选择小组', description: '选择困难症患者互助', icon: '🤔' },
            { name: '同人文小组', description: '为爱发电，创作故事', icon: '✍️' },
            // ▼▼▼ 就是新增了下面这一行！ ▼▼▼
            { name: '梦角小组', description: 'Char们分享关于user的梦境', icon: '🌙' }
        ];
        await db.forumGroups.bulkAdd(defaultGroups);
        console.log("已成功创建默认小组（包含梦角小组）。");
    }
}

// ▲▲▲ 替换结束 ▲▲▲

/**
 * 渲染论坛主屏幕，显示所有小组及其分类（已支持筛选）
 */
async function renderForumScreen() {
    const listEl = document.getElementById('forum-group-list');
    const allGroups = await db.forumGroups.toArray();
    listEl.innerHTML = '';

    // --- ▼▼▼ 【核心新增】筛选逻辑 ▼▼▼ ---
    const globalFilters = activeForumFilters.global;
    let groupsToRender = allGroups;

    if (globalFilters && globalFilters.length > 0) {
        groupsToRender = allGroups.filter(group => 
            group.categories && group.categories.some(cat => globalFilters.includes(cat))
        );
    }
    // --- ▲▲▲ 新增结束 ▲▲▲ ---

    // 检查筛选后是否还有内容
    if (groupsToRender.length === 0) {
        const message = globalFilters.length > 0 
            ? '没有找到符合筛选条件的小组哦' 
            : '还没有任何小组，点击右上角“+”创建一个吧！';
        listEl.innerHTML = `<p style="text-align:center; color: #8a8a8a; padding: 50px 0;">${message}</p>`;
        return;
    }

    // 使用筛选后的 groupsToRender 数组进行渲染
    groupsToRender.forEach(group => {
        const item = document.createElement('div');
        item.className = 'forum-group-item';

        let categoriesHtml = '';
        if (group.categories && group.categories.length > 0) {
            categoriesHtml = `
                <div class="category-tag-container">
                    ${group.categories.map(cat => `<span class="category-tag">#${cat}</span>`).join('')}
                </div>
            `;
        }

        item.innerHTML = `
            <div class="forum-group-icon">${group.icon || '📁'}</div>
            <div class="forum-group-name">${group.name}</div>
            <div class="forum-group-desc">${group.description}</div>
            ${categoriesHtml}
        `;
        item.addEventListener('click', () => openGroup(group.id, group.name));
        addLongPressListener(item, () => showGroupActions(group.id, group.name));
        listEl.appendChild(item);
    });
    
    // 更新筛选按钮状态
    const filterBtn = document.getElementById('forum-filter-btn');
    if (filterBtn) {
        filterBtn.classList.toggle('active', globalFilters && globalFilters.length > 0);
    }
}


/**
 * 【全新】长按小组时显示操作菜单（编辑或删除）
 * @param {number} groupId - 小组的ID
 * @param {string} groupName - 小组的名称
 */
async function showGroupActions(groupId, groupName) {
    // 调用你现有的弹窗函数，显示两个选项
    const choice = await showChoiceModal(`操作小组 "${groupName}"`, [
        { text: '✏️ 编辑小组信息', value: 'edit' },
        { text: '🗑️ 删除小组', value: 'delete' }
    ]);

    // 根据用户的选择，执行不同的操作
    if (choice === 'edit') {
        // 如果用户选择“编辑”，就调用你原来的编辑函数
        openGroupEditor(groupId);
    } else if (choice === 'delete') {
        // 如果用户选择“删除”，就调用你原来的删除函数
        deleteGroupAndPosts(groupId);
    }
}

// ▼▼▼ 用这块【已移除自动生成逻辑】的代码，完整替换你旧的 openGroup 函数 ▼▼▼
async function openGroup(groupId, groupName) {
    activeGroupId = groupId;
    document.getElementById('group-screen-title').textContent = groupName;
    const fanficBar = document.getElementById('fanfic-preference-bar');
    
    // 根据小组名显示或隐藏特定UI
    if (groupName === '同人文小组') {
        fanficBar.style.display = 'block';
        await populateFanficSelectors();
    } else {
        fanficBar.style.display = 'none';
    }
    await renderGroupPosts(groupId);
    showScreen('group-screen');
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 渲染小组内的帖子列表及其分类（已支持筛选）
 */
async function renderGroupPosts(groupId) {
    const listEl = document.getElementById('group-post-list');
    const allPosts = await db.forumPosts.where('groupId').equals(groupId).reverse().sortBy('timestamp');
    listEl.innerHTML = '';

    // --- ▼▼▼ 【核心新增】筛选逻辑 ▼▼▼ ---
    const groupFilters = activeForumFilters.group[groupId];
    let postsToRender = allPosts;

    if (groupFilters && groupFilters.length > 0) {
        postsToRender = allPosts.filter(post => 
            post.categories && post.categories.some(cat => groupFilters.includes(cat))
        );
    }
    // --- ▲▲▲ 新增结束 ▲▲▲ ---

    if (postsToRender.length === 0) {
        const message = groupFilters && groupFilters.length > 0 
            ? '没有找到符合筛选条件的帖子哦' 
            : '这个小组还没有帖子哦';
        listEl.innerHTML = `<p style="text-align:center; color: #8a8a8a; padding: 50px 0;">${message}</p>`;
        return;
    }

    for (const post of postsToRender) {
        const commentCount = await db.forumComments.where('postId').equals(post.id).count();
        const item = document.createElement('div');
        item.className = 'forum-post-item';
        item.dataset.postId = post.id;
        
        let categoriesHtml = '';
        if (post.categories && post.categories.length > 0) {
            categoriesHtml = `
                <div class="category-tag-container">
                    ${post.categories.map(cat => `<span class="category-tag">#${cat}</span>`).join('')}
                </div>
            `;
        }

        item.innerHTML = `
            <div class="post-item-title">${post.title}</div>
            ${categoriesHtml}
            <div class="post-item-meta">
                <span>作者: ${post.author}</span>
                <span>评论: ${commentCount}</span>
            </div>
            <button class="forum-post-delete-btn" title="删除帖子">×</button>
        `;
        listEl.appendChild(item);
    }

    // 更新筛选按钮状态
    const filterBtn = document.getElementById('group-filter-btn');
    if (filterBtn) {
        filterBtn.classList.toggle('active', groupFilters && groupFilters.length > 0);
    }
}


/**
 * 【关键修复】打开一个帖子，显示详情和评论
 */
async function openPost(postId) {
    activeForumPostId = postId;
    await renderPostDetails(postId);
    showScreen('post-screen');
}

// ▼▼▼ 用这块【功能增强版】的代码，完整替换掉你旧的 renderPostDetails 函数 ▼▼▼
/**
 * 【功能增强版】渲染帖子详情和评论 (已加入头像和楼层)
 */
async function renderPostDetails(postId) {
    const contentEl = document.getElementById('post-detail-content');
    const post = await db.forumPosts.get(postId);
    const comments = await db.forumComments.where('postId').equals(postId).sortBy('timestamp');

    if (!post) {
        contentEl.innerHTML = '<p>帖子不存在或已被删除</p>';
        return;
    }
    
    // --- 1. 获取作者头像 ---
    let authorAvatarUrl = 'https://i.postimg.cc/PxZrFFFL/o-o-1.jpg'; // 默认路人头像
    const userNickname = state.qzoneSettings.nickname || '我';
    
    if (post.author === userNickname) {
        authorAvatarUrl = state.qzoneSettings.avatar; // 如果是用户自己
    } else {
        const authorChar = Object.values(state.chats).find(c => c.name === post.author);
        if (authorChar) {
            authorAvatarUrl = authorChar.settings.aiAvatar; // 如果是角色
        }
    }

    // --- 2. 拼接评论区HTML ---
    let commentsHtml = `
        <div class="post-comments-section">
            <h3>评论 (${comments.length})</h3>
    `;
    if (comments.length > 0) {
        comments.forEach((comment, index) => {
            // --- 2a. 获取评论者头像 ---
            let commenterAvatarUrl = 'https://i.postimg.cc/PxZrFFFL/o-o-1.jpg'; // 默认路人头像
            if (comment.author === userNickname) {
                commenterAvatarUrl = state.qzoneSettings.avatar;
            } else {
                const commenterChar = Object.values(state.chats).find(c => c.name === comment.author);
                if (commenterChar) {
                    commenterAvatarUrl = commenterChar.settings.aiAvatar;
                }
            }

            // --- 2b. 处理回复 ---
            let replyHtml = '';
            if (comment.replyTo) {
                replyHtml = `<span class="reply-text">回复</span> <span class="reply-target-name">${comment.replyTo}</span>`;
            }

            // --- 2c. 拼接单条评论的完整HTML ---
            commentsHtml += `
                <div class="post-comment-item" data-commenter-name="${comment.author}">
                    <img src="${commenterAvatarUrl}" class="comment-avatar-small">
                    <div class="comment-details">
                        <div class="comment-header-line">
                            <span class="comment-author">${comment.author}</span>
                            <span class="comment-floor">${index + 1}楼</span>
                        </div>
                        <div class="comment-content">
                            ${replyHtml}
                            <span class="comment-text">${(comment.content || '').replace(/\n/g, '<br>')}</span>
                        </div>
                    </div>
                </div>
            `;
        });
    } else {
        commentsHtml += '<p style="color: var(--text-secondary); font-size: 14px;">还没有评论，快来抢沙发！</p>';
    }
    commentsHtml += '</div>';

    // --- 3. 拼接帖子详情页的完整HTML ---
    contentEl.innerHTML = `
        <div class="post-detail-header">
            <img src="${authorAvatarUrl}" class="post-author-avatar">
            <div class="post-author-info">
                <h1>${post.title}</h1>
                <div class="post-detail-meta">
                    <span>作者: ${post.author}</span> | <span>发布于: ${new Date(post.timestamp).toLocaleString()}</span>
                </div>
            </div>
        </div>
        <div class="post-detail-body">${post.content.replace(/\n/g, '<br>')}</div>
        <div class="generate-comments-container">
            <button id="generate-forum-comments-btn">✨ 生成评论</button>
        </div>
        ${commentsHtml}
    `;

    // --- 4. 重新绑定评论的点击回复事件 (这部分逻辑保持不变) ---
    contentEl.querySelectorAll('.post-comment-item').forEach(item => {
        item.addEventListener('click', () => {
            const commenterName = item.dataset.commenterName;
            const myNickname = state.qzoneSettings.nickname || '我';
            if (commenterName !== myNickname) {
                const commentInput = document.getElementById('post-comment-input');
                commentInput.placeholder = `回复 ${commenterName}:`;
                commentInput.dataset.replyTo = commenterName;
                commentInput.focus();
            }
        });
    });
}
// ▲▲▲ 替换结束 ▲▲▲



/**
 * 【AI核心】为论坛帖子生成“豆瓣风格”的评论
 */
async function generateForumComments() {
    const postIdToCommentOn = activeForumPostId; 
    if (!postIdToCommentOn) return;

    await showCustomAlert("请稍候...", "正在召唤资深豆友前来围观...");

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('请先在API设置中配置好才能生成内容哦！');
        return;
    }

    const post = await db.forumPosts.get(postIdToCommentOn); 
    const existingComments = await db.forumComments.where('postId').equals(postIdToCommentOn).toArray(); 
    const group = await db.forumGroups.get(post.groupId);

    // ▼▼▼ 用下面这【一整块新代码】替换掉旧的 prompt 变量 ▼▼▼
    const prompt = `
# 任务
你是一个专业的“豆瓣小组资深用户模拟器”。你的任务是为名为“${group.name}”的论坛小组里的一个帖子，生成5条全新的、非常“豆瓣风格”的评论。

# 帖子信息
- 标题: ${post.title}
- 内容: ${post.content.substring(0, 300)}...
- 已有评论:
${existingComments.map(c => `- ${c.author}: ${c.content}`).join('\n') || "(暂无评论)"}

# 【【【评论生成核心规则】】】
1.  **豆瓣风格**: 评论的语言风格必须非常地道，符合真实豆瓣网友的习惯。大量使用豆瓣黑话和网络用语，例如：
    - "同意楼上姐妹！"
    - "马了，感谢楼主分享"
    - "蹲一个后续"
    - "哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈" (大量的“哈”)
    - "这是可以说的吗？"
    - "码住"
    - "笑死，你是什么互联网嘴替"
    - "插眼"
    - "我先来，楼主好人一生平安"
2.  **互动性**: 生成的评论必须互相之间有互动。你可以回复楼主（作者: ${post.author}），也可以回复评论区的其他网友。
3.  **【【【昵称生成铁律】】】**: 评论者的昵称 ("author") 【必须】是你自己虚构的、随机的、生活化的、符合小组氛围的路人网友昵称。【绝对禁止】使用下方“公众人物列表”中的任何一个名字作为评论者。
4.  **格式铁律**: 你的回复【必须且只能】是一个严格的JSON数组，数组中包含5个对象。每个对象【必须】包含 "author" 和 "content" 两个字段，如果需要回复别人，可以加上 "replyTo" 字段。

# 公众人物列表 (他们是讨论的对象，但不是发帖人)
${Object.values(state.chats).filter(c => !c.isGroup).map(c => `- ${c.name}`).join('\n')}

# JSON输出格式示例:
[
  {
    "author": "早睡早起身体好",
    "content": "同意楼上哥哥的，这个确实是这样！"
  },
  {
    "author": "momo",
    "content": "哈哈哈哈哈哈哈哈哈哈这是可以说的吗",
    "replyTo": "早睡早起身体好"
  }
]
`;
    // ▲▲▲ 替换结束 ▲▲▲
    
    const messagesForApi = [{ role: 'user', content: prompt }];
    
    try {
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, prompt, messagesForApi, isGemini);
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({ model: model, messages: messagesForApi, temperature: parseFloat(state.apiConfig.temperature) || 0.8,response_format: { type: "json_object" } })
            });
        if (!response.ok) throw new Error(`API请求失败: ${response.status}`);
        const data = await response.json();
        const rawContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content);
        const cleanedContent = rawContent.replace(/^```json\s*|```$/g, '').trim();
        const newCommentsData = JSON.parse(cleanedContent);
        if (Array.isArray(newCommentsData) && newCommentsData.length > 0) {
            const commentsToAdd = newCommentsData.map((comment, index) => ({
                postId: postIdToCommentOn,
                author: comment.author || '路人',
                content: comment.content,
                replyTo: comment.replyTo || null,
                timestamp: Date.now() + index
            }));
            await db.forumComments.bulkAdd(commentsToAdd);
            await showCustomAlert("召唤成功！", `已成功召唤 ${commentsToAdd.length} 位豆友前来围观。`);
        } else {
            throw new Error("AI返回的数据格式不正确。");
        }
    } catch (error) {
        console.error("生成小组评论失败:", error);
        await showCustomAlert('生成失败', `发生了一个错误：\n${error.message}`);
    } finally {
        await renderPostDetails(postIdToCommentOn);
    }
}


/**
 * 为帖子添加新评论 (支持回复)
 */
async function handleAddComment() {
    if (!activeForumPostId) return;
    const input = document.getElementById('post-comment-input');
    const content = input.value.trim();
    if (!content) {
        alert("评论内容不能为空！");
        return;
    }
    const newComment = {
        postId: activeForumPostId,
        author: state.qzoneSettings.nickname || '我',
        content: content,
        timestamp: Date.now()
    };
    if (input.dataset.replyTo) {
        newComment.replyTo = input.dataset.replyTo;
    }
    await db.forumComments.add(newComment);
    input.value = '';
    input.placeholder = '发布你的评论...';
    delete input.dataset.replyTo;
    await renderPostDetails(activeForumPostId);
}

/**
 * 获取所有可用于同人创作的角色列表
 */
function getAvailableCharacters() {
    const user = { id: 'user', name: state.qzoneSettings.nickname || '我' };
    const chars = Object.values(state.chats)
        .filter(c => !c.isGroup)
        .map(c => ({ id: c.id, name: c.name }));
    return [user, ...chars];
}

/**
 * 填充同人文小组的CP选择器
 */
async function populateFanficSelectors() {
    const charList = getAvailableCharacters();
    const select1 = document.getElementById('fanfic-char1-select');
    const select2 = document.getElementById('fanfic-char2-select');
    select1.innerHTML = '';
    select2.innerHTML = '';
    charList.forEach(char => {
        const option1 = document.createElement('option');
        option1.value = char.name;
        option1.textContent = char.name;
        select1.appendChild(option1);
        const option2 = document.createElement('option');
        option2.value = char.name;
        option2.textContent = char.name;
        select2.appendChild(option2);
    });
    if(charList.length > 1) {
        select1.selectedIndex = 0;
        select2.selectedIndex = 1;
    }
}

// ▼▼▼ 用这块【已修改】的代码，完整替换你旧的 handleGenerateGroupContent 函数 ▼▼▼

/**
 * 【全新改造版】处理通用“生成内容”按钮的点击事件
 */
async function handleGenerateGroupContent() {
    const groupIdToGenerateFor = activeGroupId;
    if (!groupIdToGenerateFor) return;

    const group = await db.forumGroups.get(groupIdToGenerateFor);
    if (!group) return;
    
    // ★★★★★ 这就是我们这次修改的核心！ ★★★★★
    // 1. 我们在这里加一个判断，检查当前小组的名字是不是“梦角小组”
    if (group.name === '梦角小组') {
        // 如果是，就调用我们刚刚创建的新函数！
        await generateDreamPost(groupIdToGenerateFor);
    }
    // 2. 检查是不是“娱乐小组”
    else if (group.name === '娱乐小组') {
        await generateEntertainmentGroupContent(groupIdToGenerateFor);
    } 
    else if (group.name === '同人文小组') {
        // 核心修改：将小组ID传进去，并用 await 等待它执行完毕
        await generateFanfic(groupIdToGenerateFor);
    } 
    // 4. 对于所有其他普通小组
    else {
        // 调用原来的通用内容生成函数
        await generateForumContentWithAPI(groupIdToGenerateFor, group.name);
    }
    // ★★★★★ 修改结束 ★★★★★
}

// ▲▲▲ 替换结束 ▲▲▲



// ▼▼▼ 用这块【V5 | 最终原创分类版】代码，完整替换旧的 generateForumContentWithAPI 函数 ▼▼▼

/**
 * 【AI核心 - V5 世界观+原创分类版】为通用小组生成内容
 */
async function generateForumContentWithAPI(groupId, groupName) {
    if (!groupId) return;

    // --- 1. 获取小组的世界观 ---
    const group = await db.forumGroups.get(groupId);
    if (!group) {
        alert("错误：找不到该小组！");
        return;
    }
    const worldview = group.worldview || '';

    await showCustomAlert("请稍候...", `AI正在为“${groupName}”小组寻找灵感...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('请先在API设置中配置好才能生成内容哦！');
        return;
    }

    let worldviewContext = '';
    if (worldview.trim()) {
        worldviewContext = `
# 小组专属世界观 (你必须严格遵守)
${worldview}
`;
    }

    const passerbyPostCount = 5;

    // --- ▼▼▼ 【核心修改】彻底重写Prompt指令 ---
    const prompt = `
# 任务
你是一个专业的“论坛内容生成器”。你的任务是为名为“${groupName}”的论坛小组，生成【${passerbyPostCount}条】全新的、有趣的、符合小组主题的帖子，并为每条帖子生成2-3条符合情景的评论。

${worldviewContext}

# 核心规则
1.  **主题相关**: 所有帖子的标题、内容和评论都必须与小组主题“${groupName}”高度相关。
2.  **【【【分类铁律】】】**: 你【必须】为每一条帖子，根据其【具体内容】，原创1-2个高度相关的分类标签。绝对不要使用任何预设的、固定的分类列表。
    - 例如，如果帖子是讨论设定的，分类可以是 ["设定讨论"]。
    - 如果帖子是分析剧情的，分类可以是 ["剧情分析"]。
    - 如果帖子是闲聊，分类可以是 ["闲聊水"]。
3.  **作者随机**: 每条帖子的作者都必须是你虚构的、符合小组氛围的路人网友。
4.  **格式铁律**: 你的回复【必须且只能】是一个严格的JSON数组，数组中包含【${passerbyPostCount}个】帖子对象。每个对象【必须】包含 "author", "title", "content", "categories", 和 "comments" 字段。
    - "categories" 字段【必须】是你为这条帖子原创的分类数组。
    - "comments" 字段的值【必须】是一个对象数组，每个对象包含 "author" 和 "content" 字段。

# JSON输出格式示例:
[
  {
    "author": "早睡早起身体好",
    "title": "关于世界观里XX设定的一个疑问",
    "content": "我刚刚在看世界观设定，里面提到XX是蓝色的，但是在另一处又说是绿色的...",
    "categories": ["设定讨论", "剧情分析"],
    "comments": [
      {"author": "路人甲", "content": "我也发现了！蹲一个解答。"}
    ]
  }
]
`;
    // --- ▲▲▲ 更新结束 ▲▲▲ ---

    const messagesForApi = [{ role: 'user', content: prompt }];

    try {
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, prompt, messagesForApi, isGemini);
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({ model: model, messages: messagesForApi, temperature: parseFloat(state.apiConfig.temperature) || 0.8, response_format: { type: "json_object" } })
            });

        if (!response.ok) throw new Error(`API请求失败: ${response.status}`);
        
        const data = await response.json();
        const rawContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content);
        const cleanedContent = rawContent.replace(/^```json\s*|```$/g, '').trim();
        const newPostsData = JSON.parse(cleanedContent);

        if (Array.isArray(newPostsData) && newPostsData.length > 0) {
            let totalPosts = 0;
            let totalComments = 0;
            for (const postData of newPostsData) {
                // --- 3. 保存帖子时，也保存AI原创的分类 ---
                const newPost = {
                    groupId: groupId,
                    title: postData.title,
                    content: postData.content,
                    author: postData.author,
                    timestamp: Date.now() + totalPosts,
                    categories: postData.categories || [] // 保存原创分类
                };
                const postId = await db.forumPosts.add(newPost);
                totalPosts++;

                if (postData.comments && Array.isArray(postData.comments)) {
                    const commentsToAdd = postData.comments.map(comment => {
                        if (typeof comment === 'object' && comment !== null && comment.author && comment.content) {
                            return {
                                postId: postId,
                                author: comment.author,
                                content: comment.content,
                                timestamp: Date.now() + totalPosts + totalComments++
                            };
                        }
                        return null;
                    }).filter(Boolean);
                    
                    if (commentsToAdd.length > 0) {
                        await db.forumComments.bulkAdd(commentsToAdd);
                    }
                }
            }
            await showCustomAlert("生成成功！", `已为“${groupName}”小组生成了 ${totalPosts} 条新帖子和 ${totalComments} 条评论。`);
            await renderGroupPosts(groupId);
        } else {
            throw new Error("AI没有返回任何有效的数据。");
        }
    } catch (error) {
        console.error("生成小组内容失败:", error);
        await showCustomAlert('生成失败', `发生了一个错误：\n${error.message}`);
    }
}
// ▲▲▲ 替换结束 ▲▲▲




// ▼▼▼ 用这块【V10 | 健壮稳定版】代码，完整替换旧的 generateFanfic 函数 ▼▼▼

// 这是【修复后】的代码
async function generateFanfic(groupId) { // 核心修改1：在这里添加 groupId 参数，接收传入的小组ID
    if (!groupId) {
        // 安全检查，如果因为某些原因没传对ID，就报错提示，防止污染数据
        console.error("generateFanfic called without a groupId!");
        alert("发生内部错误：生成同人时未能指定小组ID。");
        return;
    }
    const char1Name = document.getElementById('fanfic-char1-select').value;
    const char2Name = document.getElementById('fanfic-char2-select').value;
    const worldviewPreference = document.getElementById('fanfic-worldview-input').value.trim();

    if (char1Name === char2Name) {
        alert("请选择两个不同的角色！");
        return;
    }
    
    await showCustomAlert("正在创作...", `粉丝正在为【${char1Name}x${char2Name}】奋笔疾书中...`);
    
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('请先配置API！');
        return;
    }

    const allChars = getAvailableCharacters();
    const char1Data = allChars.find(c => c.name === char1Name);
    const char2Data = allChars.find(c => c.name === char2Name);
    const char1Persona = (state.chats[char1Data.id]?.settings.aiPersona || '一个普通人');
    const char2Persona = (state.chats[char2Data.id]?.settings.aiPersona || '一个普通人');

    let worldviewContext = worldviewPreference ? `世界观设定：${worldviewPreference}` : '';
    
    // --- ▼▼▼ 【核心修正】重写Prompt，增强稳定性和清晰度 ---
    const prompt = `
你是一位专业的同人文写手。请根据以下要求，创作【三篇】关于角色A和角色B的、情节各不相同的短篇同人故事。

# 角色信息
- 角色A (${char1Name}): ${char1Persona}
- 角色B (${char2Name}): ${char2Persona}
${worldviewContext}

# 任务要求
1.  **创作三篇故事**: 三篇故事的情节、风格必须完全不同。
2.  **原创分类**: 为【每篇】故事，根据其情节原创1-2个最贴切的分类标签 (例如: "破镜重圆", "ABO", "甜文")。
3.  **生成评论**: 为【每篇】故事，模拟读者口吻生成3-5条评论。
4.  **JSON格式**: 你的回复【必须且只能】是一个纯净的JSON数组，直接以 '[' 开头，以 ']' 结尾。禁止包含任何其他说明文字。

# JSON结构
[
  {
    "title": "故事标题1",
    "story": "故事内容1...",
    "categories": ["原创分类1", "原创分类2"],
    "comments": [
      {"author": "读者A", "content": "评论内容A..."},
      {"author": "读者B", "content": "评论内容B..."}
    ]
  },
  ... (另外两个故事对象)
]
`;
    // --- ▲▲▲ 更新结束 ▲▲▲ ---

    const messagesForApi = [{ role: 'user', content: prompt }];
    try {
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, prompt, messagesForApi, isGemini);
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({ model: model, messages: messagesForApi, temperature: parseFloat(state.apiConfig.temperature) || 0.8, response_format: { type: "json_object" } })
            });
        if (!response.ok) throw new Error(`API请求失败: ${response.status}`);
        const data = await response.json();
        const rawContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content);
        let stories = [];
        try {
            const cleanedContent = rawContent.replace(/^```json\s*|```$/g, '').trim();
            stories = JSON.parse(cleanedContent);
            if (!Array.isArray(stories)) throw new Error("AI未返回数组格式。");
        } catch (e) {
            // --- ▼▼▼ 【核心修正】增强错误日志 ---
            console.error("JSON解析失败！", e);
            console.error("AI返回的原始文本:", rawContent);
            throw new Error("AI返回了无效的JSON格式。请按F12查看控制台中的“AI返回的原始文本”以了解详情。");
            // --- ▲▲▲ 更新结束 ▲▲▲ ---
        }
        for (let i = 0; i < stories.length; i++) {
            const storyData = stories[i];
            const newPost = {
                groupId: groupId, // 核心修改2：使用传入的 groupId
                title: `【${char1Name}x${char2Name}】${storyData.title || `无题 ${Date.now().toString().slice(-4)}`}`,
                content: storyData.story || '内容生成失败',
                author: getRandomItem(['为爱发电的太太', '圈地自萌', 'CP是真的', '嗑拉了', '咕咕咕']),
                timestamp: Date.now() + i,
                categories: storyData.categories || []
            };
            const postId = await db.forumPosts.add(newPost);
            if (storyData.comments && Array.isArray(storyData.comments)) {
                const commentsToAdd = storyData.comments.map((c, idx) => ({ postId, author: c.author || '匿名', content: c.content, timestamp: Date.now()+i+idx+1 }));
                await db.forumComments.bulkAdd(commentsToAdd);
            }
        }
        await renderGroupPosts(groupId);
        await showCustomAlert("创作完成！", `已成功为你创作了 ${stories.length} 篇新的同人故事。`);
    } catch (error) {
        console.error("生成同人文失败:", error);
        await showCustomAlert('创作失败', `发生了一个错误：\n${error.message}`);
    }
}
// ▲▲▲ 替换结束 ▲▲▲





// ▼▼▼ 用这个【V2版】替换旧的 openCreateForumPostModal 函数 ▼▼▼
/**
 * 打开创建帖子的模态框
 */
async function openCreateForumPostModal() {
    resetCreatePostModal(); 
    const modal = document.getElementById('create-post-modal');
    modal.dataset.mode = 'forum';
    document.getElementById('create-post-modal-title').textContent = '发布新帖子';
    document.getElementById('post-public-text').placeholder = '请输入帖子内容...';
    
    // 隐藏所有不需要的控件
    modal.querySelector('.post-mode-switcher').style.display = 'none';
    modal.querySelector('#image-mode-content').style.display = 'none';
    modal.querySelector('#text-image-mode-content').style.display = 'none';
    modal.querySelector('#post-comments-toggle-group').style.display = 'none';
    modal.querySelector('#post-visibility-group').style.display = 'none';
    
    const publicTextGroup = document.getElementById('post-public-text').parentElement;
    
    // --- 动态添加或显示“标题”输入框 ---
    let titleGroup = document.getElementById('forum-post-title-group');
    if (!titleGroup) {
        titleGroup = document.createElement('div');
        titleGroup.className = 'form-group';
        titleGroup.id = 'forum-post-title-group';
        titleGroup.innerHTML = `
            <label for="forum-post-title-input">标题</label>
            <input type="text" id="forum-post-title-input" placeholder="请输入帖子标题...">
        `;
        publicTextGroup.parentNode.insertBefore(titleGroup, publicTextGroup);
    }
    document.getElementById('forum-post-title-input').value = '';

    // --- ▼▼▼ 【核心新增】动态添加“分类”输入框 ▼▼▼ ---
    let categoryGroup = document.getElementById('forum-post-category-group');
    if (!categoryGroup) {
        categoryGroup = document.createElement('div');
        categoryGroup.className = 'form-group';
        categoryGroup.id = 'forum-post-category-group';
        categoryGroup.innerHTML = `
            <label for="forum-post-category-input">帖子分类 (用#号分隔)</label>
            <input type="text" id="forum-post-category-input" placeholder="例如: #剧情讨论 #角色分析">
        `;
        // 将分类输入框插入到“内容”输入框之后
        publicTextGroup.parentNode.insertBefore(categoryGroup, publicTextGroup.nextSibling);
    }
    document.getElementById('forum-post-category-input').value = '';
    // --- ▲▲▲ 新增结束 ▲▲▲ ---

    modal.classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 用这个【V2版】替换旧的 handleCreateForumPost 函数 ▼▼▼
/**
 * 处理用户点击“发布”按钮，创建新帖子的逻辑
 */
async function handleCreateForumPost() {
    const title = document.getElementById('forum-post-title-input').value.trim();
    const content = document.getElementById('post-public-text').value.trim();
    if (!title || !content) {
        alert("帖子标题和内容都不能为空哦！");
        return;
    }

    // --- ▼▼▼ 【核心新增】获取并解析分类 ▼▼▼ ---
    const categoryInput = document.getElementById('forum-post-category-input').value.trim();
    const categories = categoryInput ? categoryInput.match(/#(\S+)/g)?.map(tag => tag.substring(1)) || [] : [];
    // --- ▲▲▲ 新增结束 ▲▲▲ ---

    const newPost = {
        groupId: activeGroupId,
        title: title,
        content: content,
        author: state.qzoneSettings.nickname || '我',
        timestamp: Date.now(),
        categories: categories // 保存解析后的分类数组
    };
    
    await db.forumPosts.add(newPost);
    document.getElementById('create-post-modal').classList.remove('visible');
    await renderGroupPosts(activeGroupId);
    alert('帖子发布成功！');
}
// ▲▲▲ 替换结束 ▲▲▲


/**
 * 删除一个小组及其所有内容
 */
async function deleteGroupAndPosts(groupId) {
    const group = await db.forumGroups.get(groupId);
    if (!group) return;
    const confirmed = await showCustomConfirm(
        '确认删除',
        `确定要删除小组“${group.name}”吗？此操作将同时删除该小组内的【所有帖子和评论】，且无法恢复！`,
        { confirmButtonClass: 'btn-danger' }
    );
    if (confirmed) {
        try {
            const postsToDelete = await db.forumPosts.where('groupId').equals(groupId).toArray();
            const postIds = postsToDelete.map(p => p.id);
            if (postIds.length > 0) {
                await db.forumComments.where('postId').anyOf(postIds).delete();
            }
            await db.forumPosts.where('groupId').equals(groupId).delete();
            await db.forumGroups.delete(groupId);
            await renderForumScreen();
            alert(`小组“${group.name}”及其所有内容已删除。`);
        } catch (error) {
            console.error("删除小组时出错:", error);
            alert(`删除失败: ${error.message}`);
        }
    }
}

// ▼▼▼ 请用这块【最终修复版】的代码，完整替换掉你旧的 repostToChat 函数 ▼▼▼

/**
 * 【最终修复版】"转载"功能：将帖子内容分享到单聊，并植入强制AI评论的隐藏指令
 */
async function repostToChat() {
    if (!activeForumPostId) return;
    const post = await db.forumPosts.get(activeForumPostId);
    if (!post) {
        alert("找不到要转载的帖子！");
        return;
    }
    
    // 打开角色选择弹窗的逻辑保持不变
    const modal = document.getElementById('share-target-modal');
    const listEl = document.getElementById('share-target-list');
    listEl.innerHTML = '';
    const singleChats = Object.values(state.chats).filter(c => !c.isGroup);
    singleChats.forEach(chat => {
        const item = document.createElement('div');
        item.className = 'contact-picker-item'; 
        item.innerHTML = `
            <input type="radio" name="repost-target" value="${chat.id}" id="target-${chat.id}" style="margin-right: 15px;">
            <label for="target-${chat.id}" style="display:flex; align-items:center; width:100%; cursor:pointer;">
                <img src="${chat.settings.aiAvatar || defaultAvatar}" class="avatar">
                <span class="name">${chat.name}</span>
            </label>
        `;
        listEl.appendChild(item);
    });
    document.getElementById('share-target-modal-title').textContent = '转载到...';
    modal.classList.add('visible');

    // 确认按钮的事件监听
    const confirmBtn = document.getElementById('confirm-share-target-btn');
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    
    newConfirmBtn.onclick = async () => {
        const selectedRadio = document.querySelector('input[name="repost-target"]:checked');
        if (!selectedRadio) {
            alert("请选择一个要转载到的聊天！");
            return;
        }

        const targetChatId = selectedRadio.value;
        const targetChat = state.chats[targetChatId];
        if (!targetChat) return;

        // --- ▼▼▼ 这就是本次的【核心修改】！▼▼▼ ---

        // 1. 创建对用户可见的转载卡片消息（这部分不变）
        const repostMessage = {
            role: 'user',
            type: 'repost_forum_post',
            timestamp: Date.now(),
            content: `[转载的帖子]\nID为${post.id}\n标题: 《${post.title}》\n作者: ${post.author}\n内容: ${post.content}\n你的任务是【必须】对这个帖子发表评论。请【立刻】使用 'forum_comment' 指令完成此任务`,
            payload: {
                postId: post.id,
                title: post.title,
                author: post.author,
                content: post.content.substring(0, 100) + '...'
            }
        };
        targetChat.history.push(repostMessage);

        // 2. 创建给【AI看】的隐藏指令，并【明确地告诉AI帖子的ID】
        const hiddenInstructionMessage = {
            role: 'system',
            // 【【【看这里！我们把 post.id 加进去了！】】】
            content: `[系统指令：用户刚刚向你分享了一个ID为【${post.id}】的小组帖子，内容如下。你的任务是【必须】对这个帖子发表评论。请【立刻】使用 'forum_comment' 指令完成此任务，并确保在指令中包含正确的 "postId": ${post.id}。]\n\n--- 帖子开始 ---\n标题: ${post.title}\n作者: ${post.author}\n内容: ${post.content}\n--- 帖子结束 ---`,
            timestamp: Date.now() + 1,
            isHidden: true
        };
        targetChat.history.push(hiddenInstructionMessage);
        
        // --- ▲▲▲ 修改结束 ▲▲▲ ---

        // 后续的保存和跳转逻辑保持不变
        await db.chats.put(targetChat);
        
        modal.classList.remove('visible');
        await showCustomAlert("转载成功", `已成功将帖子转载给“${targetChat.name}”！`);
        
        openChat(targetChatId);
    };
}

// ▲▲▲ 替换结束 ▲▲▲




// ▼▼▼ 【全新】圈子/小组高级功能辅助函数 ▼▼▼
let editingGroupId = null; // 用于追踪正在编辑的小组ID

/**
 * 打开小组编辑器
 */
async function openGroupEditor(groupId) {
    editingGroupId = groupId;
    const group = await db.forumGroups.get(groupId);
    if (!group) return;

    document.getElementById('group-editor-name-input').value = group.name;
    document.getElementById('group-editor-desc-input').value = group.description;
    document.getElementById('group-editor-icon-input').value = group.icon;
    document.getElementById('group-editor-worldview-input').value = group.worldview || '';
    
    // 将分类数组转换回带'#'的字符串
    const categoriesString = (group.categories || []).map(c => `#${c}`).join(' ');
    document.getElementById('group-editor-categories-input').value = categoriesString;
    
    document.getElementById('forum-group-editor-modal').classList.add('visible');
}

/**
 * 保存对小组信息的修改
 */
async function saveGroupSettings() {
    if (!editingGroupId) return;

    const name = document.getElementById('group-editor-name-input').value.trim();
    if (!name) {
        alert('小组名称不能为空！');
        return;
    }
    
    const description = document.getElementById('group-editor-desc-input').value.trim();
    const icon = document.getElementById('group-editor-icon-input').value.trim();
    const worldview = document.getElementById('group-editor-worldview-input').value.trim();
    const categoriesInput = document.getElementById('group-editor-categories-input').value.trim();
    // 解析分类字符串
    const categories = categoriesInput ? categoriesInput.match(/#(\S+)/g)?.map(tag => tag.substring(1)) || [] : [];
    
    await db.forumGroups.update(editingGroupId, { name, description, icon, worldview, categories });
    
    document.getElementById('forum-group-editor-modal').classList.remove('visible');
    await renderForumScreen();
    alert('小组信息已更新！');
}

/**
 * 打开分类管理弹窗
 */
async function openForumCategoryManager() {
    await renderForumCategoryList();
    document.getElementById('forum-category-manager-modal').classList.add('visible');
}

/**
 * 在弹窗中渲染分类列表
 */
async function renderForumCategoryList() {
    const listEl = document.getElementById('existing-forum-categories-list');
    const categories = await db.forumCategories.toArray();
    listEl.innerHTML = '';
    if (categories.length === 0) {
        listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">还没有任何分类</p>';
    }
    categories.forEach(cat => {
        const item = document.createElement('div');
        item.className = 'existing-group-item';
        item.innerHTML = `
            <span class="group-name">${cat.name}</span>
            <span class="delete-group-btn" data-id="${cat.id}">×</span>
        `;
        listEl.appendChild(item);
    });
}

/**
 * 添加一个新的圈子分类
 */
async function addNewForumCategory() {
    const input = document.getElementById('new-forum-category-name-input');
    const name = input.value.trim();
    if (!name) {
        alert('分类名不能为空！');
        return;
    }
    const existing = await db.forumCategories.where('name').equals(name).first();
    if (existing) {
        alert(`分类 "${name}" 已经存在了！`);
        return;
    }
    await db.forumCategories.add({ name });
    input.value = '';
    await renderForumCategoryList();
}

/**
 * 删除一个圈子分类
 */
async function deleteForumCategory(categoryId) {
    const confirmed = await showCustomConfirm('确认删除', '确定要删除这个分类吗？', { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        await db.forumCategories.delete(categoryId);
        await renderForumCategoryList();
    }
}
// ▲▲▲ 新增函数结束 ▲▲▲


// ▲▲▲ 论坛功能核心代码结束 ▲▲▲

// ▼▼▼ 在 init() 函数的【上方】粘贴这【一整块新代码】 ▼▼▼
/**
 * 【全新】打开创建小组的模态框
 */
async function openGroupCreator() {
    const name = await showCustomPrompt("创建新小组", "请输入小组名称：");
    if (!name || !name.trim()) {
        if (name !== null) alert("小组名称不能为空！");
        return;
    }

    const desc = await showCustomPrompt("小组描述", "为你的小组写一句简介吧：");
    if (desc === null) return;

    const icon = await showCustomPrompt("小组图标", "输入一个 Emoji 作为小组图标：", "💬");
    if (icon === null) return;

    try {
        const newGroup = {
            name: name.trim(),
            description: desc.trim(),
            icon: icon.trim() || '💬' // 如果没输入就给个默认的
        };
        await db.forumGroups.add(newGroup);
        await renderForumScreen(); // 刷新小组列表
        alert(`小组“${name.trim()}”创建成功！`);
    } catch (error) {
        console.error("创建小组失败:", error);
        alert(`创建失败: ${error.message}`);
    }
}

/**
 * 【全新】删除一个小组
 * @param {number} groupId - 要删除的小组的ID
 */
async function deleteGroupAndPosts(groupId) {
    const group = await db.forumGroups.get(groupId);
    if (!group) return;

    const confirmed = await showCustomConfirm(
        '确认删除',
        `确定要删除小组“${group.name}”吗？此操作将同时删除该小组内的【所有帖子和评论】，且无法恢复！`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        try {
            // 1. 找到该小组下的所有帖子
            const postsToDelete = await db.forumPosts.where('groupId').equals(groupId).toArray();
            const postIds = postsToDelete.map(p => p.id);

            // 2. 如果有帖子，就找到这些帖子下的所有评论并删除
            if (postIds.length > 0) {
                await db.forumComments.where('postId').anyOf(postIds).delete();
            }

            // 3. 删除所有帖子
            await db.forumPosts.where('groupId').equals(groupId).delete();
            
            // 4. 最后删除小组本身
            await db.forumGroups.delete(groupId);

            await renderForumScreen(); // 刷新列表
            alert(`小组“${group.name}”及其所有内容已删除。`);

        } catch (error) {
            console.error("删除小组时出错:", error);
            alert(`删除失败: ${error.message}`);
        }
    }
}
// ▼▼▼ 用这块【V4 | 最终分类版】代码，完整替换旧的 generateEntertainmentGroupContent 函数 ▼▼▼

// ▼▼▼ 用这块【V5 | 最终原创分类版】代码，完整替换旧的 generateEntertainmentGroupContent 函数 ▼▼▼

/**
 * 【AI核心 - 娱乐小组 V5 | 最终原创分类版】
 */
async function generateEntertainmentGroupContent(groupId) {
    if (!groupId) return;

    await showCustomAlert("请稍候...", "娱乐小组正在紧急开会讨论最新热点...");

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('请先在API设置中配置好才能生成内容哦！');
        return;
    }

    const publicFigures = Object.values(state.chats)
        .filter(c => !c.isGroup)
        .map(c => ({ 
            name: c.name, 
            profession: c.settings.weiboProfession || '艺人',
            persona: (c.settings.weiboInstruction || c.settings.aiPersona).substring(0, 150)
        }));

    let topicsContext = '';
    if (weiboHotSearchCache && weiboHotSearchCache.length > 0) {
        topicsContext = `请围绕以下【当前最新的微博热搜话题】展开讨论：\n${weiboHotSearchCache.map(t => `- ${t.topic}`).join('\n')}`;
    } else {
        topicsContext = `请你根据下方“公众人物列表”中各个角色的【职业和人设】，为他们创造一些符合身份的、可能引发讨论的娱乐新闻或八卦事件作为讨论主题。`;
    }
    
    // --- ▼▼▼ 【核心修改】彻底重写Prompt指令 ---
    const prompt = `
# 任务
你是一个专业的“豆瓣娱乐小组资深用户模拟器”。你的任务是根据一个热门娱乐主题，生成5个帖子和对应的评论，模拟小组内的真实讨论氛围。

# 当前讨论主题
${topicsContext}

# 核心规则
1.  **豆瓣风格铁律**: 所有帖子的标题、内容和评论都【必须】是地道的“豆瓣小组”风格。
2.  **【【【分类铁律】】】**: 你【必须】为每一个帖子，根据其八卦内容，【原创】1-2个高度相关的分类标签。绝对不要使用任何预设列表。例如，如果帖子是关于恋情的，分类可以是 ["恋情瓜"]。
3.  **角色扮演铁律**: 你生成的帖子内容可以【讨论或提及】下方的公众人物，但【不能扮演他们】亲自发帖。所有帖子都必须是路人视角。
4.  **格式铁律**: 你的回复【必须且只能】是一个严格的JSON数组，包含5个帖子对象。每个对象【必须】包含 "author", "title", "content", "categories", 和 "comments" 字段。
    - "categories" 字段【必须】是你为这篇帖子原创的分类数组。

# 公众人物列表 (他们是讨论的对象，但不是发帖人)
${JSON.stringify(publicFigures, null, 2)}

# JSON输出格式示例:
[
  {
    "author": "momo",
    "title": "不懂就问，最近那个热搜上的剧真的好看吗？",
    "content": "首页天天刷到，有点好奇但又怕踩雷...",
    "categories": ["新剧讨论"],
    "comments": [
      {"author": "已注销", "content": "不好看，别去。"}
    ]
  }
]
`;
    // --- ▲▲▲ 更新结束 ▲▲▲ ---

    const messagesForApi = [{ role: 'user', content: prompt }];
    
    try {
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, prompt, messagesForApi, isGemini);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({ model: model, messages: messagesForApi, temperature: parseFloat(state.apiConfig.temperature) || 0.8,response_format: { type: "json_object" } })
            });

        if (!response.ok) throw new Error(`API请求失败: ${response.status}`);
        
        const data = await response.json();
        const rawContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content);
        const cleanedContent = rawContent.replace(/^```json\s*|```$/g, '').trim();
        const newPostsData = JSON.parse(cleanedContent);

        if (Array.isArray(newPostsData) && newPostsData.length > 0) {          
            let totalPosts = 0;
            let totalComments = 0;
            for (const postData of newPostsData) {
                // --- ▼▼▼ 【核心新增】保存分类数据 ---
                const newPost = {
                    groupId: groupId,
                    title: postData.title,
                    content: postData.content,
                    author: postData.author,
                    timestamp: Date.now() + totalPosts,
                    categories: postData.categories || [] // 保存分类
                };
                // --- ▲▲▲ 新增结束 ▲▲▲ ---
                
                const postId = await db.forumPosts.add(newPost);
                totalPosts++;

                if (postData.comments && Array.isArray(postData.comments)) {
                    const commentsToAdd = postData.comments.map(comment => ({
                        postId: postId,
                        author: comment.author,
                        content: comment.content,
                        timestamp: Date.now() + totalPosts + totalComments++
                    }));
                    if (commentsToAdd.length > 0) {
                        await db.forumComments.bulkAdd(commentsToAdd);
                    }
                }
            }
            await renderGroupPosts(groupId);
            await showCustomAlert("生成成功！", `已为娱乐小组生成了 ${totalPosts} 条新帖子和 ${totalComments} 条评论。`);
        } else {
            throw new Error("AI返回的数据格式不正确。");
        }
    } catch (error) {
        console.error("生成娱乐小组内容失败:", error);
        await showCustomAlert('生成失败', `发生了一个错误：\n${error.message}`);
    }
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 用这块【V4 | 最终原创分类版】代码，完整替换旧的 generateDreamPost 函数 ▼▼▼

/**
 * 【全新修正版 | V4】为“梦角小组”生成专属帖子的核心函数
 */
async function generateDreamPost(groupId) {
    await showCustomAlert("请稍候...", "正在为user编织一个甜蜜的梦境...");

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('请先在API设置中配置好才能生成内容哦！');
        return;
    }

    const allChars = Object.values(state.chats).filter(c => !c.isGroup);
    if (allChars.length === 0) {
        alert("还没有任何角色，无法发布梦境哦。");
        return;
    }

    const postingChar = allChars[Math.floor(Math.random() * allChars.length)];
    const userPersona = state.qzoneSettings.persona || '一个普通的、温柔的人。';
    const userNickname = state.qzoneSettings.nickname || '{{user}}';

    // --- ▼▼▼ 【核心修改】彻底重写Prompt指令 ---
    const prompt = `
# 任务：角色扮演与帖子创作（带评论和分类）
你现在【就是】角色“${postingChar.name}”。你正在一个名为“梦角小组”的秘密论坛里。
这个小组是你们这些角色，偷偷向彼此炫耀、倾诉对你们的共同爱人——用户“${userNickname}”——的爱意和幻想的地方。

# 核心规则
1.  **第一人称视角**: 你【必须】使用角色“${postingChar.name}”的第一人称视角来写作帖子正文。
2.  **帖子主题**: 你的帖子内容是你对你的爱人“${userNickname}”的爱意表达或幻想。
3.  **【【【分类铁律】】】**: 你【必须】根据梦境的具体内容，为这篇帖子【原创】1-2个高度相关的分类标签。绝对不要使用任何预设列表。例如，如果内容是甜蜜的日常，分类可以是 ["甜蜜日常"]。
4.  **评论生成**: 在创作完帖子后，你还需要立刻切换到“其他小组成员”的视角，为这篇帖子生成【2-3条】符合情景的评论。
5.  **格式铁律**: 你的回复【必须且只能】是一个严格的JSON对象，包含 "title", "content", "categories", 和 "comments" 字段。
    - "categories" 字段【必须】是你为这篇帖子原创的分类数组。

# 你的信息
-   你的名字: ${postingChar.name}
-   你的人设: ${postingChar.settings.aiPersona}

# 你的爱人信息
-   爱人的名字: ${userNickname}
-   爱人的人设: ${userPersona}

# JSON输出格式示例:
{
  "title": "关于他睡觉时的小习惯",
  "content": "偷偷告诉你们，${userNickname}睡觉的时候喜欢抱着枕头的一角...",
  "categories": ["甜蜜日常", "小习惯"],
  "comments": [
    {"author": "路人A", "content": "哇，好甜！"}
  ]
}
`;
    // --- ▲▲▲ 更新结束 ▲▲▲ ---

    const messagesForApi = [{ role: 'user', content: prompt }];
    
    try {
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, prompt, messagesForApi, isGemini);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({ model: model, messages: messagesForApi, temperature: parseFloat(state.apiConfig.temperature) || 0.8, response_format: { type: "json_object" } })
            });
        
        if (!response.ok) throw new Error(`API请求失败: ${response.status}`);
        
        const data = await response.json();
        const rawContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content);
        const cleanedContent = rawContent.replace(/^```json\s*|```$/g, '').trim();
        const postData = JSON.parse(cleanedContent);

        if (postData.title && postData.content) {
            // --- ▼▼▼ 【核心新增】保存分类数据 ---
            const newPost = {
                groupId: groupId,
                title: postData.title,
                content: postData.content,
                author: postingChar.name,
                timestamp: Date.now(),
                categories: postData.categories || [] // 保存分类
            };
            // --- ▲▲▲ 新增结束 ▲▲▲ ---
            
            const postId = await db.forumPosts.add(newPost);
            
            if (postData.comments && Array.isArray(postData.comments)) {
                const commentsToAdd = postData.comments.map((c, i) => ({ postId, author: c.author, content: c.content, timestamp: Date.now() + i + 1 }));
                await db.forumComments.bulkAdd(commentsToAdd);
            }

            await renderGroupPosts(groupId);
            await showCustomAlert("发布成功！", `“${postingChar.name}”发布了一条新的梦境。`);
        } else {
            throw new Error("AI返回的数据格式不正确。");
        }
    } catch (error) {
        console.error("生成梦角帖子失败:", error);
        await showCustomAlert('生成失败', `发生了一个错误：\n${error.message}`);
    }
}
// ▲▲▲ 替换结束 ▲▲▲



// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 把这一整块全新的功能函数，粘贴到 init() 函数的正上方 ▼▼▼

/**
 * 塔罗牌占卜功能核心
 */
let activeTarotReading = null; // 用于暂存当前占卜的结果

// 牌阵信息
const TAROT_SPREADS = {
    single: { name: '单张牌 - 快速指引', count: 1, positions: ['核心指引'] },
    three_past_present_future: { name: '三张牌 - 过去/现在/未来', count: 3, positions: ['过去', '现在', '未来'] },
    three_situation_challenge_advice: { name: '三张牌 - 情境/挑战/建议', count: 3, positions: ['情境', '挑战', '建议'] },
    celtic_cross: { name: '凯尔特十字 - 深度分析', count: 10, positions: ['现状', '挑战', '根基', '过去', '目标', '未来', '自我认知', '外部影响', '希望与恐惧', '最终结果'] }
};

// 打开塔罗牌占卜主模态框
function openTarotModal() {
    document.getElementById('tarot-divination-modal').classList.add('visible');
    // 默认显示设置界面
    document.getElementById('tarot-setup-view').style.display = 'block';
    document.getElementById('tarot-result-view').style.display = 'none';
    document.getElementById('tarot-history-view').style.display = 'none';
    // 清空输入框
    document.getElementById('tarot-question-input').value = '';
}

// 执行抽牌逻辑
function handleDrawCards() {
    const question = document.getElementById('tarot-question-input').value.trim();
    const spreadType = document.getElementById('tarot-spread-select').value;
    const orientation = document.querySelector('input[name="tarot-orientation"]:checked').value;
    
    if (!question) {
        alert('请输入您的问题或关注点。');
        return;
    }

    const spreadInfo = TAROT_SPREADS[spreadType];
    const deck = [...TAROT_DECK];

    // 洗牌
    for (let i = deck.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [deck[i], deck[j]] = [deck[j], deck[i]];
    }

    // 抽牌
    const drawnCardsRaw = deck.slice(0, spreadInfo.count);
    const drawnCards = drawnCardsRaw.map((card, index) => {
        const isReversed = orientation === 'reversed' && Math.random() < 0.5;
        return {
            ...card,
            isReversed: isReversed,
            position: spreadInfo.positions[index]
        };
    });

    activeTarotReading = {
        question: question,
        spread: spreadInfo,
        cards: drawnCards,
        timestamp: Date.now()
    };
    
    displayTarotResults(activeTarotReading);
}

// ▼▼▼ 用这个【新版本】替换旧的 displayTarotResults 函数 ▼▼▼
// 显示占卜结果 (纯文字版)
function displayTarotResults(reading) {
    const displayEl = document.getElementById('tarot-result-display');
    displayEl.innerHTML = ''; // 清空

    // 显示问题
    const questionEl = document.createElement('div');
    questionEl.className = 'tarot-result-question';
    questionEl.textContent = `您的问题是：“${reading.question}”`;
    displayEl.appendChild(questionEl);
    
    const container = document.createElement('div');
    container.className = 'tarot-spread-container';

    reading.cards.forEach(card => {
        const cardWrapper = document.createElement('div');
        cardWrapper.className = 'tarot-card-wrapper';
        
        cardWrapper.innerHTML = `
            <div class="tarot-card-position">[${card.position}]</div>
            <div class="tarot-card-name">${card.name} ${card.isReversed ? '(逆位)' : '(正位)'}</div>
        `;
        container.appendChild(cardWrapper);
    });
    
    displayEl.appendChild(container);

    // 切换视图
    document.getElementById('tarot-setup-view').style.display = 'none';
    document.getElementById('tarot-result-view').style.display = 'flex';
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 用这整块【AI智能解读最终版】代码，完整替换旧的 sendTarotReadingToChat 函数 ▼▼▼
async function sendTarotReadingToChat() {
    if (!activeTarotReading || !state.activeChatId) return;

    const chat = state.chats[state.activeChatId];
    const { proxyUrl, apiKey, model } = state.apiConfig;

    if (!proxyUrl || !apiKey || !model) {
        alert('请先在API设置中配置好才能触发AI解读哦！');
        return;
    }

    // 1. 关闭弹窗，并显示“正在解读”的提示
    document.getElementById('tarot-divination-modal').classList.remove('visible');
    await showCustomAlert("请稍候...", "塔罗师正在为你连接星辰，解读牌面...");

    try {
        const reading = activeTarotReading;
        
        // 2. 【全新优化】给“塔罗师AI”一个更专业、更结构化的指令 (Prompt)
        const cardDetails = reading.cards.map(card => {
            const orientation = card.isReversed ? '逆位' : '正位';
            const meaning = card.isReversed ? card.reversed : card.upright;
            return `- ${card.position}: ${card.name} (${orientation})，象征: ${meaning}`;
        }).join('\n');

        const tarotMasterPrompt = `
# 角色
你是一位世界级的塔罗牌解读大师，以深刻的洞察力、清晰的表达和富有同情心的指引而闻名。

# 核心任务
为用户提供一次全面、结构化且易于理解的塔罗牌解读。你的解读必须严格遵循下面的输出结构。

# 输出结构 (必须严格遵守)
你的回答必须包含以下三个部分，并使用Markdown加粗标题来分隔：

1.  **✨ 综合解读 (Overall Interpretation):**
    首先，根据所有牌面的整体感觉，给出一个高度概括的、1-2句话的核心结论或氛围描述。

2.  **🃏 牌面详解 (Card Details):**
    然后，逐一分析每一张牌。对于每一张牌，你必须：
    -   使用格式 \`**[牌位名称] - [牌名] ([正位/逆位])**\` 作为小标题。
    -   详细解释这张牌在这个特定牌位上，是如何回应用户的问题的。
    -   将牌的象征意义与用户的具体情境（问题）紧密结合起来进行分析。

3.  **💡 核心建议 (Key Advice):**
    最后，综合所有牌的信息，为用户提供一个明确、具体、可操作的行动建议或心态指引。

# 指导原则
- **故事性**: 将所有牌的含义编织成一个连贯的叙事，而不是简单地罗列关键词。
- **相关性**: 始终将解读直接与用户提出的具体问题联系起来。
- **清晰易懂**: 避免使用过于神秘或专业的术语。用平实的语言解释复杂的概念。
- **深度而非罗列**: 绝对不要只是重复我提供给你的“象征”关键词。你必须在这些关键词的基础上进行综合、提炼和深化，给出你作为大师的独特见解。

# 占卜信息
- **用户的问题**: "${reading.question}"
- **使用的牌阵**: ${reading.spread.name}
- **抽到的牌及基础含义**:
${cardDetails}

# 最终指令
你的最终输出【只能是】完整的、格式化后的解读文本。不要添加任何“好的，这是你的解读：”之类的对话性开场白。
`;

        // 3. 发起API调用，让AI扮演塔罗师
        let isGemini = proxyUrl === GEMINI_API_URL;
        let messagesForApi = [{ role: 'user', content: tarotMasterPrompt }];
        let geminiConfig = toGeminiRequestData(model, apiKey, tarotMasterPrompt, messagesForApi, isGemini);

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({ model: model, messages: messagesForApi, temperature: parseFloat(state.apiConfig.temperature) || 0.8, })
            });

        if (!response.ok) {
            throw new Error(`API请求失败: ${await response.text()}`);
        }
        
        const data = await response.json();
        const interpretation = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content).trim();

        // 4. 创建对用户可见的“系统解读”消息
        const systemMessageVisible = {
            role: 'system',
            type: 'pat_message', // 复用居中灰色气泡样式
            content: `🔮 **塔罗牌解读** 🔮\n\n**您的问题**：“${reading.question}”\n\n${interpretation}`,
            timestamp: Date.now()
        };
        chat.history.push(systemMessageVisible);
        appendMessage(systemMessageVisible, chat);

        // 5. 创建给角色Char看的隐藏指令
        const hiddenInstruction = {
            role: 'system',
            content: `[系统指令：刚刚系统为用户进行了一次塔罗牌占卜，解读结果是：“${interpretation}”。现在，请你以角色的身份，和用户一起讨论这个结果。]`,
            timestamp: Date.now() + 1, // 确保时间戳在后
            isHidden: true
        };
        chat.history.push(hiddenInstruction);

        // 6. 保存所有数据
        await saveTarotReading(activeTarotReading);
        await db.chats.put(chat);
        renderChatList();
        
        // 7. 【核心修改】我们在这里删除了 triggerAiResponse()，不再自动触发Char！
        
        activeTarotReading = null;

    } catch (error) {
        console.error("塔罗牌AI解读失败:", error);
        await showCustomAlert('解读失败', `抱歉，连接塔罗师时出现了一点问题：\n\n${error.message}`);
        activeTarotReading = null;
    }
}
// ▲▲▲ 替换结束 ▲▲▲

// 保存占卜记录到数据库
async function saveTarotReading(reading) {
    // 为了节省空间，我们只保存解读文本，而不是整个牌组对象
    const interpretationText = `牌阵: ${reading.spread.name}\n` + reading.cards.map((card, index) => {
        const orientationText = card.isReversed ? '逆位' : '正位';
        const meaning = card.isReversed ? card.reversed : card.upright;
        return `[${card.position}]: ${card.name} (${orientationText}) - ${meaning}`;
    }).join('\n');
    
    await db.tarotReadings.add({
        question: reading.question,
        interpretation: interpretationText,
        timestamp: reading.timestamp
    });
}

// 打开历史记录界面
async function openTarotHistory() {
    const readings = await db.tarotReadings.orderBy('timestamp').reverse().toArray();
    renderTarotHistory(readings);
    document.getElementById('tarot-setup-view').style.display = 'none';
    document.getElementById('tarot-history-view').style.display = 'flex';
}

// 渲染历史记录列表
function renderTarotHistory(readings) {
    const listEl = document.getElementById('tarot-history-list');
    listEl.innerHTML = '';
    if (readings.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">还没有占卜历史哦</p>';
        return;
    }
    readings.forEach(reading => {
        const item = document.createElement('div');
        item.className = 'tarot-history-item';
        item.innerHTML = `
            <div class="question">${reading.question}</div>
            <div class="details">${new Date(reading.timestamp).toLocaleString()}</div>
            <button class="tarot-history-delete-btn" data-id="${reading.id}">×</button>
        `;
        listEl.appendChild(item);
    });
}

// 删除一条历史记录
async function deleteTarotReading(readingId) {
    const confirmed = await showCustomConfirm('确认删除', '确定要删除这条占卜历史吗？', { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        await db.tarotReadings.delete(readingId);
        openTarotHistory(); // 重新加载历史记录
    }
}

// ▲▲▲ 新功能函数粘贴结束 ▲▲▲
// ▼▼▼ 把这个新函数粘贴到 renderLSLetters 函数的下方 ▼▼▼

// ▼▼▼ 【全新】这是情侣空间专属音乐播放器的CSS样式 ▼▼▼
/**
 * 【全新】渲染“分享”列表 (无封面，带简介和感想版)
 */
function renderLSShares(shares, chat) {
    const listEl = document.getElementById('ls-shares-list');
    listEl.innerHTML = '';
    if (!shares || shares.length === 0) {
        listEl.innerHTML = '<p class="ls-empty-placeholder">这里还没有任何分享哦~</p>';
        return;
    }

    [...shares].reverse().forEach(share => {
        const item = document.createElement('div');
        item.className = 'ls-list-item ls-share-item';
        item.dataset.shareData = JSON.stringify(share);

        const typeText = { song: '歌曲', movie: '电影', book: '书籍', game: '游戏' }[share.shareType] || '分享';
        const authorName = share.author === 'user' ? (chat.settings.myNickname || '我') : chat.name;
        
        // ▼▼▼ 核心修改在这里：我们重构了“摘要”部分的逻辑 ▼▼▼
        let summaryHtml = '';
        
        // 1. 如果是歌曲，显示歌手
        if (share.shareType === 'song' && share.artist) {
            summaryHtml += `<p style="margin:0; font-weight: 500;"><strong>歌手:</strong> ${share.artist}</p>`;
        }
        
        // 2. 如果有简介 (书籍和电影)，就显示简介
        if (share.summary) {
            summaryHtml += `<p style="margin:0; margin-top: 4px;"><strong>简介:</strong> ${share.summary.replace(/\n/g, '<br>')}</p>`;
        }
        
        // 3. 如果有感想，就显示感想
        if (share.thoughts) {
            summaryHtml += `<p style="margin:0; margin-top: 4px; color: #8a8a8a; font-style: italic;"><strong>感想:</strong> “${share.thoughts}”</p>`;
        }
        
        // 4. 如果啥都没有，给一个默认提示
        if (!summaryHtml) {
            summaryHtml = '<p style="margin:0; color: #8a8a8a;">暂无更多信息</p>';
        }
        // ▲▲▲ 修改结束 ▲▲▲

        // 【核心修改】这里的模板已经移除了<img>标签
        item.innerHTML = `
            <div class="share-info">
                <div class="title">
                    <span class="share-type ${share.shareType}">${typeText}</span>
                    ${share.title}
                </div>
                <div class="summary">${summaryHtml}</div>
                <div class="meta">
                    由 ${authorName} 分享于 ${formatPostTimestamp(share.timestamp)}
                </div>
            </div>
        `;
        listEl.appendChild(item);
    });
}



// ▼▼▼ 【全新】情侣空间功能核心函数 ▼▼▼

// ▼▼▼ 用下面这一整块代码，替换掉你旧的 open... 和 render... 四个函数 ▼▼▼

/**
 * 【总入口】当用户点击主屏幕的“情侣空间”App时触发
 */
async function openLoversSpaceEntry() {
    const singleChats = Object.values(state.chats).filter(chat => !chat.isGroup);
    if (singleChats.length === 0) {
        alert("你还没有任何可以建立情侣空间的角色哦，先去创建一个吧！");
        return;
    }
    if (singleChats.length === 1) {
        openLoversSpace(singleChats[0].id);
    } else {
        openCharSelectorForLoversSpace();
    }
}

// ▼▼▼ 用这块代码替换 ▼▼▼
/**
 * 打开用于情侣空间的角色选择弹窗 (已更新，会显示开启状态)
 */
async function openCharSelectorForLoversSpace() {
    const modal = document.getElementById('ls-char-selector-modal');
    const listEl = document.getElementById('ls-char-selector-list');
    listEl.innerHTML = '';
    const singleChats = Object.values(state.chats).filter(chat => !chat.isGroup);
    
    singleChats.forEach(chat => {
        const item = document.createElement('div');
        item.className = 'chat-list-item'; // 复用现有样式
        item.style.borderBottom = '1px solid var(--border-color)';
        item.dataset.chatId = chat.id;

        // 【核心修改】检查角色是否已开通情侣空间
        const isLoversSpaceActive = !!chat.loversSpaceData;
        const statusText = isLoversSpaceActive 
            ? '<span style="color: green; font-weight: bold;">已开通</span>' 
            : '<span style="color: #8a8a8a;">未开启</span>';

        item.innerHTML = `
            <img src="${chat.settings.aiAvatar || defaultAvatar}" class="avatar">
            <div class="info" style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                <span class="name">${chat.name}</span>
                <div class="last-msg">${statusText}</div>
            </div>
        `;
        listEl.appendChild(item);
    });

    modal.classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲


/**
 * 【核心】打开指定角色的情侣空间
 */
async function openLoversSpace(charId) {
    activeLoversSpaceCharId = charId;
    const chat = state.chats[charId];
    if (!chat) return;

    // 如果这个角色还没有情侣空间数据，就为他初始化一个
    if (!chat.loversSpaceData) {
chat.loversSpaceData = {
    background: 'https://i.postimg.cc/k495F4W5/profile-banner.jpg',
    relationshipStartDate: null,
    moments: [],
    albums: [],
    photos: [],
    loveLetters: [],
    shares: [],
    questions: [],
    emotionDiaries: {} // <--- 就是新增了这一行！
};
// ▲▲▲ 替换结束 ▲▲▲
        await db.chats.put(chat);
    }

    await renderLoversSpace(chat);
    showScreen('lovers-space-screen');
}

/**
 * 【全新】计算并更新“在一起”的天数
 */
function updateLoversSpaceDaysCounter(chat) {
    const counterEl = document.getElementById('ls-days-counter');
    const startDateString = chat.loversSpaceData.relationshipStartDate;

    if (startDateString) {
        const startDate = new Date(startDateString);
        const today = new Date();
        // 修正时区问题，只比较日期
        startDate.setHours(0, 0, 0, 0);
        today.setHours(0, 0, 0, 0);

        const diffTime = Math.abs(today - startDate);
        // 加1，因为第一天也算一天
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1;
        counterEl.textContent = `我们已经在一起 ${diffDays} 天了`;
    } else {
        counterEl.innerHTML = `<a>点击右上角“设置”来记录第一天吧</a>`;
    }
}

/**
 * 【渲染引擎 - 已更新】根据角色数据，渲染整个情侣空间界面
 */
async function renderLoversSpace(chat) {
    // 渲染头部
    document.getElementById('lovers-space-screen').style.backgroundImage = `url(${chat.loversSpaceData.background})`;
    
    // 这是你想要的 user & char 标题
    const userNickname = state.qzoneSettings.nickname || '{{user}}';
    document.getElementById('ls-char-name').textContent = `${userNickname} & ${chat.name}`;
    
    document.getElementById('ls-user-avatar').src = chat.settings.myAvatar || defaultAvatar;
    document.getElementById('ls-char-avatar').src = chat.settings.aiAvatar || defaultAvatar;
    
    // 调用新函数来更新天数
    updateLoversSpaceDaysCounter(chat);
    
    // 默认显示第一个页签
    switchLoversSpaceTab('ls-moments-view');
// ▼▼▼ 用下面这块【已修复】的代码替换 ▼▼▼
// 这是你的旧代码
document.querySelector('.ls-tab-item.active').classList.remove('active');
document.querySelector('.ls-tab-item[data-view="ls-moments-view"]').classList.add('active');



    // 渲染各个页签的内容
    renderLSMoments(chat.loversSpaceData.moments, chat);
    renderLSPhotos(chat.loversSpaceData.photos, chat);
    renderLSLetters(chat.loversSpaceData.loveLetters, chat);
    renderLSShares(chat.loversSpaceData.shares, chat);
    document.getElementById('ls-shares-list').innerHTML = '<p class="ls-empty-placeholder">Ta还没有分享任何内容~</p>';
}

// ▲▲▲ 替换到这里结束 ▲▲▲

// ▼▼▼ 用这块新代码替换旧的 switchLoversSpaceTab 函数 ▼▼▼
/**
 * 切换情侣空间的页签
 */
function switchLoversSpaceTab(viewId) {
    document.querySelectorAll('.ls-view').forEach(v => v.style.display = 'none'); // 使用style来隐藏
    const targetView = document.getElementById(viewId);
    if (targetView) targetView.style.display = 'block'; // 使用style来显示

    // 【核心修改】根据当前页签，显示对应的浮动按钮
    const fabMoment = document.getElementById('ls-add-moment-btn');
    const fabAlbum = document.getElementById('ls-add-album-btn');
    const fabLetter = document.getElementById('ls-add-letter-btn');
    const fabQuestion = document.getElementById('ls-add-question-btn');
    
    // 先隐藏所有
    if(fabMoment) fabMoment.style.display = 'none';
    if(fabAlbum) fabAlbum.style.display = 'none';
    if(fabLetter) fabLetter.style.display = 'none';
    if(fabQuestion) fabQuestion.style.display = 'none';

    // 再根据viewId显示对应的
    if (viewId === 'ls-moments-view' && fabMoment) fabMoment.style.display = 'block';
    else if (viewId === 'ls-album-view' && fabAlbum) fabAlbum.style.display = 'block';
    else if (viewId === 'ls-letters-view' && fabLetter) fabLetter.style.display = 'block';
    else if (viewId === 'ls-questions-view' && fabQuestion) fabQuestion.style.display = 'block';
}
// ▲▲▲ 替换结束 ▲▲▲


/**
 * 【全新】处理更换情侣空间背景的逻辑
 */
async function handleChangeLoversSpaceBackground() {
    if (!activeLoversSpaceCharId) return;

    // 复用已有的功能弹窗，让用户选择
    const choice = await showChoiceModal("更换空间背景", [
        { text: '📁 从本地上传', value: 'local' },
        { text: '🌐 使用网络URL', value: 'url' }
    ]);

    let newBackgroundUrl = null;

    if (choice === 'local') {
        // 复用已有的本地图片上传函数
        newBackgroundUrl = await uploadImageLocally();
    } else if (choice === 'url') {
        // 复用已有的URL输入弹窗
        const currentBg = state.chats[activeLoversSpaceCharId].loversSpaceData.background;
        newBackgroundUrl = await showCustomPrompt("更换背景", "请输入新的图片URL", currentBg, "url");
    }

    // 如果获取到了新的URL
    if (newBackgroundUrl && newBackgroundUrl.trim()) {
        const chat = state.chats[activeLoversSpaceCharId];
        chat.loversSpaceData.background = newBackgroundUrl.trim();
        
        // 保存到数据库
        await db.chats.put(chat);
        
        // 立刻重新渲染情侣空间以应用新背景
        await renderLoversSpace(chat);
        
        alert('情侣空间背景已更新！');
    } else if (newBackgroundUrl !== null) { // 用户点击了确定但没输入内容
         alert("请输入一个有效的URL或选择一个文件！");
    }
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲

/**
 * 渲染“说说”列表 (V2 - 已添加评论和删除功能)
 */
function renderLSMoments(moments, chat) {
    const listEl = document.getElementById('ls-moments-list');
    listEl.innerHTML = '';
    if (!moments || moments.length === 0) {
        listEl.innerHTML = '<p class="ls-empty-placeholder">还没有任何悄悄话，快来发布第一条吧！</p>';
        return;
    }
    
    // 我们需要原始的数组索引来做删除，所以这里不用 [...moments].reverse()
    for (let i = moments.length - 1; i >= 0; i--) {
        const moment = moments[i];
        const originalIndex = i; // 保存原始索引

        const isUser = moment.author === 'user';
        const authorName = isUser ? (chat.settings.myNickname || '我') : chat.name;
        const authorAvatar = isUser ? chat.settings.myAvatar : chat.settings.aiAvatar;

        // --- 核心修改：在这里构建评论区的HTML ---
        let commentsHtml = '';
        if (moment.comments && moment.comments.length > 0) {
            moment.comments.forEach((comment, commentIndex) => {
                commentsHtml += `
                    <div class="ls-comment-item">
                        <span class="commenter-name">${comment.author}:</span>
                        <span class="comment-text">${comment.text}</span>
                        <button class="ls-comment-delete-btn" data-moment-index="${originalIndex}" data-comment-index="${commentIndex}">×</button>
                    </div>
                `;
            });
        }
        
        const card = document.createElement('div');
        card.className = 'ls-moment-card';
        // 【重要】把说说的原始索引存起来，方便后面操作
        card.dataset.momentIndex = originalIndex; 
        
        // --- 核心修改：加入新的HTML结构 ---
        card.innerHTML = `
            <img src="${authorAvatar}" class="avatar">
            <div class="moment-main">
                <span class="author">${authorName}</span>
                <p class="content">${moment.content.replace(/\n/g, '<br>')}</p>
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <span class="timestamp">${formatPostTimestamp(moment.timestamp)}</span>
                </div>
                
                <!-- ▼▼▼ 这是新增的整个底部区域 ▼▼▼ -->
                <div class="ls-moment-footer">
                    <div class="ls-moment-comments-container">
                        ${commentsHtml}
                    </div>
                    <div class="ls-comment-input-area">
                        <input type="text" placeholder="添加评论...">
                        <button class="ls-comment-send-btn">发送</button>
                    </div>
                </div>
                <!-- ▲▲▲ 新增区域结束 ▲▲▲ -->

            </div>
            <!-- ▼▼▼ 这是新增的说说删除按钮 ▼▼▼ -->
            <button class="ls-moment-delete-btn" title="删除这条说说">×</button>
        `;
        listEl.appendChild(card);
    }
}



// ▼▼▼ 用这块【新代码】替换旧的 renderLSPhotos 函数 ▼▼▼
/**
 * 渲染“照片”列表
 */
function renderLSPhotos(photos, chat) {
    const listEl = document.getElementById('ls-album-list');
    listEl.innerHTML = '';
    if (!photos || photos.length === 0) {
        listEl.innerHTML = '<p class="ls-empty-placeholder" style="grid-column: 1 / -1;">还没有任何照片，点击右下角“+”上传第一张吧！</p>';
        return;
    }

    [...photos].reverse().forEach(photo => {
        const item = document.createElement('div');
        item.className = 'ls-album-item';
        
        // 【核心修改1】在这里为整个项目添加时间戳，方便我们识别是哪张照片
        item.dataset.timestamp = photo.timestamp; 

        const imageUrl = photo.type === 'image' 
            ? photo.url 
            : 'https://i.postimg.cc/KYr2qRCK/1.jpg';

        // 【核心修改2】在 .cover 内部添加了删除按钮的HTML
        item.innerHTML = `
            <div class="cover" style="background-image: url(${imageUrl});">
                <button class="ls-photo-delete-btn">×</button>
            </div>
        `;
        
        // 【核心修改3】我们不再在这里单独绑定点击事件，将在最后一步统一处理
        listEl.appendChild(item);
    });
}
// ▲▲▲ 替换结束 ▲▲▲



/**
 * 打开创建说说的弹窗
 */
function openMomentCreator() {
    document.getElementById('ls-moment-content-input').value = '';
    document.getElementById('ls-create-moment-modal').classList.add('visible');
}

/**
 * 用户发布说说 (V2 - 已添加comments字段)
 */
async function handlePostMoment() {
    const content = document.getElementById('ls-moment-content-input').value.trim();
    if (!content) {
        alert("内容不能为空哦！");
        return;
    }
    const chat = state.chats[activeLoversSpaceCharId];
    const newMoment = {
        author: 'user',
        content: content,
        timestamp: Date.now(),
        comments: [] // <-- 核心新增：为新说说创建一个空的评论数组
    };
    // 确保moments数组存在
    if (!chat.loversSpaceData.moments) {
        chat.loversSpaceData.moments = [];
    }
    chat.loversSpaceData.moments.push(newMoment);
    await db.chats.put(chat);
    
    renderLSMoments(chat.loversSpaceData.moments, chat);
    document.getElementById('ls-create-moment-modal').classList.remove('visible');
// ▼▼▼ 在 handlePostMoment 函数的末尾，粘贴下面这块新代码 ▼▼▼
// 创建一条对用户隐藏，但对AI可见的系统消息
const hiddenMessage = {
    role: 'system',
    content: `[系统提示：用户（${chat.settings.myNickname || '我'}）刚刚在我们的情侣空间发布了一条新的说说，内容是：“${content}”。请你根据人设，使用 'ls_comment' 指令对这条说说发表你的看法。]`,
    timestamp: Date.now(),
    isHidden: true // 这个标记能让消息对你隐藏，但AI能看见
};
chat.history.push(hiddenMessage);
await db.chats.put(chat); // 再次保存，确保隐藏消息被存入

// （可选）如果你希望AI在你发完说说后立刻就去评论，可以取消下面这行的注释
// triggerAiResponse();
// ▲▲▲ 粘贴结束 ▲▲▲
}


let tempUploadedPhotos = []; // 暂存待上传的照片
// ▼▼▼ 用这块新代码替换旧的 openAlbumCreator 函数 ▼▼▼
/**
 * 打开上传照片的弹窗
 */
function openAlbumCreator() {
    tempUploadedPhotos = [];
    document.getElementById('ls-album-modal-title').textContent = '上传照片';
    // 重置所有输入框和预览
    document.getElementById('ls-photo-preview-container').innerHTML = '';
    document.getElementById('ls-photo-desc-input').value = '';
    document.getElementById('ls-text-image-desc-input').value = '';
    document.getElementById('ls-photo-input').value = null;

    // 默认显示“上传图片”模式
    document.getElementById('ls-switch-to-image-mode').click();

    document.getElementById('ls-create-album-modal').classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 用这块新代码替换旧的 handlePhotoSelection 函数 ▼▼▼
/**
 * 处理用户选择照片后的预览 (单张版)
 */
function handlePhotoSelection(files) {
    const previewContainer = document.getElementById('ls-photo-preview-container');
    previewContainer.innerHTML = '';
    tempUploadedPhotos = [];
    
    const file = files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
        const dataUrl = e.target.result;
        tempUploadedPhotos.push({ url: dataUrl }); // 暂存base64
        
        // 显示预览图
        const previewItem = document.createElement('div');
        previewItem.className = 'ls-photo-preview-item';
        previewItem.innerHTML = `<img src="${dataUrl}">`;
        previewContainer.appendChild(previewItem);
    };
    reader.readAsDataURL(file);
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 用这块【已修复】的代码，替换掉你旧的 handleConfirmAlbum 函数 ▼▼▲
/**
 * 用户确认上传照片 (这是修复后的版本)
 */
async function handleConfirmAlbum() {
    const chat = state.chats[activeLoversSpaceCharId];
    if (!chat) return;

    // 1. 先判断当前是哪种模式
    const isImageMode = document.getElementById('ls-image-mode-content').classList.contains('active');
    let newPhoto;

    if (isImageMode) {
        // 2. 如果是“上传图片”模式，执行这里的检查
        if (tempUploadedPhotos.length === 0) {
            alert("请选择一张照片！"); // 只有在这种模式下，这个提示才是正确的
            return;
        }
        const description = document.getElementById('ls-photo-desc-input').value.trim();
        if (!description) {
            alert("图片描述不能为空！");
            return;
        }
        newPhoto = {
            type: 'image',
            url: tempUploadedPhotos[0].url,
            description: description,
            timestamp: Date.now()
        };
    } else {
        // 3. 如果是“使用文字图”模式，执行这里的检查
        const description = document.getElementById('ls-text-image-desc-input').value.trim();
        if (!description) {
            alert("文字图描述不能为空！");
            return;
        }
        newPhoto = {
            type: 'text_image',
            description: description,
            timestamp: Date.now()
        };
    }

    // 4. 后续的保存和刷新逻辑保持不变
    if (!chat.loversSpaceData.photos) {
        chat.loversSpaceData.photos = [];
    }

    chat.loversSpaceData.photos.push(newPhoto);
    await db.chats.put(chat);
    
    renderLSPhotos(chat.loversSpaceData.photos, chat);
    document.getElementById('ls-create-album-modal').classList.remove('visible');
}
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 把这一整块全新的功能函数，粘贴到 init() 函数的上方 ▼▼▼

/**
 * 【全新】删除情侣空间中的一张照片
 */
async function handleDeleteLSPhoto(timestamp) {
    // 弹出确认框，防止误删
    const confirmed = await showCustomConfirm(
        '删除照片',
        '确定要删除这张照片吗？此操作无法恢复。',
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        const chat = state.chats[activeLoversSpaceCharId];
        if (!chat || !chat.loversSpaceData || !chat.loversSpaceData.photos) return;

        // 从照片数组中过滤掉要删除的照片
        chat.loversSpaceData.photos = chat.loversSpaceData.photos.filter(p => p.timestamp !== timestamp);

        // 保存更新后的聊天数据
        await db.chats.put(chat);

        // 重新渲染照片列表，让删除效果立刻生效
        renderLSPhotos(chat.loversSpaceData.photos, chat);

        alert('照片已删除。');
    }
}
// ▲▲▲ 粘贴结束 ▲▲▲
/* ▼▼▼ 把这一整块全新的功能函数，粘贴到 // ▼▼▼ 【全新】情侣空间功能核心函数 ▼▼▼ 的正下方 ▼▼▼ */

let activeLoveLetter = null; // 用于暂存正在查看或回复的情书

// ▼▼▼ 用这块【已添加删除按钮】的代码，完整替换掉旧的 renderLSLetters 函数 ▼▼▼
/**
 * 【全新】渲染“情书”列表 (已加入删除功能)
 */
function renderLSLetters(letters, chat) {
    const listEl = document.getElementById('ls-letters-list');
    listEl.innerHTML = ''; // 先清空
    if (!letters || letters.length === 0) {
        listEl.innerHTML = '<p class="ls-empty-placeholder">还没有任何情书，点击右下角“+”写下第一封吧！</p>';
        return;
    }

    // 从新到旧排序显示
    [...letters].reverse().forEach(letter => {
        const item = document.createElement('div');
        item.className = 'ls-love-letter-item';
        item.dataset.letterId = letter.id;

        const svgIcon = `
            <svg class="letter-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M4 7.00005L10.2 11.65C11.2667 12.45 12.7333 12.45 13.8 11.65L20 7" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <rect x="2" y="5" width="20" height="14" rx="2" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
            </svg>
        `;

        // 【核心修改】在这里加入了删除按钮的HTML
        item.innerHTML = `
            <!-- 这是新增的删除按钮 -->
            <button class="ls-letter-delete-btn" title="删除这封情书">×</button>

            ${svgIcon}
            <div class="letter-info">
                <div class="letter-recipient">
                    <img src="${letter.recipientAvatar}" class="avatar">
                    <span>To: ${letter.recipientName}</span>
                </div>
                <div class="letter-preview">${letter.content.substring(0, 30)}...</div>
            </div>
            <div class="letter-sender">
                <img src="${letter.senderAvatar}" class="avatar">
                <span>From: ${letter.senderName}</span>
            </div>
        `;
        listEl.appendChild(item);
    });
}
// ▲▲▲ 替换结束 ▲▲▲



/**
 * 【全新】打开写情书/回信的弹窗
 * @param {object | null} replyToLetter - 如果是回信，则传入被回复的情书对象
 */
function openLoveLetterEditor(replyToLetter = null) {
    const modal = document.getElementById('ls-create-letter-modal');
    const titleEl = document.getElementById('ls-letter-modal-title');
    const recipientInput = document.getElementById('ls-letter-recipient-input');
    const contentInput = document.getElementById('ls-letter-content-input');
    
    const chat = state.chats[activeLoversSpaceCharId];
    
    if (replyToLetter) {
        // 这是回信
        titleEl.textContent = `回信给 ${replyToLetter.senderName}`;
        recipientInput.value = replyToLetter.senderName;
        contentInput.value = ''; // 清空内容
        contentInput.placeholder = `回复 ${replyToLetter.senderName} 的情书...`;
        // 暂存被回复的信，以便发送时知道是回复谁
        modal.dataset.replyingTo = JSON.stringify(replyToLetter);
    } else {
        // 这是写新信
        titleEl.textContent = `给 ${chat.name} 写一封信`;
        recipientInput.value = chat.name;
        contentInput.value = '';
        contentInput.placeholder = '在这里写下你的心意...';
        // 清除可能存在的回复标记
        delete modal.dataset.replyingTo;
    }
    
    modal.classList.add('visible');
}

/**
 * 【全新】处理用户点击“寄出”按钮的逻辑
 */
async function handlePostLoveLetter() {
    const modal = document.getElementById('ls-create-letter-modal');
    const content = document.getElementById('ls-letter-content-input').value.trim();
    if (!content) {
        alert("情书内容不能为空哦！");
        return;
    }

    const chat = state.chats[activeLoversSpaceCharId];
    const isReply = modal.dataset.replyingTo;
    
    let newLetter;

    if (isReply) {
        // 如果是回信，发信人和收信人信息要反过来
        const originalLetter = JSON.parse(isReply);
        newLetter = {
            id: 'letter_' + Date.now(),
            senderId: 'user',
            senderName: chat.settings.myNickname || '我',
            senderAvatar: chat.settings.myAvatar,
            recipientName: originalLetter.senderName, // 收信人是原信的发信人
            recipientAvatar: originalLetter.senderAvatar,
            content: content,
            timestamp: Date.now()
        };
    } else {
        // 如果是写新信
        newLetter = {
            id: 'letter_' + Date.now(),
            senderId: 'user',
            senderName: chat.settings.myNickname || '我',
            senderAvatar: chat.settings.myAvatar,
            recipientName: chat.name, // 收信人是当前角色
            recipientAvatar: chat.settings.aiAvatar,
            content: content,
            timestamp: Date.now()
        };
    }

    // 确保 loveLetters 数组存在
    if (!chat.loversSpaceData.loveLetters) {
        chat.loversSpaceData.loveLetters = [];
    }
    chat.loversSpaceData.loveLetters.push(newLetter);
    
    await db.chats.put(chat);
    // ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼
// 如果是用户写的信，就给AI发一个隐藏的系统通知
if (newLetter.senderId === 'user') {
    const hiddenMessage = {
        role: 'system',
        content: `[系统提示：用户刚刚在情侣空间给你写了一封情书，内容是：“${content}”。请你根据人设，使用 'ls_letter' 指令给用户写一封回信。]`,
        timestamp: Date.now(),
        isHidden: true // 这个标记能让消息对你隐藏，但AI能看见
    };
    chat.history.push(hiddenMessage);
    await db.chats.put(chat); // 再次保存，确保隐藏消息被存入
    
    // （可选）如果你希望AI在你发信后立刻回复，可以把下面这行的注释去掉
    // triggerAiResponse(); 
}
// ▲▲▲ 粘贴结束 ▲▲▲

    renderLSLetters(chat.loversSpaceData.loveLetters, chat);
    modal.classList.remove('visible');
}

// ▼▼▼ 用这块【使用全新信纸弹窗】的新代码，替换旧的 showLoveLetterDetail 函数 ▼▼▼
/**
 * 【全新】显示情书详情 (信纸样式版)
 * @param {string} letterId - 要显示的情书的ID
 */
async function showLoveLetterDetail(letterId) {
    const chat = state.chats[activeLoversSpaceCharId];
    activeLoveLetter = chat.loversSpaceData.loveLetters.find(l => l.id === letterId);
    if (!activeLoveLetter) return;

    // 获取新的信纸弹窗元素
    const modal = document.getElementById('ls-letter-viewer-modal');
    
    // 填充所有数据
    document.getElementById('ls-viewer-recipient-avatar').src = activeLoveLetter.recipientAvatar;
    document.getElementById('ls-viewer-recipient-name').textContent = activeLoveLetter.recipientName;
    document.getElementById('ls-viewer-body').innerHTML = activeLoveLetter.content.replace(/\n/g, '<br>'); // 正文内容
    document.getElementById('ls-viewer-sender-name').textContent = `Your dearest, ${activeLoveLetter.senderName}`; // 发信人
    document.getElementById('ls-viewer-timestamp').textContent = new Date(activeLoveLetter.timestamp).toLocaleString(); // 时间

    // 显示弹窗
    modal.classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 把这一整块全新的代码，粘贴到 // ▲▲▲ 情侣空间功能函数结束 ▲▲▲ 的正上方 ▼▼▼
/* ▼▼▼ 把这一整块全新的代码，粘贴到 // ▲▲▲ 情侣空间功能函数结束 ▲▲▲ 的正上方 ▼▼▼ */

/* --- 【全新】情侣空间-情绪日记功能核心函数 --- */

let currentDiaryDate = null; // 用于暂存正在编辑或查看的日记日期

/**
 * 渲染情绪日记的主界面（日历和心情罐子）
 */
async function renderLSDiaryView(year, month) {
    const viewEl = document.getElementById('ls-diary-view');
    const chat = state.chats[activeLoversSpaceCharId];
    if (!viewEl || !chat) return;

    const diaryData = chat.loversSpaceData.emotionDiaries || {};

    // 渲染日历
    viewEl.innerHTML = renderCalendar(year, month, diaryData);

    // 渲染心情罐子
    const jarHtml = renderMoodJar(year, month, diaryData);
    viewEl.insertAdjacentHTML('beforeend', jarHtml);
}

/**
 * 【辅助函数】生成日历的HTML
 */
function renderCalendar(year, month, diaryData) {
    const date = new Date(year, month - 1, 1);
    const firstDay = date.getDay(); // 0-6 (周日-周六)
    const daysInMonth = new Date(year, month, 0).getDate();
    const today = new Date();
    
    let calendarHtml = `
        <div class="ls-calendar-wrapper">
            <div class="ls-calendar-header">
                <button id="ls-prev-month-btn">‹</button>
                <span id="ls-current-month-display">${year}年 ${month}月</span>
                <button id="ls-next-month-btn">›</button>
            </div>
            <div class="ls-calendar-weekdays">
                <div>日</div><div>一</div><div>二</div><div>三</div><div>四</div><div>五</div><div>六</div>
            </div>
            <div class="ls-calendar-grid">
    `;

    // 空白格子
    for (let i = 0; i < firstDay; i++) {
        calendarHtml += '<div class="ls-calendar-day empty"></div>';
    }

    // 日期格子
    for (let day = 1; day <= daysInMonth; day++) {
        const dateStr = `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
        const dayData = diaryData[dateStr] || {};
        const isToday = today.getFullYear() === year && today.getMonth() + 1 === month && today.getDate() === day;

        calendarHtml += `
            <div class="ls-calendar-day ${isToday ? 'today' : ''}" data-date="${dateStr}">
                <div class="day-number">${day}</div>
                <div class="mood-emojis">
                    <span class="user-emoji">${dayData.userEmoji || ''}</span>
                    <span class="char-emoji">${dayData.charEmoji || ''}</span>
                </div>
            </div>
        `;
    }
    calendarHtml += '</div></div>';
    return calendarHtml;
}

/**
 * 【辅助函数】生成心情罐子的HTML
 */
function renderMoodJar(year, month, diaryData) {
    let allEmojis = [];
    for (const dateStr in diaryData) {
        if (dateStr.startsWith(`${year}-${String(month).padStart(2, '0')}`)) {
            const dayData = diaryData[dateStr];
            if (dayData.userEmoji) allEmojis.push(dayData.userEmoji);
            if (dayData.charEmoji) allEmojis.push(dayData.charEmoji);
        }
    }
    
    let jarHtml = `
        <div class="ls-mood-jar-wrapper">
            <h3>本月心情罐子</h3>
            <div class="ls-mood-jar">
    `;

    if (allEmojis.length > 0) {
        jarHtml += allEmojis.map(emoji => `<span class="mood-emoji-item">${emoji}</span>`).join('');
    } else {
        jarHtml += '<p style="color: var(--text-secondary); font-size: 13px;">这个月还没有记录心情哦</p>';
    }

    jarHtml += '</div></div>';
    return jarHtml;
}

/**
 * 打开日记编辑/查看弹窗
 */
function openDiaryModal(dateStr) {
    currentDiaryDate = dateStr;
    const chat = state.chats[activeLoversSpaceCharId];
    const diaryEntry = chat.loversSpaceData.emotionDiaries?.[dateStr];

    // 如果双方都有日记，或只有AI有日记，则打开查看器
    if (diaryEntry && (diaryEntry.userDiary || diaryEntry.charDiary)) {
        openDiaryViewer(dateStr, diaryEntry, chat);
    } else {
        // 否则，打开编辑器
        openDiaryEditor(dateStr, diaryEntry);
    }
}

/**
 * 打开日记编辑器
 */
function openDiaryEditor(dateStr, entryData) {
    const modal = document.getElementById('ls-diary-editor-modal');
    document.getElementById('ls-diary-editor-title').textContent = `记录 ${dateStr} 的心情`;

    const emojiSelector = document.getElementById('ls-emoji-selector');
    const emojis = ['😊', '😄', '😍', '😢', '😠', '🤔', '😴', '🤢'];
    emojiSelector.innerHTML = emojis.map(e => `<span class="emoji-option" data-emoji="${e}">${e}</span>`).join('');
    
    // 恢复之前的选择（如果有）
    const contentInput = document.getElementById('ls-diary-content-input');
    if (entryData && entryData.userEmoji) {
        emojiSelector.querySelector(`.emoji-option[data-emoji="${entryData.userEmoji}"]`)?.classList.add('selected');
        contentInput.value = entryData.userDiary || '';
    } else {
        contentInput.value = '';
    }

    modal.classList.add('visible');
}

/**
 * 打开日记查看器
 */
function openDiaryViewer(dateStr, entryData, chat) {
    const modal = document.getElementById('ls-diary-viewer-modal');
    document.getElementById('ls-diary-viewer-title').textContent = `查看 ${dateStr} 的日记`;
    const bodyEl = document.getElementById('ls-diary-viewer-body');
    bodyEl.innerHTML = '';
    
    // 显示用户日记
    if (entryData.userDiary) {
        const userBlock = document.createElement('div');
        userBlock.className = 'ls-diary-entry-block';
        userBlock.innerHTML = `
            <div class="entry-header">
                <span class="mood-emoji">${entryData.userEmoji}</span>
                <span class="author">${chat.settings.myNickname || '我'}的日记</span>
            </div>
            <p class="entry-content">${entryData.userDiary.replace(/\n/g, '<br>')}</p>
        `;
        bodyEl.appendChild(userBlock);
    }

    // 显示角色日记
    if (entryData.charDiary) {
        const charBlock = document.createElement('div');
        charBlock.className = 'ls-diary-entry-block';
        charBlock.style.borderColor = '#ff8fab'; // 给角色日记一个不同的颜色
        charBlock.innerHTML = `
            <div class="entry-header">
                <span class="mood-emoji">${entryData.charEmoji}</span>
                <span class="author">${chat.name}的日记</span>
            </div>
            <p class="entry-content">${entryData.charDiary.replace(/\n/g, '<br>')}</p>
        `;
        bodyEl.appendChild(charBlock);
    } else {
        // 如果角色还没写，给个提示
        bodyEl.innerHTML += `<p style="text-align: center; color: var(--text-secondary);">Ta 还没写今天的心情日记哦~</p>`;
    }
    
    modal.classList.add('visible');
}

/**
 * 保存用户的日记，并触发AI写日记和回应
 */
async function handleSaveUserDiary() {
    const selectedEmojiEl = document.querySelector('#ls-emoji-selector .selected');
    const userEmoji = selectedEmojiEl ? selectedEmojiEl.dataset.emoji : null;
    const userDiary = document.getElementById('ls-diary-content-input').value.trim();

    if (!userEmoji) {
        alert("请选择一个表情代表今天的心情！");
        return;
    }
    if (!userDiary) {
        alert("日记内容不能为空哦！");
        return;
    }
    
    const chat = state.chats[activeLoversSpaceCharId];
    if (!chat.loversSpaceData.emotionDiaries) {
        chat.loversSpaceData.emotionDiaries = {};
    }

    // 更新或创建当天的日记数据
    if (!chat.loversSpaceData.emotionDiaries[currentDiaryDate]) {
        chat.loversSpaceData.emotionDiaries[currentDiaryDate] = {};
    }
    chat.loversSpaceData.emotionDiaries[currentDiaryDate].userEmoji = userEmoji;
    chat.loversSpaceData.emotionDiaries[currentDiaryDate].userDiary = userDiary;
    
    // 关闭弹窗
    document.getElementById('ls-diary-editor-modal').classList.remove('visible');
    // --- 【核心联动功能开始】 ---

    // 1. 准备一条对用户可见的消息，告诉对方你写了日记
    const targetChat = state.chats[activeLoversSpaceCharId];
    if (targetChat) {
        const userNickname = state.qzoneSettings.nickname || '我';
// ▼▼▼ 用这块【新代码】替换旧的 notificationMessage 定义 ▼▼▼
const notificationMessage = {
    role: 'user',
    type: 'ls_diary_notification', // 【核心修改1】给它一个独一无二的类型
    content: { // 【核心修改2】内容变成一个对象，方便携带更多信息
        userEmoji: userEmoji, // 把用户选择的表情也带上
        text: '我刚刚写了今天的心情日记哦，你也快去看看吧！'
    },
    timestamp: Date.now()
};
        targetChat.history.push(notificationMessage);

        // 2. 创建一条对AI可见的【隐藏指令】，这是整个功能的核心
        const hiddenMessage = {
            role: 'system',
            content: `[系统指令：用户刚刚在情侣空间写了今天的日记。
            - 他们的心情是: ${userEmoji}
            - 日记内容是: "${userDiary}"
            你的任务:
            1.  【必须】根据你的人设和今天的聊天记录，也写一篇你自己的心情日记，并使用 'ls_diary_entry' 指令发送。
            2.  【必须】在写完日记后，立刻就用户今天的日记内容，以你的角色口吻，主动开启一段新的对话。]`,
            timestamp: Date.now() + 1, // 确保时间戳在后
            isHidden: true // 这个标记能让消息对用户隐藏，但AI能看见
        };
        targetChat.history.push(hiddenMessage);

        // 3. 保存所有更改到数据库
        await db.chats.put(targetChat);

        // 4. 主动跳转到单聊界面，并触发AI响应
        openChat(activeLoversSpaceCharId);
        triggerAiResponse();
    }
    // --- 【核心联动功能结束】 ---

// ▲▲▲ 新代码粘贴结束 ▲▲▲

    alert('日记已保存！');
}

/* --- 情绪日记功能函数结束 --- */
/* ▲▲▲ 新增代码粘贴结束 ▲▲▲ */

/* --- 【全新】情侣空间-情侣提问功能核心函数 --- */

let activeQuestionId = null; // 用于暂存正在回答的问题ID

/**
 * 渲染“情侣提问”列表
 */
function renderLSQuestions(questions, chat) {
    const listEl = document.getElementById('ls-questions-list');
    listEl.innerHTML = '';
    if (!questions || questions.length === 0) {
        listEl.innerHTML = '<p class="ls-empty-placeholder">还没有人提问，点击右下角“+”发起第一个提问吧！</p>';
        return;
    }

    [...questions].reverse().forEach(q => {
        const isUserQuestioner = q.questioner === 'user';
        const questionerName = isUserQuestioner ? (chat.settings.myNickname || '我') : chat.name;
        const questionerAvatar = isUserQuestioner ? chat.settings.myAvatar : chat.settings.aiAvatar;

        let answerHtml = '';
        if (q.answerText) {
            const isUserAnswerer = q.answerer === 'user';
            const answererName = isUserAnswerer ? (chat.settings.myNickname || '我') : chat.name;
            const answererAvatar = isUserAnswerer ? chat.settings.myAvatar : chat.settings.aiAvatar;
            answerHtml = `
                <div class="ls-answer-section">
                    <img src="${answererAvatar}" class="qa-avatar">
                    <div class="qa-main">
                        <div class="qa-header">
                            <span class="qa-author">${answererName}的回答</span>
                        </div>
                        <p class="qa-content">${q.answerText.replace(/\n/g, '<br>')}</p>
                    </div>
                </div>
            `;
        } else if (q.answerer === 'user') {
            // 如果轮到用户回答
            answerHtml = `
                <div class="ls-answer-placeholder">
                    <button class="ls-answer-btn" data-question-id="${q.id}">回答Ta的问题</button>
                </div>
            `;
        } else {
            // 如果轮到AI回答
            answerHtml = `
                <div class="ls-answer-placeholder">
                    <p style="color: var(--text-secondary); font-size: 14px;">等待Ta的回答...</p>
                </div>
            `;
        }

        const card = document.createElement('div');
        card.className = 'ls-question-card';
        
        // ▼▼▼ 核心修改就是在这里加入了删除按钮 ▼▼▼
        card.innerHTML = `
            <button class="ls-question-delete-btn" data-question-id="${q.id}" title="删除此提问">×</button>

            <div class="ls-question-section">
                <img src="${questionerAvatar}" class="qa-avatar">
                <div class="qa-main">
                    <div class="qa-header">
                        <span class="qa-author">${questionerName}的提问</span>
                        <span class="qa-timestamp">${formatPostTimestamp(q.timestamp)}</span>
                    </div>
                    <p class="qa-content">${q.questionText.replace(/\n/g, '<br>')}</p>
                </div>
            </div>
            ${answerHtml}
        `;
        listEl.appendChild(card);
    });
}


/**
 * 打开提问弹窗
 */
function openQuestionAsker() {
    document.getElementById('ls-question-content-input').value = '';
    document.getElementById('ls-ask-question-modal').classList.add('visible');
}

/**
 * 用户发布一个新提问
 */
async function handlePostQuestion() {
    const content = document.getElementById('ls-question-content-input').value.trim();
    if (!content) {
        alert("问题内容不能为空！");
        return;
    }
    const chat = state.chats[activeLoversSpaceCharId];
    const newQuestion = {
        id: 'q_' + Date.now(),
        questioner: 'user',
        questionText: content,
        timestamp: Date.now(),
        answerer: 'char', // 指定由AI来回答
        answerText: null
    };
    
    if (!chat.loversSpaceData.questions) {
        chat.loversSpaceData.questions = [];
    }
    chat.loversSpaceData.questions.push(newQuestion);
    await db.chats.put(chat);
    
    renderLSQuestions(chat.loversSpaceData.questions, chat);
    document.getElementById('ls-ask-question-modal').classList.remove('visible');
    
// ▼▼▼ 在 handlePostQuestion 函数的末尾，粘贴下面这块新代码 ▼▼▼
// 创建一条对用户隐藏，但对AI可见的系统消息
const hiddenMessage = {
    role: 'system',
    content: `[系统提示：用户在情侣空间向你提了一个问题：“${content}”，问题ID是“${newQuestion.id}”。请使用 'ls_answer_question' 指令来回答。]`,
    timestamp: Date.now(),
    isHidden: true
};
chat.history.push(hiddenMessage);
await db.chats.put(chat);


}

/**
 * 打开回答问题的弹窗
 */
function openAnswerEditor(questionId) {
    const chat = state.chats[activeLoversSpaceCharId];
    const question = chat.loversSpaceData.questions.find(q => q.id === questionId);
    if (!question) return;

    activeQuestionId = questionId;
    document.getElementById('ls-answer-question-text').textContent = question.questionText;
    document.getElementById('ls-answer-content-input').value = '';
    document.getElementById('ls-answer-question-modal').classList.add('visible');
}

/**
 * 用户提交回答
 */
async function handlePostAnswer() {
    if (!activeQuestionId) return;
    const answerText = document.getElementById('ls-answer-content-input').value.trim();
    if (!answerText) {
        alert("回答内容不能为空！");
        return;
    }
    const chat = state.chats[activeLoversSpaceCharId];
    const question = chat.loversSpaceData.questions.find(q => q.id === activeQuestionId);
    if (question) {
        question.answerer = 'user'; // 明确回答者是用户
        question.answerText = answerText;
        await db.chats.put(chat);
        // ▼▼▼ 用这块新代码替换上面的 ▼▼▼
const hiddenMessage = {
    role: 'system',
    content: `[系统提示：用户（${chat.settings.myNickname || '我'}）刚刚在情侣空间回答了你之前提出的问题。你的问题是：“${question.questionText}”，用户的回答是：“${answerText}”。]`,
    timestamp: Date.now(),
    isHidden: true
};
chat.history.push(hiddenMessage);
await db.chats.put(chat);
// ▲▲▲ 替换结束 ▲▲▲
        renderLSQuestions(chat.loversSpaceData.questions, chat);
    }
    document.getElementById('ls-answer-question-modal').classList.remove('visible');
    activeQuestionId = null;
}
/**
 * 【全新】删除一条情侣提问
 * @param {string} questionId - 要删除的提问的ID
 */
async function handleDeleteLSQuestion(questionId) {
    // 1. 弹出确认框，防止误删
    const confirmed = await showCustomConfirm(
        '删除提问',
        '确定要删除这个问题以及对应的回答吗？此操作无法恢复。',
        { confirmButtonClass: 'btn-danger' }
    );

    // 2. 如果用户确认删除
    if (confirmed) {
        const chat = state.chats[activeLoversSpaceCharId];
        if (!chat || !chat.loversSpaceData || !chat.loversSpaceData.questions) return;

        // 3. 从提问数组中过滤掉要删除的提问
        chat.loversSpaceData.questions = chat.loversSpaceData.questions.filter(q => q.id !== questionId);

        // 4. 保存更新后的聊天数据
        await db.chats.put(chat);

        // 5. 重新渲染提问列表，让删除效果立刻生效
        renderLSQuestions(chat.loversSpaceData.questions, chat);

        alert('提问已删除。');
    }
}

/* --- 情侣提问功能函数结束 --- */

// ▲▲▲ 粘贴结束 ▲▲▲
// ▼▼▼ 【全新】这里是情侣空间专属音乐播放器的所有核心功能函数 ▼▼▼

/**
 * 【总入口】当用户在情侣空间点击一首分享的歌曲时触发
 * @param {object} shareData - 包含歌曲信息的分享对象
 */
async function openLoversSpaceMusicPlayer(shareData) {
    await showCustomAlert("请稍候...", `正在为《${shareData.title}》寻找播放资源...`);
    
    // 检查播放列表是否已经有这首歌了
    const existingIndex = lsMusicState.playlist.findIndex(
        song => song.name === shareData.title && song.artist === shareData.artist
    );

    if (existingIndex > -1) {
        // 如果已经存在，直接播放并打开播放器
        playLSSong(existingIndex);
        document.getElementById('ls-music-player-overlay').classList.add('visible');
        return;
    }

    // 如果不存在，开始搜索
    let songData = null;
    const songName = shareData.title;
    const artistName = shareData.artist || '';

    // 策略1：优先用网易云搜索 (通常结果更准)
    const neteaseResults = await searchNeteaseMusic(songName, artistName);
    if (neteaseResults.length > 0) {
        songData = neteaseResults[0];
    } else {
        // 策略2：如果网易云找不到，再用QQ音乐搜一次
        const tencentResults = await searchTencentMusic(songName);
        if (tencentResults.length > 0) {
            songData = tencentResults[0];
        }
    }

    if (!songData) {
        await showCustomAlert("播放失败", `抱歉，在网易云和QQ音乐都没能找到《${songName}》的可播放资源。`);
        return;
    }

    // 获取播放链接
    const apiUrl = songData.source === 'netease' 
        ? `https://api.vkeys.cn/v2/music/netease?id=${songData.id}`
        : `https://api.vkeys.cn/v2/music/tencent?id=${songData.id}`;
    
    const result = await Http_Get(apiUrl);

    if (!result?.data?.url || !(await checkAudioAvailability(result.data.url))) {
        await showCustomAlert("获取失败", `找到了《${songName}》，但无法获取有效的播放链接。`);
        return;
    }

    // 【新增】获取歌词
    const lrcContent = await getLyricsForSong(songData.id, songData.source) || "";

    // 创建新的歌曲对象并添加到播放列表
    const newSong = {
        name: songData.name,
        artist: songData.artist,
        src: result.data.url,
        cover: songData.cover,
        lrcContent: lrcContent // <-- 就是新增了这一行！
    };

    lsMusicState.playlist.push(newSong);
    
    // 播放这首新添加的歌曲
    playLSSong(lsMusicState.playlist.length - 1);
    
    // 打开播放器
    document.getElementById('ls-music-player-overlay').classList.add('visible');
}

async function playLSSong(index) {
    if (index < 0 || index >= lsMusicState.playlist.length) return;

    lsMusicState.currentIndex = index;
    const track = lsMusicState.playlist[index];
    const lsAudioPlayer = document.getElementById('ls-audio-player');
    
    // 【新增】解析和渲染歌词
    track.parsedLyrics = parseLRC(track.lrcContent || ""); // 复用你已有的歌词解析函数
    track.currentLyricIndex = -1;
    renderLSLyrics(track);

    lsAudioPlayer.src = track.src;
    try {
        await lsAudioPlayer.play();
        lsMusicState.isPlaying = true;
    } catch (error) {
        console.error("情侣空间音乐播放失败:", error);
        lsMusicState.isPlaying = false;
    }
    
    renderLSMusicPlayerUI();
    renderLSMusicPlaylist(); 
}


/**
 * 切换播放/暂停状态 (情侣空间版)
 */
function toggleLSMusicPlayPause() {
    const lsAudioPlayer = document.getElementById('ls-audio-player');
    if (lsMusicState.currentIndex === -1 && lsMusicState.playlist.length > 0) {
        // 如果列表有歌但还没开始播，点击播放就从第一首开始
        playLSSong(0);
        return;
    }
    
    if (lsAudioPlayer.paused) {
        lsAudioPlayer.play();
        lsMusicState.isPlaying = true;
    } else {
        lsAudioPlayer.pause();
        lsMusicState.isPlaying = false;
    }
    renderLSMusicPlayerUI();
}

/**
 * 播放下一首 (情侣空间版)
 */
function playNextLSSong() {
    if (lsMusicState.playlist.length === 0) return;
    const newIndex = (lsMusicState.currentIndex + 1) % lsMusicState.playlist.length;
    playLSSong(newIndex);
}

/**
 * 播放上一首 (情侣空间版)
 */
function playPrevLSSong() {
    if (lsMusicState.playlist.length === 0) return;
    const newIndex = (lsMusicState.currentIndex - 1 + lsMusicState.playlist.length) % lsMusicState.playlist.length;
    playLSSong(newIndex);
}

/**
 * 更新播放器界面 (情侣空间版)
 */
function renderLSMusicPlayerUI() {
    const track = lsMusicState.playlist[lsMusicState.currentIndex];

    if (track) {
        document.getElementById('ls-album-cover').src = track.cover;
        document.getElementById('ls-song-title').textContent = track.name;
        document.getElementById('ls-artist').textContent = track.artist;
    } else {
        document.getElementById('ls-album-cover').src = 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png';
        document.getElementById('ls-song-title').textContent = '暂无歌曲';
        document.getElementById('ls-artist').textContent = '...';
    }

    document.getElementById('ls-play-pause-btn').textContent = lsMusicState.isPlaying ? '❚❚' : '▶';
}

/**
 * 更新进度条 (情侣空间版)
 */
function updateLSProgressBar() {
    const lsAudioPlayer = document.getElementById('ls-audio-player');
    const currentTimeEl = document.getElementById('ls-current-time');
    const totalTimeEl = document.getElementById('ls-total-time');
    const progressFillEl = document.getElementById('ls-progress-fill');

    if (!lsAudioPlayer.duration) {
        currentTimeEl.textContent = "0:00";
        totalTimeEl.textContent = "0:00";
        progressFillEl.style.width = '0%';
        return;
    }
    
    const progressPercent = (lsAudioPlayer.currentTime / lsAudioPlayer.duration) * 100;
    progressFillEl.style.width = `${progressPercent}%`;
    currentTimeEl.textContent = formatMusicTime(lsAudioPlayer.currentTime);
    totalTimeEl.textContent = formatMusicTime(lsAudioPlayer.duration);
    updateLSCurrentLyric(lsAudioPlayer.currentTime);
}

/**
 * 渲染播放列表 (情侣空间版)
 */
function renderLSMusicPlaylist() {
    const playlistBody = document.getElementById('ls-playlist-body');
    playlistBody.innerHTML = '';
    
    if (lsMusicState.playlist.length === 0) {
        playlistBody.innerHTML = '<p style="text-align:center; padding: 20px; color: #888;">播放列表是空的</p>';
        return;
    }

    lsMusicState.playlist.forEach((track, index) => {
        const item = document.createElement('div');
        item.className = 'playlist-item';
        if (index === lsMusicState.currentIndex) {
            item.classList.add('playing');
        }
        item.innerHTML = `
            <div class="playlist-item-info">
                <div class="title">${track.name}</div>
                <div class="artist">${track.artist}</div>
            </div>
            <div class="playlist-item-actions">
                <span class="playlist-action-btn delete-track-btn" data-index="${index}">×</span>
            </div>
        `;
        item.querySelector('.playlist-item-info').addEventListener('click', () => playLSSong(index));
        playlistBody.appendChild(item);
    });
}
// ▼▼▼ 在 clearLSMusicPlaylist() 函数的上方，粘贴这一整块新代码 ▼▼▼

/**
 * 【全新】渲染歌词列表 (情侣空间版)
 */
function renderLSLyrics(track) {
    const lyricsList = document.getElementById('ls-lyrics-list');
    lyricsList.innerHTML = '';
    if (!track.parsedLyrics || track.parsedLyrics.length === 0) {
        lyricsList.innerHTML = '<div class="lyric-line active">♪ 暂无歌词 ♪</div>';
        return;
    }
    track.parsedLyrics.forEach((line, index) => {
        const lineEl = document.createElement('div');
        lineEl.className = 'lyric-line';
        lineEl.textContent = line.text;
        lineEl.dataset.index = index;
        lyricsList.appendChild(lineEl);
    });
    lyricsList.style.transform = `translateY(45%)`; // 初始位置
}

/**
 * 【全新】更新当前高亮的歌词 (情侣空间版)
 */
function updateLSCurrentLyric(currentTime) {
    const track = lsMusicState.playlist[lsMusicState.currentIndex];
    if (!track || !track.parsedLyrics || track.parsedLyrics.length === 0) return;

    let newLyricIndex = -1;
    for (let i = 0; i < track.parsedLyrics.length; i++) {
        if (currentTime >= track.parsedLyrics[i].time) {
            newLyricIndex = i;
        } else {
            break;
        }
    }
    
    if (newLyricIndex !== track.currentLyricIndex) {
        track.currentLyricIndex = newLyricIndex;
        
        const lyricsList = document.getElementById('ls-lyrics-list');
        const container = document.getElementById('ls-lyrics-container');
        
        lyricsList.querySelectorAll('.lyric-line').forEach(line => line.classList.remove('active'));
        
        if (newLyricIndex > -1) {
            const activeLine = lyricsList.querySelector(`.lyric-line[data-index="${newLyricIndex}"]`);
            if (activeLine) {
                activeLine.classList.add('active');
                // 计算滚动偏移量，让高亮行垂直居中
                const offset = (container.offsetHeight / 2) - activeLine.offsetTop - (activeLine.offsetHeight / 2);
                lyricsList.style.transform = `translateY(${offset}px)`;
            }
        }
    }
}

// ▲▲▲ 新代码粘贴结束 ▲▲▲

/**
 * 清空播放列表 (情侣空间版)
 */
function clearLSMusicPlaylist() {
    const lsAudioPlayer = document.getElementById('ls-audio-player');
    lsAudioPlayer.pause();
    lsAudioPlayer.src = '';

    lsMusicState.playlist = [];
    lsMusicState.currentIndex = -1;
    lsMusicState.isPlaying = false;
    
    renderLSMusicPlayerUI();
    renderLSMusicPlaylist();
}

// ▲▲▲ 核心功能函数粘贴结束 ▲▲▲
// ▼▼▼ 把这一整块全新的代码，粘贴到 init() 函数的【正上方】 ▼▼▼

/* --- 【全新】情侣空间-情侣番茄钟功能核心函数 --- */

/**
 * 打开番茄钟主页并渲染历史记录
 */
async function openPomodoroScreen() {
    if (!activeLoversSpaceCharId) return;
    await renderPomodoroHistory(activeLoversSpaceCharId);
    
    // 确保显示的是主页，而不是计时器界面
    document.getElementById('ls-pomodoro-home').style.display = 'flex';
    document.getElementById('ls-pomodoro-timer-active').style.display = 'none';
}

/**
 * 渲染指定角色的番茄钟历史记录
 * @param {string} charId - 角色ID
 */
async function renderPomodoroHistory(charId) {
    const listEl = document.getElementById('ls-pomodoro-history-list');
    listEl.innerHTML = '';
    const sessions = await db.pomodoroSessions.where('chatId').equals(charId).reverse().sortBy('startTime');
    
    if (sessions.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); font-size: 14px;">还没有专注记录哦</p>';
        return;
    }

    sessions.forEach(session => {
        const item = document.createElement('div');
        item.className = 'pomodoro-history-item';
        item.dataset.sessionId = session.id;
        item.innerHTML = `
            <div class="task">${session.task}</div>
            <div class="meta">
                ${new Date(session.startTime).toLocaleString()} | 专注了 ${Math.round(session.duration / 60)} 分钟
            </div>
        `;
        item.addEventListener('click', () => showPomodoroHistoryDetail(session.id));
        listEl.appendChild(item);
    });
}

/**
 * 显示指定历史记录的聊天详情
 * @param {number} sessionId - 记录的ID
 */
async function showPomodoroHistoryDetail(sessionId) {
    const session = await db.pomodoroSessions.get(sessionId);
    if (!session) return;
    
    const modal = document.getElementById('ls-pomodoro-history-viewer-modal');
    const titleEl = document.getElementById('pomodoro-history-viewer-title');
    const contentEl = document.getElementById('pomodoro-history-viewer-content');
    
    titleEl.textContent = `“${session.task}”的专注记录`;
    contentEl.innerHTML = '';

    if (session.log && session.log.length > 0) {
        session.log.forEach(logEntry => {
            const bubble = document.createElement('div');
            bubble.className = 'pomodoro-log-bubble';
            bubble.textContent = logEntry.content;
            contentEl.appendChild(bubble);
        });
    } else {
        contentEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">这次专注期间没有聊天记录哦。</p>';
    }
    
    modal.classList.add('visible');
}

// ▼▼▼ 用这个新函数替换旧的 openPomodoroSetup ▼▼▼
function openPomodoroSetup() {
    document.getElementById('pomodoro-task-input').value = '';
    document.getElementById('pomodoro-duration-input').value = '25';
    document.getElementById('pomodoro-talk-interval-input').value = '5';
    document.getElementById('pomodoro-bg-url-input').value = '';
    
    // 核心新增：每次打开时，清空上一次本地上传的临时数据
    pomodoroState.tempBgDataUrl = null; 

    document.getElementById('ls-pomodoro-setup-modal').classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 用这个【支持正/倒计时】的新版本，替换旧的 startPomodoroSession 函数 ▼▼▼
async function startPomodoroSession() {
    const task = document.getElementById('pomodoro-task-input').value.trim();
    // 1. 获取用户选择的计时模式
    const timerType = document.querySelector('input[name="pomodoro-mode"]:checked').value;
    const durationMinutes = parseInt(document.getElementById('pomodoro-duration-input').value);
    const talkIntervalMinutes = parseInt(document.getElementById('pomodoro-talk-interval-input').value);
    const bgUrl = pomodoroState.tempBgDataUrl || document.getElementById('pomodoro-bg-url-input').value.trim();

    if (!task) {
        alert("请输入一个专注任务！");
        return;
    }
    // 2. 如果是倒计时模式，才需要检查时长是否有效
    if (timerType === 'countdown' && (isNaN(durationMinutes) || durationMinutes < 1)) {
        alert("倒计时模式下，请输入有效的专注时长！");
        return;
    }

    const chat = state.chats[activeLoversSpaceCharId];
    // 3. 根据模式，设置总时长（正计时模式总时长为0，因为它会一直增加）
    const durationSeconds = timerType === 'countdown' ? durationMinutes * 60 : 0; 
    
    pomodoroState.currentSession = {
        chatId: activeLoversSpaceCharId,
        task: task,
        duration: durationSeconds,
        timerType: timerType, // 4. 把计时模式也保存到会话记录里
        startTime: Date.now(),
        log: []
    };
    
    const timerView = document.getElementById('ls-pomodoro-timer-active');
    document.getElementById('ls-pomodoro-home').style.display = 'none';
    timerView.style.display = 'flex';
    
    if (bgUrl) {
        timerView.style.backgroundImage = `url(${bgUrl})`;
    } else {
        timerView.style.backgroundImage = `url(${chat.settings.aiAvatar})`;
    }
    
    document.getElementById('pomodoro-char-avatar').src = chat.settings.aiAvatar;
    document.getElementById('pomodoro-current-task').textContent = task;
    
    // 5. 根据模式，设置计时器的初始值
    let timeTracker = timerType === 'countdown' ? durationSeconds : 0;
    updatePomodoroTimerDisplay(timeTracker);

    pomodoroState.timerId = setInterval(() => {
        // 6. 【核心修改】根据模式决定是增加还是减少时间
        if (timerType === 'countdown') {
            timeTracker--;
            if (timeTracker <= 0) {
                updatePomodoroTimerDisplay(0); // 确保显示00:00
                endPomodoroSession(true); // 倒计时结束
            }
        } else { // 'countup'
            timeTracker++;
        }
        updatePomodoroTimerDisplay(timeTracker);
    }, 1000);
    if (talkIntervalMinutes > 0) {
        pomodoroState.periodicTalkTimerId = setInterval(() => {
            // 【核心修改】现在它会调用API来生成话语
            triggerPomodoroAIResponse("periodic_encouragement");
        }, talkIntervalMinutes * 60 * 1000);
    }
    pomodoroState.isActive = true;
    document.getElementById('ls-pomodoro-setup-modal').classList.remove('visible');
    
    const hiddenMessage = {
        role: 'system',
        content: `[系统指令：用户刚刚和你一起开始了一个番茄钟专注任务：“${task}”，时长为${durationMinutes}分钟。在专注期间，你可以通过 "pomodoro_talk" 指令来鼓励用户。]`,
        timestamp: Date.now(),
        isHidden: true
    };
    chat.history.push(hiddenMessage);
    await db.chats.put(chat);
}
// ▲▲▲ 替换结束 ▲▲▲



/**
 * 更新番茄钟的倒计时显示
 * @param {number} secondsLeft - 剩余秒数
 */
function updatePomodoroTimerDisplay(secondsLeft) {
    const minutes = Math.floor(secondsLeft / 60);
    const seconds = secondsLeft % 60;
    document.getElementById('pomodoro-time').textContent = 
        `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
}

// ▼▼▼ 用这个【已修复时长记录】的新版本，替换旧的 endPomodoroSession 函数 ▼▼▼
async function endPomodoroSession(isCompleted = false) {
    if (!pomodoroState.isActive) return;

    clearInterval(pomodoroState.timerId);
    clearInterval(pomodoroState.periodicTalkTimerId);

    // 【核心修改】在保存前，根据计时模式重新计算并更新最终的专注时长
    if (pomodoroState.currentSession.timerType === 'countup') {
        // 对于正计时，时长是结束时间减去开始时间
        pomodoroState.currentSession.duration = Math.floor((Date.now() - pomodoroState.currentSession.startTime) / 1000);
    }
    
    pomodoroState.currentSession.endTime = Date.now();
    await db.pomodoroSessions.add(pomodoroState.currentSession);
    
    document.getElementById('ls-pomodoro-timer-active').style.display = 'none';
    document.getElementById('ls-pomodoro-home').style.display = 'flex';
    await renderPomodoroHistory(activeLoversSpaceCharId);

    pomodoroState = { isActive: false, timerId: null, periodicTalkTimerId: null, currentSession: null };

    const chat = state.chats[activeLoversSpaceCharId];
    const endReason = isCompleted ? "时间到了，任务已完成" : "被用户手动中断";
    const hiddenMessage = {
        role: 'system',
        content: `[系统指令：番茄钟专注任务已结束。结束原因：${endReason}。]`,
        timestamp: Date.now(),
        isHidden: true
    };
    chat.history.push(hiddenMessage);
    await db.chats.put(chat);

    if (isCompleted) {
        showCustomAlert("专注完成！", "恭喜你完成了一次专注时光，休息一下吧！");
    } else {
        showCustomAlert("专注结束", "你中断了本次专注。");
    }
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 【功能增强版】触发番茄钟期间的AI互动 (已加入用户人设并增加回复长度)
 * @param {string} triggerType - 触发类型, 'user_click' 或 'periodic_encouragement'
 */
async function triggerPomodoroAIResponse(triggerType) {
    if (!pomodoroState.isActive || !activeLoversSpaceCharId) return;

    const chat = state.chats[activeLoversSpaceCharId];
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        console.warn("番茄钟AI互动失败：API未配置。");
        return;
    }

    // --- 【核心修改1：加入了用户人设】 ---
    const elapsedSeconds = Math.floor((Date.now() - pomodoroState.currentSession.startTime) / 1000);
    const elapsedMinutes = Math.floor(elapsedSeconds / 60);
    const timeContext = `用户已经持续专注了 ${elapsedMinutes} 分钟。`;
    const triggerReason = triggerType === 'user_click' ? '用户刚刚点击了你的头像，似乎需要一些鼓励。' : '到了你主动鼓励用户的时间。';

    const systemPrompt = `
# 任务
你正在和用户一起进行番茄钟专注。
- 你们正在进行的任务是: "${pomodoroState.currentSession.task}"
- ${timeContext}
- 触发本次对话的原因是: ${triggerReason}
- 你的角色人设: ${chat.settings.aiPersona}
- 你的聊天对象(用户)的人设: ${chat.settings.myPersona}

# 核心规则
1.  **保持专注**: 你的回复要更丰富、更有内容，大约50字左右，目的是帮助用户继续专注于任务，而不是闲聊。
2.  **格式铁律**: 你的回复【必须且只能】是一个严格的JSON对象，格式如下: \`{"type": "pomodoro_talk", "content": "你的鼓励语..."}\`

现在，请生成你的鼓励语。`;

    const userMessage = { 
        role: 'user', 
        content: `请根据你和我的角色人设，对我正在进行的“${pomodoroState.currentSession.task}”任务，说一段鼓励的话。` 
    };

    try {
        let isGemini = proxyUrl === GEMINI_API_URL;
        
        let requestBody;
        let requestUrl = `${proxyUrl}/v1/chat/completions`;
        let requestHeaders = {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${getRandomValue(apiKey)}`
        };

        if (isGemini) {
            requestUrl = `${GEMINI_API_URL}/${model}:generateContent?key=${getRandomValue(apiKey)}`;
            requestHeaders = {'Content-Type': 'application/json'};
            requestBody = {
                contents: [userMessage],
                generationConfig: {
                    temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                    "response_mime_type": "application/json", 
                },
                "systemInstruction": {
                    "parts": [{"text": systemPrompt}]
                }
            };
        } else {
            requestBody = {
                model: model,
                messages: [
                    { role: 'system', content: systemPrompt },
                    userMessage
                ],
                temperature: parseFloat(state.apiConfig.temperature) || 0.8,
                response_format: { type: "json_object" }
            };
        }

        const response = await fetch(requestUrl, {
            method: 'POST',
            headers: requestHeaders,
            body: JSON.stringify(requestBody)
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`API请求失败: ${response.status} - ${errorText}`);
        }

        const data = await response.json();
        const rawContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content)
            .replace(/^```json\s*|```$/g, '').trim();
        const responseObj = JSON.parse(rawContent);

        if (responseObj.type === 'pomodoro_talk' && responseObj.content) {
            const logEntry = { timestamp: Date.now(), content: responseObj.content };
            pomodoroState.currentSession.log.push(logEntry);
            
            const logEl = document.getElementById('pomodoro-char-log');
            logEl.textContent = responseObj.content;
            logEl.classList.add('visible');
            setTimeout(() => {
                logEl.classList.remove('visible');
            }, 4000);
        }
    } catch (error) {
        console.error("番茄钟AI互动失败:", error);
        const logEl = document.getElementById('pomodoro-char-log');
        logEl.textContent = `[错误: API调用失败，请检查F12控制台]`;
        logEl.classList.add('visible');
        setTimeout(() => {
            logEl.classList.remove('visible');
        }, 10000);
    }
}
// ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼
/**
 * 【全新】发送情侣空间邀请
 * @param {string} targetChatId - 被邀请的角色ID
 */
async function sendLoversSpaceInvitation(targetChatId) {
    const chat = state.chats[targetChatId];
    if (!chat) return;

    const myNickname = state.qzoneSettings.nickname || '我';
    
    // 1. 创建对用户可见的“邀请卡片”消息
    const visibleMessage = {
        role: 'user',
        senderName: myNickname,
        type: 'lovers_space_invitation',
        content: `${myNickname} 对 ${chat.name} 发送了一个情侣空间邀请`, // <-- 就是在这里新增了这一行！
        timestamp: Date.now(),
        status: 'pending' // 状态：pending, accepted, rejected
    };
    chat.history.push(visibleMessage);

    // 2. 创建对AI可见的“隐藏指令”消息
    const hiddenMessage = {
        role: 'system',
        content: `[系统指令：用户刚刚向你发起了“开启情侣空间”的邀请。请你根据人设，决定是否同意，并使用 'lovers_space_response' 指令回应。]`,
        timestamp: Date.now() + 1,
        isHidden: true
    };
    chat.history.push(hiddenMessage);
    
    // 3. 保存并触发AI响应
    await db.chats.put(chat);
    triggerAiResponse();
}
// ▲▲▲ 粘贴结束 ▲▲▲
// ▼▼▼ 在 init() 的【正上方】粘贴下面这一整块新代码 ▼▼▼

/**
 * 【全新】处理用户对情侣空间邀请的回应
 * @param {number} timestamp - 被回应的邀请消息的时间戳
 * @param {string} choice - 用户的选择, 'accepted' 或 'rejected'
 */
async function handleLoversSpaceResponse(timestamp, choice) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const invitationMsg = chat.history.find(m => m.timestamp === timestamp);
    if (!invitationMsg || invitationMsg.status !== 'pending') return;

    // 1. 更新原始邀请卡片的状态
    invitationMsg.status = choice;

    // 2. 根据用户的选择执行操作
    if (choice === 'accepted') {
        // 如果同意，就为这个角色创建情侣空间数据
        chat.loversSpaceData = {
            background: 'https://i.postimg.cc/k495F4W5/profile-banner.jpg',
            relationshipStartDate: null,
            moments: [],
            albums: [],
            loveLetters: [],
            shares: [],
            questions: [],
        };
        
        // 创建一条对用户可见的系统通知
        const systemNotice = {
            role: 'system',
            type: 'pat_message',
            content: `[系统：你和“${chat.name}”的情侣空间已成功开启！]`,
            timestamp: Date.now()
        };
        chat.history.push(systemNotice);
    }
    
    // 3. 创建一条对用户隐藏，但对AI可见的系统指令，告诉AI你的决定
    const hiddenMessage = {
        role: 'system',
        content: `[系统指令：用户${choice === 'accepted' ? '同意了' : '拒绝了'}你开启情侣空间的邀请。]`,
        timestamp: Date.now() + 1,
        isHidden: true
    };
    chat.history.push(hiddenMessage);

    // 4. 保存所有更改到数据库
    await db.chats.put(chat);
    
    // 5. 刷新聊天界面，并触发AI的回应
    renderChatInterface(state.activeChatId);
    triggerAiResponse();
}

/**
 * 【全新】应用主屏幕图标和小组件的文字颜色
 * @param {string} color - 颜色代码, e.g., '#FFFFFF'
 */
function applyHomeIconWidgetTextColor(color) {
    const phoneScreen = document.getElementById('phone-screen');
    if (phoneScreen && color) {
        // 使用新的CSS变量名
        phoneScreen.style.setProperty('--home-icon-widget-text-color', color);
    }
}
/**
 * 【新增辅助函数1】将时长字符串（如“2.5小时”, "30m"）解析为分钟数
 * @param {string} durationString - 时长描述文本
 * @returns {number} - 对应的分钟数
 */
function parseDurationToMinutes(durationString) {
    if (!durationString || typeof durationString !== 'string') return 0;
    
    const text = durationString.toLowerCase();
    const num = parseFloat(text.match(/(\d+(\.\d+)?)/)?.[0]) || 0;

    if (text.includes('小时') || text.includes('h')) {
        return num * 60;
    }
    if (text.includes('分钟') || text.includes('m')) {
        return num;
    }
    // 如果没有单位，但数值大于等于10，我们猜测是分钟
    if (num >= 10) {
        return num;
    }
    // 其他情况（如数值很小且无单位），猜测是小时
    return num * 60;
}

/**
 * 【新增辅助函数2】将总分钟数格式化为 "X小时Y分钟" 的字符串
 * @param {number} totalMinutes - 总分钟数
 * @returns {string} - 格式化后的时长字符串
 */
function formatMinutesToDuration(totalMinutes) {
    if (totalMinutes < 1) return '不到1分钟';
    
    const hours = Math.floor(totalMinutes / 60);
    const minutes = Math.round(totalMinutes % 60);

    if (hours > 0 && minutes > 0) {
        return `${hours}小时${minutes}分钟`;
    } else if (hours > 0) {
        return `${hours}小时`;
    } else {
        return `${minutes}分钟`;
    }
}
// ▼▼▼ 【全新】圈子/小组分类筛选功能核心函数 ▼▼▼

// ▼▼▼ 用这块【已修复】的代码，完整替换你旧的 openForumFilterModal 函数 ▼▼▼
/**
 * 【总入口】打开分类筛选模态框 (V3 - 已分离小组和帖子的分类)
 * @param {'global' | 'group'} type - 筛选类型：'global'为主页筛选小组，'group'为小组内筛选帖子
 * @param {number|null} id - 如果是小组内筛选，则为小组的ID
 */
async function openForumFilterModal(type, id = null) {
    currentFilterContext = { type, id };
    const modal = document.getElementById('forum-filter-modal');
    const listEl = document.getElementById('forum-filter-category-list');
    listEl.innerHTML = '';

    // --- ▼▼▼ 核心修正：根据上下文，从不同的地方收集分类 ▼▼▼ ---
    let availableCategories = new Set(); // 使用Set来自动去重

    try {
        if (type === 'global') {
            // 如果是在“圈子”主页，我们只关心【小组】的分类
            console.log("正在为小组列表收集分类...");
            const allGroups = await db.forumGroups.toArray();
            allGroups.forEach(group => {
                if (group.categories) {
                    group.categories.forEach(cat => availableCategories.add(cat));
                }
            });
        } else if (type === 'group' && id) {
            // 如果是在具体的“小组”页面，我们只关心该小组下【帖子】的分类
            console.log(`正在为小组 ID: ${id} 的帖子列表收集分类...`);
            const postsInGroup = await db.forumPosts.where('groupId').equals(id).toArray();
            postsInGroup.forEach(post => {
                if (post.categories) {
                    post.categories.forEach(cat => availableCategories.add(cat));
                }
            });
        }
    } catch (error) {
        console.error("收集分类标签时出错:", error);
    }
    // --- ▲▲▲ 修复结束 ▲▲▲ ---

    const categoryArray = Array.from(availableCategories).sort(); // 转换为数组并排序

    if (categoryArray.length === 0) {
        listEl.innerHTML = '<p style="color: var(--text-secondary); padding: 20px;">当前没有任何可用的分类标签。</p>';
    } else {
        const activeFilters = type === 'global' ? activeForumFilters.global : (activeForumFilters.group[id] || []);
        
        categoryArray.forEach((catName, index) => {
            const isChecked = activeFilters.includes(catName);
            const label = document.createElement('label');
            const inputId = `filter-cat-${type}-${index}`; // 创建唯一的ID
            label.setAttribute('for', inputId);
            label.innerHTML = `
                <input type="checkbox" id="${inputId}" value="${catName}" ${isChecked ? 'checked' : ''}>
                <span>${catName}</span>
            `;
            listEl.appendChild(label);
        });
    }
    
    modal.classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲


/**
 * 应用筛选条件并刷新列表
 */
async function applyForumFilter() {
    const { type, id } = currentFilterContext;
    const selectedCategories = Array.from(document.querySelectorAll('#forum-filter-category-list input:checked')).map(cb => cb.value);

    const filterBtnId = type === 'global' ? 'forum-filter-btn' : 'group-filter-btn';
    const filterBtn = document.getElementById(filterBtnId);

    if (type === 'global') {
        activeForumFilters.global = selectedCategories;
        await renderForumScreen();
    } else if (type === 'group' && id) {
        if (!activeForumFilters.group[id]) activeForumFilters.group[id] = [];
        activeForumFilters.group[id] = selectedCategories;
        await renderGroupPosts(id);
    }
    
    // 根据是否应用了筛选，更新图标状态
    if (selectedCategories.length > 0) {
        filterBtn.classList.add('active');
    } else {
        filterBtn.classList.remove('active');
    }

    document.getElementById('forum-filter-modal').classList.remove('visible');
}

// ▲▲▲ 新增函数结束 ▲▲▲




// ▼▼▼ 【全新】宠物功能核心函数 ▼▼▼

let currentPetData = null; // 用于暂存正在编辑的宠物数据
let isPetDragging = false; // 标记是否正在拖动宠物
let petDragOffset = { x: 0, y: 0 };

/**
 * 【领养系统改造版】打开宠物主面板（设置与互动）
 */
async function openPetModal() {
    if (!state.activeChatId || state.chats[state.activeChatId].isGroup) {
        alert("只有在单人聊天中才能养宠物哦！");
        return;
    }
    const chat = state.chats[state.activeChatId];

    // 核心判断：检查是否已领养
    if (!chat.settings.petAdopted) {
        // 如果未领养，弹出确认框
        const confirmed = await showCustomConfirm(
            '领养新宠物',
            `你还没有为“${chat.name}”领养宠物，要现在开启宠物系统吗？`,
            { confirmText: '现在领养' }
        );

        if (confirmed) {
            // 用户同意领养
            chat.settings.petAdopted = true;
            // 创建一个全新的默认宠物对象
            chat.settings.pet = {
                type: '无', name: '', image: '🥚', persona: '一只可爱的小宠物，对世界充满好奇。',
                petChatHistory: [], isCustomImage: false,
                display: { show: false, size: 100, top: '80%', left: '50%' },
                status: {
                    hunger: 100, happiness: 100, intimacyToUser: 50,
                    intimacyToChar: 50, lastUpdated: Date.now()
                }
            };
            await db.chats.put(chat);
            alert(`恭喜！你已成功为“${chat.name}”开启宠物系统！现在来为它设置一下吧。`);
            // 领养成功后，再次调用本函数，这次会直接进入设置界面
            openPetModal(); 
        }
        // 如果用户取消，则什么也不做
        return;
    }

    // --- 如果已经领养，则执行原来的显示逻辑 ---
    currentPetData = JSON.parse(JSON.stringify(chat.settings.pet)); 

    document.getElementById('pet-type-input').value = currentPetData.type === '无' ? '' : currentPetData.type;
    document.getElementById('pet-name-input').value = currentPetData.name;
    document.getElementById('pet-image-input').value = currentPetData.image;
    document.getElementById('pet-display-toggle').checked = currentPetData.display.show;
    document.getElementById('pet-size-slider').value = currentPetData.display.size;
    document.getElementById('pet-size-value').textContent = `${currentPetData.display.size}px`;
    document.getElementById('pet-persona-input').value = currentPetData.persona || '';
    
    updatePetPreview();

    if (currentPetData.type !== '无') {
        document.getElementById('pet-stats-area').style.display = 'flex';
        updatePetStatusUI(currentPetData);
    } else {
        document.getElementById('pet-stats-area').style.display = 'none';
    }

    const positionControls = document.getElementById('pet-position-controls');
    positionControls.style.display = currentPetData.display.show ? 'block' : 'none';
    
    document.getElementById('pet-modal').classList.add('visible');
}


/**
 * 计算并应用宠物的数值衰减
 * @param {object} pet - 宠物对象
 * @returns {boolean} - 如果数值发生了变化，返回 true
 */
function applyPetDecay(pet) {
    if (!pet || !pet.status) return false;

    const now = Date.now();
    const lastUpdated = pet.status.lastUpdated || now;
    const timeElapsed = now - lastUpdated;

    // 计算过去了多少个衰减周期
    const intervalsPassed = Math.floor(timeElapsed / PET_DECAY_INTERVAL);

    if (intervalsPassed > 0) {
        // 计算总共要衰减多少
        const totalHungerDecay = intervalsPassed * PET_DECAY_AMOUNT.hunger;
        const totalHappinessDecay = intervalsPassed * PET_DECAY_AMOUNT.happiness;

        // 应用衰减，确保不低于0
        pet.status.hunger = Math.max(0, pet.status.hunger - totalHungerDecay);
        pet.status.happiness = Math.max(0, pet.status.happiness - totalHappinessDecay);

        // 更新最后更新时间，只加上已经计算过的周期的时间，避免丢失零头时间
        pet.status.lastUpdated = lastUpdated + intervalsPassed * PET_DECAY_INTERVAL;
        
        console.log(`宠物"${pet.name}"数值衰减: ${intervalsPassed}个周期, 饱食度-${totalHungerDecay}, 心情-${totalHappinessDecay}`);
        return true; // 数值已改变
    }

    return false; // 数值未改变
}

/**
 * 停止当前的宠物衰减计时器
 */
function stopPetDecayTimer() {
    if (petDecayTimer) {
        clearInterval(petDecayTimer);
        petDecayTimer = null;
        // console.log("宠物衰减计时器已停止。");
    }
}

/**
 * 为当前聊天中的宠物启动衰减计时器
 */
function startPetDecayTimer() {
    stopPetDecayTimer(); // 先确保停止任何旧的计时器

    const chat = state.chats[state.activeChatId];
    if (!chat || !chat.settings.pet || chat.settings.pet.type === '无') {
        return; // 如果当前聊天没有宠物，则不启动
    }
    
    // console.log(`为宠物"${chat.settings.pet.name}"启动衰减计时器。`);
    
    // 使用 setInterval 定期检查并应用衰减
    petDecayTimer = setInterval(async () => {
        const currentChat = state.chats[state.activeChatId];
        if (!currentChat) { // 安全检查，如果聊天已关闭则停止计时器
            stopPetDecayTimer();
            return;
        }
        const pet = currentChat.settings.pet;
        
        if (applyPetDecay(pet)) {
            // 如果数值变化了，更新UI并保存到数据库
            // 只有当宠物面板打开时才需要更新UI
            if (document.getElementById('pet-modal').classList.contains('visible')) {
                 updatePetStatusUI(pet);
            }
            await db.chats.put(currentChat);
        }
    }, 60 * 1000); // 每分钟检查一次，是否到达了衰减周期
}

// ▲▲▲ 新代码粘贴结束 ▲▲▲


// ▼▼▼ 用这块【已更新】的代码，替换旧的 updatePetStatusUI 函数 ▼▼▼
/**
 * 【全新】更新宠物数值面板的UI显示
 * @param {object} petData - 宠物的数据对象
 */
function updatePetStatusUI(petData) {
    const hunger = petData.status.hunger || 0;
    const happiness = petData.status.happiness || 0;
    // ★★★ 新增：获取亲密度数值 ★★★
    const intimacyToUser = petData.status.intimacyToUser || 0;
    const intimacyToChar = petData.status.intimacyToChar || 0;

    const hungerFill = document.querySelector('#pet-hunger-bar .stat-bar-fill');
    const happinessFill = document.querySelector('#pet-happiness-bar .stat-bar-fill');
    // ★★★ 新增：获取亲密度进度条元素 ★★★
    const intimacyUserFill = document.querySelector('#pet-intimacy-user-bar .stat-bar-fill');
    const intimacyCharFill = document.querySelector('#pet-intimacy-char-bar .stat-bar-fill');

    if (hungerFill) {
        hungerFill.style.width = `${hunger}%`;
        hungerFill.textContent = `${hunger}%`;
    }
    if (happinessFill) {
        happinessFill.style.width = `${happiness}%`;
        happinessFill.textContent = `${happiness}%`;
    }
    // ★★★ 新增：渲染亲密度进度条 ★★★
    if (intimacyUserFill) {
        intimacyUserFill.style.width = `${intimacyToUser}%`;
        intimacyUserFill.textContent = `${intimacyToUser}%`;
    }
    if (intimacyCharFill) {
        intimacyCharFill.style.width = `${intimacyToChar}%`;
        intimacyCharFill.textContent = `${intimacyToChar}%`;
    }
}
// ▲▲▲ 替换结束 ▲▲▲



/**
 * 在弹窗中更新宠物的预览
 */
function updatePetPreview() {
    const previewDisplay = document.getElementById('pet-preview-display');
    const nameEl = document.getElementById('pet-preview-name');
    const typeEl = document.getElementById('pet-preview-type');
    
    const imageInput = document.getElementById('pet-image-input').value.trim();

    if (imageInput.startsWith('http') || imageInput.startsWith('data:image')) {
        previewDisplay.innerHTML = `<img src="${imageInput}" style="width: 60px; height: 60px; object-fit: contain;">`;
    } else {
        previewDisplay.textContent = imageInput || '🥚';
    }
    
    nameEl.textContent = document.getElementById('pet-name-input').value.trim() || '(未命名)';
    typeEl.textContent = document.getElementById('pet-type-input').value.trim() || '物种';
}


/**
 * 保存宠物设置
 */
async function savePetSettings() {
    const chat = state.chats[state.activeChatId];
    
    // 从UI读取数据
    const type = document.getElementById('pet-type-input').value.trim() || '无';
    const name = document.getElementById('pet-name-input').value.trim();
    const image = document.getElementById('pet-image-input').value.trim() || '🥚';
    
    const newPetSettings = {
        ...currentPetData, // 保留如位置等未在主面板修改的属性
        type: type,
        name: name,
        image: image,
        persona: document.getElementById('pet-persona-input').value.trim(),
        isCustomImage: image.startsWith('http') || image.startsWith('data:image'),
        display: {
            ...currentPetData.display,
            show: document.getElementById('pet-display-toggle').checked,
            size: parseInt(document.getElementById('pet-size-slider').value)
        }
    };

    // 更新到 state 和数据库
    chat.settings.pet = newPetSettings;
    await db.chats.put(chat);
    
    // 刷新聊天界面上的宠物
    renderChatPet();
    
    document.getElementById('pet-modal').classList.remove('visible');
    currentPetData = null; // 清理临时数据
    alert('宠物信息已保存！');
}

/**
 * 在聊天界面上渲染宠物
 */
function renderChatPet() {
    const chat = state.chats[state.activeChatId];
    const petContainer = document.getElementById('chat-pet-container');
    const petEl = document.getElementById('chat-pet');

    if (!chat || chat.isGroup || !chat.settings.petAdopted || !chat.settings.pet || !chat.settings.pet.display.show) {
        petEl.style.display = 'none';
        return;
    }

    const pet = chat.settings.pet;
    petEl.style.display = 'block';
    
    if (pet.isCustomImage) {
        petEl.innerHTML = `<img src="${pet.image}" alt="${pet.name}">`;
    } else {
        petEl.innerHTML = pet.image;
    }
    
    // 应用样式
    petEl.style.fontSize = `${pet.display.size}px`;
    petEl.style.width = `${pet.display.size}px`;
    petEl.style.height = `${pet.display.size}px`;
    petEl.style.top = pet.display.top;
    petEl.style.left = pet.display.left;
}

// ▼▼▼ 用这块【新代码】替换旧的 handlePetInteraction 函数 ▼▼▼
/**
 * 处理用户与宠物的互动 (V2 - 增强互动记录)
 * @param {string} action - 互动类型, e.g., 'feed', 'play'
 */
async function handlePetInteraction(action) {
    const chat = state.chats[state.activeChatId];
    if (!chat || !chat.settings.petAdopted || !chat.settings.pet || chat.settings.pet.type === '无') {
        alert("你还没有宠物，或者还没有给它设定种类哦！");
        return;
    }

    const pet = chat.settings.pet;
    let actionText = '';
    const myNickname = chat.settings.myNickname || '我';

    switch(action) {
        case 'feed':
            pet.status.hunger = Math.min(100, pet.status.hunger + 20);
            pet.status.happiness = Math.min(100, pet.status.happiness + 5);
            pet.status.intimacyToUser = Math.min(100, pet.status.intimacyToUser + 10);
            actionText = `${myNickname} 喂了 ${pet.name} 一些食物。`;
            break;
        case 'play':
            pet.status.hunger = Math.max(0, pet.status.hunger - 10);
            pet.status.happiness = Math.min(100, pet.status.happiness + 15);
            pet.status.intimacyToUser = Math.min(100, pet.status.intimacyToUser + 15);
            actionText = `${myNickname} 陪 ${pet.name} 玩了一会儿。`;
            break;
        case 'touch':
            pet.status.happiness = Math.min(100, pet.status.happiness + 10);
            pet.status.intimacyToUser = Math.min(100, pet.status.intimacyToUser + 5);
            actionText = `${myNickname} 轻轻地抚摸了 ${pet.name}。`;
            break;
        case 'chat':
            openPetChat();
            return; 
    }
    
    updatePetStatusUI(pet);
    chat.settings.pet = pet; 

    // ★★★ 核心修改1：创建对用户【可见】的系统消息 ★★★
    const visibleMessage = {
        role: 'system',
        type: 'pat_message',
        content: `[系统：${actionText}]`,
        timestamp: Date.now()
    };
    chat.history.push(visibleMessage);
    
    // ★★★ 核心修改2：创建给AI看的【隐藏】指令 ★★★
    const hiddenMessageForAI = {
        role: 'system',
        content: `[系统提示：用户刚刚和宠物“${pet.name}”进行了互动：${actionText}。]`,
        timestamp: Date.now() + 1, // 确保时间戳在后
        isHidden: true
    };
    chat.history.push(hiddenMessageForAI);

    await db.chats.put(chat);
    
    if (document.getElementById('chat-interface-screen').classList.contains('active')) {
        appendMessage(visibleMessage, chat);
    }
    
    document.getElementById('pet-modal').classList.remove('visible');
}
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 【全新】宠物对话功能核心函数 ▼▼▼

/**
 * 打开宠物聊天模态框
 */
function openPetChat() {
    const chat = state.chats[state.activeChatId];
    if (!chat || !chat.settings.pet || chat.settings.pet.type === '无') {
        alert("先给你的宠物起个名字和种类吧！");
        return;
    }
    
    // 关闭主设置面板，打开聊天面板
    document.getElementById('pet-modal').classList.remove('visible');
    const chatModal = document.getElementById('pet-chat-modal');
    document.getElementById('pet-chat-title').textContent = `和“${chat.settings.pet.name}”的对话`;
    document.getElementById('pet-chat-input').value = '';
    
    renderPetChatHistory(); // 渲染历史记录
    chatModal.classList.add('visible');
}

/**
 * 渲染宠物的聊天记录
 */
function renderPetChatHistory() {
    const chat = state.chats[state.activeChatId];
    const pet = chat.settings.pet;
    const messagesEl = document.getElementById('pet-chat-messages');
    messagesEl.innerHTML = '';

    if (!pet.petChatHistory || pet.petChatHistory.length === 0) {
        messagesEl.innerHTML = `<p style="text-align:center; color: var(--text-secondary);">试着和它打个招呼吧！</p>`;
        return;
    }
    
    // 获取用户头像
    const myAvatar = chat.settings.myAvatar || defaultAvatar;

    pet.petChatHistory.forEach(msg => {
        const wrapper = document.createElement('div');
        // 【核心】这里的 msg.sender 会是 'user', 'pet', 或 'char'
        wrapper.className = `message-wrapper ${msg.sender}`; 
        
        const bubble = document.createElement('div');
        bubble.className = 'message-bubble';
        
        let avatarSrc = '';
        let avatarHtml = '';

        // ▼▼▼ 问题就在下面这段逻辑，我们来修复它 ▼▼▼
        if (msg.sender === 'user') {
            // 如果是用户发的，使用用户头像
            avatarSrc = myAvatar;
            avatarHtml = `<img src="${avatarSrc}" class="avatar">`;
        } else if (msg.sender === 'char') {
            // 【【【这就是新增的修复逻辑！】】】
            // 如果是角色(char)发的，就使用角色的头像
            avatarSrc = chat.settings.aiAvatar || defaultAvatar;
            avatarHtml = `<img src="${avatarSrc}" class="avatar">`;
        } else { // 剩下的情况就是宠物(pet)自己发的
            avatarSrc = pet.isCustomImage ? pet.image : null;
            if (avatarSrc) {
                // 如果是图片，显示图片
                avatarHtml = `<img src="${avatarSrc}" class="avatar">`;
            } else {
                // 如果是Emoji，直接显示Emoji
                avatarHtml = `<div class="avatar" style="font-size: 28px; text-align: center;">${pet.image}</div>`;
            }
        }
        // ▲▲▲ 修复结束 ▲▲▲
        
        bubble.innerHTML = `
            ${avatarHtml}
            <div class="content">${msg.content.replace(/\n/g, '<br>')}</div>
        `;
        wrapper.appendChild(bubble);
        messagesEl.appendChild(wrapper);
    });

    messagesEl.scrollTop = messagesEl.scrollHeight;
}

// ▼▼▼ 用这块【新代码】替换旧的 handleSendToPet 函数 ▼▼▼
/**
 * 处理用户在宠物聊天框中发送消息
 */
async function handleSendToPet() {
    const chat = state.chats[state.activeChatId];
    const pet = chat.settings.pet;
    const input = document.getElementById('pet-chat-input');
    const userInput = input.value.trim();
    if (!userInput) return;

    input.value = '';
    input.style.height = 'auto';

    pet.petChatHistory.push({ sender: 'user', content: userInput });
    renderPetChatHistory();

    const petResponse = await getPetApiResponse(pet);
    if (petResponse) {
        pet.petChatHistory.push({ sender: 'pet', content: petResponse });
        renderPetChatHistory();
    }
    
    // ★★★ 核心修改：创建对用户【可见】的系统消息，记录这次对话 ★★★
    const visibleLog = `[系统：你和宠物“${pet.name}”进行了对话。你说：“${userInput}”，它回应：“${petResponse}”。]`;
    const visibleMessage = {
        role: 'system',
        type: 'pat_message', // 使用这个类型来显示居中灰色气泡
        content: visibleLog,
        timestamp: Date.now()
    };
    chat.history.push(visibleMessage);

    // 只有当用户正在查看当前聊天时，才实时追加到界面上
    if (document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chat.id) {
        appendMessage(visibleMessage, chat);
    }
    
    // 创建给AI看的【隐藏】指令，这部分保持不变
    const hiddenMessageForAI = `[系统提示：用户刚刚和宠物“${pet.name}”进行了一次对话。用户说：“${userInput}”，宠物回应：“${petResponse}”。]`;
    const hiddenMessage = {
        role: 'system',
        content: hiddenMessageForAI,
        timestamp: Date.now() + 1,
        isHidden: true
    };
    chat.history.push(hiddenMessage);

    await db.chats.put(chat);
}
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 用这块【已修复】的代码替换旧的 getPetApiResponse 函数 ▼▼▼
/**
 * 【AI核心】为宠物获取API回复
 * @param {object} pet - 宠物对象
 * @returns {Promise<string|null>} - AI生成的宠物回复文本
 */
async function getPetApiResponse(pet) {
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert("请先配置API！");
        return "（我好像断线了...）";
    }

    // ★★★ 核心修复2：重构对话历史的生成逻辑 ★★★
    const historyForPet = pet.petChatHistory.slice(-6).map(msg => {
        let senderName;
        if (msg.sender === 'user') {
            senderName = '主人';
        } else if (msg.sender === 'char') {
            senderName = msg.senderName; // 正确获取Char的名字
        } else { // 'pet'
            senderName = pet.name;
        }
        return `${senderName}: ${msg.content}`;
    }).join('\n');

    const systemPrompt = `你现在正在扮演一只宠物。
# 你的核心设定
- 你的种类: ${pet.type}
- 你的名字: ${pet.name}
- 你的性格和背景故事: ${pet.persona}

# 核心规则
1. 你【必须】完全代入你的角色设定进行回复。
2. 你的回复应该是简短、可爱的，符合一只宠物的说话方式（例如，使用拟声词、简单的词汇）。
3. 你的回复【只能是纯文本】，不要包含任何JSON或特殊格式。

# 最近的对话
${historyForPet}

现在，请根据上面的对话，继续你的回应。`;

    try {
        const messagesForApi = [{ role: 'user', content: "请根据你在系统指令中读到的规则，立即开始你的行动。" }];
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini, state.apiConfig.temperature);

        
        const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
            body: JSON.stringify({
                model: model,
                messages: [{ role: 'system', content: systemPrompt }, ...messagesForApi],
                temperature: parseFloat(state.apiConfig.temperature) || 0.8,
            })
        });

        if (!response.ok) throw new Error(await response.text());
        const data = await response.json();
        return (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content).trim();
    } catch (error) {
        console.error("获取宠物回复失败:", error);
        return "（呜...我好像说不出话了...）";
    }
}
// ▲▲▲ 替换结束 ▲▲▲


/**
 * 初始化宠物的拖拽功能
 */
function initPetDragging() {
    const petEl = document.getElementById('chat-pet');
    const container = document.getElementById('chat-pet-container');

    const onDragStart = (e) => {
        if (!petEl.style.display || petEl.style.display === 'none') return;
        e.preventDefault();
        isPetDragging = true;
        
        const rect = petEl.getBoundingClientRect();
        const coords = getEventCoords(e);

        petDragOffset.x = coords.x - rect.left;
        petDragOffset.y = coords.y - rect.top;

        document.addEventListener('mousemove', onDragMove);
        document.addEventListener('mouseup', onDragEnd);
        document.addEventListener('touchmove', onDragMove, { passive: false });
        document.addEventListener('touchend', onDragEnd);
    };

    const onDragMove = (e) => {
        if (!isPetDragging) return;
        e.preventDefault();
        
        const containerRect = container.getBoundingClientRect();
        const coords = getEventCoords(e);

        let newLeft = coords.x - petDragOffset.x - containerRect.left;
        let newTop = coords.y - petDragOffset.y - containerRect.top;

        // 边界检测
        newLeft = Math.max(0, Math.min(newLeft, container.clientWidth - petEl.offsetWidth));
        newTop = Math.max(0, Math.min(newTop, container.clientHeight - petEl.offsetHeight));
        
        // 用百分比存储，以适应不同屏幕尺寸
        petEl.style.left = `${(newLeft / container.clientWidth) * 100}%`;
        petEl.style.top = `${(newTop / container.clientHeight) * 100}%`;
    };

    const onDragEnd = async () => {
        if (!isPetDragging) return;
        isPetDragging = false;
        
        // 拖动结束后，保存新的位置
        const chat = state.chats[state.activeChatId];
        if (chat && chat.settings.pet) {
            chat.settings.pet.display.top = petEl.style.top;
            chat.settings.pet.display.left = petEl.style.left;
            await db.chats.put(chat);
        }

        document.removeEventListener('mousemove', onDragMove);
        document.removeEventListener('mouseup', onDragEnd);
        document.removeEventListener('touchmove', onDragMove);
        document.removeEventListener('touchend', onDragEnd);
    };

    petEl.addEventListener('mousedown', onDragStart);
    petEl.addEventListener('touchstart', onDragStart, { passive: true });
}

// ▲▲▲ 宠物功能核心函数结束 ▲▲▲
/**
 * 【全新】显示微博内容生成的目标角色选择器
 * @returns {Promise<object|string|null>} - 返回选中的角色对象, 'all', 或 null (如果用户取消)
 */
async function showCharacterSelectorForWeibo() {
    // 1. 找出所有单聊角色
    const singleChats = Object.values(state.chats).filter(chat => !chat.isGroup);

    if (singleChats.length === 0) {
        alert("还没有任何角色可以生成内容哦。");
        return null;
    }

    // 2. 准备弹窗的选项
    const options = [
        // 添加一个“随机”选项，保留原来的功能
        { text: '✨ 随机 (所有角色)', value: 'all' }, 
        // 遍历所有角色，为每个角色创建一个选项
        ...singleChats.map(chat => ({
            text: `👤 ${chat.name}`, // 选项显示的名字
            value: chat.id         // 选项的值是角色的唯一ID
        }))
    ];

    // 3. 调用你现有的操作菜单弹窗，并等待用户选择
    const selectedId = await showChoiceModal("请选择本次生成的主角", options);

    // 4. 根据用户的选择，返回不同的结果
    if (selectedId === null) {
        return null; // 用户点击了“取消”
    }
    if (selectedId === 'all') {
        return 'all'; // 用户选择了“随机”
    }

    // 如果用户选择了某个角色，就返回那个角色的完整数据对象
    return state.chats[selectedId];
}
/**
 * 【全新 | V2多选版】显示微博内容生成的目标角色选择器
 * @returns {Promise<Array|string|null>} - 返回选中的角色ID数组, 'all', 或 null
 */
async function showMultiCharacterSelectorForWeibo() {
    return new Promise(resolve => {
        const modal = document.getElementById('weibo-char-selector-modal');
        const listEl = document.getElementById('weibo-char-selector-list');
        const confirmBtn = document.getElementById('weibo-confirm-char-select-btn');
        const cancelBtn = document.getElementById('weibo-cancel-char-select-btn');
        const selectAllBtn = document.getElementById('weibo-select-all-btn');
        const deselectAllBtn = document.getElementById('weibo-deselect-all-btn');

        listEl.innerHTML = '';
        const singleChats = Object.values(state.chats).filter(chat => !chat.isGroup);

        if (singleChats.length === 0) {
            alert("还没有任何角色可以生成内容哦。");
            resolve(null);
            return;
        }

        // 添加一个“随机”选项
        const randomOption = document.createElement('div');
        randomOption.className = 'player-selection-item';
        randomOption.innerHTML = `
            <input type="radio" name="weibo-char-choice" value="all" id="weibo-char-random" checked style="margin-right: 15px;">
            <label for="weibo-char-random" style="display:flex; align-items:center; width:100%; cursor:pointer;">
                <span class="name">✨ 随机选择 (所有角色)</span>
            </label>
        `;
        listEl.appendChild(randomOption);
        
        // 添加一个“指定”选项的标题
        const specificOptionHeader = document.createElement('div');
        specificOptionHeader.className = 'player-selection-item';
        specificOptionHeader.innerHTML = `
            <input type="radio" name="weibo-char-choice" value="specific" id="weibo-char-specific" style="margin-right: 15px;">
            <label for="weibo-char-specific" style="display:flex; align-items:center; width:100%; cursor:pointer;">
                <span class="name">👤 指定以下角色</span>
            </label>
        `;
        listEl.appendChild(specificOptionHeader);

        // 渲染所有可选的角色
        singleChats.forEach(chat => {
            const item = document.createElement('div');
            item.className = 'player-selection-item';
            item.style.paddingLeft = '50px'; // 向内缩进，表示是“指定”的子选项
            item.innerHTML = `
                <input type="checkbox" class="weibo-char-checkbox" value="${chat.id}" id="weibo-char-${chat.id}">
                <label for="weibo-char-${chat.id}" style="display:flex; align-items:center; width:100%; cursor:pointer;">
                    <img src="${chat.settings.aiAvatar || defaultAvatar}" alt="${chat.name}">
                    <span class="name">${chat.name}</span>
                </label>
            `;
            listEl.appendChild(item);
        });

        const cleanup = () => {
            modal.classList.remove('visible');
            // 清除事件监听器，防止内存泄漏
            newConfirmBtn.removeEventListener('click', onConfirm);
            cancelBtn.removeEventListener('click', onCancel);
            selectAllBtn.removeEventListener('click', onSelectAll);
            deselectAllBtn.removeEventListener('click', onDeselectAll);
        };
        
        const onConfirm = () => {
            const choice = document.querySelector('input[name="weibo-char-choice"]:checked').value;
            if (choice === 'all') {
                cleanup();
                resolve('all');
            } else {
                const selectedIds = Array.from(document.querySelectorAll('.weibo-char-checkbox:checked')).map(cb => cb.value);
                if (selectedIds.length === 0) {
                    alert("请至少选择一个指定的角色！");
                    return;
                }
                cleanup();
                resolve(selectedIds);
            }
        };

        const onCancel = () => { cleanup(); resolve(null); };
        const onSelectAll = () => document.querySelectorAll('.weibo-char-checkbox').forEach(cb => cb.checked = true);
        const onDeselectAll = () => document.querySelectorAll('.weibo-char-checkbox').forEach(cb => cb.checked = false);

        // 使用克隆节点技巧来确保事件只被绑定一次
        const newConfirmBtn = confirmBtn.cloneNode(true);
        confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);

        newConfirmBtn.addEventListener('click', onConfirm);
        cancelBtn.addEventListener('click', onCancel);
        selectAllBtn.addEventListener('click', onSelectAll);
        deselectAllBtn.addEventListener('click', onDeselectAll);

        modal.classList.add('visible');
    });
}
// ▼▼▼ 把这一整块全新的功能函数，粘贴到 <script> 内的功能函数定义区 ▼▼▼

/**
 * 【线下模式】渲染预设下拉框
 */
function renderOfflinePresetsSelector() {
    const chat = state.chats[state.activeChatId];
    if (!chat || !chat.settings.offlineMode) return;

    const select = document.getElementById('offline-preset-select');
    const presets = chat.settings.offlineMode.presets || [];
    select.innerHTML = '<option value="">-- 使用自定义输入 --</option>'; // 默认选项
    presets.forEach((preset, index) => {
        const option = document.createElement('option');
        option.value = index; // 使用数组索引作为值
        option.textContent = preset.name;
        select.appendChild(option);
    });
}

/**
 * 【线下模式】当用户选择一个预设时，自动填充输入框
 */
function handleOfflinePresetSelection() {
    const chat = state.chats[state.activeChatId];
    if (!chat || !chat.settings.offlineMode) return;
    
    const select = document.getElementById('offline-preset-select');
    const selectedIndex = select.value;

    if (selectedIndex !== "") {
        const preset = chat.settings.offlineMode.presets[parseInt(selectedIndex)];
        if (preset) {
            document.getElementById('offline-prompt-input').value = preset.prompt;
            document.getElementById('offline-style-input').value = preset.style;
        }
    }
}

/**
 * 【线下模式】打开预设管理的操作菜单
 */
async function openOfflinePresetManager() {
    const select = document.getElementById('offline-preset-select');
    const selectedIndex = select.value;

    // 弹出一个包含多个选项的菜单
    const choice = await showChoiceModal("管理线下模式预设", [
        { text: '💾 保存当前为新预设', value: 'save_new' },
        { text: '✏️ 更新选中预设', value: 'update_selected', disabled: selectedIndex === "" },
        { text: '🗑️ 删除选中预设', value: 'delete_selected', disabled: selectedIndex === "" }
    ]);
    
    // 根据用户的选择执行操作
    switch (choice) {
        case 'save_new':
            await saveCurrentAsOfflinePreset();
            break;
        case 'update_selected':
            if (selectedIndex !== "") await updateSelectedOfflinePreset(parseInt(selectedIndex));
            break;
        case 'delete_selected':
            if (selectedIndex !== "") await deleteSelectedOfflinePreset(parseInt(selectedIndex));
            break;
    }
}

/**
 * 【线下模式】将当前输入框的内容保存为一个新预设
 */
async function saveCurrentAsOfflinePreset() {
    const chat = state.chats[state.activeChatId];
    const name = await showCustomPrompt("保存新预设", "请输入预设名称：");
    
    if (name && name.trim()) {
        const newPreset = {
            name: name.trim(),
            prompt: document.getElementById('offline-prompt-input').value.trim(),
            style: document.getElementById('offline-style-input').value.trim()
        };
        chat.settings.offlineMode.presets.push(newPreset);
        await db.chats.put(chat); // 保存回数据库
        renderOfflinePresetsSelector(); // 刷新下拉框
        alert(`预设 "${name.trim()}" 已保存！`);
    }
}

/**
 * 【线下模式】用当前输入框的内容更新选中的预设
 */
async function updateSelectedOfflinePreset(index) {
    const chat = state.chats[state.activeChatId];
    const preset = chat.settings.offlineMode.presets[index];
    if (!preset) return;

    const confirmed = await showCustomConfirm("确认更新", `确定要用当前内容覆盖预设 "${preset.name}" 吗？`);
    if (confirmed) {
        preset.prompt = document.getElementById('offline-prompt-input').value.trim();
        preset.style = document.getElementById('offline-style-input').value.trim();
        await db.chats.put(chat);
        alert("预设已更新！");
    }
}

/**
 * 【线下模式】删除选中的预设
 */
async function deleteSelectedOfflinePreset(index) {
    const chat = state.chats[state.activeChatId];
    const preset = chat.settings.offlineMode.presets[index];
    if (!preset) return;

    const confirmed = await showCustomConfirm("确认删除", `确定要删除预设 "${preset.name}" 吗？`, { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        chat.settings.offlineMode.presets.splice(index, 1);
        await db.chats.put(chat);
        renderOfflinePresetsSelector(); // 刷新下拉框
        // 删除后清空输入框
        document.getElementById('offline-prompt-input').value = '';
        document.getElementById('offline-style-input').value = '';
        alert("预设已删除。");
    }
}

// ▲▲▲ 新功能函数粘贴结束 ▲▲▲
// ▼▼▼ 【全新】微博私信功能核心函数 ▼▼▼

// ▼▼▼ 【全新】微博私信功能核心函数 ▼▼▼

/**
 * 【总入口】当用户点击关注列表时，打开私信界面
 * @param {object} targetInfo - 包含被点击角色/NPC信息的对象
 */
async function openWeiboDms(targetInfo) {
    currentViewingDmsFor = targetInfo;
    const charId = targetInfo.isNpc ? targetInfo.ownerId : targetInfo.id;
    const chat = state.chats[charId];
    if (!chat) return;

    // 检查并生成粉丝私信数据
    const dmsData = await generateAndCacheFanDms(chat);
    
    // 渲染私信列表
    renderDmList(dmsData, targetInfo.name);

    // 显示私信列表屏幕
    showScreen('weibo-dm-list-screen');
}

/**
 * 【AI核心】检查或生成角色的粉丝私信数据
 * @param {object} characterChat - 角色/NPC的 "主人" 的聊天对象
 * @returns {Promise<Array>} - 粉丝私信对话数组
 */
async function generateAndCacheFanDms(characterChat, addMore = false) {
    // 如果不是“继续生成”，且缓存已存在，则直接返回
    if (!addMore && characterChat.weiboDms && characterChat.weiboDms.length > 0) {
        console.log(`从缓存加载 "${characterChat.name}" 的粉丝私信。`);
        return characterChat.weiboDms;
    }

    const alertMessage = addMore ? "正在生成更多私信内容..." : `正在为“${characterChat.name}”生成粉丝私信内容...`;
    await showCustomAlert("请稍候...", alertMessage);
    
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('请先配置API！');
        return [];
    }

    const truncatedMainPersona = (characterChat.settings.aiPersona || '一个普通的角色').substring(0, 500);
    const truncatedWeiboInstruction = (characterChat.settings.weiboInstruction || '无特殊指令').substring(0, 400);
    
    // 如果是继续生成，把现有对话作为上下文
    const existingDmsContext = addMore ? `
# 已有私信记录 (供你参考，你可以选择延续对话或开启新对话):
${JSON.stringify(characterChat.weiboDms, null, 2)}
` : '';

        // 【优化后】的AI指令
        const systemPrompt = `
# 任务
你现在是角色“${characterChat.name}”的社交媒体运营助理。
你的任务是根据该角色的【所有信息】，虚构一个包含${addMore ? '2-3' : '3-5'}位不同粉丝的私信列表，并为每位粉丝创作一段生动、真实的对话历史。
${existingDmsContext}

# 角色信息 (你必须综合参考以下所有信息)
- 角色名: ${characterChat.name}
- 公开职业: ${characterChat.settings.weiboProfession || '未设定'}
- 核心人设 (最高优先级): ${truncatedMainPersona}
- 微博互动准则 (处理私信时需遵守): ${truncatedWeiboInstruction}

# 核心规则
1.  **粉丝多样性**: 创作${addMore ? '2-3' : '3-5'}位不同类型的粉丝（例如：狂热粉、事业粉、CP粉、黑粉、路人粉、广告商等）。
2.  **【【【对话鲜活度铁律】】】**: 为了让对话更真实，你必须：
    -   **避免机械问答**：不要生成“你好”-“你好”之类的无意义对话。让对话像一个正在进行的真实互动片段。
    -   **注入情绪和语气**：粉丝的语气可以是兴奋的、担忧的、质疑的、开玩笑的。角色的回应也要符合人设，可能是冷淡的、温柔的、官方的，或者干脆已读不回。
    -   **使用网络语言**: 适当加入符合粉丝圈文化的网络用语、emoji或颜文字，让对话更接地气。
    -   **内容多样化**: 私信内容不应只局限于工作，也可以是粉丝分享自己的日常、表达关心、提出一些私人问题等。
3.  **角色回应**: 根据角色的【微博互动准则】和【核心人设】，决定角色是否会回复私信以及如何回复。例如，一个高冷的角色可能只会回复重要信息，或者干脆不回复。
4.  **格式铁律**: 你的回复【必须且只能】是一个严格的JSON数组，直接以 '[' 开头，以 ']' 结尾。

# JSON对象结构 (注意：你不再需要提供头像URL)
{
  "fanName": "粉丝的微博昵称",
  "fanPersona": "对这位粉丝的简单描述 (例如: '一个担心哥哥事业的妈妈粉')",
  "messages": [
    { "sender": "fan", "text": "粉丝发的第一条消息..." },
    { "sender": "char", "text": "角色回复的消息..." }
  ]
}

现在，请开始生成私信列表。`;


    try {
        const messagesForApi = [{ role: 'user', content: systemPrompt }];
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini, state.apiConfig.temperature);

        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({ model: model, messages: messagesForApi, temperature: parseFloat(state.apiConfig.temperature) || 0.8, response_format: { type: "json_object" } })
            });
        
        if (!response.ok) {
            throw new Error(`API请求失败: ${response.status} - ${await response.text()}`);
        }
        
        const data = await response.json();
        const rawContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content);
        const cleanedContent = rawContent.replace(/^```json\s*|```$/g, '').trim();
        const newDmsData = JSON.parse(cleanedContent);
        // 【已修复】在这里为AI生成的数据手动添加随机头像
        if (Array.isArray(newDmsData)) {
            // 这是你提供的两个头像URL
            const fanAvatars = [
                'https://i.postimg.cc/PxZrFFFL/o-o-1.jpg',
                'https://i.postimg.cc/Qd0Y537F/com-xingin-xhs-20251011153800.png'
            ];

            // 遍历AI生成的每一段对话，这次我们加入了 index 参数
            newDmsData.forEach((convo, index) => {
                // 【核心修改】使用索引和取余运算符(%)来交替分配头像
                convo.fanAvatarUrl = fanAvatars[index % fanAvatars.length];
            });
        }


        if (Array.isArray(newDmsData)) {
            if (addMore) {
                // 合并新旧数据
                characterChat.weiboDms.push(...newDmsData);
            } else {
                characterChat.weiboDms = newDmsData;
            }
            await db.chats.put(characterChat);
            return characterChat.weiboDms;
        }
        throw new Error("AI返回的数据不是一个有效的数组。");
    } catch (error) {
        console.error("生成粉丝私信失败:", error);
        await showCustomAlert('生成失败', `抱歉，生成私信时发生了一个错误。\n\n详细信息:\n${error.message}`);
        return characterChat.weiboDms || []; // 失败时返回旧数据或空数组
    }
}

/**
 * 渲染粉丝私信列表
 * @param {Array} dmsData - 私信对话数组
 * @param {string} charName - 角色名
 */
function renderDmList(dmsData, charName) {
    const listEl = document.getElementById('weibo-dm-list');
    const titleEl = document.getElementById('weibo-dm-list-title');
    listEl.innerHTML = '';
    titleEl.textContent = `${charName}的私信`;

    if (!dmsData || dmsData.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">还没有收到任何私信哦</p>';
        return;
    }

    dmsData.forEach((convo, index) => {
        const lastMsg = convo.messages[convo.messages.length - 1];
        const item = document.createElement('div');
        item.className = 'dm-list-item';
        item.dataset.fanIndex = index; // 用索引来标识
        item.innerHTML = `
            <img src="${convo.fanAvatarUrl}" class="dm-avatar">
            <div class="dm-info">
                <div class="dm-name">${convo.fanName}</div>
                <div class="dm-last-msg">${lastMsg.text}</div>
            </div>
        `;
        listEl.appendChild(item);
    });
}

/**
 * 打开私信详情页
 * @param {number} fanIndex - 粉丝在私信数组中的索引
 */
function openDmDetail(fanIndex) {
    const charId = currentViewingDmsFor.isNpc ? currentViewingDmsFor.ownerId : currentViewingDmsFor.id;
    const chat = state.chats[charId];
    const conversation = chat.weiboDms[fanIndex];
    
    if (conversation) {
        renderDmDetail(conversation, chat);
        showScreen('weibo-dm-detail-screen');
    }
}

/**
 * 渲染私信详情页的聊天气泡
 * @param {object} conversation - 单个粉丝的对话对象
 * @param {object} characterChat - 角色的聊天对象
 */
function renderDmDetail(conversation, characterChat) {
    const messagesEl = document.getElementById('weibo-dm-messages');
    const titleEl = document.getElementById('weibo-dm-detail-title');
    messagesEl.innerHTML = '';
    titleEl.textContent = conversation.fanName;
    
    const charAvatar = characterChat.settings.aiAvatar || defaultAvatar;

    conversation.messages.forEach((msg, index) => {
        const isFan = msg.sender === 'fan';
        const wrapper = document.createElement('div');
        wrapper.className = `message-wrapper ${isFan ? 'fan' : 'char'}`;

        const bubble = document.createElement('div');
        bubble.className = `message-bubble`;

        const avatarHtml = `<img src="${isFan ? conversation.fanAvatarUrl : charAvatar}" class="avatar">`;
        const contentHtml = `<div class="content">${msg.text.replace(/\n/g, '<br>')}</div>`;
        
        // ★★★ 只有粉丝的消息才添加删除按钮 ★★★
        const deleteBtnHtml = isFan 
            ? `<button class="dm-message-delete-btn" data-message-index="${index}">×</button>` 
            : '';

        bubble.innerHTML = `${avatarHtml}${contentHtml}`;
        // 将删除按钮添加到wrapper，而不是bubble内部，以方便定位
        wrapper.innerHTML = deleteBtnHtml; 
        wrapper.appendChild(bubble);

        messagesEl.appendChild(wrapper);
    });
    
    messagesEl.scrollTop = messagesEl.scrollHeight;
}
/**
 * 【全新】清空当前角色的所有粉丝私信
 */
async function handleClearAllDms() {
    if (!currentViewingDmsFor) return;

    const charId = currentViewingDmsFor.isNpc ? currentViewingDmsFor.ownerId : currentViewingDmsFor.id;
    const chat = state.chats[charId];
    if (!chat || !chat.weiboDms || chat.weiboDms.length === 0) {
        alert("没有可以清空的私信。");
        return;
    }

    const confirmed = await showCustomConfirm(
        '确认清空',
        `确定要清空“${currentViewingDmsFor.name}”收到的所有粉丝私信吗？此操作不可恢复。`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        chat.weiboDms = []; // 清空数组
        await db.chats.put(chat); // 保存到数据库
        renderDmList(chat.weiboDms, currentViewingDmsFor.name); // 重新渲染列表
        alert('所有私信已清空。');
    }
}

/**
 * ★★★ 处理删除单条私信的逻辑 ★★★
 * @param {number} fanIndex - 粉丝对话的索引
 * @param {number} messageIndex - 要删除的消息的索引
 */
async function handleDeleteWeiboDm(fanIndex, messageIndex) {
    const charId = currentViewingDmsFor.isNpc ? currentViewingDmsFor.ownerId : currentViewingDmsFor.id;
    const chat = state.chats[charId];
    if (!chat || !chat.weiboDms[fanIndex]) return;

    const conversation = chat.weiboDms[fanIndex];
    const messageText = conversation.messages[messageIndex].text.substring(0, 30);
    
    const confirmed = await showCustomConfirm(
        '删除私信',
        `确定要删除这条私信吗？\n\n“${messageText}...”`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        // 从消息数组中移除
        conversation.messages.splice(messageIndex, 1);
        
        // 如果一个对话的所有消息都被删除了，可以选择是否删除整个对话
        if (conversation.messages.length === 0) {
            chat.weiboDms.splice(fanIndex, 1);
            await db.chats.put(chat);
            // 返回私信列表
            renderDmList(chat.weiboDms, currentViewingDmsFor.name);
            showScreen('weibo-dm-list-screen');
        } else {
            await db.chats.put(chat);
            // 重新渲染当前对话
            renderDmDetail(conversation, chat);
        }
        alert('私信已删除。');
    }
}

/**
 * ★★★ 处理点击“继续生成”按钮的逻辑 ★★★
 */
async function handleGenerateMoreDms() {
    const charId = currentViewingDmsFor.isNpc ? currentViewingDmsFor.ownerId : currentViewingDmsFor.id;
    const chat = state.chats[charId];
    if (!chat) return;

    // 调用核心AI函数，并传入 addMore=true 参数
    const newDmsData = await generateAndCacheFanDms(chat, true);
    
    // 渲染更新后的私信列表
    renderDmList(newDmsData, currentViewingDmsFor.name);
}

// ▲▲▲ 核心功能函数粘贴结束 ▲▲▲
// ▼▼▼ 【全新】粘贴这一整块聊天总结功能的核心函数 ▼▼▼
// ▼▼▼ 在JS顶部变量区，粘贴下面这2块代码 ▼▼▼

// 全局变量，用于存储所有正在运行的物流更新计时器，方便在离开页面时清除
let logisticsUpdateTimers = [];

// 物流时间线模板 (delay单位是毫秒)
// 你可以随意修改这里的文本和延迟时间，打造你自己的物流故事！
const logisticsTimelineTemplate = [
    { text: '您的订单已提交', delay: 1000 * 2 }, // 2秒
    { text: '付款成功，等待商家打包', delay: 1000 * 10 }, // 10秒后
    { text: '【{city}仓库】已打包，等待快递揽收', delay: 1000 * 60 * 5 }, // 5分钟后
    { text: '【{city}快递】已揽收', delay: 1000 * 60 * 20 }, // 20分钟后
    { text: '快件已到达【{city}分拨中心】', delay: 1000 * 60 * 60 * 2 }, // 2小时后
    { text: '【{city}分拨中心】已发出，下一站【{next_city}】', delay: 1000 * 60 * 60 * 8 }, // 8小时后
    { text: '快件已到达【{user_city}转运中心】', delay: 1000 * 60 * 60 * 20 }, // 20小时后
    { text: '快件正在派送中，派送员：兔兔快递员，电话：123-4567-8910，请保持电话畅通', delay: 1000 * 60 * 60 * 24 }, // 24小时后
    { text: '您的快件已签收，感谢您在桃宝购物，期待再次为您服务！', delay: 1000 * 60 * 60 * 28 }, // 28小时后
];

// ▲▲▲ 粘贴结束 ▲▲▲

let isSummarizing = false; // 全局锁，防止重复触发总结

// ▼▼▼ 【V2 - 流程分离版】用这整块代码替换旧的 checkAndTriggerSummary 函数 ▼▼▼
/**
 * 【总入口 V2】检查是否需要触发总结或提醒
 * @param {string} chatId - 当前聊天的ID
 */
async function checkAndTriggerSummary(chatId) {
    if (isSummarizing) return; 

    const chat = state.chats[chatId];
    if (!chat || !chat.settings.summary || !chat.settings.summary.enabled) return;

    const summarySettings = chat.settings.summary;
    // 核心修改：我们不再从0开始，而是从上次总结的位置开始计算
    const lastSummaryIndex = summarySettings.lastSummaryIndex;
    const messagesSinceLastSummary = chat.history.slice(lastSummaryIndex + 1);

    if (messagesSinceLastSummary.length >= summarySettings.count) {
        isSummarizing = true; 
        if (summarySettings.mode === 'auto') {
            await performAutomaticSummary(chatId);
        } else {
            // 对于手动模式，现在只弹提醒
            await notifyForManualSummary(chatId);
        }
        isSummarizing = false;
    }
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【V2 - 范围精确版】用这整块代码替换旧的 performAutomaticSummary 函数 ▼▼▼
/**
 * 自动在后台执行总结，只总结触发条件的N条消息
 */
async function performAutomaticSummary(chatId) {
    console.log(`自动总结触发 for chat: ${chatId}`);
    const chat = state.chats[chatId];
    const summarySettings = chat.settings.summary;

    // 【核心修改】精确截取最后N条消息作为总结范围
    const messagesToSummarize = chat.history.slice(-summarySettings.count);
    
    try {
        const summaryText = await generateSummary(chatId, messagesToSummarize);
        if (summaryText) {
            await saveSummaryAsMemory(chatId, summaryText);
        }
    } catch (e) {
        // generateSummary 内部已经处理了错误弹窗，这里我们只需要记录日志即可
        console.error("自动总结过程中发生未捕获的错误:", e);
    }
}
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 【V2 - 仅提醒版】用这整块新代码替换旧的 promptForManualSummary 函数 ▼▼▼
/**
 * 弹出提示框，【提醒】用户可以进行手动总结了
 */
async function notifyForManualSummary(chatId) {
    console.log(`手动总结提醒触发 for chat: ${chatId}`);
    
    // 只弹出一个简单的通知
    await showCustomAlert(
        '总结提醒',
        '对话已达到设定长度，你可以随时在“聊天设置”中点击“立即手动总结”来生成对话记忆。'
    );

    // 【重要】提醒过后，更新“上次总结位置”，以防止每条新消息都弹窗。
    // 这意味着计时器会从现在重新开始计算。
    const chat = state.chats[chatId];
    chat.settings.summary.lastSummaryIndex = chat.history.length - 1;
    await db.chats.put(chat);
}
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 【V2 - 时间戳增强版】用这整块代码替换旧的 generateSummary 函数 ▼▼▼
/**
 * 【AI核心 V2 - 时间戳增强版】调用API生成总结内容
 * @param {string} chatId - 聊天的ID
 * @param {Array | null} specificMessages - 如果提供，则只总结这个数组里的消息；如果为null，则总结自上次以来的所有消息。
 * @returns {Promise<string|null>} - AI生成的总结文本
 */
async function generateSummary(chatId, specificMessages = null) {
    const chat = state.chats[chatId];
    const { proxyUrl, apiKey, model } = state.apiConfig;

    if (!proxyUrl || !apiKey || !model) {
        throw new Error('API未配置，无法生成总结。');
    }

    const summarySettings = chat.settings.summary;
    let messagesToSummarize;

    if (specificMessages && specificMessages.length > 0) {
        messagesToSummarize = specificMessages;
    } else {
        const lastSummaryIndex = summarySettings.lastSummaryIndex > -1 ? summarySettings.lastSummaryIndex : 0;
        messagesToSummarize = chat.history.slice(lastSummaryIndex + 1);
    }
    
    const filteredMessagesForSummary = messagesToSummarize.filter(msg => msg.type !== 'summary');

    if (filteredMessagesForSummary.length === 0) {
        if (!specificMessages) {
             await showCustomAlert("无需总结", "自上次总结以来没有新的对话内容。");
        }
        return null;
    }

    // --- ★★★ 核心修改1：在构建对话文本时，加入时间戳！ ★★★ ---
    const conversationText = filteredMessagesForSummary.map(msg => {
        const sender = msg.role === 'user' ? (chat.isGroup ? (chat.settings.myNickname || '我') : '我') : (msg.senderName || chat.name);
        let content = '';
        if (typeof msg.content === 'string') {
            content = msg.content;
        } else if (Array.isArray(msg.content)) {
            content = '[图片]';
        } else if (msg.type) {
            content = `[${msg.type}]`;
        }
        // 将毫秒时间戳转换为人类可读的日期时间字符串
        const readableTime = new Date(msg.timestamp).toLocaleString('zh-CN', { hour12: false });
        return `[${readableTime}] ${sender}: ${content}`;
    }).join('\n');

    // --- ★★★ 核心修改2：更新系统指令，要求AI使用时间戳！ ★★★ ---
    const systemPrompt = summarySettings.prompt + `\n\n重要提示：每条消息开头都有一个 [时间] 标记。你在总结时，【必须】参考这些时间，在总结关键事件时附上对应的时间范围或具体时间点，让总结包含时间线索。\n\n--- 对话开始 ---\n${conversationText}\n--- 对话结束 ---`;
    
    try {
        if (!specificMessages) {
             await showCustomAlert("正在生成...", "AI正在努力总结你们的对话，请稍候...");
        }
        
        const isGemini = proxyUrl === GEMINI_API_URL;
        const messagesForApi = [{ role: 'user', content: systemPrompt }];
        const geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini);

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data)
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({
                    model: model,
                    messages: messagesForApi,
                    temperature: parseFloat(state.apiConfig.temperature) || 0.3,
                })
            });

        if (!response.ok) throw new Error(await response.text());
        const data = await response.json();
        const aiContent = isGemini 
            ? data?.candidates?.[0]?.content?.parts?.[0]?.text 
            : data?.choices?.[0]?.message?.content;

        if (!aiContent) {
            throw new Error("AI返回了空内容。");
        }
        
        return aiContent;

    } catch (error) {
        console.error("生成总结失败:", error);
        await showCustomAlert('总结失败', `发生错误: ${error.message}`);
        return null;
    }
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 将生成的总结作为一条特殊的记忆消息保存起来
 */
async function saveSummaryAsMemory(chatId, summaryText) {
    const chat = state.chats[chatId];
    
    // 记录下总结操作发生时的最后一条消息的索引
    const newLastSummaryIndex = chat.history.length - 1;

    const summaryMessage = {
        role: 'system',
        type: 'summary', // 特殊类型
        content: summaryText,
        timestamp: Date.now(),
        isHidden: true // 这条消息对AI可见，但对用户隐藏
    };

    chat.history.push(summaryMessage);
    chat.settings.summary.lastSummaryIndex = newLastSummaryIndex; // 更新索引
    
    await db.chats.put(chat);
    console.log(`新的总结已作为记忆保存 for chat: ${chatId}`);
}

// --- 以下是总结管理界面的函数 ---

let editingSummaryTimestamp = null;

// ▼▼▼ 用这块【V2 - 美化版】代码替换旧的 openSummaryViewer 函数 ▼▼▼
async function openSummaryViewer() {
    const chat = state.chats[state.activeChatId];
    document.getElementById('summary-viewer-title').textContent = `“${chat.name}”的对话记忆`;
    
    const listEl = document.getElementById('summary-list');
    listEl.innerHTML = '';
    
    const summaries = chat.history.filter(msg => msg.type === 'summary');

    if (summaries.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a;">还没有生成过任何总结。</p>';
    } else {
        [...summaries].reverse().forEach(summary => {
            const card = document.createElement('div');
            card.className = 'summary-item-card';
            
            // --- ★★★ 核心修改：让生成时间显示得更简短好看！ ★★★ ---
            card.innerHTML = `
                <div class="summary-actions">
                    <button class="concise-summary-btn" data-timestamp="${summary.timestamp}" title="精简总结">✨</button>
                    <button class="edit-summary-btn" data-timestamp="${summary.timestamp}" title="编辑">✏️</button>
                    <button class="delete-summary-btn" data-timestamp="${summary.timestamp}" title="删除">🗑️</button>
                </div>
                <div class="summary-content">${summary.content.replace(/\n/g, '<br>')}</div>
                <div class="summary-meta">
                    <span>生成于: ${new Date(summary.timestamp).toLocaleString('zh-CN', { dateStyle: 'short', timeStyle: 'short'})}</span>
                </div>
            `;
            listEl.appendChild(card);
        });
    }
    
    document.getElementById('chat-settings-modal').classList.remove('visible');
    document.getElementById('summary-viewer-modal').classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲


/**
 * 编辑一条总结
 */
async function editSummary(timestamp) {
    const chat = state.chats[state.activeChatId];
    const summary = chat.history.find(msg => msg.timestamp === timestamp);
    if (!summary) return;

    const newContent = await showCustomPrompt(
        '编辑总结',
        '修改总结内容:',
        summary.content,
        'textarea'
    );

    if (newContent !== null) {
        summary.content = newContent.trim();
        await db.chats.put(chat);
        openSummaryViewer(); // 重新渲染列表
    }
}

/**
 * 【已修复】删除一条总结，并智能更新总结索引
 */
async function deleteSummary(timestamp) {
    const confirmed = await showCustomConfirm('确认删除', '确定要删除这条总结记忆吗？这可能会影响AI的长期记忆。', { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        const chat = state.chats[state.activeChatId];
        
        // 1. 从历史记录中过滤掉被删除的总结
        chat.history = chat.history.filter(msg => msg.timestamp !== timestamp);

        // 2. --- 核心修复：重新计算 lastSummaryIndex ---
        // 找到剩下的总结中，最新的那一条
        const lastRemainingSummary = chat.history.filter(m => m.type === 'summary').pop();
        
        let newLastSummaryIndex;

        if (lastRemainingSummary) {
            // 3. 如果还有其他总结，就找到它在历史记录中的位置
            const lastSummaryMessageIndexInHistory = chat.history.findIndex(m => m.timestamp === lastRemainingSummary.timestamp);
            // 4. 新的索引就是它前面那条普通消息的索引
            newLastSummaryIndex = lastSummaryMessageIndexInHistory > 0 ? (lastSummaryMessageIndexInHistory - 1) : -1;
        } else {
            // 5. 如果一条总结都不剩了，就彻底重置索引
            newLastSummaryIndex = -1;
        }
        
        // 6. 更新设置
        if (chat.settings.summary) {
            chat.settings.summary.lastSummaryIndex = newLastSummaryIndex;
        }

        // 保存更改并刷新UI
        await db.chats.put(chat);
        openSummaryViewer();
        await showCustomAlert('操作成功', '总结已删除！');
    }
}

// ▼▼▼ 把这一整块全新的功能函数，粘贴到你的JS代码中 ▼▼▼

/**
 * 【AI核心】调用API将指定文本精简为摘要
 * @param {string} originalText - 原始的、较长的总结文本
 * @returns {Promise<string|null>} - AI生成的精简摘要，如果失败则返回null
 */
async function generateConciseSummary(originalText) {
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        throw new Error('API未配置，无法生成精简摘要。');
    }

    // 核心Prompt：指示AI将内容精简为一句话
    const systemPrompt = `请你将以下内容精简为一句话的核心摘要，保留最关键的人物、事件和结论，字数控制在20字以内：\n\n--- 内容开始 ---\n${originalText}\n--- 内容结束 ---`;

    try {
        const response = await fetch(`${proxyUrl}/v1/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
            body: JSON.stringify({
                model: model,
                messages: [{ role: 'user', content: systemPrompt }],
                temperature: parseFloat(state.apiConfig.temperature) || 0.5,
            })
        });

        if (!response.ok) throw new Error(await response.text());
        const data = await response.json();
        return data.choices[0].message.content;

    } catch (error) {
        console.error("生成精简摘要失败:", error);
        await showCustomAlert('精简失败', `发生错误: ${error.message}`);
        return null;
    }
}

/**
 * 处理单条总结的精简
 * @param {number} timestamp - 要精简的总结消息的时间戳
 */
async function handleConciseSummary(timestamp) {
    const chat = state.chats[state.activeChatId];
    const summary = chat.history.find(msg => msg.timestamp === timestamp);
    if (!summary) return;

    await showCustomAlert("请稍候...", "AI正在努力为您精简内容...");

    const conciseText = await generateConciseSummary(summary.content);

    if (conciseText) {
        summary.content = conciseText.trim(); // 用精简后的文本替换原文
        await db.chats.put(chat); // 保存到数据库
        await openSummaryViewer(); // 重新渲染列表
        await showCustomAlert('成功', '本条总结已精简！');
    }
}

/**
 * 处理全部总结的精简
 */
async function handleConciseAllSummaries() {
    const chat = state.chats[state.activeChatId];
    const summaries = chat.history.filter(msg => msg.type === 'summary');

    if (summaries.length === 0) {
        alert("没有可以精简的总结。");
        return;
    }

    const confirmed = await showCustomConfirm(
        '确认全部精简',
        `确定要精简全部 ${summaries.length} 条总结吗？此操作会覆盖原始内容且不可恢复。`,
        { confirmButtonClass: 'btn-danger' }
    );
    if (!confirmed) return;

    await showCustomAlert("请稍候...", `正在批量精简 ${summaries.length} 条总结，这可能需要一些时间...`);

    try {
        // 使用 for...of 循环来逐条处理，避免同时发送太多API请求导致被限制
        for (const summary of summaries) {
            const conciseText = await generateConciseSummary(summary.content);
            if (conciseText) {
                summary.content = conciseText.trim();
            }
            // 每处理完一条，稍微等待一下，给API一点喘息时间
            await new Promise(resolve => setTimeout(resolve, 500));
        }

        await db.chats.put(chat);
        await openSummaryViewer();
        await showCustomAlert('成功', '所有总结都已精简完毕！');
    } catch (error) {
        // generateConciseSummary 内部已经处理了错误弹窗，这里我们只需要确保流程正常结束
        console.error("批量精简时出错:", error);
    }
}

// ▼▼▼ 第2步：用这块【已改造】的代码，完整替换旧的 triggerManualSummaryNow 函数 ▼▼▼

/**
 * 【手动总结 V2】用户点击“立即手动总结”按钮时触发的函数 (支持不同模式)
 * @param {'latest' | 'range'} mode - 总结模式
 * @param {{start: number, end: number} | null} range - 如果是范围模式，则为起始和结束序号
 */
async function triggerManualSummaryNow(mode = 'latest', range = null) {
    if (isSummarizing) {
        alert("正在处理上一个总结任务，请稍候...");
        return;
    }

    const chat = state.chats[state.activeChatId];
    if (!chat) {
        alert("错误：找不到当前聊天，无法总结。");
        return;
    }
    
    isSummarizing = true; // 上锁

    try {
        let messagesToSummarize = [];

        // --- ▼▼▼ 这就是我们本次修改的核心逻辑 ▼▼▼ ---

        // 1. 根据传入的模式，决定要截取哪些消息
        if (mode === 'latest') {
            const summarySettings = chat.settings.summary;
            const count = (summarySettings && summarySettings.count > 0) ? summarySettings.count : 20;
            messagesToSummarize = chat.history.slice(-count);
            console.log(`手动总结最新 ${count} 条消息...`);
        } else if (mode === 'range' && range) {
            // 注意：数组索引从0开始，而用户输入从1开始，所以需要-1
            messagesToSummarize = chat.history.slice(range.start - 1, range.end);
            console.log(`手动总结从 ${range.start} 到 ${range.end} 的消息...`);
        } else {
            throw new Error("无效的总结模式或范围。");
        }

        // --- ▲▲▲ 修改结束 ▲▲▲ ---

        // 后续的逻辑保持不变
        if (messagesToSummarize.length === 0) {
            alert("选定的范围内没有可总结的聊天记录。");
            isSummarizing = false; // 解锁
            return;
        }
        
        const summaryText = await generateSummary(state.activeChatId, messagesToSummarize);
        
        if (summaryText) {
            await saveSummaryAsMemory(state.activeChatId, summaryText);
            await showCustomAlert('总结完成', '新的对话记忆已生成！');
            if (document.getElementById('summary-viewer-modal').classList.contains('visible')) {
                openSummaryViewer();
            }
        }
    } catch (e) {
        console.error("手动总结过程中发生未捕获的错误:", e);
        await showCustomAlert('错误', '手动总结时发生错误，详情请查看控制台。');
    } finally {
        isSummarizing = false; // 别忘了无论成功失败都要解锁
    }
}

// ▲▲▲ 替换结束 ▲▲▲


/**
 * 【全新】更新角色手机钱包的余额和交易记录
 * @param {string} charId - 要更新钱包的角色ID
 * @param {number} amount - 交易金额 (正数为收入, 负数为支出)
 * @param {string} description - 交易描述 (例如: "转账给 XX", "收到 XX 的红包")
 */
async function updateCharacterBankBalance(charId, amount, description) {
    // 安全检查：如果缺少关键信息，则直接返回
    if (!charId || !amount || isNaN(amount)) {
        console.warn("updateCharacterBankBalance 调用失败：缺少charId或有效的amount。");
        return;
    }

    // 从全局状态中获取角色对象
    const chat = state.chats[charId];
    // 安全检查：确保角色存在且不是群聊
    if (!chat || chat.isGroup) {
        console.warn(`updateCharacterBankBalance 跳过：找不到ID为 ${charId} 的角色或该ID为群聊。`);
        return;
    }

    // --- 确保数据结构完整，兼容旧数据 ---
    if (!chat.characterPhoneData) {
        chat.characterPhoneData = {};
    }
    if (!chat.characterPhoneData.bank) {
        chat.characterPhoneData.bank = { balance: 0, transactions: [] };
    }
    // 如果旧数据的余额不是数字，则强制设为0
    if (typeof chat.characterPhoneData.bank.balance !== 'number') {
        chat.characterPhoneData.bank.balance = 0;
    }
    // 如果旧数据的交易记录不是数组，则创建一个空数组
    if (!Array.isArray(chat.characterPhoneData.bank.transactions)) {
        chat.characterPhoneData.bank.transactions = [];
    }

    // --- 核心逻辑 ---
    // 1. 创建一条新的交易记录
    const newTransaction = {
        type: amount > 0 ? '收入' : '支出',
        amount: Math.abs(amount), // 交易记录里的金额总是正数
        description: description,
        timestamp: Date.now() // 记录交易发生的时间
    };

    // 2. 更新余额
    chat.characterPhoneData.bank.balance += amount;

    // 3. 将新交易记录添加到列表的开头（让最新的显示在最前面）
    chat.characterPhoneData.bank.transactions.unshift(newTransaction);

    // 4. 将更新后的角色数据保存回数据库
    await db.chats.put(chat);
    
    console.log(`✅ 钱包同步成功: 角色[${chat.name}], 交易[${description}], 金额[${amount.toFixed(2)}], 新余额[${chat.characterPhoneData.bank.balance.toFixed(2)}]`);
}

// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 把这一整块全新的功能函数，粘贴到 init() 函数的正上方 ▼▼▼

/* --- 【全新】“桃宝”App 核心功能函数 --- */

let currentEditingProductId = null; // 用于追踪正在编辑的商品ID
/**
 * 【全新 | 已修复】清空桃宝首页的所有商品及购物车
 */
async function clearTaobaoProducts() {
    // 1. 修改提示语，告知用户购物车也会被清空
    const confirmed = await showCustomConfirm(
        '确认清空',
        '确定要清空桃宝首页的所有商品吗？此操作将【一并清空购物车】，且无法恢复。',
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        try {
            // 使用数据库事务，确保两步操作要么都成功，要么都失败，更安全
            await db.transaction('rw', db.taobaoProducts, db.taobaoCart, async () => {
                // 清空商品库
                await db.taobaoProducts.clear();
                // ▼▼▼ 核心新增代码1：清空购物车数据库 ▼▼▼
                await db.taobaoCart.clear();
            });
            
            // 重新渲染UI
            await renderTaobaoProducts(); 
            // ▼▼▼ 核心新增代码2：刷新购物车UI（让页面变空） ▼▼▼
            await renderTaobaoCart();
            // ▼▼▼ 核心新增代码3：更新购物车角标（让红点消失） ▼▼▼
            updateCartBadge();

            // 2. 修改成功提示
            await showCustomAlert('操作成功', '所有商品及购物车已被清空！');

        } catch (error) {
            console.error("清空桃宝商品时出错:", error);
            await showCustomAlert('操作失败', `发生错误: ${error.message}`);
        }
    }
}


/**
 * 【总入口】打开“桃宝”App，并渲染默认视图
 */
async function openTaobaoApp() {
    showScreen('taobao-screen');
    await renderTaobaoProducts(); // 默认显示所有商品
    renderBalanceDetails(); // 刷新余额显示
}

// ▼▼▼ 请将这一整块全新的功能函数，完整地粘贴到 // 桃宝 App 功能函数区的末尾 ▼▼▼

/**
 * 【全新】切换“桃宝”App内的不同视图（首页、购物车、订单、我的）
 */
function switchTaobaoView(viewId) {
    document.querySelectorAll('.taobao-view').forEach(v => v.classList.remove('active'));
    document.getElementById(viewId).classList.add('active');

    document.querySelectorAll('.taobao-tab').forEach(t => {
        t.classList.toggle('active', t.dataset.view === viewId);
    });

    // 根据切换的视图，执行对应的渲染函数
    if (viewId === 'orders-view') {
        renderTaobaoOrders();
    } else if (viewId === 'my-view') {
        renderBalanceDetails();
    } else if (viewId === 'cart-view') {
        renderTaobaoCart(); // ★★★ 新增：切换到购物车时，渲染购物车内容
    }
}

/**
 * 【全新】渲染购物车页面
 */
async function renderTaobaoCart() {
    const listEl = document.getElementById('cart-item-list');
    const checkoutBar = document.getElementById('cart-checkout-bar');
    listEl.innerHTML = '';
    
    const cartItems = await db.taobaoCart.toArray();

    if (cartItems.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">购物车空空如也~</p>';
        checkoutBar.style.display = 'none';
        updateCartBadge(0);
        return;
    }
    
    checkoutBar.style.display = 'flex';
    let totalPrice = 0;
    let totalItems = 0;

    for (const item of cartItems) {
        const product = await db.taobaoProducts.get(item.productId);
        if (!product) continue;

        totalItems += item.quantity;
        totalPrice += product.price * item.quantity;

        const itemEl = document.createElement('div');
        itemEl.className = 'cart-item';
        itemEl.innerHTML = `
            <img src="${product.imageUrl}" class="product-image" data-product-id="${product.id}">
            <div class="cart-item-info" data-product-id="${product.id}">
                <div class="product-name">${product.name}</div>
                <div class="product-price">¥${product.price.toFixed(2)}</div>
            </div>
            <div class="quantity-controls">
                <button class="quantity-decrease" data-cart-id="${item.id}" ${item.quantity <= 1 ? 'disabled' : ''}>-</button>
                <span class="quantity-display">${item.quantity}</span>
                <button class="quantity-increase" data-cart-id="${item.id}">+</button>
            </div>
            <button class="delete-cart-item-btn" data-cart-id="${item.id}">×</button>
        `;
        listEl.appendChild(itemEl);
    }
    
    document.getElementById('cart-total-price').textContent = `¥ ${totalPrice.toFixed(2)}`;
    const checkoutBtn = document.getElementById('checkout-btn');
    checkoutBtn.textContent = `结算(${totalItems})`;
    checkoutBtn.dataset.totalPrice = totalPrice; // 把总价存起来，方便结算时用

    updateCartBadge(totalItems);
}

/**
 * 【全新】更新购物车图标上的角标数量
 */
function updateCartBadge() {
    const badge = document.getElementById('cart-item-count-badge');
    db.taobaoCart.toArray().then(items => {
        const totalCount = items.reduce((sum, item) => sum + item.quantity, 0);
        if (totalCount > 0) {
            badge.textContent = totalCount > 99 ? '99+' : totalCount;
            badge.style.display = 'inline-block';
        } else {
            badge.style.display = 'none';
        }
    });
}

/**
 * 【全新】处理加入购物车的逻辑
 */
async function handleAddToCart(productId) {
    const existingItem = await db.taobaoCart.where('productId').equals(productId).first();
    if (existingItem) {
        // 如果已存在，则数量+1
        await db.taobaoCart.update(existingItem.id, { quantity: existingItem.quantity + 1 });
    } else {
        // 如果不存在，则新增
        await db.taobaoCart.add({ productId: productId, quantity: 1 });
    }
    await showCustomAlert('成功', '宝贝已加入购物车！');
    updateCartBadge(); // 更新角标
}

/**
 * 【全新】处理购物车内商品数量的变化
 */
async function handleChangeCartItemQuantity(cartId, change) {
    const item = await db.taobaoCart.get(cartId);
    if (!item) return;

    const newQuantity = item.quantity + change;
    if (newQuantity <= 0) {
        // 如果数量减到0，就删除该项
        await handleRemoveFromCart(cartId);
    } else {
        await db.taobaoCart.update(cartId, { quantity: newQuantity });
        await renderTaobaoCart();
    }
}

/**
 * 【全新】从购物车中移除商品
 */
async function handleRemoveFromCart(cartId) {
    await db.taobaoCart.delete(cartId);
    await renderTaobaoCart();
}

// ▼▼▼ 用这块【已集成评价功能】的代码，完整替换旧的 openProductDetail 函数 ▼▼▼
/**
 * 【全新】打开商品详情弹窗 (已集成评价功能)
 */
async function openProductDetail(productId) {
    const product = await db.taobaoProducts.get(productId);
    if (!product) return;

    const modal = document.getElementById('product-detail-modal');
    const bodyEl = document.getElementById('product-detail-body');
    const reviewsSection = document.getElementById('product-reviews-section');
    const reviewsListEl = document.getElementById('product-reviews-list');
    const generateBtn = document.getElementById('generate-reviews-btn');
    
    // 渲染商品基本信息
    bodyEl.innerHTML = `
        <img src="${product.imageUrl}" class="product-image" alt="${product.name}">
        <h2 class="product-name">${product.name}</h2>
        <p class="product-price">${product.price.toFixed(2)}</p>
        <p style="color: #888; font-size: 13px;">店铺: ${product.store || '桃宝自营'}</p>
    `;

    // ★★★ 渲染评价区域 ★★★
    reviewsListEl.innerHTML = '';
    if (product.reviews && product.reviews.length > 0) {
        // 如果有评价，就渲染它们
        product.reviews.forEach(review => {
            const reviewEl = document.createElement('div');
            reviewEl.className = 'product-review-item';
            reviewEl.innerHTML = `
                <div class="review-author">${review.author}</div>
                <p>${review.text}</p>
            `;
            reviewsListEl.appendChild(reviewEl);
        });
        generateBtn.style.display = 'none'; // 有评价了就隐藏生成按钮
    } else {
        // 如果没有评价，就显示提示和生成按钮
        reviewsListEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary); font-size: 13px;">还没有人评价哦~</p>';
        generateBtn.style.display = 'block';
    }

    // 重新绑定“生成评价”按钮的事件 (使用克隆节点防止重复绑定)
    const newGenerateBtn = generateBtn.cloneNode(true);
    generateBtn.parentNode.replaceChild(newGenerateBtn, generateBtn);
    newGenerateBtn.addEventListener('click', () => generateProductReviews(productId));

    // 重新绑定“加入购物车”按钮的事件
    const addToCartBtn = document.getElementById('detail-add-to-cart-btn');
    const newAddToCartBtn = addToCartBtn.cloneNode(true);
    addToCartBtn.parentNode.replaceChild(newAddToCartBtn, addToCartBtn);
    newAddToCartBtn.onclick = async () => {
        await handleAddToCart(productId);
        modal.classList.remove('visible'); // 添加后自动关闭弹窗
    };
    
    // 绑定关闭按钮
    document.getElementById('close-product-detail-btn').onclick = () => modal.classList.remove('visible');

    modal.classList.add('visible');
}

/**
 * 【全新】AI核心：为指定商品生成评价
 * @param {number} productId - 商品的ID
 */
async function generateProductReviews(productId) {
    await showCustomAlert("请稍候...", "正在召唤买家秀大军...");
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('请先配置API！');
        return;
    }
    
    const product = await db.taobaoProducts.get(productId);
    if (!product) return;

    const prompt = `
# 任务
你是一位专业的电商评论生成器。请你为以下商品生成3-5条风格各异的模拟买家评价。

# 商品信息
- 名称: ${product.name}
- 价格: ${product.price}元
- 分类: ${product.category || '未分类'}

# 核心规则
1.  **风格多样**: 生成的评论应包含不同风格，例如：
    -   **好评**: 详细夸赞商品的某个优点。
    -   **中评/追评**: 描述使用一段时间后的感受，可能提到一些小瑕疵。
    -   **差评**: 吐槽商品的某个缺点，但语气要像真实买家。
    -   **搞笑评论**: 写一些幽默风趣的评论。
    -   **简洁评论**: 例如“好评”、“还行”、“物流很快”。
2.  **昵称真实**: 评论的作者昵称 ("author") 必须是随机的、生活化的、符合购物App用户习惯的。例如：“匿名用户”、“小王不吃香菜”、“可乐爱好者”。
3.  **格式铁律**: 你的回复【必须且只能】是一个严格的JSON数组，每个对象代表一条评论，并包含 "author" 和 "text" 两个字段。

# JSON输出格式示例:
[
  { "author": "匿名用户", "text": "物流很快，包装也很好，宝贝跟描述的一样，好评！" },
  { "author": "是小张呀", "text": "有点色差，不过还能接受。先用用看，过段时间再来追评。" }
]
`;
    try {
        const messagesForApi = [{ role: 'user', content: prompt }];
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, prompt, messagesForApi, isGemini);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({ model: model, messages: messagesForApi, temperature: parseFloat(state.apiConfig.temperature) || 1.0,response_format: { type: "json_object" } })
            });

        if (!response.ok) throw new Error(`API请求失败: ${await response.text()}`);
        
        const data = await response.json();
        const rawContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content);
        const cleanedContent = rawContent.replace(/^```json\s*|```$/g, '').trim();
        const newReviews = JSON.parse(cleanedContent);

        if (Array.isArray(newReviews) && newReviews.length > 0) {
            // 将AI生成的评价保存到商品数据中
            await db.taobaoProducts.update(productId, { reviews: newReviews });
            await showCustomAlert("生成成功！", `已成功生成 ${newReviews.length} 条评价。`);
            // 重新打开详情页，刷新显示
            await openProductDetail(productId);
        } else {
            throw new Error("AI返回的数据格式不正确。");
        }
    } catch (error) {
        console.error("生成商品评价失败:", error);
        await showCustomAlert('生成失败', `发生错误: ${error.message}`);
    }
}
// ▲▲▲ 新增功能函数结束 ▲▲▲

// ▼▼▼ 用这块【已集成物流】的代码，替换旧的 handleCheckout 函数 ▼▼▼
/**
 * 【全新】结算购物车
 */
async function handleCheckout() {
    const checkoutBtn = document.getElementById('checkout-btn');
    const totalPrice = parseFloat(checkoutBtn.dataset.totalPrice);
    
    if (totalPrice <= 0) return;

    const currentBalance = state.globalSettings.userBalance || 0;
    if (currentBalance < totalPrice) {
        alert("余额不足！请先去“我的”页面充值。");
        return;
    }
    
    const confirmed = await showCustomConfirm(
        '确认支付',
        `本次将花费 ¥${totalPrice.toFixed(2)}，确定要结算吗？`,
        { confirmText: '立即支付' }
    );
    
    if (confirmed) {
        const cartItems = await db.taobaoCart.toArray();
        const productPromises = cartItems.map(item => db.taobaoProducts.get(item.productId));
        const productsInCart = await Promise.all(productPromises);
        const validProducts = productsInCart.filter(Boolean);

        let description = '购买商品: ';
        const itemNames = validProducts.map(p => `“${p.name}”`);
        if (itemNames.length > 2) {
            description += itemNames.slice(0, 2).join('、') + ` 等${itemNames.length}件商品`;
        } else {
            description += itemNames.join('、');
        }
        
        await updateUserBalanceAndLogTransaction(-totalPrice, description);

        // ★★★ 核心修改：为每个订单创建物流历史起点 ★★★
        const newOrders = cartItems.map((item, index) => ({
            productId: item.productId,
            quantity: item.quantity,
            timestamp: Date.now() + index, // 订单创建时间
            status: '已付款，等待发货'
            // 我们不再需要在数据库里存 logisticsHistory，因为它是动态模拟的
        }));
        
        await db.taobaoOrders.bulkAdd(newOrders);
        await db.taobaoCart.clear();
        await renderTaobaoCart();

        alert('支付成功！宝贝正在火速打包中~');
        switchTaobaoView('orders-view');
    }
}
// ▲▲▲ 替换结束 ▲▲▲




// ▼▼▼ 【最终修复版】请用这整块代码，完整替换旧的 renderTaobaoProducts 函数 ▼▼▼
/**
 * 【最终修复版】渲染商品列表，杜绝重复并移除多余按钮
 */
async function renderTaobaoProducts(category = null) {
    const gridEl = document.getElementById('product-grid');
    const categoryTabsEl = document.getElementById('product-category-tabs');
    
    // 我们仍然保留清空操作，这是个好习惯
    gridEl.innerHTML = '';

    const allProducts = await db.taobaoProducts.orderBy('name').toArray();
    const categories = [...new Set(allProducts.map(p => p.category).filter(Boolean))];

    // 渲染分类页签 (这部分逻辑是正确的，保持不变)
    categoryTabsEl.innerHTML = `<button class="category-tab-btn ${!category ? 'active' : ''}" data-category="all">全部</button>`;
    categories.forEach(cat => {
        categoryTabsEl.innerHTML += `<button class="category-tab-btn ${category === cat ? 'active' : ''}" data-category="${cat}">${cat}</button>`;
    });

    const productsToRender = category 
        ? allProducts.filter(p => p.category === category)
        : allProducts;

    if (productsToRender.length === 0) {
        gridEl.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary);">还没有商品哦，点击右上角“+”添加吧！</p>';
        return;
    }

    productsToRender.forEach(product => {
        // ★★★ 核心修复1：在这里检查商品是否已存在 ★★★
        // 如果页面上已经有一个带有相同商品ID的卡片了，就直接跳过，不执行后面的添加操作。
        if (gridEl.querySelector(`[data-product-id="${product.id}"]`)) {
            console.warn(`检测到重复商品，已跳过渲染: ${product.name}`);
            return; // 跳过本次循环
        }

        const card = document.createElement('div');
        card.className = 'product-card';
        card.dataset.productId = product.id;

        // ★★★ 核心修复2：移除了您不想要的“加入购物车”按钮 ★★★
        card.innerHTML = `
            <img src="${product.imageUrl}" class="product-image" alt="${product.name}">
            <div class="product-info">
                <div class="product-name">${product.name}</div>
                <div class="product-price">${product.price.toFixed(2)}</div>
            </div>
        `;
        // 长按删除功能保持不变
        addLongPressListener(card, () => showProductActions(product.id));

        // 最终将创建好的卡片添加到页面
        gridEl.appendChild(card);
    });
}
// ▲▲▲ 替换结束 ▲▲▲




/**
 * 渲染“我的订单”列表
 */
async function renderTaobaoOrders() {
    const listEl = document.getElementById('order-list');
    listEl.innerHTML = '';
    const orders = await db.taobaoOrders.reverse().sortBy('timestamp');

    if (orders.length === 0) {
        listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">还没有任何订单记录</p>';
        return;
    }

    for (const order of orders) {
        const product = await db.taobaoProducts.get(order.productId);
        if (!product) continue;

        const item = document.createElement('div');
        item.className = 'order-item';
        item.dataset.orderId = order.id;
        item.innerHTML = `
            <img src="${product.imageUrl}" class="product-image">
            <div class="order-info">
                <div class="product-name">${product.name}</div>
                <div class="order-status">${order.status}</div>
                <div class="order-time">${new Date(order.timestamp).toLocaleString()}</div>
            </div>
        `;
        listEl.appendChild(item);
    }
}

/**
 * 渲染“我的”页面的余额
 */
function renderTaobaoBalance() {
    const balance = state.globalSettings.userBalance || 0;
    document.getElementById('user-balance-display').textContent = `¥ ${balance.toFixed(2)}`;
}

/**
 * 打开添加商品的方式选择弹窗
 */
function openAddProductChoiceModal() {
    document.getElementById('add-product-choice-modal').classList.add('visible');
}

/**
 * 打开手动添加/编辑商品的弹窗
 */
function openProductEditor(productId = null) {
    currentEditingProductId = productId;
    const modal = document.getElementById('product-editor-modal');
    const titleEl = document.getElementById('product-editor-title');
    
    if (productId) {
        titleEl.textContent = '编辑商品';
        // (异步) 加载现有商品数据
        db.taobaoProducts.get(productId).then(product => {
            if (product) {
                document.getElementById('product-name-input').value = product.name;
                document.getElementById('product-price-input').value = product.price;
                document.getElementById('product-image-input').value = product.imageUrl;
                document.getElementById('product-category-input').value = product.category || '';
            }
        });
    } else {
        titleEl.textContent = '添加新商品';
        // 清空输入框
        document.getElementById('product-name-input').value = '';
        document.getElementById('product-price-input').value = '';
        document.getElementById('product-image-input').value = '';
        document.getElementById('product-category-input').value = '';
    }
    modal.classList.add('visible');
}

// ▼▼▼ 用这块【新代码】替换旧的 saveProduct 函数 ▼▼▼
/**
 * 保存手动添加或编辑的商品
 */
async function saveProduct() {
    const name = document.getElementById('product-name-input').value.trim();
    const price = parseFloat(document.getElementById('product-price-input').value);
    let imageUrl = document.getElementById('product-image-input').value.trim(); // 核心修改1：使用let
    const category = document.getElementById('product-category-input').value.trim();

    // 核心修改2：现在图片URL不是必填项了
    if (!name || isNaN(price) || price <= 0) {
        alert("请填写所有必填项（名称、有效价格）！");
        return;
    }

    // 核心修改3：如果图片URL为空，就调用我们的新函数获取一个随机默认图
    if (!imageUrl) {
        imageUrl = getRandomDefaultProductImage();
    }

    const productData = { name, price, imageUrl, category };

    if (currentEditingProductId) {
        await db.taobaoProducts.update(currentEditingProductId, productData);
        alert('商品已更新！');
    } else {
        await db.taobaoProducts.add(productData);
        alert('新商品已添加！');
    }

    document.getElementById('product-editor-modal').classList.remove('visible');
    await renderTaobaoProducts(); // 刷新商品列表
    currentEditingProductId = null;
}
// ▲▲▲ 替换结束 ▲▲▲


/**
 * 打开识别链接的弹窗
 */
function openAddFromLinkModal() {
    document.getElementById('link-paste-area').value = '';
    document.getElementById('add-from-link-modal').classList.add('visible');
}

// ▼▼▼ 用这块【新代码】替换旧的 handleAddFromLink 函数 ▼▼▼
/**
 * 核心功能：处理粘贴的分享文案
 */
async function handleAddFromLink() {
    const text = document.getElementById('link-paste-area').value;
    const nameMatch = text.match(/「(.+?)」/);

    if (!nameMatch || !nameMatch[1]) {
        alert('无法识别商品名称！请确保粘贴了包含「商品名」的完整分享文案。');
        return;
    }

    const name = nameMatch[1];
    
    document.getElementById('add-from-link-modal').classList.remove('visible');
    
    const priceStr = await showCustomPrompt(`商品: ${name}`, "请输入价格 (元):", "", "number");
    if (priceStr === null) return;
    const price = parseFloat(priceStr);
    if (isNaN(price) || price <= 0) {
        alert("请输入有效的价格！");
        return;
    }

    // 核心修改1：让图片URL变成可选
    let imageUrl = await showCustomPrompt(`商品: ${name}`, "请输入图片链接 (URL, 可选):");
    if (imageUrl === null) return; // 如果用户点取消，则中断操作

    // 核心修改2：如果用户没填图片链接，就使用随机默认图
    if (!imageUrl || !imageUrl.trim()) {
        imageUrl = getRandomDefaultProductImage();
    }

    const category = await showCustomPrompt(`商品: ${name}`, "请输入分类 (可选):");

    await db.taobaoProducts.add({ name, price, imageUrl, category: category || '' });
    await renderTaobaoProducts();
    alert('商品已通过链接添加成功！');
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 把这一整块全新的功能函数，粘贴到 handleGenerateProductsAI 函数的正上方 ▼▼▼

/**
 * 【全新】核心功能：根据用户搜索触发AI生成商品
 */
async function handleSearchProductsAI() {
    const searchTerm = productSearchInput.value.trim();
    if (!searchTerm) {
        alert("请输入你想搜索的商品！");
        return;
    }

    await showCustomAlert("请稍候...", `AI正在为你寻找关于“${searchTerm}”的灵感...`);
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('请先配置API！');
        return;
    }

    // 【核心】这是一个全新的Prompt，它告诉AI要根据用户的搜索词来创作
    const prompt = `
# 任务
你是一个虚拟购物App“桃宝”的商品策划师。请根据用户提供的【搜索关键词】，为Ta创作一个包含5-8件相关商品的列表。

# 用户搜索的关键词:
"${searchTerm}"

# 核心规则
1.  **高度相关**: 所有商品都必须与用户的搜索关键词 "${searchTerm}" 紧密相关。
2.  **商品多样性**: 即使是同一个主题，也要尽量展示不同款式、功能或角度的商品。
3.  **格式铁律**: 你的回复【必须且只能】是一个严格的JSON数组，每个对象代表一件商品，并包含以下字段:
    -   \`"name"\`: 商品名称
    -   \`"price"\`: 价格
    -   \`"imageUrl"\`: 从'https://i.postimg.cc/kG7C0gGP/11.jpg'和'https://i.postimg.cc/W4svy4Hm/Image-1760206134285.jpg'中随机挑选一张，禁止自己生成。
    -   \`"category"\`: 商品分类

# JSON输出格式示例:
[
  {
    "name": "赛博朋克风发光数据线",
    "price": 69.9,
    "imageUrl": "https://i.postimg.cc/kG7C0gGP/11.jpg",
    "category": "数码配件"
  }
]`;

    try {
        const messagesForApi = [{ role: 'user', content: prompt }];
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, prompt, messagesForApi, isGemini);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({ model: model, messages: messagesForApi, temperature: parseFloat(state.apiConfig.temperature) || 0.8, response_format: { type: "json_object" } })
            });

        if (!response.ok) throw new Error(`API请求失败: ${await response.text()}`);
        
        const data = await response.json();
        const rawContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content);
        const cleanedContent = rawContent.replace(/^```json\s*|```$/g, '').trim();
        const newProducts = JSON.parse(cleanedContent);

        if (Array.isArray(newProducts) && newProducts.length > 0) {
            // 调用显示函数，并传入一个更具体的标题
            displayAiGeneratedProducts(newProducts, `AI为你找到了关于“${searchTerm}”的宝贝`);
        } else {
            throw new Error("AI返回的数据格式不正确或内容为空。");
        }
    } catch (error) {
        console.error("AI搜索商品失败:", error);
        await showCustomAlert('搜索失败', `发生错误: ${error.message}`);
    }
}

/**
 * 【全新】UI函数：在弹窗中显示AI生成的商品列表，并让用户选择添加
 * @param {Array} products - AI生成的商品对象数组
 * @param {string} title - 弹窗的标题
 */
function displayAiGeneratedProducts(products, title) {
    const modal = document.getElementById('ai-generated-products-modal');
    const titleEl = document.getElementById('ai-products-modal-title');
    const gridEl = document.getElementById('ai-product-results-grid');
    
    titleEl.textContent = title;
    gridEl.innerHTML = '';

    products.forEach((product, index) => {
        const card = document.createElement('div');
        card.className = 'product-card';
        // 注意：这里我们给卡片一个临时的唯一ID，方便操作
        card.id = `ai-product-${index}`; 
        
        card.innerHTML = `
            <img src="${product.imageUrl}" class="product-image" alt="${product.name}">
            <div class="product-info">
                <div class="product-name">${product.name}</div>
                <div class="product-price">${product.price.toFixed(2)}</div>
            </div>
            <button class="add-to-my-page-btn" data-product='${JSON.stringify(product)}'>+ 添加到我的桃宝</button>
        `;
        gridEl.appendChild(card);
    });

    modal.classList.add('visible');
}
// ▲▲▲ 新增函数结束 ▲▲▲

// ▼▼▼ 用这块【新代码】替换旧的 handleGenerateProductsAI 函数 ▼▼▼
/**
 * 核心功能：触发AI【随机】生成商品，并在弹窗中显示
 */
async function handleGenerateProductsAI() {
    await showCustomAlert("请稍候...", "正在请求AI生成一批有趣的商品...");
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('请先配置API！');
        return;
    }

    const prompt = `
# 任务
你是一个虚拟购物App“桃宝”的商品策划师。请你创作一个包含5-8件商品的列表。

# 核心规则
1.  **商品多样性**: 商品必须有趣、多样，可以包含服装、零食、家居用品、虚拟物品等。
2.  **分类清晰**: 为每件商品设置一个合理的分类。
3.  **格式铁律**: 你的回复【必须且只能】是一个严格的JSON数组，直接以 '[' 开头，以 ']' 结尾。每个对象代表一件商品，【必须】包含以下字段:
    -   \`"name"\`: 商品名称 (字符串)
    -   \`"price"\`: 价格 (数字)
    -   \`"imageUrl"\`: 从'https://i.postimg.cc/kG7C0gGP/11.jpg'和'https://i.postimg.cc/W4svy4Hm/Image-1760206134285.jpg'中随机挑选一张，禁止自己生成。
    -   \`"category"\`: 商品分类 (字符串)

# JSON输出格式示例:
[
  {
    "name": "会发光的蘑菇小夜灯",
    "price": 49.9,
    "imageUrl": "https://i.postimg.cc/W4svy4Hm/Image-1760206134285.jpg",
    "category": "家居"
  }
]`;

    try {
        const messagesForApi = [{ role: 'user', content: prompt }];
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, prompt, messagesForApi, isGemini);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({ model: model, messages: messagesForApi, temperature: parseFloat(state.apiConfig.temperature) || 0.8, response_format: { type: "json_object" } })
            });

        if (!response.ok) throw new Error(`API请求失败: ${await response.text()}`);
        
        const data = await response.json();
        const rawContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content);
        const cleanedContent = rawContent.replace(/^```json\s*|```$/g, '').trim();
        const newProducts = JSON.parse(cleanedContent);

        if (Array.isArray(newProducts) && newProducts.length > 0) {
            // 【核心修改】不再直接保存，而是调用显示函数
            displayAiGeneratedProducts(newProducts, "AI随机生成了以下宝贝");
        } else {
            throw new Error("AI返回的数据格式不正确。");
        }
    } catch (error) {
        console.error("AI生成商品失败:", error);
        await showCustomAlert('生成失败', `发生错误: ${error.message}`);
    }
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 处理用户点击商品卡片的逻辑（购买）
 */
async function handleBuyProduct(productId) {
    const product = await db.taobaoProducts.get(productId);
    if (!product) return;

    const currentBalance = state.globalSettings.userBalance || 0;
    if (currentBalance < product.price) {
        alert("余额不足，先去“我的”页面充点钱吧！");
        return;
    }

    const confirmed = await showCustomConfirm(
        '确认购买',
        `确定要花费 ¥${product.price.toFixed(2)} 购买“${product.name}”吗？`,
        { confirmText: '立即支付' }
    );

    if (confirmed) {
        // 1. 扣除余额
        state.globalSettings.userBalance -= product.price;
        await db.globalSettings.put(state.globalSettings);

        // 2. 创建订单
        const newOrder = {
            productId: productId,
            timestamp: Date.now(),
            status: '已付款，等待发货'
        };
        await db.taobaoOrders.add(newOrder);
        
        // 模拟物流更新
        setTimeout(async () => {
            const orderToUpdate = await db.taobaoOrders.where({ timestamp: newOrder.timestamp }).first();
            if (orderToUpdate) {
                await db.taobaoOrders.update(orderToUpdate.id, { status: '已发货，运输中' });
            }
        }, 1000 * 10); // 10秒后更新为已发货

        alert('购买成功！你可以在“我的订单”中查看物流信息。');
        renderTaobaoBalance(); // 刷新余额显示
    }
}

/**
 * 长按商品时显示操作菜单
 */
async function showProductActions(productId) {
    const choice = await showChoiceModal("商品操作", [
        { text: '✏️ 编辑商品', value: 'edit' },
        { text: '🗑️ 删除商品', value: 'delete' }
    ]);

    if (choice === 'edit') {
        openProductEditor(productId);
    } else if (choice === 'delete') {
        const product = await db.taobaoProducts.get(productId);
        const confirmed = await showCustomConfirm(
            '确认删除',
            `确定要删除商品“${product.name}”吗？`,
            { confirmButtonClass: 'btn-danger' }
        );
        if (confirmed) {
            await db.taobaoProducts.delete(productId);
            await renderTaobaoProducts();
            alert('商品已删除。');
        }
    }
}
// ▼▼▼ 把这两块全新的函数，粘贴到 init() 函数的上方 ▼▼▼

/**
 * 【全新】核心函数：更新用户余额并记录一笔交易
 * @param {number} amount - 交易金额 (正数为收入, 负数为支出)
 * @param {string} description - 交易描述 (例如: "转账给 XX", "收到 XX 的红包")
 */
async function updateUserBalanceAndLogTransaction(amount, description) {
    if (isNaN(amount)) return; // 安全检查

    // 确保余额是数字
    state.globalSettings.userBalance = (state.globalSettings.userBalance || 0) + amount;

    const newTransaction = {
        type: amount > 0 ? 'income' : 'expense',
        amount: Math.abs(amount),
        description: description,
        timestamp: Date.now()
    };

    // 使用数据库事务，确保两步操作要么都成功，要么都失败
    await db.transaction('rw', db.globalSettings, db.userWalletTransactions, async () => {
        await db.globalSettings.put(state.globalSettings);
        await db.userWalletTransactions.add(newTransaction);
    });
    
    console.log(`用户钱包已更新: 金额=${amount.toFixed(2)}, 新余额=${state.globalSettings.userBalance.toFixed(2)}`);
}

/**
 * 【全新】渲染“我的”页面的余额和交易明细
 */
async function renderBalanceDetails() {
    // 1. 渲染当前余额
    const balance = state.globalSettings.userBalance || 0;
    document.getElementById('user-balance-display').textContent = `¥ ${balance.toFixed(2)}`;

    // 2. 渲染交易明细列表
    const listEl = document.getElementById('balance-details-list');
    listEl.innerHTML = ''; // 清空旧列表

    const transactions = await db.userWalletTransactions.reverse().sortBy('timestamp');

    if (transactions.length === 0) {
        listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary); margin-top: 20px;">还没有任何明细记录</p>';
        return;
    }
    
    // 给列表加个标题
    listEl.innerHTML = '<h3 style="margin-bottom: 10px; color: var(--text-secondary);">余额明细</h3>';

    transactions.forEach(item => {
        const itemEl = document.createElement('div');
        itemEl.className = 'transaction-item';
        const sign = item.type === 'income' ? '+' : '-';
        
        itemEl.innerHTML = `
            <div class="transaction-info">
                <div class="description">${item.description}</div>
                <div class="timestamp">${new Date(item.timestamp).toLocaleString()}</div>
            </div>
            <div class="transaction-amount ${item.type}">
                ${sign} ${item.amount.toFixed(2)}
            </div>
        `;
        listEl.appendChild(itemEl);
    });
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲
// ▼▼▼ 在 init() 函数的上方，粘贴下面这 3 个新函数 ▼▼▼

/**
 * 【全新】打开物流详情页面
 * @param {number} orderId - 被点击的订单ID
 */
async function openLogisticsView(orderId) {
    const order = await db.taobaoOrders.get(orderId);
    if (!order) {
        alert("找不到该订单！");
        return;
    }

    // 每次打开都先清空旧的计时器
    logisticsUpdateTimers.forEach(timerId => clearTimeout(timerId));
    logisticsUpdateTimers = [];

    // 显示物流页面，并开始渲染
    showScreen('logistics-screen');
    await renderLogisticsView(order);
}

/**
 * 【全新】渲染物流详情页面的所有内容
 * @param {object} order - 订单对象
 */
async function renderLogisticsView(order) {
    const contentArea = document.getElementById('logistics-content-area');
    contentArea.innerHTML = '加载中...';

    const product = await db.taobaoProducts.get(order.productId);
    if (!product) {
        contentArea.innerHTML = '无法加载商品信息。';
        return;
    }

    // 渲染顶部的商品信息卡片
    contentArea.innerHTML = `
        <div class="logistics-product-summary">
            <img src="${product.imageUrl}" class="product-image">
            <div class="info">
                <div class="name">${product.name} (x${order.quantity})</div>
                <div class="status" id="logistics-main-status">查询中...</div>
            </div>
        </div>
        <div class="logistics-timeline" id="logistics-timeline-container"></div>
    `;

    const timelineContainer = document.getElementById('logistics-timeline-container');
    const mainStatusEl = document.getElementById('logistics-main-status');
    const creationTime = order.timestamp; // 使用订单的创建时间作为起点

    // 准备一些随机城市名，让物流看起来更真实
    const cities = ["东莞", "广州", "长沙", "武汉", "郑州", "北京", "上海", "成都", "西安"];
    const startCity = getRandomItem(cities);
    let nextCity = getRandomItem(cities.filter(c => c !== startCity));
    const userCity = getRandomItem(cities.filter(c => c !== startCity && c !== nextCity)) || '您的城市';
    
    // --- 这就是模拟物流的核心 ---
    let cumulativeDelay = 0;
    logisticsTimelineTemplate.forEach(stepInfo => {
        cumulativeDelay += stepInfo.delay;
        const eventTime = creationTime + cumulativeDelay; // 计算出这个步骤“应该”发生的时间
        const now = Date.now();

        // 替换文本中的占位符
        const stepText = stepInfo.text.replace(/{city}/g, startCity).replace('{next_city}', nextCity).replace('{user_city}', userCity);

        // 如果这个步骤的发生时间已经过去或就是现在
        if (now >= eventTime) {
            // 就立即把它渲染到页面上
            addLogisticsStep(timelineContainer, mainStatusEl, stepText, eventTime, true);
        } else {
            // 否则，它就是一个“未来”的步骤
            const delayUntilEvent = eventTime - now; // 计算还有多久才发生
            // 设置一个定时器，在未来的那个时间点执行
            const timerId = setTimeout(() => {
                // 执行前再次检查用户是否还停留在物流页面
                if (document.getElementById('logistics-screen').classList.contains('active')) {
                    addLogisticsStep(timelineContainer, mainStatusEl, stepText, eventTime, true);
                }
            }, delayUntilEvent);
            // 把这个定时器的ID存起来，方便离开页面时清除
            logisticsUpdateTimers.push(timerId);
        }
    });

    // 如果订单刚刚创建，可能还没有任何步骤满足时间条件，此时手动显示第一条
    if (timelineContainer.children.length === 0) {
        const firstStep = logisticsTimelineTemplate[0];
        const stepText = firstStep.text.replace(/{city}/g, startCity).replace('{next_city}', nextCity).replace('{user_city}', userCity);
        addLogisticsStep(timelineContainer, mainStatusEl, stepText, creationTime, true);
    }
}

/**
 * 【全新】在时间轴上添加一个物流步骤的辅助函数
 * @param {HTMLElement} container - 时间轴的DOM容器
 * @param {HTMLElement} mainStatusEl - 顶部主状态的DOM元素
 * @param {string} text - 物流信息文本
 * @param {number} timestamp - 该步骤发生的时间戳
 * @param {boolean} prepend - 是否添加到最前面（最新的步骤放前面）
 */
function addLogisticsStep(container, mainStatusEl, text, timestamp, prepend = false) {
    const stepEl = document.createElement('div');
    stepEl.className = 'logistics-step';
    stepEl.innerHTML = `
        <div class="logistics-step-content">
            <div class="status-text">${text}</div>
            <div class="timestamp">${new Date(timestamp).toLocaleString('zh-CN')}</div>
        </div>
    `;

    if (prepend) {
        container.prepend(stepEl); // 插入到最前面
        mainStatusEl.textContent = text; // 更新顶部的状态
    } else {
        container.appendChild(stepEl);
    }
}
// ▲▲▲ 粘贴结束 ▲▲▲
// ▼▼▼ 把这一整块全新的功能函数，粘贴到 init() 函数的正上方 ▼▼▼

/**
 * 【全新】处理角色手机钱包余额和交易记录的通用函数
 * @param {string} charId - 要更新钱包的角色ID
 * @param {number} amount - 交易金额 (正数为收入, 负数为支出)
 * @param {string} description - 交易描述
 */
async function updateCharacterPhoneBankBalance(charId, amount, description) {
    const chat = state.chats[charId];
    if (!chat || chat.isGroup) return;

    if (!chat.characterPhoneData) chat.characterPhoneData = {};
    if (!chat.characterPhoneData.bank) chat.characterPhoneData.bank = { balance: 0, transactions: [] };
    if (typeof chat.characterPhoneData.bank.balance !== 'number') chat.characterPhoneData.bank.balance = 0;

    chat.characterPhoneData.bank.balance += amount;

    const newTransaction = {
        type: amount > 0 ? '收入' : '支出',
        amount: Math.abs(amount),
        description: description,
        timestamp: Date.now()
    };
    
    // 让最新的交易记录显示在最前面
    if (!Array.isArray(chat.characterPhoneData.bank.transactions)) {
        chat.characterPhoneData.bank.transactions = [];
    }
    chat.characterPhoneData.bank.transactions.unshift(newTransaction);

    await db.chats.put(chat);
    console.log(`✅ 角色[${chat.name}]钱包已更新: 金额=${amount.toFixed(2)}, 新余额=${chat.characterPhoneData.bank.balance.toFixed(2)}`);
}

/**
 * 【全新】打开一个单选的角色选择器，让用户选择一个代付对象
 * @returns {Promise<string|null>} - 返回选中的角色ID，如果取消则返回null
 */
async function openCharSelectorForCart() {
    return new Promise(resolve => {
        // 复用分享功能的弹窗，很方便
        const modal = document.getElementById('share-target-modal');
        const listEl = document.getElementById('share-target-list');
        const titleEl = document.getElementById('share-target-modal-title');
        const confirmBtn = document.getElementById('confirm-share-target-btn');
        const cancelBtn = document.getElementById('cancel-share-target-btn');

        titleEl.textContent = '分享给谁代付？';
        listEl.innerHTML = '';

        const singleChats = Object.values(state.chats).filter(c => !c.isGroup);

        if (singleChats.length === 0) {
            alert("你还没有任何可以分享的好友哦。");
            modal.classList.remove('visible');
            resolve(null);
            return;
        }

        // 使用 radio 单选按钮
        singleChats.forEach(chat => {
            const item = document.createElement('div');
            item.className = 'contact-picker-item';
            item.innerHTML = `
                <input type="radio" name="cart-share-target" value="${chat.id}" id="target-${chat.id}" style="margin-right: 15px;">
                <label for="target-${chat.id}" style="display:flex; align-items:center; width:100%; cursor:pointer;">
                    <img src="${chat.settings.aiAvatar || defaultAvatar}" class="avatar">
                    <span class="name">${chat.name}</span>
                </label>
            `;
            listEl.appendChild(item);
        });

        modal.classList.add('visible');

        const newConfirmBtn = confirmBtn.cloneNode(true);
        confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
        const newCancelBtn = cancelBtn.cloneNode(true);
        cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
        
        const cleanup = () => modal.classList.remove('visible');

        newConfirmBtn.onclick = () => {
            const selectedRadio = document.querySelector('input[name="cart-share-target"]:checked');
            if (selectedRadio) {
                cleanup();
                resolve(selectedRadio.value);
            } else {
                alert("请选择一个代付对象！");
            }
        };

        newCancelBtn.onclick = () => {
            cleanup();
            resolve(null);
        };
    });
}

/**
 * 【全新】清空桃宝购物车
 */
async function clearTaobaoCart() {
    await db.taobaoCart.clear();
    await renderTaobaoCart();
    updateCartBadge();
}

/**
 * 【全新】根据购物车内容创建订单
 * @param {Array} cartItems - 购物车项目数组
 */
async function createOrdersFromCart(cartItems) {
    if (!cartItems || cartItems.length === 0) return;
    const newOrders = cartItems.map((item, index) => ({
        productId: item.productId,
        quantity: item.quantity,
        timestamp: Date.now() + index, // 防止时间戳完全相同
        status: '已付款，等待发货'
    }));
    await db.taobaoOrders.bulkAdd(newOrders);
    // 简单模拟物流更新
    setTimeout(async () => {
        const ordersToUpdate = await db.taobaoOrders.where('status').equals('已付款，等待发货').toArray();
        for (const order of ordersToUpdate) {
            await db.taobaoOrders.update(order.id, { status: '已发货，运输中' });
        }
    }, 1000 * 10);
}

// ▼▼▼ 请用下面这整块【修复后】的代码，完整替换掉你旧的 handleShareCart 函数 ▼▼▼

/**
 * 【全新总入口 | 已修复备注名】处理“分享给Ta代付”的全部逻辑
 */
async function handleShareCart() {
    const cartItems = await db.taobaoCart.toArray();
    if (cartItems.length === 0) {
        alert("购物车是空的，先去加点宝贝吧！");
        return;
    }

    const targetChatId = await openCharSelectorForCart();
    if (!targetChatId) return;

    const char = state.chats[targetChatId];
    if (!char) return;

    let totalPrice = 0;
    const productPromises = cartItems.map(item => db.taobaoProducts.get(item.productId));
    const products = await Promise.all(productPromises);
    cartItems.forEach((item, index) => {
        const product = products[index];
        if (product) {
            totalPrice += product.price * item.quantity;
        }
    });

    const charBalance = char.characterPhoneData?.bank?.balance || 0;
    if (charBalance < totalPrice) {
        await showCustomAlert("代付失败", `“${char.name}”的钱包余额不足！\n需要 ¥${totalPrice.toFixed(2)}，但余额只有 ¥${charBalance.toFixed(2)}。`);
        return;
    }
    
    const confirmed = await showCustomConfirm(
        '确认代付',
        `将分享购物车给“${char.name}”并请求代付，共计 ¥${totalPrice.toFixed(2)}。\n这将会清空你的购物车，并从Ta的钱包扣款。确定吗？`,
        { confirmText: '确定' }
    );

    if (!confirmed) return;
    
    await showCustomAlert("处理中...", "正在通知Ta代付并下单...");
    
    // --- ▼▼▼ 这就是本次的核心修改 ▼▼▼ ---

    // 1. 获取角色的手机数据，准备查找备注名
    const characterPhoneData = char.characterPhoneData || { chats: {} };
    
    // 2. 在角色的联系人中，找到代表“用户”的那个联系人对象
    //    （通常是那个没有聊天记录的特殊联系人条目）
    const userContactInData = Object.values(characterPhoneData.chats || {}).find(c => !c.history || c.history.length === 0);
    
    // 3. 获取角色给用户的备注名，如果没设置，就默认用“我”
    const remarkForUser = userContactInData ? userContactInData.remarkName : '我';
    
    // 4. 使用这个新的备注名来创建交易记录
    const description = `为“${remarkForUser}”的桃宝购物车买单`;
    await updateCharacterPhoneBankBalance(targetChatId, -totalPrice, description);
    
    // --- ▲▲▲ 修改结束 ▲▲▲ ---

    await createOrdersFromCart(cartItems);

    const itemsSummary = products.map((p, i) => `${p.name} x${cartItems[i].quantity}`).join('、 ');
    
    // 给AI看的隐藏指令，告诉它发生了什么
    const hiddenMessage = {
        role: 'system',
        content: `[系统提示：用户刚刚与你分享了TA的购物车，并请求你为总价为 ¥${totalPrice.toFixed(2)} 的商品付款。你已经同意并支付了，你的钱包余额已被扣除。商品包括：${itemsSummary}。请根据你的人设对此作出回应，例如表示宠溺、抱怨花钱太多或者询问买了什么。]`,
        timestamp: Date.now(),
        isHidden: true
    };
    char.history.push(hiddenMessage);
    await db.chats.put(char);

    await clearTaobaoCart();

    await showCustomAlert("操作成功", `“${char.name}”已成功为你买单！`);
    renderChatList();
    
    openChat(targetChatId); // 跳转到聊天界面
    triggerAiResponse(); // 让AI回应这次代付
}

// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 把下面这两块全新的函数，粘贴到你的JS功能函数定义区 ▼▼▼

/**
 * 【全新】处理“为Ta购买”的全部逻辑
 */
async function handleBuyForChar() {
    const cartItems = await db.taobaoCart.toArray();
    if (cartItems.length === 0) {
        alert("购物车是空的，先去加点宝贝吧！");
        return;
    }

    const targetChatId = await openCharSelectorForCart();
    if (!targetChatId) return; // 用户取消选择

    const char = state.chats[targetChatId];
    if (!char) return;

    let totalPrice = 0;
    const productPromises = cartItems.map(item => db.taobaoProducts.get(item.productId));
    const products = await Promise.all(productPromises);
    products.forEach((product, index) => {
        if (product) {
            totalPrice += product.price * cartItems[index].quantity;
        }
    });

    // 检查用户余额
    if ((state.globalSettings.userBalance || 0) < totalPrice) {
        alert(`余额不足！本次需要 ¥${totalPrice.toFixed(2)}，但你的余额只有 ¥${(state.globalSettings.userBalance || 0).toFixed(2)}。`);
        return;
    }

    const confirmed = await showCustomConfirm(
        '确认赠送',
        `确定要花费 ¥${totalPrice.toFixed(2)} 为“${char.name}”购买购物车中的所有商品吗？`,
        { confirmText: '为Ta买单' }
    );

    if (confirmed) {
        await showCustomAlert("正在处理...", "正在为你心爱的Ta下单...");

        // 1. 扣除用户余额
        await updateUserBalanceAndLogTransaction(-totalPrice, `为 ${char.name} 购买商品`);
        
        // 2. 将购物车内容转化为订单（记录在你的订单里）
        await createOrdersFromCart(cartItems);

        // 3. 发送礼物通知给对方
        await sendGiftNotificationToChar(targetChatId, products, cartItems, totalPrice);
        
        // 4. 清空购物车
        await clearTaobaoCart();

        await showCustomAlert("赠送成功！", `你为“${char.name}”购买的礼物已下单，并已通过私信通知对方啦！`);
        renderChatList(); // 刷新列表，显示未读消息
    }
}

// ▼▼▼ 用这块【新代码】替换旧的 sendGiftNotificationToChar 函数 ▼▼▼
// ▼▼▼ 把下面这两块全新的函数，粘贴到你的JS功能函数定义区 ▼▼▼

/**
 * 【全新】处理“为Ta购买”的全部逻辑
 */
async function handleBuyForChar() {
    const cartItems = await db.taobaoCart.toArray();
    if (cartItems.length === 0) {
        alert("购物车是空的，先去加点宝贝吧！");
        return;
    }

    const targetChatId = await openCharSelectorForCart();
    if (!targetChatId) return; // 用户取消选择

    const char = state.chats[targetChatId];
    if (!char) return;

    let totalPrice = 0;
    const productPromises = cartItems.map(item => db.taobaoProducts.get(item.productId));
    const products = await Promise.all(productPromises);
    products.forEach((product, index) => {
        if (product) {
            totalPrice += product.price * cartItems[index].quantity;
        }
    });

    // 检查用户余额
    if ((state.globalSettings.userBalance || 0) < totalPrice) {
        alert(`余额不足！本次需要 ¥${totalPrice.toFixed(2)}，但你的余额只有 ¥${(state.globalSettings.userBalance || 0).toFixed(2)}。`);
        return;
    }

    const confirmed = await showCustomConfirm(
        '确认赠送',
        `确定要花费 ¥${totalPrice.toFixed(2)} 为“${char.name}”购买购物车中的所有商品吗？`,
        { confirmText: '为Ta买单' }
    );

    if (confirmed) {
        await showCustomAlert("正在处理...", "正在为你心爱的Ta下单...");

        // 1. 扣除用户余额
        await updateUserBalanceAndLogTransaction(-totalPrice, `为 ${char.name} 购买商品`);
        
        // 2. 将购物车内容转化为订单（记录在你的订单里）
        await createOrdersFromCart(cartItems);

        // 3. 发送礼物通知给对方
        await sendGiftNotificationToChar(targetChatId, products, cartItems, totalPrice);
        
        // 4. 清空购物车
        await clearTaobaoCart();

        await showCustomAlert("赠送成功！", `你为“${char.name}”购买的礼物已下单，并已通过私信通知对方啦！`);
        renderChatList(); // 刷新列表，显示未读消息
    }
}

// ▼▼▼ 用这块【最终正确版】代码，完整替换旧的 sendGiftNotificationToChar 函数 ▼▼▼

/**
 * 【全新 | 最终正确版】发送礼物通知到指定角色的聊天
 * 效果：发送一条本质是文本、但外观是卡片的消息。
 *      - 用户界面显示为漂亮的礼物卡片。
 *      - 消息数据中包含完整的文本信息。
 *      - AI 仍然通过隐藏的系统指令接收信息。
 */
async function sendGiftNotificationToChar(targetChatId, products, cartItems, totalPrice) {
    const chat = state.chats[targetChatId];
    if (!chat) return;

    const itemsSummary = products.map((p, i) => `${p.name} x${cartItems[i].quantity}`).join('、');
    
    // 1. 【核心】先准备好这条消息的“文本内容”
    const messageTextContent = `我给你买了新礼物，希望你喜欢！\n商品清单：${itemsSummary}\n合计：¥${totalPrice.toFixed(2)}`;

    // 2. 创建对用户【可见】的消息对象。现在它同时拥有 “文本内容” 和 “卡片样式指令”
    const visibleMessage = {
        role: 'user',
        
        // 【核心修改】为这条消息添加一个 content 属性，这就是它的“文本本体”
        // 当你复制这条消息时，复制出来的内容就是这个。
        content: messageTextContent, 
        
        // 同时保留 type 和 payload，它们告诉渲染器“把这条消息画成卡片”
        type: 'gift_notification', 
        timestamp: Date.now(),
        payload: {
            senderName: state.qzoneSettings.nickname || '我',
            itemSummary: itemsSummary,
            totalPrice: totalPrice,
            itemCount: cartItems.length,
        }
    };
    chat.history.push(visibleMessage);

    // 3. 【这部分不变】创建一条给AI看的【隐藏】指令，确保AI能理解并回应
    const hiddenMessage = {
        role: 'system',
        content: `[系统指令：用户刚刚为你购买了${cartItems.length}件商品，总价值为${totalPrice.toFixed(2)}元。商品包括：${itemsSummary}。请根据你的人设对此表示感谢或作出其他反应。]`,
        timestamp: Date.now() + 1,
        isHidden: true
    };
    chat.history.push(hiddenMessage);

    // 4. 【这部分不变】未读消息只增加1条
    chat.unreadCount = (chat.unreadCount || 0) + 1;
    await db.chats.put(chat);
    
    // 5. 【这部分不变】发送横幅通知
    if (state.activeChatId !== targetChatId) {
        showNotification(targetChatId, '你收到了一份礼物！');
    }
}
// ▲▲▲ 替换结束 ▲▲▲




// ▼▼▼ 【全新】购物车代付功能核心函数 ▼▼▼

/**
 * 【全新总入口 | 无隐藏消息版】处理用户点击“分享给Ta代付”按钮的逻辑
 */
async function handleShareCartRequest() {
    const cartItems = await db.taobaoCart.toArray();
    if (cartItems.length === 0) {
        alert("购物车是空的，先去加点宝贝吧！");
        return;
    }

    const targetChatId = await openCharSelectorForCart();
    if (!targetChatId) return;

    const chat = state.chats[targetChatId];
    if (!chat) return;

    let totalPrice = 0;
    const productPromises = cartItems.map(item => db.taobaoProducts.get(item.productId));
    const products = await Promise.all(productPromises);
    const itemsSummary = products.map((p, i) => {
        if(p) {
            totalPrice += p.price * cartItems[i].quantity;
            return `${p.name} x${cartItems[i].quantity}`;
        }
        return '';
    }).filter(Boolean).join('、 ');
    
    const charBalance = chat.characterPhoneData?.bank?.balance || 0;

    const confirmed = await showCustomConfirm(
        '确认代付请求',
        `将向“${chat.name}”发起购物车代付请求，共计 ¥${totalPrice.toFixed(2)}。`,
        { confirmText: '发送请求' }
    );

    if (!confirmed) return;

    // --- ▼▼▼【核心修改】在这里，我们只创建一条消息 ▼▼▼ ---
    
    // 1. 直接将所有信息都放入 content 字段，让用户也能看到
    const requestContent = `[购物车代付请求]
总金额: ¥${totalPrice.toFixed(2)}
商品: ${itemsSummary}
(你的当前余额: ¥${charBalance.toFixed(2)})
请使用 'cart_payment_response' 指令回应。`;

    // 2. 创建一条普通的用户消息，不再有 isHidden 标记
    const requestMessage = {
        role: 'user', // 由用户发出
        type: 'cart_share_request', // 类型保持不变，用于UI渲染
        timestamp: Date.now(),
        content: requestContent, // 将包含所有信息的文本作为内容
        payload: { // payload 依然保留，用于UI渲染卡片
            totalPrice: totalPrice,
            itemCount: cartItems.length,
            status: 'pending' 
        }
    };
    
    // 3. 将这条【单一的】消息添加到历史记录
    chat.history.push(requestMessage);

    // --- ▲▲▲ 修改结束 ▲▲▲ ---

    await db.chats.put(chat);
    
    await showCustomAlert("请求已发送", `已将代付请求发送给“${chat.name}”，请在聊天中查看TA的回应。`);
    
    openChat(targetChatId);
}


/**
 * 【辅助函数】打开一个单选的角色选择器，让用户选择代付对象
 * (这个函数复用了分享功能的弹窗，稍作修改)
 */
async function openCharSelectorForCart() {
    return new Promise(resolve => {
        const modal = document.getElementById('share-target-modal');
        const listEl = document.getElementById('share-target-list');
        const titleEl = document.getElementById('share-target-modal-title');
        const confirmBtn = document.getElementById('confirm-share-target-btn');
        const cancelBtn = document.getElementById('cancel-share-target-btn');

        titleEl.textContent = '分享给谁代付？';
        listEl.innerHTML = '';

        const singleChats = Object.values(state.chats).filter(c => !c.isGroup);

        if (singleChats.length === 0) {
            alert("你还没有任何可以分享的好友哦。");
            modal.classList.remove('visible');
            resolve(null);
            return;
        }

        // 使用 radio 单选按钮
        singleChats.forEach(chat => {
            const item = document.createElement('div');
            item.className = 'contact-picker-item';
            item.innerHTML = `
                <input type="radio" name="cart-share-target" value="${chat.id}" id="target-${chat.id}" style="margin-right: 15px;">
                <label for="target-${chat.id}" style="display:flex; align-items:center; width:100%; cursor:pointer;">
                    <img src="${chat.settings.aiAvatar || defaultAvatar}" class="avatar">
                    <span class="name">${chat.name}</span>
                </label>
            `;
            listEl.appendChild(item);
        });

        modal.classList.add('visible');

        const newConfirmBtn = confirmBtn.cloneNode(true);
        confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
        const newCancelBtn = cancelBtn.cloneNode(true);
        cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
        
        const cleanup = () => modal.classList.remove('visible');

        newConfirmBtn.onclick = () => {
            const selectedRadio = document.querySelector('input[name="cart-share-target"]:checked');
            if (selectedRadio) {
                cleanup();
                resolve(selectedRadio.value);
            } else {
                alert("请选择一个代付对象！");
            }
        };

        newCancelBtn.onclick = () => {
            cleanup();
            resolve(null);
        };
    });
}

/**
 * 【辅助函数】清空用户的桃宝购物车
 */
async function clearTaobaoCart() {
    await db.taobaoCart.clear();
    updateCartBadge();
    // 如果用户正好在看购物车，就刷新一下
    if (document.getElementById('cart-view').classList.contains('active')) {
        renderTaobaoCart();
    }
}

/**
 * 【辅助函数】根据购物车内容创建订单
 * @param {Array} cartItems - 从数据库读出的购物车项目数组
 */
async function createOrdersFromCart(cartItems) {
    if (!cartItems || cartItems.length === 0) return;
    const newOrders = cartItems.map((item, index) => ({
        productId: item.productId,
        quantity: item.quantity,
        timestamp: Date.now() + index, // 防止时间戳完全相同
        status: '已付款，等待发货'
    }));
    await db.taobaoOrders.bulkAdd(newOrders);
    
    // 模拟10秒后自动发货
    setTimeout(async () => {
        const orderIds = newOrders.map(order => order.timestamp);
        const ordersToUpdate = await db.taobaoOrders.where('timestamp').anyOf(orderIds).toArray();
        for (const order of ordersToUpdate) {
            await db.taobaoOrders.update(order.id, { status: '已发货，运输中' });
        }
        console.log(`${ordersToUpdate.length} 个新订单状态已更新为“已发货”。`);
    }, 1000 * 10);
}

// ▲▲▲ 新功能函数结束 ▲▲▲

/* --- “桃宝”App 功能函数结束 --- */
// ▼▼▼ 【全新】这是角色手机外观设置的所有核心函数，请粘贴到JS功能区 ▼▼▼

/**
 * 【总入口】打开角色手机的外观设置页面
 */
function openCharPhoneAppearanceSettings() {
    renderCharPhoneAppearanceScreen(); // 渲染页面内容
    showCharacterPhonePage('character-phone-appearance-screen'); // 显示页面
    loadCharPhonePresetsToDropdown();
}

/**
 * 【全新 | 已修复】渲染角色手机的外观设置页面
 */
function renderCharPhoneAppearanceScreen() {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    if (!chat) return;

    // --- 渲染壁纸预览 (逻辑不变) ---
    const wallpaperPreview = document.getElementById('char-phone-wallpaper-preview');
    const wallpaperUrl = chat.characterPhoneData.wallpaper || '';
    if (wallpaperUrl) {
        wallpaperPreview.style.backgroundImage = `url(${wallpaperUrl})`;
        wallpaperPreview.textContent = '';
    } else {
        wallpaperPreview.style.backgroundImage = 'none';
        wallpaperPreview.textContent = '暂无壁纸';
    }
// --- 渲染App内壁纸预览 ---
const appWallpaperPreview = document.getElementById('char-phone-app-wallpaper-preview');
const appWallpaperUrl = newAppWallpaperBase64 || chat.characterPhoneData.appWallpaper || '';
if (appWallpaperUrl) {
    appWallpaperPreview.style.backgroundImage = `url(${appWallpaperUrl})`;
    appWallpaperPreview.textContent = '';
} else {
    appWallpaperPreview.style.backgroundImage = 'none';
    appWallpaperPreview.textContent = '点击下方上传';
}
// --- App内壁纸预览渲染结束 ---
    // --- 渲染App图标设置列表 (核心修复) ---
    const iconGrid = document.getElementById('char-phone-icon-settings-grid');
    iconGrid.innerHTML = '';
    const customIcons = chat.characterPhoneData.appIcons || {};

    // ★★★ 我们已经把那行碍事的 `if (app.id === 'appearance') continue;` 删掉了！★★★
    CHAR_PHONE_APPS.forEach(app => {
        const customIconUrl = customIcons[app.id];
        // 使用默认图标作为备用
        const currentIconUrl = customIconUrl || (DEFAULT_APP_ICONS[app.id] || '');
        const currentIconHtml = currentIconUrl ? `<img src="${currentIconUrl}" style="width:100%; height:100%; object-fit:cover;">` : app.svg;
        
        const itemEl = document.createElement('div');
        itemEl.className = 'icon-setting-item'; 
        itemEl.dataset.iconId = app.id; 
        itemEl.innerHTML = `
            <div class="icon-preview" style="width: 50px; height: 50px; border-radius: 12px; display: flex; justify-content: center; align-items: center; padding: 8px; background: #f0f2f5;">
                ${currentIconHtml}
            </div>
            <span style="font-size: 13px;">${app.name}</span>
            <button class="change-icon-btn" data-icon-id="${app.id}" style="padding: 4px 10px; font-size: 12px; border: 1px solid #ccc; background-color: #f0f0f0; border-radius: 5px; cursor: pointer;">更换</button>
        `;
        iconGrid.appendChild(itemEl);
    });
    
    // --- 渲染小组件预览 (逻辑不变) ---
    const widgets = chat.characterPhoneData.widgets || {};
    const widgetPreview1 = document.getElementById('char-phone-widget-preview-1');
    const widgetPreview2 = document.getElementById('char-phone-widget-preview-2');

    if (widgets.widget1_url) {
        widgetPreview1.style.backgroundImage = `url(${widgets.widget1_url})`;
        widgetPreview1.textContent = '';
    } else {
        widgetPreview1.style.backgroundImage = 'none';
        widgetPreview1.textContent = '点击上传';
    }
    
    if (widgets.widget2_url) {
        widgetPreview2.style.backgroundImage = `url(${widgets.widget2_url})`;
        widgetPreview2.textContent = '';
    } else {
        widgetPreview2.style.backgroundImage = 'none';
        widgetPreview2.textContent = '点击上传';
    }
}



/**
 * 处理角色手机壁纸的更换和移除
 * @param {string} newUrl - 新的壁纸URL，如果为空字符串则表示移除
 */
async function handleCharPhoneWallpaperChange(newUrl) {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    
    chat.characterPhoneData.wallpaper = newUrl;
    await db.chats.put(chat);
    
    // 立即应用壁纸到角色手机主屏幕
    const phoneScreen = document.getElementById('character-phone-screen');
    if (newUrl) {
        phoneScreen.style.backgroundImage = `url(${newUrl})`;
        phoneScreen.style.backgroundColor = 'transparent';
    } else {
        phoneScreen.style.backgroundImage = 'none';
        const isDarkMode = document.getElementById('phone-screen').classList.contains('dark-mode');
        phoneScreen.style.backgroundColor = isDarkMode ? '#000' : '#f0f2f5';
    }
    
    // 刷新设置页面的预览
    renderCharPhoneAppearanceScreen();
    alert(newUrl ? '壁纸已更新！' : '壁纸已移除！');
}

/**
 * 处理角色手机App图标的更换
 * @param {string} iconId - 要更换的App的ID
 */
async function handleChangeCharPhoneIcon(iconId) {
    if (!activeCharacterPhoneId) return;
    
    const choice = await showChoiceModal("更换图标", [
        { text: '📁 从本地上传', value: 'local' },
        { text: '🌐 使用网络URL', value: 'url' },
        { text: '🔄 恢复默认', value: 'reset' }
    ]);

    let newIconUrl = null;

    if (choice === 'local') {
        newIconUrl = await uploadImageLocally();
    } else if (choice === 'url') {
        newIconUrl = await showCustomPrompt("图标URL", "请输入图片链接");
    } else if (choice === 'reset') {
        const chat = state.chats[activeCharacterPhoneId];
        if (chat.characterPhoneData.appIcons && chat.characterPhoneData.appIcons[iconId]) {
            delete chat.characterPhoneData.appIcons[iconId];
            await db.chats.put(chat);
            renderCharPhoneAppearanceScreen();
            renderCharacterAppGrid();
            alert('图标已恢复默认。');
        }
        return;
    }

    if (newIconUrl && newIconUrl.trim()) {
        const chat = state.chats[activeCharacterPhoneId];
        if (!chat.characterPhoneData.appIcons) {
            chat.characterPhoneData.appIcons = {};
        }
        chat.characterPhoneData.appIcons[iconId] = newIconUrl.trim();
        await db.chats.put(chat);
        
        renderCharPhoneAppearanceScreen(); // 刷新设置页面
        renderCharacterAppGrid(); // 刷新主屏幕
        alert('图标已更新！');
    }
}

// ▲▲▲ 新增函数粘贴结束 ▲▲▲
// ▼▼▼ 把这一整块全新的功能函数，粘贴到 init() 函数的上方 ▼▼▼

let currentViewingWeiboProfileId = null; // 全局变量，记录正在查看哪个角色的主页

/**
 * 【全新】打开指定角色的微博主页
 * @param {string} charId - 要查看的角色的ID
 */
async function openWeiboCharProfile(charId) {
    currentViewingWeiboProfileId = charId;
    const chat = state.chats[charId];
    if (!chat) return;

    // 渲染角色主页内容
    await renderWeiboCharProfile(charId);
    
    // 渲染该角色的微博Feed
    await renderCharSpecificFeed(charId);

    // 切换到角色主页屏幕
    showScreen('weibo-char-profile-screen');
    
    // 隐藏关注列表弹窗（如果它还开着）
    document.getElementById('weibo-following-modal').classList.remove('visible');
}

/**
 * 【全新】渲染角色微博主页的个人资料部分 (V2 - 支持粉丝/关注数)
 * @param {string} charId - 角色的ID
 */
async function renderWeiboCharProfile(charId) {
    const chat = state.chats[charId];
    if (!chat) return;

    // 渲染基础信息（这部分不变）
    document.getElementById('weibo-char-profile-title').textContent = `${chat.name}的主页`;
    document.getElementById('weibo-char-avatar-img').src = chat.settings.weiboAvatar || chat.settings.aiAvatar;
    document.getElementById('weibo-char-nickname').textContent = chat.settings.weiboNickname || chat.name;
    document.getElementById('weibo-char-background-img').src = chat.settings.weiboBackground;
    document.getElementById('weibo-char-profession-display').textContent = chat.settings.weiboProfession || '职业未设定';
    
    // --- ▼▼▼ 这就是我们新增的核心逻辑 ▼▼▼ ---

    // 1. 从设置中读取关注数和粉丝数
    document.getElementById('weibo-char-following-count').textContent = chat.settings.weiboFollowingCount || '0';
    document.getElementById('weibo-char-fans-count').textContent = chat.settings.weiboFansCount || '0';

    // 2. 动态计算并显示微博数
    const postCount = await db.weiboPosts.where('authorId').equals(charId).count();
    document.getElementById('weibo-char-posts-count').textContent = postCount;
    
    // --- ▲▲▲ 新增逻辑结束 ▲▲▲ ---

    // 渲染头像框 (这部分不变)
    const frameImg = document.getElementById('weibo-char-avatar-frame');
    const frameUrl = chat.settings.weiboAvatarFrame || '';
    if (frameUrl) {
        frameImg.src = frameUrl;
        frameImg.style.display = 'block';
    } else {
        frameImg.style.display = 'none';
    }
}


/**
 * 【全新】渲染指定角色的微博Feed
 * @param {string} charId - 角色的ID
 */
async function renderCharSpecificFeed(charId) {
    const feedEl = document.getElementById('char-weibo-feed-list');
    feedEl.innerHTML = '';
    
    const posts = await db.weiboPosts.where('authorId').equals(charId).reverse().sortBy('timestamp');
    
    if (posts.length === 0) {
        feedEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">Ta 还没有发过微博哦。</p>';
        return;
    }

    posts.forEach(post => {
        // 复用我们强大的微博帖子创建函数
        feedEl.appendChild(createWeiboPostElement(post));
    });
}

/**
 * 【全新】打开角色微博资料的编辑器
 */
async function openCharWeiboEditor() {
    if (!currentViewingWeiboProfileId) return;
    const chat = state.chats[currentViewingWeiboProfileId];
    if (!chat) return;

    // 填充当前数据到编辑器
    document.getElementById('char-weibo-editor-avatar-preview').src = chat.settings.weiboAvatar || chat.settings.aiAvatar;
    document.getElementById('char-weibo-editor-nickname-input').value = chat.settings.weiboNickname || chat.name;
    document.getElementById('char-weibo-editor-bg-preview').src = chat.settings.weiboBackground;

    // 显示弹窗
    document.getElementById('char-weibo-editor-modal').classList.add('visible');
}

/**
 * 【全新】保存对角色微博资料的修改
 */
async function saveCharWeiboProfile() {
    if (!currentViewingWeiboProfileId) return;
    const chat = state.chats[currentViewingWeiboProfileId];
    if (!chat) return;

    // 从编辑器获取新数据
    chat.settings.weiboAvatar = document.getElementById('char-weibo-editor-avatar-preview').src;
    chat.settings.weiboNickname = document.getElementById('char-weibo-editor-nickname-input').value.trim();
    chat.settings.weiboBackground = document.getElementById('char-weibo-editor-bg-preview').src;

    // 保存到数据库
    await db.chats.put(chat);
    
    // 刷新主页显示
    await renderWeiboCharProfile(currentViewingWeiboProfileId);
    
    document.getElementById('char-weibo-editor-modal').classList.remove('visible');
    alert('角色微博资料已保存！');
}

// ▲▲▲ 新功能函数粘贴结束 ▲▲▲
// ▼▼▼ 在 const db = ... 的正上方，粘贴下面这一整块新代码 ▼▼▼

/**
 * 【全新】根据角色人设和职业，生成初始的微博关注数和粉丝数
 * @param {object} chat - 角色的聊天对象
 * @returns {{following: string, fans: string}}
 */
function getInitialWeiboStats(chat) {
    const persona = (chat.settings.aiPersona || '') + (chat.settings.weiboProfession || '');
    const keywords = ["偶像", "明星", "演员", "歌手", "博主", "网红", "UP主", "主播", "选手", "画家", "作家"];
    const isPublicFigure = keywords.some(keyword => persona.includes(keyword));

    let fansCount, followingCount;

    if (isPublicFigure) {
        fansCount = Math.floor(100000 + Math.random() * 9900000); // 10万 - 1000万
        followingCount = Math.floor(50 + Math.random() * 450); // 50 - 500
    } else {
        fansCount = Math.floor(100 + Math.random() * 4900); // 100 - 5000
        followingCount = Math.floor(50 + Math.random() * 250); // 50 - 300
    }

    return {
        fans: formatNumberToChinese(fansCount),
        following: formatNumberToChinese(followingCount)
    };
}

/**
 * 【全新】将数字格式化为带“万”或“亿”的字符串
 * @param {number} num - 原始数字
 * @returns {string} - 格式化后的字符串
 */
function formatNumberToChinese(num) {
    if (num >= 100000000) {
        return (num / 100000000).toFixed(1).replace(/\.0$/, '') + '亿';
    }
    if (num >= 10000) {
        return (num / 10000).toFixed(1).replace(/\.0$/, '') + '万';
    }
    return String(num);
}

// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 【最终修复版】用这整块代码，完整替换你旧的 playMinimaxAudio 函数 ▼▼▼
let isIntentionalStop = false;
// ▼▼▼ 步骤 1：添加或替换这两行代码 ▼▼▼
let isTtsPlaying = false; // 全局锁，true表示有语音正在播放或加载
let currentTtsAudioBubble = null; // 记录当前正在播放动画或音频的气泡元素
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 第1步：在这里粘贴下面这个【全新的】辅助函数 ▼▼▼
/**
 * 【全新】查找从指定位置开始的所有连续AI语音消息
 * @param {Array} history - 完整的聊天历史记录数组
 * @param {number} startIndex - 开始查找的索引位置
 * @returns {Array} - 一个包含所有连续AI语音消息对象的数组
 */
function findConsecutiveAiVoiceMessages(history, startIndex) {
    const messagesToPlay = [];
    if (startIndex < 0 || startIndex >= history.length) {
        return messagesToPlay;
    }

    // 从点击的那条消息开始，向后遍历
    for (let i = startIndex; i < history.length; i++) {
        const msg = history[i];
        // 检查这条消息是否是AI发送的，并且类型是语音
        if (msg.role === 'assistant' && msg.type === 'voice_message') {
            messagesToPlay.push(msg); // 如果是，就把它加入待播放列表
        } else {
            // 一旦遇到不是AI语音的消息（比如用户的回复，或AI的图片/文字消息），就立刻停止查找
            break;
        }
    }
    return messagesToPlay;
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲
// ▼▼▼ 第1步：在这里粘贴这个【全新的】停止函数 ▼▼▼

// ▼▼▼ 第2步：用这整块【V2 - 精准停止版】代码，完整替换旧的 stopMinimaxAudio 函数 ▼▼▼

/**
 * 【V2 - 精准停止版】停止当前正在播放的Minimax TTS语音
 */
function stopMinimaxAudio() {
    if (!isTtsPlaying) return;

    // 核心修改1：在执行停止操作前，先设置“故意停止”的标志为 true
    isIntentionalStop = true;

    const ttsPlayer = document.getElementById('tts-audio-player');
    ttsPlayer.pause();
    ttsPlayer.src = ''; // 这行代码会触发 onerror 事件

    if (window.currentAnimatingBubbles) {
        window.currentAnimatingBubbles.forEach(b => b.classList.remove('playing'));
    }

    isTtsPlaying = false;
    currentTtsAudioBubble = null;
    window.currentAnimatingBubbles = null;
    console.log('Minimax TTS: Playback stopped by user.');

    // 核心修改2：用一个微小的延迟来重置标志位
    // 这能确保 onerror 事件有足够的时间检查到标志位，然后再将其重置
    setTimeout(() => {
        isIntentionalStop = false;
    }, 100);
}

// ▲▲▲ 替换结束 ▲▲▲



// ▼▼▼ 第3步：用这整块【V8 - 错误处理终极版】代码，完整替换旧的 playMinimaxAudio 函数 ▼▼▼

// ▼▼▼ 用这块【新代码】替换旧的 playMinimaxAudio 函数 ▼▼▼
/**
 * 【V9 - 全局模型版】调用 Minimax TTS API 生成语音并播放
 * @param {string} text - 要转换为语音的合并后的文本
 * @param {string} voiceId - Minimax 的语音 ID
 * @param {Array<HTMLElement>} bubblesToAnimate - 需要播放动画的所有语音气泡元素的数组
 */
async function playMinimaxAudio(text, voiceId, bubblesToAnimate) {
    stopMinimaxAudio();
    await new Promise(resolve => setTimeout(resolve, 50));

    const ttsPlayer = document.getElementById('tts-audio-player');
    const firstBubble = bubblesToAnimate[0];

    isTtsPlaying = true;
    currentTtsAudioBubble = firstBubble;
    window.currentAnimatingBubbles = bubblesToAnimate;
    bubblesToAnimate.forEach(b => b.classList.add('playing'));

    const mainAudioPlayer = document.getElementById('audio-player');
    if (mainAudioPlayer && !mainAudioPlayer.paused) {
        mainAudioPlayer.pause();
        musicState.isPlaying = false;
        updatePlayerUI();
    }

    const groupId = state.apiConfig.minimaxGroupId;
    const apiKey = state.apiConfig.minimaxApiKey;
    if (!groupId || !apiKey) {
        await showCustomAlert('语音播放失败', '尚未配置Minimax的Group ID和API Key。');
        stopMinimaxAudio();
        return;
    }

    // ★★★ 核心修改：从全局 apiConfig 获取语音模型 ★★★
    const speechModel = state.apiConfig.minimaxSpeechModel || 'speech-01';
    console.log(`正在使用 Minimax 语音模型: ${speechModel}`);

    try {
        const response = await fetch(`https://api.minimax.chat/v1/text_to_speech?GroupId=${groupId}`, {
            method: 'POST',
            headers: { 'Authorization': `Bearer ${apiKey}`, 'Content-Type': 'application/json' },
            body: JSON.stringify({ 
                text: text, 
                voice_id: voiceId, 
                model: speechModel, // ★★★ 使用我们获取到的模型变量 ★★★
                speed: 1.0, 
                pitch: 0, 
                timber_list: [] 
            })
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`Minimax API 错误: ${errorData.base_resp?.status_msg || response.statusText}`);
        }
        const contentType = response.headers.get('Content-Type');
        if (!contentType || !contentType.startsWith('audio/')) {
            const errorData = await response.json().catch(() => response.text());
            throw new Error(`Minimax API 未返回有效的音频文件，而是返回了: ${JSON.stringify(errorData)}`);
        }
        const audioBlob = await response.blob();
        const audioUrl = URL.createObjectURL(audioBlob);

        ttsPlayer.src = audioUrl;
        
        const cleanupAndReset = () => {
            if (isTtsPlaying) {
                isTtsPlaying = false;
                URL.revokeObjectURL(audioUrl); 
                if (window.currentAnimatingBubbles) {
                    window.currentAnimatingBubbles.forEach(b => b.classList.remove('playing'));
                }
                currentTtsAudioBubble = null;
                window.currentAnimatingBubbles = null;
            }
        };

       ttsPlayer.onended = cleanupAndReset;
        
        ttsPlayer.onerror = (e) => {
             if (!isIntentionalStop) {
                 console.error("TTS音频播放时发生错误，已自动切换为文本显示:", e);
             } else {
                 console.log("Intentional stop triggered error event, alert skipped.");
             }
             cleanupAndReset();
        };

        await ttsPlayer.play();

    } catch (error) {
        console.error("Minimax TTS 调用失败:", error);
        await showCustomAlert('语音合成失败', `错误信息: ${error.message}`);
        stopMinimaxAudio();
    }
}
// ▲▲▲ 替换结束 ▲▲▲




// ▼▼▼ 【全新】角色手机外观预设功能核心函数 ▼▼▼

/**
 * 启用或禁用角色手机预设管理按钮
 * @param {boolean} isEnabled - 是否启用
 */
function toggleCharPhonePresetButtons(isEnabled) {
    document.getElementById('apply-char-phone-preset-btn').disabled = !isEnabled;
    document.getElementById('update-char-phone-preset-btn').disabled = !isEnabled;
    document.getElementById('rename-char-phone-preset-btn').disabled = !isEnabled;
    document.getElementById('delete-char-phone-preset-btn').disabled = !isEnabled;
    document.getElementById('export-char-phone-preset-btn').disabled = !isEnabled;
}

/**
 * 加载角色手机外观预设到下拉框
 */
async function loadCharPhonePresetsToDropdown() {
    const selector = document.getElementById('char-phone-preset-selector');
    if (!selector) return;
    selector.innerHTML = '<option value="">-- 请选择一个预设 --</option>';
    const presets = await db.charPhonePresets.toArray();
    presets.forEach(preset => {
        const option = document.createElement('option');
        option.value = preset.id;
        option.textContent = preset.name;
        selector.appendChild(option);
    });
    activeCharPhonePresetId = null;
    toggleCharPhonePresetButtons(false);
}

/**
 * 当用户从下拉框选择一个预设时触发
 */
function handleCharPhonePresetSelection() {
    const selector = document.getElementById('char-phone-preset-selector');
    activeCharPhonePresetId = selector.value ? parseInt(selector.value) : null;
    toggleCharPhonePresetButtons(!!activeCharPhonePresetId);
}

// ▼▼▼ 用这块【修复后】的代码，完整替换你旧的 applySelectedCharPhonePreset 函数 ▼▼▼
async function applySelectedCharPhonePreset() {
    if (!activeCharPhonePresetId) {
        alert("请先从下拉框中选择一个要应用的预设。");
        return;
    }
    if (!activeCharacterPhoneId) {
        alert("错误：没有找到当前正在操作的角色手机。");
        return;
    }
    const preset = await db.charPhonePresets.get(activeCharPhonePresetId);
    const chat = state.chats[activeCharacterPhoneId];

    if (preset && preset.data && chat) {
        // 将预设数据深拷贝一份，应用到角色的手机数据上
        chat.characterPhoneData.wallpaper = preset.data.wallpaper || '';
        chat.characterPhoneData.appIcons = { ...DEFAULT_APP_ICONS, ...(preset.data.appIcons || {}) };
        chat.characterPhoneData.widgets = { ...(preset.data.widgets || {}) };
        
        // ★★★ 这就是我们新增的一行！★★★
        chat.characterPhoneData.appWallpaper = preset.data.appWallpaper || '';

        await db.chats.put(chat);
        
        // 刷新手机界面以显示新外观
        openCharacterPhone(activeCharacterPhoneId);
        
        // 刷新外观设置页面，以便预览和数据同步
        renderCharPhoneAppearanceScreen();

        alert(`已成功为“${chat.name}”应用预设: "${preset.name}"！`);
    } else {
        alert("应用预设失败，找不到预设或角色数据。");
    }
}
// ▲▲▲ 替换结束 ▲▲▲


/**
 * 保存当前角色手机的外观设置为一个新的预设
 */
async function saveCurrentCharPhonePreset() {
    if (!activeCharacterPhoneId) return;

    const presetName = await showCustomPrompt("保存预设", "请为这个外观方案起个名字：");
    if (!presetName || !presetName.trim()) {
        if (presetName !== null) alert("名字不能为空！");
        return;
    }

    const chat = state.chats[activeCharacterPhoneId];
    // 从当前角色的数据中提取外观设置
    const presetData = {
        wallpaper: chat.characterPhoneData.wallpaper || '',
        appIcons: { ...(chat.characterPhoneData.appIcons || {}) },
        widgets: { ...(chat.characterPhoneData.widgets || {}) },
        appWallpaper: chat.characterPhoneData.appWallpaper || '',
    };

    await db.charPhonePresets.add({ name: presetName.trim(), data: presetData });
    await loadCharPhonePresetsToDropdown();
    alert(`外观预设 "${presetName.trim()}" 已保存！`);
}

/**
 * 更新当前选中的预设
 */
async function updateSelectedCharPhonePreset() {
    if (!activeCharPhonePresetId || !activeCharacterPhoneId) return;

    const currentPreset = await db.charPhonePresets.get(activeCharPhonePresetId);
    if (!currentPreset) return;

    const confirmed = await showCustomConfirm(
        "确认更新",
        `确定要用当前手机的外观覆盖预设 "${currentPreset.name}" 吗？`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        const chat = state.chats[activeCharacterPhoneId];
        const presetData = {
            wallpaper: chat.characterPhoneData.wallpaper || '',
            appIcons: { ...(chat.characterPhoneData.appIcons || {}) },
            widgets: { ...(chat.characterPhoneData.widgets || {}) },
            appWallpaper: chat.characterPhoneData.appWallpaper || '',
        };
        await db.charPhonePresets.update(activeCharPhonePresetId, { data: presetData });
        await showCustomAlert('成功', `预设 "${currentPreset.name}" 已更新！`);
    }
}

/**
 * 重命名选中的预设
 */
async function renameSelectedCharPhonePreset() {
    if (!activeCharPhonePresetId) return;
    const currentPreset = await db.charPhonePresets.get(activeCharPhonePresetId);
    const newName = await showCustomPrompt("重命名", "请输入新的名称：", currentPreset.name);
    if (newName && newName.trim()) {
        await db.charPhonePresets.update(activeCharPhonePresetId, { name: newName.trim() });
        await loadCharPhonePresetsToDropdown();
        document.getElementById('char-phone-preset-selector').value = activeCharPhonePresetId;
        alert("重命名成功！");
    }
}

/**
 * 删除选中的预设
 */
async function deleteSelectedCharPhonePreset() {
    if (!activeCharPhonePresetId) return;
    const currentPreset = await db.charPhonePresets.get(activeCharPhonePresetId);
    const confirmed = await showCustomConfirm("确认删除", `确定要删除预设 "${currentPreset.name}" 吗？`, { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        await db.charPhonePresets.delete(activeCharPhonePresetId);
        await loadCharPhonePresetsToDropdown();
        alert("预设已删除。");
    }
}

/**
 * 导出选中的预设
 */
async function exportCharPhonePreset() {
    if (!activeCharPhonePresetId) return;
    const preset = await db.charPhonePresets.get(activeCharPhonePresetId);
    const blob = new Blob([JSON.stringify(preset, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `[CharPhone]${preset.name}.json`;
    a.click();
    URL.revokeObjectURL(url);
}

/**
 * 导入预设文件
 */
function importCharPhonePreset(file) {
    if (!file) return;
    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const data = JSON.parse(e.target.result);
            if (data.name && data.data) {
                await db.charPhonePresets.add({ name: `${data.name} (导入)`, data: data.data });
                await loadCharPhonePresetsToDropdown();
                alert(`预设 "${data.name}" 导入成功！`);
            } else {
                alert("导入失败：文件格式不正确。");
            }
        } catch (error) {
            alert(`导入失败：文件解析错误。${error.message}`);
        }
    };
    reader.readAsText(file);
}

// ▲▲▲ 角色手机外观预设功能函数结束 ▲▲▲
// ▼▼▼ 把下面这一整块全新的代码，粘贴到 init() 函数的上方 ▼▼▼

/**
 * [全新] 在外观设置页面渲染出所有App的名称设置项
 */
function renderAppNameSettings() {
    const grid = document.getElementById('icon-rename-grid');
    if (!grid) return;
    grid.innerHTML = '';

    const appLabels = state.globalSettings.appLabels || {};

    // 遍历默认标签对象，以确保所有app都有设置项
    for (const appId in DEFAULT_APP_LABELS) {
        if (DEFAULT_APP_LABELS.hasOwnProperty(appId)) {
            const defaultName = DEFAULT_APP_LABELS[appId];
            const currentName = appLabels[appId] || defaultName;

            const item = document.createElement('div');
            item.className = 'form-group';
            item.style.marginBottom = '0'; // 让布局更紧凑
            item.innerHTML = `
                <label for="rename-input-${appId}">${defaultName}</label>
                <input type="text" id="rename-input-${appId}" class="app-rename-input" data-appid="${appId}" value="${currentName}">
            `;
            grid.appendChild(item);
        }
    }
}

/**
 * [全新] 将保存的App名称应用到主屏幕的图标上
 */
function applyAppLabels() {
    const appLabels = state.globalSettings.appLabels || {};
    
    for (const appId in DEFAULT_APP_LABELS) {
        if (DEFAULT_APP_LABELS.hasOwnProperty(appId)) {
            const defaultName = DEFAULT_APP_LABELS[appId];
            const customName = appLabels[appId] || defaultName;

            // 这个选择器会同时找到主屏幕和Dock栏上的所有图标
            const icons = document.querySelectorAll(`.desktop-app-icon [id="icon-img-${appId}"]`);
            
            icons.forEach(iconImg => {
                const appIconContainer = iconImg.closest('.desktop-app-icon');
                if (appIconContainer) {
                    const labelElement = appIconContainer.querySelector('.label');
                    if (labelElement) {
                        labelElement.textContent = customName;
                    }
                }
            });
        }
    }
}

/**
 * [全新] 从输入框读取并保存用户修改的App名称
 */
function saveAppLabels() {
    const appNameInputs = document.querySelectorAll('.app-rename-input');
    if (!state.globalSettings.appLabels) {
        state.globalSettings.appLabels = {};
    }

    appNameInputs.forEach(input => {
        const appId = input.dataset.appid;
        const newName = input.value.trim();
        const defaultName = DEFAULT_APP_LABELS[appId];

        // 如果用户输入了新名字，且和默认名字不一样，就保存
        if (newName && newName !== defaultName) {
            state.globalSettings.appLabels[appId] = newName;
        } else {
            // 如果用户清空了输入框，或者改回了默认名字，就删除保存记录，以恢复默认
            delete state.globalSettings.appLabels[appId];
        }
    });
}


// ▼▼▼ 请用这整块【全新修复版】代码，替换掉你旧的 handleImportSillyTavernWorldBook 函数 ▼▼▼
/**
 * 【全新 | 已修复】处理导入的SillyTavern世界书文件
 * @param {File} file - 用户选择的JSON文件
 */
async function handleImportSillyTavernWorldBook(file) {
    // 使用FileReader来读取文件内容
    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const text = e.target.result;
            const data = JSON.parse(text);

            // 验证文件格式是否正确，确保包含'entries'对象
            if (!data.entries || typeof data.entries !== 'object') {
                throw new Error("文件格式无效。SillyTavern世界书应包含'entries'对象。");
            }

            // 从文件名提取名称，作为新的分类名
            let categoryName = file.name.replace(/\.(json|jsonl)$/i, '').trim();
            if (!categoryName) categoryName = '导入的世界书';

            // 检查该分类是否已存在，如果不存在则创建
            let category = await db.worldBookCategories.where('name').equals(categoryName).first();
            if (!category) {
                const newCategoryId = await db.worldBookCategories.add({ name: categoryName });
                category = { id: newCategoryId, name: categoryName };
                console.log(`创建了新的世界书分类: ${categoryName} (ID: ${newCategoryId})`);
            } else {
                console.log(`将条目添加到已存在的分类: ${categoryName} (ID: ${category.id})`);
            }

            const newBooks = [];
            // 遍历SillyTavern worldbook中的所有条目
            for (const key in data.entries) {
                const entry = data.entries[key];
                
                // ★★★ 核心修改：移除了 !entry.disable 的检查，现在会导入所有条目 ★★★
                if (entry) { 
                    // 使用entry.comment作为书名，如果为空则使用"条目 key"作为备用
                    const entryName = (entry.comment || `条目 ${key}`).trim();
                    const entryContent = (entry.content || '').trim();
                    // 确保书名和内容都不为空
                    if (entryName && entryContent) {
                        newBooks.push({
                            id: 'wb_' + Date.now() + Math.random(), // 创建唯一ID
                            name: entryName,
                            content: entryContent,
                            categoryId: category.id // 归属到新的分类
                        });
                    }
                }
            }

            if (newBooks.length === 0) {
                alert('没有找到任何可导入的有效条目。');
                return;
            }
            
            // 批量将新书添加到数据库，效率更高
            await db.worldBooks.bulkAdd(newBooks);
            // 更新内存中的state，以便UI能立即刷新
            state.worldBooks.push(...newBooks); 

            // 重新渲染世界书列表，显示新内容
            await renderWorldBookScreen();
            await showCustomAlert('导入成功', `成功将《${categoryName}》中的 ${newBooks.length} 个条目导入到世界书！`);

        } catch (error) {
            console.error("导入世界书失败:", error);
            await showCustomAlert('导入失败', `无法解析文件，请确保它是有效的SillyTavern世界书JSON文件。\n\n错误: ${error.message}`);
        }
    };
    // 以UTF-8编码读取文件内容
    reader.readAsText(file, 'UTF-8');
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【全新】心声背景更换功能的核心函数 ▼▼▼

/**
 * 【总入口】当用户点击“更换背景”按钮时，弹出操作菜单
 */
async function handleInnerVoiceBgChange() {
    const choice = await showChoiceModal("更换心声背景", [
        { text: '上传新背景', value: 'upload' },
        { text: '恢复默认', value: 'reset' }
    ]);

    if (choice === 'upload') {
        // 触发隐藏的文件选择器
        document.getElementById('inner-voice-bg-input').click();
    } else if (choice === 'reset') {
        // 调用保存函数并传入空字符串，表示恢复默认
        await saveInnerVoiceBackground('');
    }
}

// ▼▼▼ 用这块【V2 - 角色独立版】代码，完整替换旧的 saveInnerVoiceBackground 函数 ▼▼▼
/**
 * 【V2】保存新的背景图片URL到【当前角色】
 * @param {string} url - 图片的URL (可以是网络链接或Base64)
 */
async function saveInnerVoiceBackground(url) {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    // 1. 【核心修改】将背景URL保存在当前角色的数据中
    chat.innerVoiceBackground = url;

    // 2. 将更新后的整个 chat 对象保存回数据库
    await db.chats.put(chat);

    // 3. 立即应用新的背景
    applyInnerVoiceBackground(url);

    // 4. 给用户一个反馈
    alert(url ? '当前角色背景已更新！' : '当前角色背景已恢复默认。');
}
// ▲▲▲ 替换结束 ▲▲▲


/**
 * 将指定的背景图应用到心声面板上
 * @param {string} url - 图片的URL
 */
function applyInnerVoiceBackground(url) {
    const panel = document.getElementById('inner-voice-main-panel');
    if (!panel) return;

    if (url) {
        panel.style.backgroundImage = `url(${url})`;
    } else {
        // 如果URL为空，就移除背景图，恢复CSS中定义的默认样式
        panel.style.backgroundImage = 'none';
    }
}

// ▲▲▲ 新增功能函数结束 ▲▲▲

/**
 * [全新] 估算文本的Token数 (按字符数计算)
 * @param {string} text - 要计算的文本
 * @returns {number} - 估算的token数
 */
function calculateTokenCount(text) {
    if (!text) return 0;
    // 这是一个非常简化的估算，直接返回字符数。
    // 对于中文，一个字约等于1-2个token。对于英文，一个词约等于1.3个token。
    // 直接用字符数作为一个简单直观的参考值。
    return text.length;
}
/**
 * [全新] 为Token计算准备完整的上下文和提示词
 * @param {string} chatId - 目标聊天的ID
 * @returns {Promise<string>} - 拼接好的、将要发送给AI的完整文本
 */
async function getContextForTokenCalculation(chatId) {
    const chat = state.chats[chatId];
    if (!chat) return '';

    let combinedText = '';
    const settings = chat.settings;

    // 1. 添加核心提示词 (人设)
    if(chat.isGroup) {
        const membersList = chat.members.map(m => `- **${m.originalName}**: ${m.persona}`).join('\n');
        const myNickname = chat.settings.myNickname || '我';
        combinedText += `你是一个群聊AI... # 群成员列表及人设\n${membersList}\n# 用户的角色\n- **${myNickname}**: ${chat.settings.myPersona}`;
    } else {
        combinedText += chat.settings.aiPersona || '';
        combinedText += chat.settings.myPersona || '';
    }

    // 2. 添加世界书内容
    if (settings.linkedWorldBookIds && settings.linkedWorldBookIds.length > 0) {
        const linkedContents = settings.linkedWorldBookIds.map(bookId => {
            const worldBook = state.worldBooks.find(wb => wb.id === bookId);
            return worldBook ? worldBook.content : '';
        }).join('\n');
        combinedText += linkedContents;
    }
    
    // 3. 添加所有总结作为长期记忆
    const summaryContext = chat.history.filter(msg => msg.type === 'summary').map(s => s.content).join('\n');
    combinedText += summaryContext;

    // 4. 添加最近的对话记录 (上下文记忆)
    const history = chat.history.filter(msg => !msg.isHidden);
    const memoryDepth = settings.maxMemory || 10;
    const contextMessages = history.slice(-memoryDepth);

    const messageText = contextMessages.map(msg => {
        let content = '';
        if (typeof msg.content === 'string') {
            content = msg.content;
        } else if (Array.isArray(msg.content)) {
            content = '[图片]'; // 将图片简化为占位符
        } else if (msg.type) {
            content = `[${msg.type}]`;
        }
        const sender = msg.role === 'user' ? '用户' : (msg.senderName || chat.name);
        return `${sender}: ${content}`;
    }).join('\n');

    combinedText += '\n' + messageText;
    
    return combinedText;
}
/**
 * 【全新】清理所有与已删除角色关联的失效数据
 */
async function clearOrphanedData() {
    // 1. 在执行敏感操作前，先弹窗向用户确认
    const confirmed = await showCustomConfirm(
        '确认清理',
        '此操作将扫描并删除所有与【已不存在的角色】关联的数据（如动态、微博、回忆、通话记录等），释放存储空间。\n\n此操作不可撤销，确定要继续吗？',
        { confirmButtonClass: 'btn-danger' } // 使用醒目的红色按钮
    );

    // 如果用户点了“取消”，则直接退出
    if (!confirmed) return;

    // 显示一个“处理中”的提示，避免用户以为程序卡死
    await showCustomAlert("请稍候...", "正在扫描并清理失效数据...");

    try {
        let totalDeletedCount = 0;

        // 2. 获取所有仍然存在的、有效的角色ID列表
        const validChatIds = new Set((await db.chats.toArray()).map(c => c.id));
        validChatIds.add('user'); // 'user' (即“我”) 永远是有效的作者

        // 3. 定义我们需要检查的数据库表和它们用来关联角色ID的字段名
        const tablesToCheck = [
            { name: 'qzonePosts', idField: 'authorId', typeName: '动态' },
            { name: 'weiboPosts', idField: 'authorId', typeName: '微博' },
            { name: 'memories', idField: 'chatId', typeName: '回忆/约定' },
            { name: 'callRecords', idField: 'chatId', typeName: '通话记录' }
        ];

        // 4. 遍历每一个需要检查的表
        for (const tableInfo of tablesToCheck) {
            const table = db[tableInfo.name];
            const allItems = await table.toArray();
            
            // 找出所有作者ID已经不存在的“孤儿”数据
            const idsToDelete = allItems
                .filter(item => !validChatIds.has(item[tableInfo.idField]))
                .map(item => item.id);

            // 如果找到了需要删除的数据
            if (idsToDelete.length > 0) {
                await table.bulkDelete(idsToDelete); // 批量删除，效率更高
                console.log(`从 ${tableInfo.name} 表中清除了 ${idsToDelete.length} 条失效数据。`);
                totalDeletedCount += idsToDelete.length;
            }
        }

        // 5. 根据清理结果，给用户最终的反馈
        if (totalDeletedCount > 0) {
            await showCustomAlert('清理完成', `已成功清理 ${totalDeletedCount} 条失效数据！`);
        } else {
            await showCustomAlert('扫描完成', '未发现任何可清理的失效数据。');
        }

    } catch (error) {
        console.error("清理失效数据时出错:", error);
        await showCustomAlert('操作失败', `清理过程中发生错误: ${error.message}`);
    }
}
// ▼▼▼ 把这一整块全新的功能函数，粘贴到 init() 函数的【正上方】 ▼▼▼

/**
 * 【全新】处理取消情侣空间
 */
async function handleCancelLoversSpace() {
    if (!activeLoversSpaceCharId) return;
    const confirmed = await showCustomConfirm(
        '取消情侣空间',
        '确定要取消情侣空间吗？这会使空间变为未启用状态，但所有数据（说说、照片等）都会被保留。此操作不会通知对方。',
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        const chat = state.chats[activeLoversSpaceCharId];
        if (chat && chat.loversSpaceData) {
            // 将情侣空间数据设置为null，即可禁用它
            chat.loversSpaceData = null;
            await db.chats.put(chat);
            document.getElementById('ls-settings-modal').classList.remove('visible');
            alert('情侣空间已取消。');
            // 返回到聊天列表主屏幕
            showScreen('chat-list-screen');
        }
    }
}

// ▼▼▼ 【最终版】请用这整块代码，完整替换旧的 handleDisconnectLoversSpace 函数 ▼▼▼

// ▼▼▼ 第1步：用这块【最终双消息版】的代码，完整替换旧的 handleDisconnectLoversSpace 函数 ▼▼▼
/**
 * 【最终版 | 解除卡片+系统通知】处理解除情侣关系
 */
async function handleDisconnectLoversSpace() {
    if (!activeLoversSpaceCharId) return;
    const chat = state.chats[activeLoversSpaceCharId];
    if (!chat) return;

    const confirmed = await showCustomConfirm(
        '解除关系',
        `确定要与“${chat.name}”解除关系吗？情侣空间将被取消，并且对方会收到通知并对此发表意见。`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        // 1. 禁用空间
        chat.loversSpaceData = null;

        // 2. 【核心新增1】创建您发出的、在右侧的“解除卡片”
        const userDisconnectCardMessage = {
            role: 'user',                       
            type: 'lovers_space_disconnect',    // 一个新类型，用于渲染卡片
            content: `情侣空间已解除`,           // 卡片底层可编辑的文字
            timestamp: Date.now()
        };
        chat.history.push(userDisconnectCardMessage);

        // 3. 【核心新增2】创建居中的、灰色的“系统通知”
        const systemNotification = {
            role: 'system',
            type: 'pat_message', // 复用“拍一拍”的居中灰色气泡样式
            content: `你和 ${chat.name} 的情侣空间已解除`,
            timestamp: Date.now() + 1 // 时间戳+1确保在卡片之后
        };
        chat.history.push(systemNotification);

        // 4. 【保留】给AI看的隐藏指令，完全不变
        const hiddenMessageForAI = {
            role: 'system',
            content: `[系统指令：用户刚刚解除了与你的情侣关系。]`,
            timestamp: Date.now() + 2, // 时间戳再+1
            isHidden: true
        };
        chat.history.push(hiddenMessageForAI);

        // 5. 保存、关闭弹窗、跳转、触发回应
        await db.chats.put(chat);
        document.getElementById('ls-settings-modal').classList.remove('visible');
        document.getElementById('lovers-space-screen').classList.remove('visible');
        
        openChat(activeLoversSpaceCharId);
        
        alert('关系已解除，对方已知晓。');
        triggerAiResponse();
    }
}
// ▲▲▲ 第1步替换结束 ▲▲▲
// ▼▼▼ 第1步：在这里粘贴下面这整块新代码 ▼▼▼

/**
 * 【全新】打开手动总结的模式选择弹窗
 */
async function openManualSummaryOptions() {
    const choice = await showChoiceModal(
        '手动总结',
        [
            { text: '总结最新内容', value: 'latest' },
            { text: '总结指定范围', value: 'range' }
        ]
    );

    if (choice === 'latest') {
        // 用户选择总结最新，调用主函数并传入'latest'模式
        await triggerManualSummaryNow('latest');
    } else if (choice === 'range') {
        // 用户选择总结范围，调用范围输入函数
        await promptForSummaryRange();
    }
}

/**
 * 【全新】提示用户输入要总结的消息范围
 */
async function promptForSummaryRange() {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const totalMessages = chat.history.length;
    if (totalMessages === 0) {
        alert("聊天记录为空，无法进行总结。");
        return;
    }

    // 弹出输入框，让用户输入开始序号
    const startStr = await showCustomPrompt('指定范围', `请输入开始的消息序号 (1 - ${totalMessages})`, '1', 'number');
    if (startStr === null) return; // 用户点击了取消

    const startNum = parseInt(startStr);
    if (isNaN(startNum) || startNum < 1 || startNum > totalMessages) {
        alert("请输入有效的开始序号。");
        return;
    }

    // 弹出输入框，让用户输入结束序号
    const endStr = await showCustomPrompt('指定范围', `请输入结束的消息序号 (${startNum} - ${totalMessages})`, totalMessages, 'number');
    if (endStr === null) return; // 用户点击了取消

    const endNum = parseInt(endStr);
    if (isNaN(endNum) || endNum < startNum || endNum > totalMessages) {
        alert("请输入有效的结束序号。");
        return;
    }

    // 调用主函数并传入'range'模式和具体的范围
    await triggerManualSummaryNow('range', { start: startNum, end: endNum });
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲
/* ▼▼▼ 【全新】这是User自己的私信功能的所有核心函数 ▼▼▼ */

/**
 * 【总入口】打开User的私信列表
 */
async function openUserDmListScreen() {
    const settings = state.qzoneSettings || {};
    // 如果还没有生成过私信，就先让AI生成
    if (!settings.userDms || settings.userDms.length === 0) {
        await generateUserDms();
    } else {
        // 如果已经有了，就直接渲染
        renderUserDmList(settings.userDms);
    }
    showScreen('user-dm-list-screen');
}

/**
 * 【AI核心 V4 - 已增加初始粉丝数量】调用AI为User生成一批粉丝私信
 */
async function generateUserDms(isAddingMore = false) {
    const settings = state.qzoneSettings;
    const { proxyUrl, apiKey, model } = state.apiConfig;

    if (!proxyUrl || !apiKey || !model) {
        alert('请先配置API！');
        return;
    }

    if (!isAddingMore && settings.userDms && settings.userDms.length > 0) {
        const confirmed = await showCustomConfirm(
            '重新生成',
            '已有私信记录。重新生成将覆盖现有所有私信，确定吗？',
            { confirmButtonClass: 'btn-danger' }
        );
        if (!confirmed) return;
    }

    const alertMessage = isAddingMore ? "正在召唤新粉丝..." : "AI正在为你模拟粉丝私信...";
    await showCustomAlert("请稍候...", alertMessage);

    const userPersona = `
# 用户信息 (这是你私信的对象，请仔细阅读)
- 你的微博昵称: ${settings.weiboNickname || settings.nickname}
- 你的微博职业: ${settings.weiboUserProfession || '未设定'}
- 你的隐藏人设 (粉丝看不到，但会影响他们对你的态度): ${settings.weiboUserPersona || '一个普通的微博用户。'}
`;

    const existingDmsContext = (isAddingMore && settings.userDms)
        ? `# 已有私信 (供你参考，请生成全新的对话)\n${JSON.stringify(settings.userDms.slice(-5))}`
        : '';

    // --- ▼▼▼ 修改点1：增加粉丝数量 ▼▼▼ ---
    const systemPrompt = `
# 任务
你是一个专业的“微博生态模拟器”。你的任务是根据用户的微博人设，虚构一个包含${isAddingMore ? '3-4' : '5-8'}位不同粉丝/路人的私信列表，并为每位粉丝创作一段【他们单方面发送给用户的】私信内容。
${userPersona}
${existingDmsContext}

# 核心规则
1.  **粉丝多样性**: 创作${isAddingMore ? '3-4' : '5-8'}位不同类型的粉丝。他们的私信内容和语气【必须】与他们的身份以及【用户的微博人设】高度相关。
2.  **【【【对话单向性铁律】】】**: 你生成的对话【只能包含粉丝发送给用户的消息】。绝对不要模拟用户的回复。
3.  **格式铁律**: 你的回复【必须且只能】是一个严格的JSON数组，直接以 '[' 开头，以 ']' 结尾。
4.  **随机头像**: 为每位粉丝从下方头像池中随机挑选一个URL。

# JSON对象结构 (重要：messages数组里只能有sender为"fan"的对象！)
{
  "fanName": "粉丝的微博昵称",
  "fanPersona": "对这位粉丝的简单描述 (例如: '一个担心哥哥事业的妈妈粉')",
  "fanAvatarUrl": "从头像池中选择的URL",
  "messages": [
    { "sender": "fan", "text": "这是粉丝发来的第一条消息..." },
    { "sender": "fan", "text": "这是粉丝紧接着发的第二条消息，因为还没收到回复..." }
  ]
}

# 头像池 (fanAvatarUrl 必须从以下链接中选择一个)
- https://i.postimg.cc/PxZrFFFL/o-o-1.jpg
- https://i.postimg.cc/Qd0Y537F/com-xingin-xhs-20251011153800.png
现在，请开始生成【只有粉丝发言】的私信列表。`;
    // --- ▲▲▲ 修改结束 ▲▲▲ ---
    try {
        const messagesForApi = [{ role: 'user', content: systemPrompt }];
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini, state.apiConfig.temperature);

        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({ model: model, messages: messagesForApi, temperature: parseFloat(state.apiConfig.temperature) || 0.8, response_format: { type: "json_object" } })
            });

        if (!response.ok) throw new Error(`API请求失败: ${response.status}`);
        
        const data = await response.json();
        const rawContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content);
        const cleanedContent = rawContent.replace(/^```json\s*|```$/g, '').trim();
        const newDmsData = JSON.parse(cleanedContent);

        if (Array.isArray(newDmsData)) {
            newDmsData.forEach((convo, index) => {
                if (!convo.fanAvatarUrl) {
                    const fanAvatars = ['https://i.postimg.cc/PxZrFFFL/o-o-1.jpg', 'https://i.postimg.cc/Qd0Y537F/com-xingin-xhs-20251011153800.png'];
                    convo.fanAvatarUrl = fanAvatars[index % fanAvatars.length];
                }
            });

            if (isAddingMore) {
                settings.userDms.push(...newDmsData);
            } else {
                settings.userDms = newDmsData;
            }
            await saveQzoneSettings();
            renderUserDmList(settings.userDms);
            
            await showCustomAlert('生成成功', `${isAddingMore ? '新的私信已添加！' : '粉丝私信已生成！'}`);
        } else {
            throw new Error("AI返回的数据不是一个有效的数组。");
        }
    } catch (error) {
        console.error("生成User私信失败:", error);
        await showCustomAlert('生成失败', `发生错误: ${error.message}`);
    }
}


/**
 * 【已增强】处理用户点击“触发AI回应”按钮
 */
async function handleTriggerUserDmAiReply() {
    if (currentUserDmFanIndex === null) return;
    
    const convo = state.qzoneSettings.userDms[currentUserDmFanIndex];
    if (!convo) return;
    
    const inputEl = document.getElementById('user-dm-input');
    inputEl.placeholder = "等待对方回复中...";
    inputEl.disabled = true;

    const aiResponse = await triggerUserDmAiReply(convo);
    if (aiResponse && aiResponse.length > 0) {
        // ▼▼▼ 修改点4：使用 ... 展开数组 ▼▼▼
        convo.messages.push(...aiResponse);
        await saveQzoneSettings();
        renderUserDmDetail(convo);
        renderUserDmList(state.qzoneSettings.userDms);
    }
    
    inputEl.placeholder = "和粉丝聊点什么...";
    inputEl.disabled = false;
    inputEl.focus();
}


/**
 * 【已增强】处理用户点击“重Roll”按钮
 */
async function handleUserDmReroll() {
    if (currentUserDmFanIndex === null) return;
    
    const convo = state.qzoneSettings.userDms[currentUserDmFanIndex];
    if (!convo || convo.messages.length === 0) return;

    let lastMessageIndex = convo.messages.length - 1;
    
    // 循环向前查找，直到找到第一个不是自己发的消息
    while (lastMessageIndex >= 0 && convo.messages[lastMessageIndex].sender === 'char') {
        lastMessageIndex--;
    }
    
    // 如果没找到粉丝的消息，或者全是自己的消息，则提示
    if (lastMessageIndex < 0 || convo.messages[lastMessageIndex].sender !== 'fan') {
        alert("只能对粉丝的最新回复使用重Roll功能哦。");
        return;
    }

    // 从找到的第一个粉丝消息开始，删除之后的所有消息
    convo.messages.splice(lastMessageIndex);
    
    renderUserDmDetail(convo);
    
    const inputEl = document.getElementById('user-dm-input');
    inputEl.placeholder = "正在重新生成回复...";
    inputEl.disabled = true;
    
    const aiResponse = await triggerUserDmAiReply(convo);
    if (aiResponse && aiResponse.length > 0) {
         // ▼▼▼ 修改点5：使用 ... 展开数组 ▼▼▼
        convo.messages.push(...aiResponse);
        renderUserDmDetail(convo);
    }

    await saveQzoneSettings();
    renderUserDmList(state.qzoneSettings.userDms);

    inputEl.placeholder = "和粉丝聊点什么...";
    inputEl.disabled = false;
    inputEl.focus();
}


/**
 * 【V2-已添加左滑删除】渲染User的私信列表
 */
function renderUserDmList(dmsData) {
    const listEl = document.getElementById('user-dm-list-container');
    listEl.innerHTML = '';

    if (!dmsData || dmsData.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">还没有收到任何私信哦</p>';
        return;
    }

    dmsData.forEach((convo, index) => {
        const lastMsg = convo.messages[convo.messages.length - 1];
        
        // ★★★ 核心修改：创建滑动容器和操作按钮 ★★★
        const swipeContainer = document.createElement('div');
        swipeContainer.className = 'user-dm-list-item-swipe-container';

        const contentWrapper = document.createElement('div');
        contentWrapper.className = 'user-dm-list-item-content';
        contentWrapper.innerHTML = `
            <div class="dm-list-item" data-fan-index="${index}">
                <img src="${convo.fanAvatarUrl}" class="dm-avatar">
                <div class="dm-info">
                    <div class="dm-name-line">
                        <span class="dm-name">${convo.fanName}</span>
                        <span class="dm-persona-tag">${convo.fanPersona}</span>
                    </div>
                    <div class="dm-last-msg">${lastMsg.sender === 'char' ? '你: ' : ''}${lastMsg.text}</div>
                </div>
            </div>
        `;
        
        const actionsWrapper = document.createElement('div');
        actionsWrapper.className = 'user-dm-swipe-actions';
        actionsWrapper.innerHTML = `<button class="swipe-action-btn delete" data-fan-index="${index}">删除</button>`;

        swipeContainer.appendChild(contentWrapper);
        swipeContainer.appendChild(actionsWrapper);
        listEl.appendChild(swipeContainer);
    });
}
/**
 * 【全新】处理删除单条用户私信的逻辑
 */
async function handleDeleteUserDmMessage(fanIndex, messageIndex) {
    if (fanIndex === null || messageIndex === null) return;
    
    const settings = state.qzoneSettings;
    const conversation = settings.userDms[fanIndex];
    if (!conversation) return;

    const messageText = conversation.messages[messageIndex].text.substring(0, 30);
    const confirmed = await showCustomConfirm('删除私信', `确定要删除这条私信吗？\n\n“${messageText}...”`, { confirmButtonClass: 'btn-danger' });

    if (confirmed) {
        conversation.messages.splice(messageIndex, 1);

        if (conversation.messages.length === 0) {
            // 如果这是最后一条消息，则删除整个对话
            settings.userDms.splice(fanIndex, 1);
            await saveQzoneSettings();
            renderUserDmList(settings.userDms);
            showScreen('user-dm-list-screen'); // 返回到列表页
        } else {
            // 否则只更新当前对话
            await saveQzoneSettings();
            renderUserDmDetail(conversation);
        }
        alert('私信已删除。');
    }
}

/**
 * 【全新】处理删除整个用户私信对话的逻辑
 */
async function handleDeleteUserDmConversation(fanIndex) {
    const settings = state.qzoneSettings;
    const conversation = settings.userDms[fanIndex];
    if (!conversation) return;

    const confirmed = await showCustomConfirm('删除对话', `确定要删除与“${conversation.fanName}”的全部对话吗？`, { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        settings.userDms.splice(fanIndex, 1);
        await saveQzoneSettings();
        renderUserDmList(settings.userDms);
        alert('对话已删除。');
    } else {
        // 如果取消，则把滑块收回去
        const swipedContent = document.querySelector(`.user-dm-list-item-content.swiped`);
        if (swipedContent) swipedContent.classList.remove('swiped');
    }
}


/**
 * 打开与某个粉丝的私信详情页
 */
function openUserDmDetail(fanIndex) {
    currentUserDmFanIndex = fanIndex;
    const convo = state.qzoneSettings.userDms[fanIndex];
    if (!convo) return;
    
    renderUserDmDetail(convo);
    showScreen('user-dm-detail-screen');
}

/**
 * 【V2-已添加删除按钮】渲染私信详情页的具体内容
 */
function renderUserDmDetail(conversation) {
    const messagesEl = document.getElementById('user-dm-messages-container');
    const titleEl = document.getElementById('user-dm-detail-title');
    messagesEl.innerHTML = '';
    titleEl.textContent = conversation.fanName;
    
    const userAvatar = state.qzoneSettings.avatar || defaultAvatar;

    conversation.messages.forEach((msg, index) => {
        const isFan = msg.sender === 'fan';
        const wrapper = document.createElement('div');
        wrapper.className = `message-wrapper ${isFan ? 'fan' : 'user-self'}`;
        
        const bubble = document.createElement('div');
        bubble.className = `message-bubble`;

        const avatarHtml = `<img src="${isFan ? conversation.fanAvatarUrl : userAvatar}" class="avatar">`;
        const contentHtml = `<div class="content">${msg.text.replace(/\n/g, '<br>')}</div>`;
        
        // ★★★ 核心修改：在这里创建删除按钮的HTML ★★★
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'user-dm-message-delete-btn';
        deleteBtn.dataset.messageIndex = index; // 用索引来标识是哪条消息
        deleteBtn.title = "删除";
        deleteBtn.innerHTML = '×';
        
        bubble.innerHTML = `${avatarHtml}${contentHtml}`;
        
        // ★★★ 将气泡和删除按钮都添加到容器中 ★★★
        wrapper.appendChild(bubble);
        wrapper.appendChild(deleteBtn);
        
        messagesEl.appendChild(wrapper);
    });

    messagesEl.scrollTop = messagesEl.scrollHeight;
}


/**
 * 【已修复】处理用户在私信详情页发送消息 (仅发送，不触发AI)
 */
async function handleSendUserDm() {
    const inputEl = document.getElementById('user-dm-input');
    const messageText = inputEl.value.trim();
    if (!messageText || currentUserDmFanIndex === null) return;

    const convo = state.qzoneSettings.userDms[currentUserDmFanIndex];
    
    // 1. 创建你的消息对象
    const newMessage = { sender: 'char', text: messageText };

    // 2. 将你的消息添加到对话历史中
    convo.messages.push(newMessage);
    
    // 3. 清空输入框并重置样式
    inputEl.value = '';
    inputEl.style.height = 'auto';

    // 4. 重新渲染对话详情和左侧列表，以显示你的新消息
    renderUserDmDetail(convo);
    renderUserDmList(state.qzoneSettings.userDms);

    // 5. 保存状态
    await saveQzoneSettings();
    
    // 6. 重新聚焦输入框，方便你继续输入或等待操作
    inputEl.focus();
    
    // 注意：此处已移除所有自动触发AI回复的代码
}



/**
 * 【AI回复核心 V2 - 已增强回复丰富度】调用AI生成粉丝的回复 (可以生成多条)
 */
async function triggerUserDmAiReply(conversation) {
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        console.error("API配置不完整");
        return null;
    }
    
    const settings = state.qzoneSettings;

    // --- ▼▼▼ 修改点2：全新的、更丰富的AI指令 ▼▼▼ ---
    const systemPrompt = `
# 角色扮演任务
你将扮演一个正在和偶像或博主私信的粉丝。

# 你的粉丝人设
- 你的昵称: "${conversation.fanName}"
- 你的性格和背景: "${conversation.fanPersona}"

# 博主信息 (你正在和他/她聊天)
- 微博昵称: ${settings.weiboNickname || settings.nickname}
- 微博职业: ${settings.weiboUserProfession || '未设定'}
- 博主的隐藏人设: ${settings.weiboUserPersona || '一个普通的微博用户。'}

# 对话历史 (最近的5条)
${conversation.messages.slice(-5).map(m => `- ${m.sender === 'fan' ? conversation.fanName : '我'}: ${m.text}`).join('\n')}

# 你的任务
根据以上人设和对话历史，生成你接下来的回复。

# 回复规则
1.  **深度扮演**: 你的回复必须【极度符合】你的粉丝人设。语气、用词、情绪都要到位。
2.  **内容丰富**: 不要只回复一句话。你的回复应该包含情绪(激动、失望、好奇等)、思考，或者向博主提出新的问题来推动对话。
3.  **【【【格式铁律】】】**: 你的回复必须是一个【JSON数组】，即使只有一条消息。这个数组可以包含3到8条消息对象，模拟真实聊天中连续发消息的场景。
4.  **对象结构**: 数组中的每个对象都必须是 {"sender": "fan", "text": "你的单条回复内容"}。

现在，请以JSON数组的格式，生成你接下来要发送的1-3条消息。`;
    // --- ▲▲▲ 修改结束 ▲▲▲ ---

    try {
        const messagesForApi = [{ role: 'user', content: systemPrompt }];
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini, state.apiConfig.temperature);


        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data)
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify({ model: model, messages: messagesForApi, temperature: 1.0, response_format: { type: "json_object" } })
            });

        if (!response.ok) throw new Error(`API请求失败: ${response.status}`);
        
        const data = await response.json();
        const rawContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content);
        const cleanedContent = rawContent.replace(/^```json\s*|```$/g, '').trim();
        
        // AI现在返回的是一个数组，我们直接解析并返回它
        const newMessages = JSON.parse(cleanedContent);

        // 做一个兼容性检查，如果AI意外返回了单个对象，我们把它包装成数组
        return Array.isArray(newMessages) ? newMessages : [newMessages];

    } catch (error) {
        console.error('触发粉丝回复失败:', error);
        await showCustomAlert('回复生成失败', `发生错误: ${error.message}`);
        // 返回一个包含错误信息的数组，以便界面能显示出来
        return [{ sender: 'fan', text: `(AI生成回复时出错了: ${error.message})` }];
    }
}

/**
 * 清空所有User的私信
 */
async function handleClearAllUserDms() {
    const confirmed = await showCustomConfirm(
        '确认清空', 
        '确定要清空所有粉丝私信吗？此操作不可恢复。',
        { confirmButtonClass: 'btn-danger' }
    );
    if (confirmed) {
        state.qzoneSettings.userDms = [];
        await saveQzoneSettings();
        renderUserDmList([]);
        alert('所有私信已清空。');
    }
}

/* ▲▲▲ 全新的 User 私信功能核心函数结束 ▲▲▲ */
/**
 * 【全新】将时间字符串（如 "20:00", "早上9点"）解析为分钟数
 * @param {string} timeStr - 时间字符串
 * @returns {number} - 从午夜0点开始的分钟数
 */
function parseTime(timeStr) {
    if (!timeStr || typeof timeStr !== 'string') return -1; // 错误或无效输入返回-1

    let hours = 0;
    let minutes = 0;

    // 匹配 "HH:mm" 或 "H:mm" 格式
    const match = timeStr.match(/(\d{1,2}):(\d{2})/);
    if (match) {
        hours = parseInt(match[1], 10);
        minutes = parseInt(match[2], 10);
    } else {
        // 如果不是标准格式，尝试匹配中文描述
        const numMatch = timeStr.match(/(\d+)/);
        const num = numMatch ? parseInt(numMatch[0], 10) : -1;

        if (num !== -1) {
            if (timeStr.includes('下午') || timeStr.includes('晚上')) {
                // 下午1点(13点)到晚上11点(23点)
                if (num < 12) {
                    hours = num + 12;
                } else {
                    hours = num; // 如果已经是24小时制如“晚上20点”，直接使用
                }
            } else {
                // 早上或上午
                hours = num;
            }
        } else {
            return -1; // 无法解析
        }
    }

    // 处理特殊情况，如晚上12点应为0点
    if ((timeStr.includes('晚上') || timeStr.includes('凌晨')) && hours === 12) {
        hours = 0;
    }
    // 处理下午12点应为12点
    if ((timeStr.includes('下午') || timeStr.includes('中午')) && hours === 24) {
        hours = 12;
    }

    return hours * 60 + minutes;
}
// ▼▼▼ 【V2.2 | 修复熄灭重燃逻辑】请用这块新代码替换旧的 updateStreak 函数 ▼▼▼
/**
 * 【火花 V2.2】检查并更新火花天数 (已修复熄灭后从1开始的问题)
 * @param {string} chatId - 要更新火花的聊天ID
 * @returns {Promise<boolean>} - 如果火花天数有变化，则返回true
 */
async function updateStreak(chatId) {
    const chat = state.chats[chatId];
    // 如果不是单聊，或功能未开启，直接返回
    if (!chat || chat.isGroup || !chat.settings.streak?.enabled) {
        return false;
    }

    const streak = chat.settings.streak;
    const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD格式

    // 如果今天已经互动过了，就什么都不做
    if (streak.lastInteractionDate === today) {
        return false;
    }

    let changed = false;

    // 检查火花是否已熄灭
    if (streak.lastInteractionDate && streak.extinguishThreshold !== -1) {
        const lastDate = new Date(streak.lastInteractionDate);
        const todayDate = new Date(today);
        // 为了精确计算天数差异，我们将两个日期都设置为UTC时间的午夜
        const lastDateUTC = Date.UTC(lastDate.getFullYear(), lastDate.getMonth(), lastDate.getDate());
        const todayDateUTC = Date.UTC(todayDate.getFullYear(), todayDate.getMonth(), todayDate.getDate());
        
        const daysDiff = (todayDateUTC - lastDateUTC) / (1000 * 60 * 60 * 24);

        if (daysDiff >= streak.extinguishThreshold) {
            // ★★★ 核心修改就在这里！★★★
            // 将 currentDays 重置为 0，这样稍后的 ++ 操作就会让它变为 1
            streak.currentDays = 0; 
            console.log(`🔥 与 ${chat.name} 的火花因超过 ${streak.extinguishThreshold} 天未联系而熄灭，将重新从 1 开始计算。`);
            changed = true;
        }
    }
    
    // 今天是新的互动日，天数+1
    // 如果是永不熄灭模式，currentDays 为 -1, 不应该增加
    if (streak.currentDays >= 0) {
        streak.currentDays++;
        changed = true;
    }
    
    // 更新最后互动日期为今天
    streak.lastInteractionDate = today;

    // 只要是新的一天互动，就应该保存更新后的日期
    await db.chats.put(chat);
    
    if(changed) {
        console.log(`🔥 与 ${chat.name} 的火花天数更新为: ${streak.currentDays}`);
    }
    
    return changed; // 返回是否发生了变化
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 用这块【修复后】的代码替换旧的 handleToggleAdmin 函数 ▼▼▼
/**
 * 【全新 | 权限修复版】处理设置/取消管理员
 */
async function handleToggleAdmin(memberId) {
    const chat = state.chats[state.activeChatId];
    // 权限检查：确保操作者是群主
    if (!chat || chat.ownerId !== 'user') {
        alert("你不是群主，没有权限执行此操作！");
        return;
    }

    let targetNickname;
    let isAdminNow;

    // --- ★★★ 核心修改在这里 ★★★ ---
    // 1. 判断操作目标是不是用户自己
    if (memberId === 'user') {
        // 如果是用户，就修改 chat.settings 里的专属标志
        // 我们使用 isUserAdmin 属性来记录用户是否是管理员
        chat.settings.isUserAdmin = !chat.settings.isUserAdmin;
        targetNickname = chat.settings.myNickname || '我';
        isAdminNow = chat.settings.isUserAdmin;
    } else {
        // 如果是其他成员，保持原有逻辑不变
        const member = chat.members.find(m => m.id === memberId);
        if (!member) return;

        // 【重要】不能将群主设为管理员或取消其管理员身份
        if (member.id === chat.ownerId) {
            alert("不能对群主进行此操作。");
            return;
        }
        
        member.isAdmin = !member.isAdmin;
        targetNickname = member.groupNickname;
        isAdminNow = member.isAdmin;
    }
    // --- ▲▲▲ 修改结束 ▲▲▲

    await db.chats.put(chat);
    
    // 准备并发送系统通知消息
    const actionText = isAdminNow ? '设为管理员' : '取消了管理员身份';
    const myNickname = chat.settings.myNickname || '我';
    // 这里我们用 logSystemMessage 函数来发送通知，它会自动刷新UI
    await logSystemMessage(chat.id, `“${myNickname}”将“${targetNickname}”${actionText}。`);

    // 刷新成员管理列表的显示
    renderMemberManagementList(); 
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 用这块【修复后】的代码替换旧的 handleSetMemberTitle 函数 ▼▼▼
/**
 * 【全新 | 权限修复版】处理设置群成员头衔
 */
async function handleSetMemberTitle(memberId) {
    const chat = state.chats[state.activeChatId];
    // 权限检查：群主或管理员才能设置
    const isOwner = chat.ownerId === 'user';
    const isAdmin = chat.settings.isUserAdmin;

    if (!chat || (!isOwner && !isAdmin)) {
        alert("你不是群主或管理员，没有权限执行此操作！");
        return;
    }
    
    let targetNickname;
    let oldTitle;
    
    // --- ★★★ 核心修改在这里 ★★★ ---
    if (memberId === 'user') {
        targetNickname = chat.settings.myNickname || '我';
        oldTitle = chat.settings.myGroupTitle || '';
    } else {
        const member = chat.members.find(m => m.id === memberId);
        if (!member) return;
        targetNickname = member.groupNickname;
        oldTitle = member.groupTitle || '';
    }
    // --- ▲▲▲ 修改结束 ▲▲▲

    const newTitle = await showCustomPrompt(`为“${targetNickname}”设置头衔`, '留空则为取消头衔', oldTitle);
    
    if (newTitle !== null) {
        const trimmedTitle = newTitle.trim();
        // --- ★★★ 核心修改在这里 ★★★ ---
        if (memberId === 'user') {
            chat.settings.myGroupTitle = trimmedTitle;
        } else {
            const member = chat.members.find(m => m.id === memberId);
            if (member) member.groupTitle = trimmedTitle;
        }
        // --- ▲▲▲ 修改结束 ▲▲▲

        await db.chats.put(chat);
        
        const myNickname = chat.settings.myNickname || '我';
        await logTitleChange(chat.id, myNickname, targetNickname, trimmedTitle);

        renderMemberManagementList();
    }
}
// ▲▲▲ 替换结束 ▲▲▲




// ▼▼▼ 请用这块【功能增强版】的代码，完整替换你旧的 handleTransferOwnership 函数 ▼▼▼
/**
 * 【全新】处理转让群主 (已添加系统消息通知)
 */
async function handleTransferOwnership(memberId) {
    const chat = state.chats[state.activeChatId];
    const newOwner = chat.members.find(m => m.id === memberId);
    if (!newOwner) return;

    // 【新增】获取旧群主的昵称，也就是你自己的昵称
    const oldOwnerNickname = chat.settings.myNickname || '我';

    const confirmed = await showCustomConfirm(
        '转让群主',
        `你确定要将群主身份转让给“${newOwner.groupNickname}”吗？\n此操作不可撤销，你将失去群主权限。`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        // 更新群主ID
        chat.ownerId = newOwner.id;
        
        // 将新群主设为管理员（如果他之前不是）
        newOwner.isAdmin = true;

        // ★★★★★ 这就是我们本次唯一需要添加的核心代码！ ★★★★★
        // 1. 构建系统消息的内容
        const message = `“${oldOwnerNickname}”已将群主转让给“${newOwner.groupNickname}”`;
        
        // 2. 调用你已有的函数来发送这条系统消息
        //    这个函数会自动保存数据并刷新聊天列表，非常方便！
        await logSystemMessage(chat.id, message);
        // ★★★★★ 添加结束 ★★★★★

        // 刷新成员管理列表的显示
        renderMemberManagementList(); 
        
        // 给出成功提示
        await showCustomAlert('操作成功', `群主已成功转让给“${newOwner.groupNickname}”。`);
    }
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 【全新】发送一条居中显示的系统消息到当前聊天
 * @param {string} chatId - 目标聊天的ID
 * @param {string} messageContent - 要显示的消息内容
 */
async function logSystemMessage(chatId, messageContent) {
    const chat = state.chats[chatId];
    if (!chat) return;

    // 1. 创建系统消息对象
    const systemMessage = {
        role: 'system',       // 这是一个系统角色的消息
        type: 'pat_message',  // 复用“拍一拍”的居中灰色气泡样式
        content: messageContent,
        timestamp: Date.now()
    };

    // 2. 将消息添加到聊天记录并保存
    chat.history.push(systemMessage);
    await db.chats.put(chat);

    // 3. 如果用户正在查看此聊天，则立即显示新消息
    if (state.activeChatId === chatId && document.getElementById('chat-interface-screen').classList.contains('active')) {
        appendMessage(systemMessage, chat);
    }
    
    // 4. 刷新聊天列表以更新预览
    await renderChatList();

    console.log(`系统消息已记录: ${messageContent}`);
}


/**
 * 【V2 - 重构版】记录并发送群头衔变更的系统消息
 * @param {string} chatId - 发生变更的群聊ID
 * @param {string} actorName - 执行操作的人的昵称
 * @param {string} targetName - 被修改头衔的人的昵称
 * @param {string} newTitle - 新的头衔
 */
async function logTitleChange(chatId, actorName, targetName, newTitle) {
    // 1. 构造消息内容
    const messageContent = newTitle 
        ? `${actorName} 将“${targetName}”的群头衔修改为“${newTitle}”`
        : `${actorName} 取消了“${targetName}”的群头衔`;
        
    // 2. 调用通用的系统消息函数
    await logSystemMessage(chatId, messageContent);
}
/* ▼▼▼ 【全新】群公告功能核心函数 ▼▼▼ */

/* ▼▼▼ 【全新 | 已修复】群公告功能核心函数 ▼▼▼ */

/**
 * 打开群公告弹窗并渲染内容
 */
function openGroupAnnouncementModal() {
    const chat = state.chats[state.activeChatId];
    if (!chat || !chat.isGroup) return;

    const modal = document.getElementById('group-announcement-modal');
    const contentArea = document.getElementById('announcement-content-area');
    const footer = document.getElementById('announcement-footer');

    const announcement = chat.settings.groupAnnouncement || '暂无公告';
    contentArea.innerHTML = announcement.replace(/\n/g, '<br>');
    
    const canEdit = chat.ownerId === 'user' || chat.settings.isUserAdmin;
    
    footer.innerHTML = ''; 
    if (canEdit) {
        const editBtn = document.createElement('button');
        editBtn.className = 'cancel';
        editBtn.textContent = '编辑';
        // 【核心修复1】改用 addEventListener 来绑定事件，更安全可靠
        editBtn.addEventListener('click', editGroupAnnouncement); 
        footer.appendChild(editBtn);
    }
    
    const closeBtn = document.createElement('button');
    closeBtn.className = 'save'; 
    closeBtn.textContent = '关闭';
    // 【核心修复2】同样改用 addEventListener
    closeBtn.addEventListener('click', closeGroupAnnouncementModal); 
    footer.appendChild(closeBtn);

    modal.classList.add('visible');
}

/**
 * 进入公告编辑模式
 */
function editGroupAnnouncement() {
    const chat = state.chats[state.activeChatId];
    const contentArea = document.getElementById('announcement-content-area');
    const footer = document.getElementById('announcement-footer');

    const currentContent = chat.settings.groupAnnouncement || '';
    contentArea.innerHTML = `<textarea id="announcement-editor">${currentContent}</textarea>`;
    
    // 【核心修复3】这里也全部改用 addEventListener 的方式绑定
    footer.innerHTML = ''; // 先清空

    const cancelBtn = document.createElement('button');
    cancelBtn.className = 'cancel';
    cancelBtn.textContent = '取消';
    cancelBtn.addEventListener('click', closeGroupAnnouncementModal); // 直接调用函数
    
    const saveBtn = document.createElement('button');
    saveBtn.className = 'save';
    saveBtn.textContent = '保存';
    saveBtn.addEventListener('click', saveGroupAnnouncement); // 直接调用函数

    footer.appendChild(cancelBtn);
    footer.appendChild(saveBtn);
    
    document.getElementById('announcement-editor').focus();
}

/**
 * 保存新的群公告
 */
async function saveGroupAnnouncement() {
    const chat = state.chats[state.activeChatId];
    const newContent = document.getElementById('announcement-editor').value.trim();

    chat.settings.groupAnnouncement = newContent;
    await db.chats.put(chat);
    
    const myNickname = chat.settings.myNickname || '我';
    await logSystemMessage(chat.id, `“${myNickname}”修改了群公告。`);

    closeGroupAnnouncementModal();
    alert('群公告已更新！');
}

/**
 * 关闭群公告弹窗
 */
function closeGroupAnnouncementModal() {
    // 关闭后，重新渲染一次查看状态，以防用户取消了编辑
    const modal = document.getElementById('group-announcement-modal');
    modal.classList.remove('visible');
    // 延迟一点点再打开，可以避免视觉上的冲突
    setTimeout(() => {
        if(modal.classList.contains('visible')) { // 做个检查，万一用户快速操作
           openGroupAnnouncementModal();
        }
    }, 10);
    // 直接关闭，不再重新打开
    document.getElementById('group-announcement-modal').classList.remove('visible');
}

/* ▲▲▲ 新功能函数结束 ▲▲▲ */
/**
 * 【全新】获取并格式化当前聊天的续火花状态，生成给AI看的上下文
 * @param {object} chat - 当前的聊天对象
 * @returns {string} - 格式化后的火花状态文本，或空字符串
 */
async function getStreakContext(chat) {
    // 1. 安全检查：如果不是单聊，或者功能未开启，则直接返回空内容
    if (!chat || chat.isGroup || !chat.settings.streak?.enabled) {
        return "";
    }

    const streak = chat.settings.streak;
    const currentDays = streak.currentDays || 0;
    const extinguishThreshold = streak.extinguishThreshold || 1;
    const lastInteractionDate = streak.lastInteractionDate;
    let isExtinguished = false;

    // 2. 判断火花是否已熄灭
    if (lastInteractionDate && extinguishThreshold !== -1) {
        const lastDate = new Date(lastInteractionDate);
        const todayDate = new Date();
        todayDate.setHours(0, 0, 0, 0); // 将时间设为当日零点，以精确计算天数

        // 计算最后一次互动到今天过了多少天
        const daysDiff = (todayDate.getTime() - lastDate.getTime()) / (1000 * 60 * 60 * 24);

        if (daysDiff >= extinguishThreshold) {
            isExtinguished = true;
        }
    }

    let statusText = "";

    // 3. 根据不同状态，生成给AI看的不同文本
    if (isExtinguished && currentDays > 0) {
        // 这种状态表示“曾经有过火花，但现在断了”
        statusText = `你们的聊天火花【已熄灭】。之前曾连续聊了 ${currentDays} 天，但现在中断了。`;
    } else if (currentDays > 10) {
        statusText = `你们的聊天火花正在热烈燃烧，已经持续了【${currentDays}】天了！这是一个值得纪念的数字。`;
    } else if (currentDays > 0) {
        statusText = `你们的聊天火花正在延续，已经持续了【${currentDays}】天。`;
    } else {
        // 天数为0，说明是刚开启或刚重置
        statusText = "你们刚刚点燃了聊天火花，要继续保持哦！";
    }
    
    // 4. 拼接成最终的上下文格式
    return `\n- **聊天火花状态**: ${statusText}`;
}
// ▼▼▼ 【全新】这是用户表情包批量删除的JS核心函数 ▼▼▼

/**
 * 切换用户表情包的选择模式
 */
function toggleUserStickerSelectionMode() {
    isUserStickerSelectionMode = !isUserStickerSelectionMode;
    const stickerPanel = document.getElementById('sticker-panel');
    const stickerGrid = document.getElementById('sticker-grid');
    
    // 清空选择集并更新UI
    selectedUserStickers.clear();
    stickerPanel.classList.toggle('selection-mode', isUserStickerSelectionMode);
    stickerGrid.classList.toggle('selection-mode', isUserStickerSelectionMode);
    
    document.getElementById('edit-user-stickers-btn').style.display = isUserStickerSelectionMode ? 'none' : 'block';
    document.getElementById('done-user-stickers-btn').style.display = isUserStickerSelectionMode ? 'block' : 'none';
    document.getElementById('sticker-panel-footer').style.display = isUserStickerSelectionMode ? 'block' : 'none';
    document.getElementById('delete-selected-user-stickers-btn').textContent = `删除已选 (0)`;
    document.getElementById('delete-selected-user-stickers-btn').disabled = true;

    // 重新渲染表情列表以应用新的事件监听器
    renderStickerPanel();
}

/**
 * 退出用户表情包的选择模式
 */
function exitUserStickerSelectionMode() {
    if (isUserStickerSelectionMode) {
        toggleUserStickerSelectionMode();
    }
}
// ▲▲▲ 新函数粘贴结束 ▲▲▲
// ▼▼▼ 【全新】这是角色表情包批量删除的JS核心函数 ▼▼▼

/**
 * 切换角色表情包的选择模式
 */
function toggleCharStickerSelectionMode() {
    isCharStickerSelectionMode = !isCharStickerSelectionMode;
    const screen = document.getElementById('char-sticker-manager-screen');
    
    // 清空选择集并更新UI
    selectedCharStickers.clear();
    screen.classList.toggle('selection-mode', isCharStickerSelectionMode);
    
    document.getElementById('edit-char-stickers-btn').style.display = isCharStickerSelectionMode ? 'none' : 'block';
    document.getElementById('done-char-stickers-btn').style.display = isCharStickerSelectionMode ? 'block' : 'none';
    document.getElementById('char-sticker-footer').style.display = isCharStickerSelectionMode ? 'block' : 'none';
    document.getElementById('delete-selected-char-stickers-btn').textContent = `删除已选 (0)`;
    document.getElementById('delete-selected-char-stickers-btn').disabled = true;

    // 重新渲染当前激活的页签
    const activeTab = document.querySelector('#char-sticker-manager-screen .frame-tab.active');
    if (activeTab) {
        renderCharStickers(activeTab.id === 'sticker-tab-exclusive' ? 'exclusive' : 'common');
    }
}

/**
 * 退出角色表情包的选择模式
 */
function exitCharStickerSelectionMode() {
    if (isCharStickerSelectionMode) {
        toggleCharStickerSelectionMode();
    }
}

// ▼▼▼ 用这块【新代码】替换旧的 showInnerVoiceEditOptions 函数 ▼▼▼
/**
 * 【总入口】当用户点击心声面板的编辑按钮时，打开操作菜单
 */
async function showInnerVoiceEditOptions() {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const borderHidden = chat.settings.innerVoiceHideHeaderBorder || false;
    const borderOptionText = borderHidden ? '显示分割线' : '隐藏分割线';
    
    // 【核心修改】在选项数组里新增了 'editStyles'
    const choice = await showChoiceModal("编辑心声面板", [
        { text: '🎨 编辑面板样式', value: 'editStyles' },
        { text: borderOptionText, value: 'toggleBorder' },
        { text: '修改领养人', value: 'editAdopter' }
    ]);

    if (choice === 'editStyles') {
        openInnerVoiceStyleEditor(); // 调用我们新写的函数来打开样式编辑器
    } else if (choice === 'toggleBorder') {
        await toggleInnerVoiceHeaderBorder();
    } else if (choice === 'editAdopter') {
        await editInnerVoiceAdopterName();
    }
}
// ▲▲▲ 替换结束 ▲▲▲


/**
 * 切换心声面板头部分割线的显示/隐藏
 */
async function toggleInnerVoiceHeaderBorder() {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    // 确保 chat.settings 存在
    if (!chat.settings) chat.settings = {};

    // 切换布尔值
    chat.settings.innerVoiceHideHeaderBorder = !(chat.settings.innerVoiceHideHeaderBorder || false);

    // 保存到数据库
    await db.chats.put(chat);

    // 更新UI
    const header = document.querySelector('#inner-voice-main-panel .modal-header');
    if (header) {
        header.classList.toggle('no-border', chat.settings.innerVoiceHideHeaderBorder);
    }

    await showCustomAlert('操作成功', `分割线已${chat.settings.innerVoiceHideHeaderBorder ? '隐藏' : '显示'}。`);
}

// ▼▼▼ 用这块【模板编辑版】的代码，替换旧的 editInnerVoiceAdopterName 函数 ▼▼▼
/**
 * 修改“领养人”的标签模板
 */
async function editInnerVoiceAdopterName() {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    // 获取当前的标签模板，如果没有设置过，就使用默认值
    const currentFormat = chat.settings.innerVoiceAdopterLabelFormat || '领养人: {{user}}';
    
    // 弹出输入框，让用户编辑整个模板字符串
    const newFormat = await showCustomPrompt(
        '修改领养人标签', 
        '你可以修改整个标签，其中 {{user}} 会被自动替换为你的昵称。', 
        currentFormat
    );

    // 如果用户输入了新内容（不是取消）
    if (newFormat !== null) {
        // 保存新模板，如果输入为空则恢复默认
        chat.settings.innerVoiceAdopterLabelFormat = newFormat.trim() || '领养人: {{user}}';
        await db.chats.put(chat);
        
        // 重新渲染心声面板以显示新标签
        openInnerVoiceModal(); 
        await showCustomAlert('修改成功', '领养人标签已更新！');
    }
}
// ▲▲▲ 替换结束 ▲▲▲
/* ▼▼▼ 【全新】心声面板样式编辑功能的核心函数 ▼▼▼ */

/**
 * 将十六进制颜色(#FFFFFF)转换为 "R, G, B" 字符串 (255, 255, 255)
 * @param {string} hex - 十六进制颜色代码
 * @returns {string} - RGB字符串
 */
function hexToRgb(hex) {
    if (!hex || hex.length < 4) return '255, 255, 255';
    let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : '255, 255, 255';
}

// ▼▼▼ 用这块新代码替换旧的 applySavedInnerVoiceStyles 函数 ▼▼▼
/**
 * 将保存的样式应用到心声面板
 */
function applySavedInnerVoiceStyles() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    if (!chat || !chat.settings.innerVoiceStyles) return;

    const styles = chat.settings.innerVoiceStyles;
    const panel = document.getElementById('inner-voice-main-panel');

    panel.style.setProperty('--iv-color-clothing', styles.clothingColor);
    panel.style.setProperty('--iv-color-behavior', styles.behaviorColor);
    panel.style.setProperty('--iv-color-thoughts', styles.thoughtsColor);
    panel.style.setProperty('--iv-color-naughty', styles.naughtyColor);
    panel.style.setProperty('--iv-card-bg-rgb', hexToRgb(styles.cardBgColor));
    panel.style.setProperty('--iv-card-opacity', styles.cardOpacity);
    
    // ★★★ 核心新增：在这里应用我们保存的图标颜色！ ★★★
    panel.style.setProperty('--iv-icon-color', styles.iconColor || '#ff8a80');
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 用这块新代码替换旧的 openInnerVoiceStyleEditor 函数 ▼▼▼
/**
 * 打开心声面板样式编辑器
 */
function openInnerVoiceStyleEditor() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    if (!chat || !chat.settings.innerVoiceStyles) return;

    document.getElementById('inner-voice-edit-options-modal')?.classList.remove('visible');
    
    const styles = chat.settings.innerVoiceStyles;
    const modal = document.getElementById('inner-voice-editor-modal');
    
    // 加载当前样式到编辑器
    document.getElementById('iv-color-clothing').value = styles.clothingColor;
    document.getElementById('iv-color-behavior').value = styles.behaviorColor;
    document.getElementById('iv-color-thoughts').value = styles.thoughtsColor;
    document.getElementById('iv-color-naughty').value = styles.naughtyColor;
    document.getElementById('iv-card-bg-color').value = styles.cardBgColor;
    document.getElementById('iv-opacity-slider').value = styles.cardOpacity;
    document.getElementById('iv-opacity-value').textContent = `${Math.round(styles.cardOpacity * 100)}%`;
    
    // ★★★ 核心新增：在这里加载我们保存的图标颜色！ ★★★
    document.getElementById('iv-icon-color').value = styles.iconColor || '#ff8a80';

    modal.classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 保存用户修改的样式
 */
async function saveInnerVoiceStyles() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    
    // 从编辑器读取新值
    const newStyles = {
        clothingColor: document.getElementById('iv-color-clothing').value,
        behaviorColor: document.getElementById('iv-color-behavior').value,
        thoughtsColor: document.getElementById('iv-color-thoughts').value,
        naughtyColor: document.getElementById('iv-color-naughty').value,
        cardBgColor: document.getElementById('iv-card-bg-color').value,
        cardOpacity: parseFloat(document.getElementById('iv-opacity-slider').value),
        iconColor: document.getElementById('iv-icon-color').value
    };

    // 更新到state和数据库
    chat.settings.innerVoiceStyles = newStyles;
    await db.chats.put(chat);
    
    // 关闭弹窗
    document.getElementById('inner-voice-editor-modal').classList.remove('visible');
    
    // 重新应用一下最终保存的样式，以防万一
    applySavedInnerVoiceStyles();
    
    await showCustomAlert('保存成功', '心声面板的样式已更新！');
}

/* ▲▲▲ 新功能函数结束 ▲▲▲ */
// ▼▼▼ 把这一整块全新的功能函数，粘贴到 init() 函数的【正上方】 ▼▼▼

/**
 * 【全新】打开AI生成群成员的模态框
 */
function openAiGenerateMembersModal() {
    // 清空上次的输入
    document.getElementById('ai-member-count-input').value = '3';
    document.getElementById('ai-member-prompt-input').value = '';
    // 显示弹窗
    document.getElementById('ai-generate-members-modal').classList.add('visible');
}

// ▼▼▼ 用这整块【已修复】的代码，完整替换你旧的 handleGenerateMembers 函数 ▼▼▼
/**
 * 【全新 | AI核心】处理用户点击“开始生成”按钮的逻辑 (已修复)
 */
async function handleGenerateMembers() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    if (!chat || !chat.isGroup) return;

    const count = parseInt(document.getElementById('ai-member-count-input').value);
    const requirements = document.getElementById('ai-member-prompt-input').value.trim();

    if (isNaN(count) || count < 1 || count > 20) {
        alert('请输入1到20之间的有效人数！');
        return;
    }

    document.getElementById('ai-generate-members-modal').classList.remove('visible');
    await showCustomAlert("请稍候...", `AI正在为“${chat.name}”创造 ${count} 位新朋友...`);

    const systemPrompt = `
# 任务
你是一个群聊成员生成器。请根据用户的要求，为群聊“${chat.name}”创建${count}个新成员。

# 用户要求:
${requirements || '无特殊要求，请自由发挥。'}

# 核心规则
1.  你生成的每个成员都必须有独特的名字(name)和鲜明的性格人设(persona)。
2.  人设描述要生动、具体，能体现出角色的特点。
3.  【格式铁律】: 你的回复【必须且只能】是一个严格的JSON数组，直接以'['开头, 以']'结尾。数组中的每个元素都是一个代表成员的JSON对象。

# JSON输出格式示例:
[
  {
    "name": "林风",
    "persona": "一个阳光开朗的运动系少年，热爱篮球，性格直爽，是团队里的气氛担当。"
  },
  {
    "name": "陈雪",
    "persona": "文静内向的学霸少女，喜欢读书和画画，心思细腻，不善言辞但观察力敏锐。"
  }
]
`;

    try {
        const { proxyUrl, apiKey, model } = state.apiConfig;
        let isGemini = proxyUrl === GEMINI_API_URL;
        let messagesForApi = [{ role: 'user', content: systemPrompt }];
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({ model: model, messages: messagesForApi, temperature: 1.0, response_format: { type: "json_object" } })
            });

        if (!response.ok) throw new Error(`API请求失败: ${response.status} - ${await response.text()}`);

        const data = await response.json();
        const rawContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content).replace(/^```json\s*|```$/g, '').trim();
        const newMembersData = JSON.parse(rawContent);

        if (Array.isArray(newMembersData) && newMembersData.length > 0) {
            const addedNames = [];
            newMembersData.forEach((memberData, index) => {
                if (memberData.name && memberData.persona) {
                    const newMember = {
                        id: 'npc_' + (Date.now() + index),
                        originalName: memberData.name.trim(),
                        groupNickname: memberData.name.trim(),
                        avatar: defaultGroupMemberAvatar,
                        persona: memberData.persona.trim(),
                        avatarFrame: '',
                        isAdmin: false,
                        groupTitle: ''
                    };
                    chat.members.push(newMember);
                    addedNames.push(`“${newMember.groupNickname}”`);
                }
            });

            if (addedNames.length > 0) {
                await db.chats.put(chat);
                await logSystemMessage(chat.id, `邀请了 ${addedNames.length} 位新成员: ${addedNames.join('、')}加入了群聊。`);
                await showCustomAlert("生成成功！", `${addedNames.length} 位新成员已加入群聊！`);
                renderMemberManagementList(); // 刷新成员管理列表

                // ★★★★★ 核心修复：就是删除了下面这一行！ ★★★★★
                // renderGroupMemberSettings(chat.members); 

            } else {
                throw new Error("AI返回的数据格式不正确，缺少name或persona字段。");
            }
        } else {
            throw new Error("AI返回的数据不是有效的数组。");
        }
    } catch (error) {
        console.error("AI生成群成员失败:", error);
        await showCustomAlert('生成失败', `发生了一个错误：\n${error.message}`);
    }
}
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 【全新 | 彻底重构】约会大作战 - 邀请与支付核心功能函数 ▼▼▼

/**
 * 【总入口 V2】当用户点击约会卡片时，打开角色选择器
 * @param {object} scene - 被选中的约会场景对象
 */
async function openDatingCharacterSelector(scene) {
    const modal = document.getElementById('dating-char-selector-modal');
    const listEl = document.getElementById('dating-char-selector-list');
    listEl.innerHTML = '';

    // 1. 找出所有可约会的单聊角色
    const singleChats = Object.values(state.chats).filter(chat => !chat.isGroup);

    if (singleChats.length === 0) {
        alert("你还没有任何可以约会的角色哦，先去创建一个吧！");
        return;
    }

    // 2. 为每个角色创建列表项
    singleChats.forEach(chat => {
        const item = document.createElement('div');
        item.className = 'character-select-item'; // 复用现有的样式
        item.dataset.charId = chat.id; // 将角色ID存起来
        item.innerHTML = `
            <img src="${chat.settings.aiAvatar || defaultAvatar}" alt="${chat.name}">
            <span class="name">${chat.name}</span>
        `;
        // 3. 【核心】为每个角色项绑定点击事件
        item.addEventListener('click', () => {
            modal.classList.remove('visible'); // 点击后先关闭选择器
            openDatingInvitationModal(scene, chat.id); // 然后带着场景和角色ID，打开支付弹窗
        });
        listEl.appendChild(item);
    });

    // 绑定取消按钮
    document.getElementById('dating-cancel-char-select-btn').onclick = () => modal.classList.remove('visible');
    
    // 4. 显示角色选择弹窗
    modal.classList.add('visible');
}


// ▼▼▼ 请用这【一整块】全新的代码，完整替换掉你旧的 openDatingInvitationModal 函数 ▼▼▼
/**
 * 【V2 | 文游改造版】打开支付方式选择的模态框
 * @param {object} scene - 约会场景对象
 * @param {string} targetCharId - 被邀请角色的ID
 */
async function openDatingInvitationModal(scene, targetCharId) {
    const modal = document.getElementById('dating-payment-modal');
    document.getElementById('dating-modal-scene-name').textContent = scene.name;
    document.getElementById('dating-modal-scene-cost').textContent = `预计花费: ${scene.cost}金币`;

    const optionsContainer = document.getElementById('dating-payment-options');
    optionsContainer.innerHTML = '';

    const chat = state.chats[targetCharId];
    if (!chat) return;

    // --- ★★★ 核心修改在这里 ★★★ ---
    // 我们现在将所有支付选项的处理函数都改为调用 startDatingScene

    const createButton = (text, handler, requiresBalanceCheck = 0) => {
        const button = document.createElement('button');
        button.className = 'form-button';
        button.textContent = text;
        button.onclick = async () => {
            modal.classList.remove('visible');
            
            // 如果需要检查余额
            if (requiresBalanceCheck > 0) {
                const userBalance = state.globalSettings.userBalance || 0;
                if (userBalance < requiresBalanceCheck) {
                    await showCustomAlert("余额不足", "你的钱包空空如也，无法支付这次约会的花费！");
                    return;
                }
                // 扣款并记录
                await updateUserBalanceAndLogTransaction(-requiresBalanceCheck, `约会支出: ${scene.name}`);
                await showCustomAlert("支付成功", `已成功支付 ${requiresBalanceCheck}金币！`);
            }
            // 调用新的开始约会函数！
            handler(scene, targetCharId);
        };
        optionsContainer.appendChild(button);
    };

    // 1. 我来付全款：检查并扣除全款，然后开始约会
    createButton('我来付全款', startDatingScene, scene.cost);

    // 2. 让对方付全款：直接开始约会 (我们假设对方同意了)
    createButton(`让 ${chat.name} 付全款`, startDatingScene);

    // 3. AA制：检查并扣除一半款项，然后开始约会
    createButton('我们AA制吧', startDatingScene, scene.cost / 2);
    
    // 4. 找人借钱：这个逻辑保持不变，它会打开借钱的流程
    const otherChars = Object.values(state.chats).filter(c => !c.isGroup && c.id !== targetCharId);
    if (otherChars.length > 0) {
        const borrowBtn = document.createElement('button');
        borrowBtn.className = 'form-button';
        borrowBtn.textContent = '我钱不够，找别人借点...';
        borrowBtn.onclick = () => {
            modal.classList.remove('visible');
            openBorrowMoneyModal(scene, targetCharId); // 调用旧的借钱函数
        };
        optionsContainer.appendChild(borrowBtn);
    }
    // --- ★★★ 修改结束 ★★★ ---

    document.getElementById('dating-cancel-btn').onclick = () => modal.classList.remove('visible');
    modal.classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲


/**
 * 【重构版】处理用户付全款的逻辑
 * @param {object} scene - 约会场景对象
 * @param {string} targetCharId - 被邀请角色的ID
 */
async function handleUserPaysForDate(scene, targetCharId) {
    const cost = scene.cost;
    const userBalance = state.globalSettings.userBalance || 0;

    if (userBalance < cost) {
        await showCustomAlert("余额不足", "你的钱包空空如也，无法支付这次约会的花费！");
        return;
    }

    await updateUserBalanceAndLogTransaction(-cost, `约会支出: ${scene.name}`);
    await showCustomAlert("支付成功", `已成功支付 ${cost}金币！现在可以开始你们的约会了。`);

    const hiddenMessage = {
        role: 'system',
        content: `[系统提示：用户已为约会“${scene.name}”付款，花费${cost}金币。现在约会正式开始，请根据场景和人设，开启一段浪漫的约会对话。]`,
        timestamp: Date.now(),
        isHidden: true
    };
    
    // 【核心修改】将消息添加到【目标角色】的聊天记录中
    const chat = state.chats[targetCharId];
    chat.history.push(hiddenMessage);
    await db.chats.put(chat);
    
    // 打开与该角色的聊天并触发回应
    openChat(targetCharId);
    triggerAiResponse();
}

/**
 * 【重构版】向AI请求让它付全款
 * @param {object} scene - 约会场景对象
 * @param {string} targetCharId - 被邀请角色的ID
 */
async function requestCharToPay(scene, targetCharId) {
    const chat = state.chats[targetCharId];
    const cost = scene.cost;

    const hiddenMessage = {
        role: 'system',
        content: `[系统指令：用户邀请你进行约会“${scene.name}”，并希望由你来支付全部费用（${cost}金币）。你的钱包余额是 ${chat.characterPhoneData.bank.balance.toFixed(2)} 金币。请根据你的人设、你与用户的关系以及你的钱包余额，决定是否同意。你【必须】使用 'dating_payment_response' 指令，并设置 "decision" 为 "accept" 或 "reject" 来回应。]`,
        timestamp: Date.now(),
        isHidden: true
    };

    chat.history.push(hiddenMessage);
    await db.chats.put(chat);
    
    await showCustomAlert("请求已发送", `已向 ${chat.name} 发出请求，请到聊天中查看Ta的回应吧。`);
    openChat(targetCharId);
    triggerAiResponse();
}

/**
 * 【重构版】向AI请求AA制
 * @param {object} scene - 约会场景对象
 * @param {string} targetCharId - 被邀请角色的ID
 */
async function requestAAsplit(scene, targetCharId) {
    const chat = state.chats[targetCharId];
    const splitCost = scene.cost / 2;

    if ((state.globalSettings.userBalance || 0) < splitCost) {
        await showCustomAlert("余额不足", `你的余额不足以支付AA制的费用（${splitCost.toFixed(2)}金币）！`);
        return;
    }
    
    const hiddenMessage = {
        role: 'system',
        content: `[系统指令：用户邀请你进行约会“${scene.name}”，并提议AA制，即各自支付 ${splitCost.toFixed(2)} 金币。你的钱包余额是 ${chat.characterPhoneData.bank.balance.toFixed(2)} 金币。请根据你的人设和你与用户的关系，决定是否同意。你【必须】使用 'dating_aa_response' 指令，并设置 "decision" 为 "accept" 或 "reject" 来回应。]`,
        timestamp: Date.now(),
        isHidden: true
    };
    
    chat.history.push(hiddenMessage);
    await db.chats.put(chat);

    await showCustomAlert("请求已发送", `已向 ${chat.name} 发出AA制的提议，请到聊天中查看Ta的回应吧。`);
    openChat(targetCharId);
    triggerAiResponse();
}


// ▼▼▼ 【全新 | V2版】约会借钱功能核心函数 ▼▼▼

/**
 * 【V2 | 带头像、可滑动】打开“找人借钱”的选择列表
 * @param {object} scene - 约会场景对象
 * @param {string} dateTargetCharId - 你的约会对象ID
 */
async function openBorrowMoneyModal(scene, dateTargetCharId) {
    const modal = document.getElementById('borrow-money-modal');
    const listEl = document.getElementById('borrow-money-char-list');
    listEl.innerHTML = '';

    const otherChars = Object.values(state.chats).filter(c => !c.isGroup && c.id !== dateTargetCharId);

    if (otherChars.length === 0) {
        alert("没有其他可以借钱的朋友了。");
        return;
    }

    otherChars.forEach(char => {
        const item = document.createElement('div');
        item.className = 'character-select-item'; // 复用样式
        item.dataset.charId = char.id;
        item.innerHTML = `
            <img src="${char.settings.aiAvatar || defaultAvatar}" alt="${char.name}">
            <span class="name">${char.name}</span>
        `;
        item.addEventListener('click', async () => {
            modal.classList.remove('visible');
            const borrowAmountStr = await showCustomPrompt("借多少？", "请输入你想借的金额", "", "number");
            const borrowAmount = parseFloat(borrowAmountStr);
            if (borrowAmount > 0) {
                await requestToBorrowMoney(scene, dateTargetCharId, char.id, borrowAmount);
            } else if (borrowAmountStr !== null) {
                alert("请输入有效的借款金额！");
            }
        });
        listEl.appendChild(item);
    });

    document.getElementById('borrow-money-cancel-btn').onclick = () => modal.classList.remove('visible');
    modal.classList.add('visible');
}

async function requestToBorrowMoney(scene, dateTargetCharId, lenderChatId, amount) {
    const dateTargetChat = state.chats[dateTargetCharId]; 
    const lenderChat = state.chats[lenderChatId];     
    if (!lenderChat || !dateTargetChat) return;

    const myNickname = dateTargetChat.settings.myNickname || '我';

    // 1. 先构建payload和文本内容，方便复用
    const reasonText = `用于和“${dateTargetChat.name}”在“${scene.name}”的约会。`;
    const payloadData = {
        lenderName: lenderChat.name,
        amount: amount,
        reason: reasonText
    };
    // ★★★ 这就是我们新增的文本消息内容 ★★★
    const textContent = `向 ${lenderChat.name} 借钱 ${amount.toFixed(2)}元，${reasonText}`;

    // 2. 创建完整的消息对象，同时包含 payload 和 content
    const borrowRequestMessage = {
        role: 'user',
        type: 'borrow_money_request',
        timestamp: Date.now(),
        payload: payloadData,      // payload 用于渲染借条卡片（保持不变）
        content: textContent       // content 用于显示为文本消息（这是新增的）
    };
    
    // 将借条发到“债主”的聊天里 (这部分代码保持不变)
    lenderChat.history.push(borrowRequestMessage);
    
    // 3. 【核心修改】创建给AI看的、带有详细信息的隐藏指令
    const hiddenMessage = {
        role: 'system',
        content: `[系统指令：用户 “${myNickname}” 想向你借 ${amount.toFixed(2)} 金币，用于和 “${dateTargetChat.name}” 在 “${scene.name}” 约会。你的钱包余额是 ${lenderChat.characterPhoneData.bank.balance.toFixed(2)} 金币。请根据你的人设、你和用户的关系以及你的钱包余额，决定是否借钱。你【必须】使用 'lend_money_response' 指令，并设置 "decision" 为 "accept" 或 "reject" 来回应，并可以在文本消息中说明理由。]`,
        timestamp: Date.now() + 1, // 确保时间戳在后
        isHidden: true
    };
    lenderChat.history.push(hiddenMessage);
    await db.chats.put(lenderChat);

    await showCustomAlert("借钱请求已发送", `已向“${lenderChat.name}”发起了借款请求，请到和Ta的聊天中查看结果。`);
    
    // 打开与“债主”的聊天并触发回应
    openChat(lenderChatId);
    triggerAiResponse();
}
// ▼▼▼ 【全新】约会大作战-文游模式核心功能 ▼▼▼

let datingGameState = {
    isActive: false,
    scene: null,
    characterId: null,
    storyHistory: [], // 用于记录对话历史，方便AI生成后续内容
};
// ▼▼▼ 【最终渐变版】用这整块新代码，替换旧的 renderDatingValues 函数 ▼▼▼
/**
 * 【最终版 | SVG 渐变填充】渲染约会数值条（心形UI）
 * 这个版本使用线性渐变，最稳定、最高效。
 */
function renderDatingValues() {
    const romanceContainer = document.getElementById('romance-value');
    const lustContainer = document.getElementById('lust-value');
    if (!romanceContainer || !lustContainer) return;

    // 清空旧的心形
    romanceContainer.innerHTML = '';
    lustContainer.innerHTML = '';

    // 辅助函数：渲染一个完整的数值条
    const renderValueBar = (container, value, type) => {
        // ★★★ 核心修复：直接在这里定义颜色，不再使用CSS变量 ★★★
        const fillColor = type === 'romance' ? '#ff8fab' : '#ffde59'; // 粉色代表浪漫，黄色代表性欲
        // ★★★ 修复结束 ★★★

        const emptyColor = '#ccc';
        const emptyOpacity = '0.3';

        for (let i = 0; i < 5; i++) {
            // 计算当前这颗心应该被填充的百分比 (0-100)
            const fillPercentage = Math.max(0, Math.min(100, (value - i * 20) * 5));
            
            // 为每个SVG的渐变效果生成一个唯一的ID
            const gradientId = `heart-gradient-${type}-${i}`;

            const heartSvg = `
                <svg viewBox="0 0 24 24">
                    <defs>
                        <linearGradient id="${gradientId}" x1="0" x2="0" y1="1" y2="0">
                            <stop offset="${fillPercentage}%" stop-color="${fillColor}" />
                            <stop offset="${fillPercentage}%" stop-color="${emptyColor}" stop-opacity="${emptyOpacity}" />
                        </linearGradient>
                    </defs>
                    <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"
                          fill="url(#${gradientId})"
                          stroke="#aaa" 
                          stroke-width="1.5"/>
                </svg>
            `;
            container.innerHTML += heartSvg;
        }
    };
    
    // 调用函数，渲染两个数值条
    renderValueBar(romanceContainer, datingGameState.romance, 'romance');
    renderValueBar(lustContainer, datingGameState.lust, 'lust');
}
// ▲▲▲ 替换结束 ▲▲▲




/**
 * 【总入口 V3】开始一场约会 (已适配新版文游逻辑)
 */
async function startDatingScene(scene, targetCharId) {
    console.log(`开始约会: 场景="${scene.name}", 角色ID=${targetCharId}`);

    datingGameState = {
        isActive: true,
        scene: scene,
        characterId: targetCharId,
        storyHistory: [],
        romance: 0,
        lust: 0,
        currentStoryText: "",
        currentSentenceIndex: -1,
        sentences: [],
        isSwitchingSentence: false,
        // ▼▼▼ 在这里添加下面这行新代码 ▼▼▼
        isNsfwMode: false, 
        // ▲▲▲ 添加结束 ▲▲▲
    };


    const chat = state.chats[targetCharId];
    if (!chat) return;

    // 2. 准备UI元素
    const backgroundEl = document.getElementById('dating-game-background');
    const charNameEl = document.getElementById('dating-game-char-name');
    const textContentEl = document.getElementById('dating-game-text-content');
    const choicesEl = document.getElementById('dating-game-choices');

    // 3. 重置UI到初始状态
    charNameEl.textContent = chat.name;
    backgroundEl.style.backgroundImage = 'none';
    textContentEl.innerHTML = '<p>AI正在精心构筑你们的约会世界...</p>';
    textContentEl.parentElement.style.opacity = 1;
    choicesEl.innerHTML = '';
    
    // 4. 显示游戏界面
    showScreen('dating-game-screen');

    // 5. 并行加载背景图和第一段剧情
    const imagePrompt = scene.imagePrompt + ", vertical, phone wallpaper, cinematic lighting, masterpiece, best quality, beautiful anime style art";
    generateAndLoadImage(imagePrompt)
        .then(imageUrl => { backgroundEl.style.backgroundImage = `url(${imageUrl})`; })
        .catch(error => { 
            console.error("约会背景图加载失败:", error);
            backgroundEl.style.backgroundColor = '#1c1e26';
        });
    // ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼
    // 重置数值
    datingGameState.romance = 0;
    datingGameState.lust = 0;
        // 重置并显示完成度进度条
    datingGameState.completion = 0;
    renderDatingCompletion();
    document.getElementById('dating-completion-bar-container').style.display = 'block';
    // 渲染并显示心形UI
    renderDatingValues();
    document.getElementById('dating-values-container').style.display = 'flex';
    // ▲▲▲ 新代码粘贴结束 ▲▲▲
    await triggerDatingStory("start");
}
// ▼▼▼ 【全新】这是渲染完成度进度条的UI函数 ▼▼▼
/**
 * 渲染并更新约会完成度进度条的UI
 */
function renderDatingCompletion() {
    const container = document.getElementById('dating-completion-bar-container');
    const fill = document.getElementById('dating-completion-bar-fill');
    const text = document.getElementById('dating-completion-text');

    if (!container || !fill || !text) return;
    
    // 从游戏状态中获取完成度
    const completion = datingGameState.completion || 0;
    
    // 更新填充条的宽度和百分比文字
    fill.style.width = `${completion}%`;
    text.textContent = `${Math.round(completion)}%`;
}
// ▲▲▲ 新增函数结束 ▲▲▲

// ▼▼▼ 【V5 | 最终浪漫版】请用这整块代码，完整替换掉你旧的 triggerDatingStory 函数 ▼▼▼
async function triggerDatingStory(userAction) {
  datingGameState.isNsfwMode = false;
    if (!datingGameState.isActive) return;

    const { scene, characterId, storyHistory } = datingGameState;
    const chat = state.chats[characterId];
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert("API未配置，无法继续约会。");
        return;
    }
    
    if (userAction !== "start") {
        storyHistory.push(`【你的选择】: ${userAction}`);
    }

    const textContentEl = document.getElementById('dating-game-text-content');
    const choicesEl = document.getElementById('dating-game-choices');
    
    textContentEl.innerHTML = '<p><i>对方正在思考...</i></p>';
    choicesEl.innerHTML = '';

    const uiSettings = chat.settings.datingUISettings || {};
    const customPrompt = uiSettings.prompt || '';
    const customStyle = uiSettings.style || '你的回复必须是【第三人称】的旁白，详细描绘场景、角色的动作、神态、心理活动以及对话。让用户感觉像在看小说。';

    let spriteContext = '';
    let spriteChoiceInstruction = '';
    const spriteGroupId = uiSettings.spriteGroupId;

    if (spriteGroupId) {
        const sprites = await db.datingSprites.where('groupId').equals(spriteGroupId).toArray();
        if (sprites.length > 0) {
            spriteContext = `
# 可用角色立绘
你有一个立绘库，请根据当前情景选择一个最能表达角色“${chat.name}”心情和动作的立绘描述。
- ${sprites.map(s => `[描述: ${s.description}]`).join('\n- ')}
`;
            spriteChoiceInstruction = `"sprite": "【从上方列表中选择一个最合适的描述，并填在这里】",`;
        }
    }

// ▼▼▼ 【V6 | 完成度版】用这整块代码，替换旧的 triggerDatingStory 函数里的 systemPrompt ▼▼▼
// ▼▼▼ 【V2 | 智能评分版】用这整块代码，替换旧的 triggerDatingStory 函数里的 systemPrompt ▼▼▼
    const systemPrompt = `
# 角色扮演：恋爱互动小说游戏引擎
你现在是一个顶级的恋爱互动小说游戏引擎。你的任务是根据用户选择，推动一个浪漫约会故事的发展。
## 故事背景
- **你的角色**: 你将扮演角色“${chat.name}”。
- **你的角色人设**: ${chat.settings.aiPersona}\n${customPrompt}
- **用户的人设**: ${chat.settings.myPersona}
- **约会场景**: ${scene.name}
${spriteContext}
## 当前约会状态 (重要参考)
- **浪漫值**: ${datingGameState.romance}/100
- **性欲值**: ${datingGameState.lust}/100
- **约会完成度**: ${datingGameState.completion}%

## 核心规则
1.  **沉浸式叙事**: ${customStyle}
2.  **提供选择**: 在每段叙事后，你【必须】提供 2-4 个供用户选择的行动或对话选项。
3.  **【【【智能评分铁律】】】**: 你【必须】根据当前的故事进展、用户的选择以及你的回应，对本次互动的“质量”进行评估，并给出三个数值的【增加值】。
    - **"romance" (浪漫值)**: 如果互动是甜蜜、温馨或感人的，可以增加5-15分。
    - **"lust" (性欲值)**: 如果互动包含挑逗、暗示或身体接触，可以增加5-15分。
    - **"completion_increase" (完成度增加值)**:
        -   这是一个【可正可负】的数值。
        -   **正面互动**: 如果用户的选择让关系升温（例如，选择了更浪漫或大胆的选项），你应该给一个正数，范围在 **3到10** 之间。
        -   **负面互动**: 如果用户的选择很煞风景、粗鲁或导致尴尬，你应该给一个【负数】，范围在 **-10到-1** 之间，表示约会进度倒退。
        -   **平淡互动**: 如果互动很平淡或只是过渡，可以给 **0** 或 **1-2** 分。
4.  **【【【结束时机铁律】】】**: 当你认为故事已经发展到一个完美的、可以自然结束的节点时（例如：互相道别、回到家中），并且总完成度已接近100%，你【必须】将 \`"isDateOver"\` 字段设置为 \`true\`。
5.  **【【【格式铁律】】】**: 你的回复【必须且只能】是一个严格的JSON对象，格式如下:
    {
      ${spriteChoiceInstruction}
      "story": "【这里是你的叙事内容...】",
      "choices": [
        "【选项1的文字描述】",
        "【选项2的文字描述】"
      ],
      "valuesUpdate": {
        "romance": 5,
        "lust": 0,
        "completion_increase": 8
      },
      "isDateOver": false
    }
## 故事历史 (供你参考)
${storyHistory.join('\n')}
现在，请根据用户的最新选择“${userAction}”，生成下一段故事、新的选项和智能评分。
`;
// ▲▲▲ 替换结束 ▲▲▲


    try {
        const messagesForApi = [{ role: 'user', content: systemPrompt }];
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({ model: model, messages: messagesForApi, temperature: 0.9, response_format: { type: "json_object" } })
            });

        if (!response.ok) throw new Error(`API 请求失败: ${await response.text()}`);
        
        const data = await response.json();
        const rawContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content).replace(/^```json\s*|```$/g, '').trim();
        const gameData = JSON.parse(rawContent);

// ▼▼▼ 【V6 | 完成度最终版】用这整块代码，替换旧的 triggerDatingStory 函数里的 if (gameData.story...) 代码块 ▼▼▼
if (gameData.story && Array.isArray(gameData.choices)) {
    if (gameData.valuesUpdate) {
        const romanceChange = gameData.valuesUpdate.romance || 0;
        const lustChange = gameData.valuesUpdate.lust || 0;
        const completionIncrease = gameData.valuesUpdate.completion_increase || 0;

        datingGameState.romance = Math.max(0, Math.min(100, datingGameState.romance + romanceChange));
        datingGameState.lust = Math.max(0, Math.min(100, datingGameState.lust + lustChange));
        datingGameState.completion = Math.max(0, Math.min(100, datingGameState.completion + completionIncrease));
        
        console.log(`数值更新 -> 浪漫: ${datingGameState.romance}/100, 性欲: ${datingGameState.lust}/100, 完成度: ${datingGameState.completion}% (本次变化: ${completionIncrease})`);

        renderDatingValues();
        renderDatingCompletion();
    }
    
    const isDateOver = gameData.isDateOver || false;
    // ★★★ 核心修改：检查约会是否结束，并且完成度达到100% ★★★
    if (isDateOver && datingGameState.completion >= 100) {
        // 如果满足条件，就显示结算卡片，而不是直接结束
        showDatingSummaryCard(gameData.story); 
        return; // 显示卡片后，结束本次函数执行
    }
    
    // 如果约会未结束，则继续正常流程
    const spriteContainer = document.getElementById('dating-game-sprite-container');
    const spriteImg = document.getElementById('dating-game-sprite');
    if (gameData.sprite && spriteGroupId) {
        const chosenSprite = await db.datingSprites.where({ groupId: spriteGroupId, description: gameData.sprite }).first();
        if (chosenSprite) {
            spriteContainer.style.display = 'block';
            spriteContainer.style.left = `${chosenSprite.x}%`;
            spriteContainer.style.bottom = `${100 - chosenSprite.y}%`;
            spriteContainer.style.width = `${chosenSprite.size}%`;
            spriteContainer.style.transform = `translateX(-50%) translateY(${100 - chosenSprite.y}%)`;
            spriteImg.style.opacity = 0;
            setTimeout(() => { spriteImg.src = chosenSprite.url; spriteImg.style.opacity = 1; }, 300);
        } else {
            if (spriteContainer) spriteContainer.style.display = 'none';
        }
    } else {
        if (spriteContainer) spriteContainer.style.display = 'none';
    }
    
    datingGameState.storyHistory.push(`【旁白】: ${gameData.story}`);
    displayStoryText(gameData.story, gameData.choices);
    
    if (datingGameState.lust >= 100 && !datingGameState.isNsfwMode) {
        await triggerNsfwScene();
    }

} else {
    throw new Error("AI返回的数据格式不正确。");
}
// ▲▲▲ 替换结束 ▲▲▲



    } catch (error) {
        console.error("约会剧情生成失败:", error);
        textContentEl.innerHTML = `<p style="color: #ff8a80;">错误: 剧情加载失败，AI可能开小差了... \n(${error.message})</p>`;
    }
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 请用这整块【最终修复版】代码，完整替换旧的 triggerNsfwScene 函数 ▼▼▼
/**
 * 【V5 | 最终修复版】当欲望值满时，触发并推进NSFW剧情
 * @param {string} userAction - 用户的选择或自定义行动
 */
async function triggerNsfwScene(userAction = "故事自然发展") {
    // 1. 设置并确认NSFW模式标志
    datingGameState.isNsfwMode = true;
    console.log("NSFW模式已激活，正在生成NSFW剧情...");

    if (!datingGameState.isActive) return;

    // 2. 获取所需的所有数据 (这部分不变)
    const { scene, characterId, storyHistory } = datingGameState;
    const chat = state.chats[characterId];
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert("API未配置，无法继续约会。");
        return;
    }
    
    storyHistory.push(`【你的选择】: ${userAction}`);
    
    // 3. 更新UI为等待状态 (这部分不变)
    const textContentEl = document.getElementById('dating-game-text-content');
    const choicesEl = document.getElementById('dating-game-choices');
    textContentEl.innerHTML = '<p><i>气氛变得有些不一样了...</i></p>';
    choicesEl.innerHTML = '';

    // 4. 读取约会场景的通用设置 (这部分不变)
    const uiSettings = chat.settings.datingUISettings || {};
    const customPrompt = uiSettings.prompt || '';
    const baseStyle = uiSettings.style || '你的回复必须是【第三人称】的旁白，详细描绘场景、角色的动作、神态、心理活动以及对话。让用户感觉像在看小说。';
    const nsfwStyleInstruction = `
# NSFW剧情指令 (最高优先级)
接下来的故事【必须】包含详细、露骨、毫不避讳的性爱场面描写。你需要大胆地描绘角色的身体接触、动作、喘息、对话和内心感受，让故事进入高潮。叙事必须连贯、自然，符合角色性格。`;
    const customStyleWithNsfw = `${baseStyle}\n${nsfwStyleInstruction}`;
    
    // 立绘逻辑 (这部分不变)
    let spriteContext = '';
    let spriteChoiceInstruction = '';
    const spriteGroupId = uiSettings.spriteGroupId;
    if (spriteGroupId) {
        const sprites = await db.datingSprites.where('groupId').equals(spriteGroupId).toArray();
        if (sprites.length > 0) {
            spriteContext = `\n# 可用角色立绘\n${sprites.map(s => `- [描述: ${s.description}]`).join('\n')}`;
            spriteChoiceInstruction = `"sprite": "【从上方列表中选择一个最合适的描述，并填在这里】",`;
        }
    }

    // 5. ★★★ 核心修复：构建全新的、更清晰的System Prompt ★★★
    const systemPrompt = `
# 角色扮演：NSFW恋爱互动小说游戏引擎
你现在是一个顶级的成人小说游戏引擎。你的任务是根据用户选择，续写一段已经发展到高潮的浪漫约会故事。

## 故事背景
- **你的角色**: 你将扮演角色“${chat.name}”。
- **你的角色人设**: ${chat.settings.aiPersona}\n${customPrompt}
- **用户的人设**: ${chat.settings.myPersona}
- **约会场景**: ${scene.name}
${spriteContext}
## 当前约会状态 (重要参考)
- **浪漫值**: ${datingGameState.romance}/100
- **性欲值**: ${datingGameState.lust}/100
- **约会完成度**: ${datingGameState.completion}%

## 核心规则
1.  **沉浸式叙事**: ${customStyleWithNsfw}
2.  **提供选择**: 在每段NSFW叙事后，你【必须】提供 2-4 个供用户选择的、符合当前情景的行动或对话选项。
3.  **智能评分**: 你【必须】根据当前的故事进展、用户的选择以及你的回应，对本次互动的“质量”进行评估，并给出三个数值的【增加值】。
    - "romance" (浪漫值): 如果互动是甜蜜、温馨或感人的，可以增加5-15分。
    - "lust" (性欲值): 因为是NSFW剧情，此项应该持续增加，范围在10-25分之间。
    - "completion_increase" (完成度增加值): 如果用户的选择让关系升温（例如，选择了更浪漫或大胆的选项），你应该给一个正数，范围在 3到10 之间。如果用户的选择很煞风景，你应该给一个负数，范围在 -10到-1 之间。
4.  **【【【结束时机铁律】】】**: 你的主要任务是推进剧情，但当故事发展到一个**自然且满足的结局**时（例如：激情后的温存、相拥而眠、约定下次再见等），你【必须】将 \`"isDateOver"\` 字段设置为 \`true\` 来结束本次约会。这是结束的唯一方式。**不要无限地进行下去。**
5.  **格式铁律**: 你的回复【必须且只能】是一个严格的JSON对象，格式如下:
    {
      ${spriteChoiceInstruction}
      "story": "【这里是你的NSFW叙事内容...】",
      "choices": [
        "【选项1的文字描述】",
        "【选项2的文字描述】"
      ],
      "valuesUpdate": {
        "romance": 5,
        "lust": 15,
        "completion_increase": 7
      },
      "isDateOver": false
    }
## 故事历史 (供你参考)
${storyHistory.join('\n')}

现在，请根据用户的最新选择“${userAction}”，生成下一段NSFW故事、新的选项和智能评分。
`;

    try {
        const messagesForApi = [{ role: 'user', content: systemPrompt }];
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini);
        
        const response = await fetch(isGemini ? geminiConfig.url : `${proxyUrl}/v1/chat/completions`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
            body: JSON.stringify({ model: model, messages: messagesForApi, temperature: 1.0, response_format: { type: "json_object" } })
        });

        if (!response.ok) throw new Error(`API 请求失败: ${await response.text()}`);
        
        const data = await response.json();
        const rawContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content).replace(/^```json\s*|```$/g, '').trim();
        const gameData = JSON.parse(rawContent);

        if (gameData.story && Array.isArray(gameData.choices)) {
            // 数值更新逻辑 (不变)
            if (gameData.valuesUpdate) {
                const romanceChange = gameData.valuesUpdate.romance || 0;
                const lustChange = gameData.valuesUpdate.lust || 0;
                const completionIncrease = gameData.valuesUpdate.completion_increase || 1; 
                datingGameState.romance = Math.max(0, Math.min(100, datingGameState.romance + romanceChange));
                datingGameState.lust = Math.max(0, Math.min(100, datingGameState.lust + lustChange));
                datingGameState.completion = Math.max(0, Math.min(100, datingGameState.completion + completionIncrease));
                renderDatingValues();
                renderDatingCompletion();
            }

            // ★★★ 核心修复：只根据 AI 的 `isDateOver` 标志来决定是否结束 ★★★
            const isDateOver = gameData.isDateOver || false;
            if (isDateOver) {
                showDatingSummaryCard(gameData.story); 
                return; 
            }
            
            // 后续的立绘更新、故事记录和文本显示逻辑保持不变
            const spriteContainer = document.getElementById('dating-game-sprite-container');
            const spriteImg = document.getElementById('dating-game-sprite');
            if (gameData.sprite && spriteGroupId) {
                const chosenSprite = await db.datingSprites.where({ groupId: spriteGroupId, description: gameData.sprite }).first();
                if (chosenSprite) {
                    spriteContainer.style.display = 'block';
                    spriteContainer.style.left = `${chosenSprite.x}%`;
                    spriteContainer.style.bottom = `${100 - chosenSprite.y}%`;
                    spriteContainer.style.width = `${chosenSprite.size}%`;
                    spriteContainer.style.transform = `translateX(-50%) translateY(${100 - chosenSprite.y}%)`;
                    spriteImg.style.opacity = 0;
                    setTimeout(() => { spriteImg.src = chosenSprite.url; spriteImg.style.opacity = 1; }, 300);
                } else {
                    if (spriteContainer) spriteContainer.style.display = 'none';
                }
            } else {
                if (spriteContainer) spriteContainer.style.display = 'none';
            }
            
            datingGameState.storyHistory.push(`【旁白】: ${gameData.story}`);
            displayStoryText(gameData.story, gameData.choices);
        } else {
            throw new Error("AI返回的数据格式不正确。");
        }
    } catch (error) {
        console.error("NSFW剧情生成失败:", error);
        textContentEl.innerHTML = `<p style="color: #ff8a80;">错误: NSFW剧情加载失败... \n(${error.message})</p>`;
    }
}
// ▲▲▲ 替换结束 ▲▲▲


/**
 * 【全新】处理剧情文本的逐句显示
 * @param {string} storyText - AI返回的完整剧情文本
 * @param {Array<string>} choices - AI返回的选项数组
 */
function displayStoryText(storyText, choices) {
    // 1. 按标点符号分割句子
    const sentences = storyText.match(/[^。！？\s][^。！？]*[。！？]?/g) || [storyText];
    
    // 2. 更新游戏状态
    datingGameState.sentences = sentences;
    datingGameState.currentSentenceIndex = -1; // 重置索引
    datingGameState.choices = choices; // 暂存选项

    // 3. 准备UI，但【不显示】选项
    document.getElementById('dating-game-text-content').innerHTML = '';
    document.getElementById('dating-game-choices').innerHTML = '';
    
    // 4. 显示第一句
    showNextSentence();
}

// ▼▼▼ 【最终修正版 V3】请用这块代码，完整替换旧的 showNextSentence 函数 ▼▼▼

// ▼▼▼ 【最终决战版】请用这块代码，完整替换旧的 showNextSentence 函数 ▼▼▼

/**
 * 【最终版V4】显示下一句剧情文本，或在结束后显示选项
 * - 修正了文本意外消失的bug (使用appendChild代替innerHTML)
 * - 增加了点击保护，防止跳过句子
 */
function showNextSentence() {
    // 如果正在切换句子，则阻止任何新的操作，防止用户快速点击跳过剧情
    if (datingGameState.isSwitchingSentence) return;
    datingGameState.isSwitchingSentence = true; // 加锁

    const { sentences, choices } = datingGameState;
    const textContentEl = document.getElementById('dating-game-text-content');
    const choicesEl = document.getElementById('dating-game-choices');
    const textboxEl = textContentEl.parentElement;

    // 句子索引+1
    datingGameState.currentSentenceIndex++;
    const nextIndex = datingGameState.currentSentenceIndex;
    
    // 用安全的方式移除旧的“点击继续”提示
    const oldIndicator = textboxEl.querySelector('.continue-indicator');
    if (oldIndicator) {
        oldIndicator.remove();
    }
    
    // 先让旧文本淡出
    textContentEl.classList.add('fade-out');

    // 设定一个延迟来执行文本替换和动画
    setTimeout(() => {
        if (nextIndex < sentences.length) {
            const nextSentence = sentences[nextIndex];
            
            // 【关键修正1】使用textContent进行安全的文本替换，绝对不会累积
            textContentEl.textContent = nextSentence;
            
            // 如果这不是最后一句...
            if (nextIndex < sentences.length - 1) {
                // 【关键修正2】用安全的方式创建并添加“点击继续”的提示，不会再破坏现有内容
                const indicator = document.createElement('div');
                indicator.className = 'continue-indicator';
                indicator.textContent = '▼';
                textboxEl.appendChild(indicator);
            } else {
                 // 如果是最后一句了，才显示选项
                choices.forEach(choiceText => {
                    const choiceBtn = document.createElement('button');
                    choiceBtn.className = 'dating-game-choice-btn';
                    choiceBtn.textContent = choiceText;
                                    // ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼
                // ★★★ 核心修改：根据是否在NSFW模式，调用不同的函数 ★★★
                choiceBtn.onclick = () => {
                    if (datingGameState.isNsfwMode) {
                        triggerNsfwScene(choiceText);
                    } else {
                        triggerDatingStory(choiceText);
                    }
                };
                // ▲▲▲ 新代码粘贴结束 ▲▲▲
                    choicesEl.appendChild(choiceBtn);
                });

                // 添加“自由输入”按钮
                const inputBtn = document.createElement('button');
                inputBtn.className = 'dating-game-choice-btn input-action';
                inputBtn.textContent = '自定义行动...';
            // ▼▼▼ 用下面这段新的 onclick 代码替换旧的 ▼▼▼
            // ★★★ 核心修改：同样根据模式调用不同函数 ★★★
            inputBtn.onclick = async () => {
                const userInput = await showCustomPrompt("你的行动", "请输入你想说的话或想做的事：");
                if (userInput && userInput.trim()) {
                    if (datingGameState.isNsfwMode) {
                        triggerNsfwScene(userInput.trim());
                    } else {
                        triggerDatingStory(userInput.trim());
                    }
                }
            };
            // ▲▲▲ 替换结束 ▲▲▲
                choicesEl.appendChild(inputBtn);
            }
        }
        
        // 让新文本淡入
        textContentEl.classList.remove('fade-out');

        // 所有操作完成后，解锁，允许下一次点击
        datingGameState.isSwitchingSentence = false; 

    }, 250); // 稍微增加一点时间，确保动画流畅
}

// ▲▲▲ 替换结束 ▲▲▲



// ▼▼▼ 【V2 | 流程重构版】用这块新代码替换旧的 endDate 函数 ▼▼▼
/**
 * 【总入口】当用户点击“结束约会”时，弹出选择框
 */
async function endDate() {
    if (!datingGameState.isActive) return;

    // 1. 弹出选择框，让用户决定如何结束
    const choice = await showChoiceModal(
        '结束约会',
        [
            { text: '生成并记录约会', value: 'record' },
            { text: '直接结束不记录', value: 'discard' }
        ]
    );
    
    // 2. 根据用户的选择执行不同操作
    if (choice === 'record') {
        // 如果选择“记录”，就显示结算卡片
        showDatingSummaryCard();
    } else if (choice === 'discard') {
        // 如果选择“不记录”，就直接结束并返回聊天列表
        finalizeAndExitDate();
    }
    // 如果用户点了取消，则什么也不做，约会继续
}

/**
 * 【全新】最终结束约会并重置状态的函数
 */
async function finalizeAndExitDate() {
    if (!datingGameState.isActive) return;

    const chat = state.chats[datingGameState.characterId];
    if (chat) {
        const endMessage = { role: 'system', type: 'pat_message', content: `你和“${chat.name}”在“${datingGameState.scene.name}”的约会结束了。`, timestamp: Date.now() };
        chat.history.push(endMessage);
        await db.chats.put(chat);
    }
    
    // ▼▼▼【核心修复】就是在这里加上这一行！▼▼▼
    document.getElementById('dating-completion-bar-container').style.display = 'none';
    // ▲▲▲ 修复结束 ▲▲▲

    // 重置游戏状态
    datingGameState = {
        isActive: false, scene: null, characterId: null, storyHistory: [], romance: 0,
        lust: 0, completion: 0, currentStoryText: "", currentSentenceIndex: -1,
        sentences: [], isSwitchingSentence: false, isNsfwMode: false
    };

    // 隐藏结算卡片（如果它还开着）
    document.getElementById('dating-summary-overlay').classList.remove('visible');

    // 返回聊天列表并刷新
    showScreen('chat-list-screen');
    await renderChatList();
}



/* ▲▲▲ 约会大作战文游改造函数结束 ▲▲▲ */
// ▼▼▼ 用这块【已集成新功能】的代码，完整替换旧的 openDatingSettingsModal 函数 ▼▼▼
/**
 * 【总入口】打开约会场景设置弹窗
 */
async function openDatingSettingsModal() {
    const modal = document.getElementById('dating-game-settings-modal');
    const chat = state.chats[datingGameState.characterId];
    if (!chat) return;

    // 1. 加载当前角色的约会UI设置
    currentDatingUISettings = JSON.parse(JSON.stringify(chat.settings.datingUISettings || {
        prompt: '', style: '', backgroundUrl: '',
        spriteGroupId: null, // ★★★ 确保这个属性存在 ★★★
        sprite: { url: '', x: 50, y: 100, size: 80 }
    }));
    
    // 2. 填充弹窗内容 (保持不变)
    document.getElementById('dating-prompt-input').value = currentDatingUISettings.prompt;
    document.getElementById('dating-style-input').value = currentDatingUISettings.style;
    document.getElementById('dating-bg-url-input').value = currentDatingUISettings.backgroundUrl;
    
    // 3. ★★★ 核心修改：在这里调用新的渲染函数 ★★★
    await renderDatingSpriteGroupSelector();
    await renderDatingPresetSelector();

    // 4. 显示弹窗
    modal.classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 【核心】应用当前的UI设置到游戏界面
 */
function applyDatingUISettings() {
    if (!currentDatingUISettings) return;
    
    // 应用背景图
    const backgroundEl = document.getElementById('dating-game-background');
    if (currentDatingUISettings.backgroundUrl) {
        backgroundEl.style.backgroundImage = `url(${currentDatingUISettings.backgroundUrl})`;
    } else {
        // 如果没有设置，可以恢复到场景默认图或一个通用背景
        const imagePrompt = datingGameState.scene.imagePrompt + ", vertical, phone wallpaper, cinematic lighting, masterpiece, best quality, beautiful anime style art";
        generateAndLoadImage(imagePrompt)
            .then(imageUrl => { backgroundEl.style.backgroundImage = `url(${imageUrl})`; })
            .catch(() => { backgroundEl.style.backgroundColor = '#1c1e26'; });
    }

    // 应用立绘
    const spriteContainer = document.getElementById('dating-game-sprite-container');
    const spriteImg = document.getElementById('dating-game-sprite');
    const sprite = currentDatingUISettings.sprite;
    if (sprite.url) {
        spriteImg.src = sprite.url;
        spriteContainer.style.display = 'block';
        spriteContainer.style.left = `${sprite.x}%`;
        spriteContainer.style.bottom = `${100 - sprite.y}%`;
        spriteContainer.style.width = `${sprite.size}%`;
        // 根据Y坐标调整transform，使立绘的“脚”能贴住设定的位置
        spriteContainer.style.transform = `translateX(-50%) translateY(${100 - sprite.y}%)`;

    } else {
        spriteImg.src = '';
        spriteContainer.style.display = 'none';
    }
}

// ▼▼▼ 用这块【已集成新功能】的代码，完整替换旧的 saveDatingSettings 函数 ▼▼▼
/**
 * 【核心】保存当前设置到角色数据中
 */
async function saveDatingSettings() {
    if (!datingGameState.characterId) return;
    const chat = state.chats[datingGameState.characterId];
    
    // 从UI读取所有设置值
    currentDatingUISettings.prompt = document.getElementById('dating-prompt-input').value.trim();
    currentDatingUISettings.style = document.getElementById('dating-style-input').value.trim();
    currentDatingUISettings.backgroundUrl = document.getElementById('dating-bg-url-input').value.trim();
    
    // ★★★ 核心新增：保存选中的立绘组ID ★★★
    const selectedSpriteGroupId = document.getElementById('dating-sprite-group-select').value;
    currentDatingUISettings.spriteGroupId = selectedSpriteGroupId ? parseInt(selectedSpriteGroupId) : null;

    // 立绘位置和大小的保存逻辑保持不变 (但我们现在不再在这里保存立绘URL了)
    currentDatingUISettings.sprite.x = 50;
    currentDatingUISettings.sprite.y = 100;
    currentDatingUISettings.sprite.size = 80;
    currentDatingUISettings.sprite.url = ''; // URL由AI动态决定，这里不保存

    // 确保角色的settings对象存在
    if (!chat.settings) chat.settings = {};
    // 保存
    chat.settings.datingUISettings = currentDatingUISettings;
    await db.chats.put(chat);
    
    // 应用并关闭弹窗
    applyDatingUISettings();
    document.getElementById('dating-game-settings-modal').classList.remove('visible');
    alert("场景设置已保存！");
}
// ▲▲▲ 替换结束 ▲▲▲

/**
 * 【辅助】处理图片上传
 * @param {'bg' | 'sprite'} type - 上传类型
 */
function handleDatingImageUpload(type) {
    const inputId = type === 'bg' ? 'dating-bg-upload-input' : 'dating-sprite-upload-input';
    const urlInputId = type === 'bg' ? 'dating-bg-url-input' : 'dating-sprite-url-input';
    document.getElementById(inputId).click();

    document.getElementById(inputId).onchange = async (e) => {
        const file = e.target.files[0];
        if (file) {
            const dataUrl = await new Promise(resolve => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.readAsDataURL(file);
            });
            document.getElementById(urlInputId).value = dataUrl;
            if(type === 'bg') currentDatingUISettings.backgroundUrl = dataUrl;
            else currentDatingUISettings.sprite.url = dataUrl;
            applyDatingUISettings();
        }
        e.target.value = null; // 清空以便下次选择
    };
}

/**
 * 【重Roll功能】
 */
async function handleDatingReroll() {
    if (!datingGameState.isActive || datingGameState.storyHistory.length === 0) {
        alert("还没有可以重Roll的内容哦！");
        return;
    }

    // 1. 找到最后一次用户的行动
    let lastUserActionIndex = -1;
    for (let i = datingGameState.storyHistory.length - 1; i >= 0; i--) {
        if (datingGameState.storyHistory[i].startsWith('【你的选择】')) {
            lastUserActionIndex = i;
            break;
        }
    }
    
    // 如果找不到用户的行动（比如刚开始），就重Roll第一段剧情
    if (lastUserActionIndex === -1) {
        datingGameState.storyHistory = [];
        await triggerDatingStory("start");
        return;
    }

    // 2. 截取历史记录，回到用户做出选择之前的状态
    const lastUserAction = datingGameState.storyHistory[lastUserActionIndex].replace('【你的选择】: ', '');
    datingGameState.storyHistory = datingGameState.storyHistory.slice(0, lastUserActionIndex);
    
    // 3. 重新触发AI，使用户的最后一次行动再次生效
    await triggerDatingStory(lastUserAction);
}

// --- 以下是预设管理功能 (逻辑与你其他预设功能类似) ---

async function renderDatingPresetSelector() {
    const select = document.getElementById('dating-preset-select');
    const presets = await db.datingPresets.toArray();
    select.innerHTML = '<option value="">-- 自定义 --</option>';
    presets.forEach(p => {
        select.innerHTML += `<option value="${p.id}">${p.name}</option>`;
    });
}

async function handleDatingPresetSelect() {
    const select = document.getElementById('dating-preset-select');
    const presetId = parseInt(select.value);
    if (presetId) {
        const preset = await db.datingPresets.get(presetId);
        if (preset) {
            // 加载预设到当前设置并刷新UI
            currentDatingUISettings = preset.settings;
            // 重新填充弹窗内容
            document.getElementById('dating-prompt-input').value = currentDatingUISettings.prompt;
            document.getElementById('dating-style-input').value = currentDatingUISettings.style;
            document.getElementById('dating-bg-url-input').value = currentDatingUISettings.backgroundUrl;
            document.getElementById('dating-sprite-url-input').value = currentDatingUISettings.sprite.url;
            document.getElementById('sprite-x-slider').value = currentDatingUISettings.sprite.x;
            document.getElementById('sprite-y-slider').value = currentDatingUISettings.sprite.y;
            document.getElementById('sprite-size-slider').value = currentDatingUISettings.sprite.size;
            // 实时应用预览
            applyDatingUISettings();
        }
    }
}

async function openDatingPresetManager() {
    const select = document.getElementById('dating-preset-select');
    const selectedId = select.value ? parseInt(select.value) : null;

    const choice = await showChoiceModal("管理场景预设", [
        { text: '💾 保存当前为新预设', value: 'save' },
        { text: '🔄 更新选中预设', value: 'update', disabled: !selectedId },
        { text: '🗑️ 删除选中预设', value: 'delete', disabled: !selectedId }
    ]);

    if (choice === 'save') {
        const name = await showCustomPrompt("保存预设", "请输入预设名称：");
        if (name && name.trim()) {
            const currentSettings = {
                prompt: document.getElementById('dating-prompt-input').value.trim(),
                style: document.getElementById('dating-style-input').value.trim(),
                backgroundUrl: document.getElementById('dating-bg-url-input').value.trim(),
                sprite: {
                    url: document.getElementById('dating-sprite-url-input').value.trim(),
                    x: parseInt(document.getElementById('sprite-x-slider').value),
                    y: parseInt(document.getElementById('sprite-y-slider').value),
                    size: parseInt(document.getElementById('sprite-size-slider').value)
                }
            };
            await db.datingPresets.add({ name: name.trim(), settings: currentSettings });
            await renderDatingPresetSelector();
            alert('预设已保存！');
        }
    } else if (choice === 'update' && selectedId) {
        const currentSettings = { /* ... (同上) ... */ };
        await db.datingPresets.update(selectedId, { settings: currentSettings });
        alert('预设已更新！');
    } else if (choice === 'delete' && selectedId) {
        const confirmed = await showCustomConfirm("确认删除", "确定要删除这个预设吗？");
        if(confirmed) {
            await db.datingPresets.delete(selectedId);
            await renderDatingPresetSelector();
            alert('预设已删除。');
        }
    }
}
// ▲▲▲ 新功能函数粘贴结束 ▲▲▲
/* ▼▼▼ 【全新】约会立绘功能核心函数 ▼▼▼ */

/**
 * 【渲染】约会设置中“立绘组”的下拉选择器
 */
async function renderDatingSpriteGroupSelector() {
    const select = document.getElementById('dating-sprite-group-select');
    select.innerHTML = '<option value="">-- 不使用立绘 --</option>'; // 默认选项

    const groups = await db.datingSpriteGroups.toArray();
    groups.forEach(group => {
        select.innerHTML += `<option value="${group.id}">${group.name}</option>`;
    });

    // 根据当前加载的预设，自动选中对应的立绘组
    if (currentDatingUISettings && currentDatingUISettings.spriteGroupId) {
        select.value = currentDatingUISettings.spriteGroupId;
    }
}

/**
 * 【总入口】打开立绘组管理器
 */
async function openSpriteGroupManager() {
    await renderSpriteGroupManagerList();
    document.getElementById('sprite-group-manager-modal').classList.add('visible');
}

/**
 * 【渲染】在管理器中渲染立绘组列表
 */
async function renderSpriteGroupManagerList() {
    const container = document.getElementById('sprite-group-list-container');
    container.innerHTML = '';
    const groups = await db.datingSpriteGroups.orderBy('name').toArray();

    if (groups.length === 0) {
        container.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">还没有任何立绘组，点击“新建”创建一个吧！</p>';
        return;
    }

    groups.forEach(group => {
        const item = document.createElement('div');
        item.className = 'sprite-group-list-item';
        item.innerHTML = `
            <span class="group-name">${group.name}</span>
            <div class="group-actions">
                <button class="form-button-secondary" data-action="edit" data-id="${group.id}">编辑</button>
                <button class="form-button-secondary" data-action="delete" data-id="${group.id}" style="color: #ff3b30;">删除</button>
            </div>
        `;
        container.appendChild(item);
    });
}

/**
 * 【总入口】打开立绘组编辑器（用于新建或编辑）
 * @param {number|null} groupId - 如果是编辑，则传入ID；如果是新建，则为null
 */
async function openSpriteEditor(groupId = null) {
    editingSpriteGroupId = groupId;
    const modal = document.getElementById('sprite-editor-modal');
    const titleEl = document.getElementById('sprite-editor-title');
    const nameInput = document.getElementById('sprite-group-name-input');
    const listEditor = document.getElementById('sprite-list-editor');
    
    listEditor.innerHTML = ''; // 清空旧的立绘
    
    if (groupId) {
        // 编辑模式
        const group = await db.datingSpriteGroups.get(groupId);
        const sprites = await db.datingSprites.where('groupId').equals(groupId).toArray();
        titleEl.textContent = `编辑立绘组: ${group.name}`;
        nameInput.value = group.name;
        sprites.forEach(sprite => {
            listEditor.appendChild(createSpriteEditCard(sprite));
        });
    } else {
        // 新建模式
        titleEl.textContent = '新建立绘组';
        nameInput.value = '';
        // 默认创建一个空的立绘卡片
        listEditor.appendChild(createSpriteEditCard());
    }

    modal.classList.add('visible');
}

/**
 * 【辅助函数 V2 - 已添加位置大小滑块】创建一个立绘编辑卡片的DOM元素
 * @param {object} sprite - 可选的立绘数据对象
 * @returns {HTMLElement}
 */
function createSpriteEditCard(sprite = {}) {
    const card = document.createElement('div');
    card.className = 'sprite-edit-card';
    card.dataset.spriteId = sprite.id || `new_${Date.now()}_${Math.random()}`;

    // ★★★ 核心修改：为 x, y, size 提供默认值 ★★★
    const xPos = sprite.x ?? 50;  // 默认水平居中
    const yPos = sprite.y ?? 100; // 默认垂直贴底
    const size = sprite.size ?? 80; // 默认大小为80%

    // ★★★ 核心修改：在HTML中加入了三个滑块和数值显示 ★★★
    card.innerHTML = `
        <div class="preview-container" style="background-image: url(${sprite.url || ''})"></div>
        <div class="fields-container">
            <div class="form-group" style="margin:0;">
                <label>描述 (用于AI识别)</label>
                <textarea class="sprite-desc-input" rows="2">${sprite.description || ''}</textarea>
            </div>
            <div class="form-group" style="margin:0;">
                <label>图片 (URL或本地上传)</label>
                <div class="bg-upload-container">
                    <button class="form-button-secondary upload-sprite-btn" style="margin-top:0;">上传</button>
                    <input class="sprite-url-input" type="text" value="${sprite.url || ''}" placeholder="或粘贴URL">
                </div>
            </div>
            
            <!-- ▼▼▼ 从这里开始，是我们新增的滑块UI ▼▼▼ -->
            <div class="position-controls">
                <label>X 位置: <span class="pos-value">${xPos}%</span></label>
                <input type="range" class="sprite-x-slider" min="0" max="100" value="${xPos}">
            </div>
            <div class="position-controls">
                <label>Y 位置: <span class="pos-value">${yPos}%</span></label>
                <input type="range" class="sprite-y-slider" min="0" max="100" value="${yPos}">
            </div>
            <div class="position-controls">
                <label>大小: <span class="pos-value">${size}%</span></label>
                <input type="range" class="sprite-size-slider" min="10" max="150" value="${size}">
            </div>
            <!-- ▲▲▲ 新增UI结束 ▲▲▲ -->

        </div>
        <button class="delete-sprite-btn">×</button>
    `;

    // 为卡片内的按钮绑定事件 (这部分不变)
    card.querySelector('.delete-sprite-btn').onclick = () => card.remove();
    card.querySelector('.upload-sprite-btn').onclick = () => handleSpriteImageUpload(card);
    card.querySelector('.sprite-url-input').oninput = (e) => {
        card.querySelector('.preview-container').style.backgroundImage = `url(${e.target.value})`;
    };
    
    // ★★★ 核心修改：为新滑块绑定事件，实时更新旁边的数值显示 ★★★
    card.querySelectorAll('.position-controls input[type="range"]').forEach(slider => {
        slider.addEventListener('input', () => {
            const valueSpan = slider.previousElementSibling.querySelector('.pos-value');
            if(valueSpan) {
                valueSpan.textContent = `${slider.value}%`;
            }
        });
    });

    return card;
}


/**
 * 【辅助】处理单个立绘的图片上传
 * @param {HTMLElement} cardElement - 对应的立绘编辑卡片
 */
function handleSpriteImageUpload(cardElement) {
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = 'image/*';
    fileInput.onchange = async () => {
        const file = fileInput.files[0];
        if (file) {
            const dataUrl = await new Promise(resolve => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.readAsDataURL(file);
            });
            cardElement.querySelector('.sprite-url-input').value = dataUrl;
            cardElement.querySelector('.preview-container').style.backgroundImage = `url(${dataUrl})`;
        }
    };
    fileInput.click();
}

/**
 * 【核心 V2 - 已支持位置大小】保存整个立绘组（包括所有立绘）
 */
async function saveSpriteGroup() {
    const name = document.getElementById('sprite-group-name-input').value.trim();
    if (!name) {
        alert("立绘组名称不能为空！");
        return;
    }

    // 1. 保存或更新立绘组的名称 (这部分不变)
    let groupId;
    if (editingSpriteGroupId) {
        await db.datingSpriteGroups.update(editingSpriteGroupId, { name });
        groupId = editingSpriteGroupId;
    } else {
        groupId = await db.datingSpriteGroups.add({ name });
    }

    // 2. 准备更新的立绘数据 (★★★ 核心修改在这里 ★★★)
    const spriteCards = document.querySelectorAll('#sprite-list-editor .sprite-edit-card');
    const spritesToSave = [];
    let hasError = false;

    spriteCards.forEach(card => {
        const description = card.querySelector('.sprite-desc-input').value.trim();
        const url = card.querySelector('.sprite-url-input').value.trim();
        
        // ▼▼▼ 从新增的滑块中读取 x, y, size 的值 ▼▼▼
        const x = parseInt(card.querySelector('.sprite-x-slider').value);
        const y = parseInt(card.querySelector('.sprite-y-slider').value);
        const size = parseInt(card.querySelector('.sprite-size-slider').value);
        // ▲▲▲ 读取结束 ▲▲▲

        if (!description || !url) {
            hasError = true;
        }

        spritesToSave.push({
            id: card.dataset.spriteId.startsWith('new_') ? undefined : parseInt(card.dataset.spriteId),
            groupId: groupId,
            description,
            url,
            // ▼▼▼ 将读取到的值添加到要保存的对象中 ▼▼▼
            x: x,
            y: y,
            size: size
            // ▲▲▲ 添加结束 ▲▲▲
        });
    });

    if (hasError) {
        alert("存在描述或图片URL为空的立绘，请填写完整！");
        return;
    }

    // 3. 使用事务，一次性更新所有数据 (这部分不变)
    await db.transaction('rw', db.datingSprites, async () => {
        await db.datingSprites.where('groupId').equals(groupId).delete();
        await db.datingSprites.bulkAdd(spritesToSave);
    });

    // 4. 关闭弹窗并刷新UI (这部分不变)
    document.getElementById('sprite-editor-modal').classList.remove('visible');
    await renderSpriteGroupManagerList();
    await renderDatingSpriteGroupSelector();
    
    if (document.getElementById('dating-game-settings-modal').classList.contains('visible')) {
        document.getElementById('dating-sprite-group-select').value = groupId;
    }
    
    alert('立绘组已保存！');
}


/**
 * 【核心】删除一个立绘组及其所有立绘
 * @param {number} groupId - 要删除的立绘组的ID
 */
async function deleteSpriteGroup(groupId) {
    const group = await db.datingSpriteGroups.get(groupId);
    const confirmed = await showCustomConfirm('删除立绘组', `确定要删除立绘组 “${group.name}” 吗？此操作不可恢复。`, {confirmButtonClass: 'btn-danger'});
    if (confirmed) {
        await db.transaction('rw', db.datingSpriteGroups, db.datingSprites, db.datingPresets, async () => {
            // 1. 删除该组下的所有立绘
            await db.datingSprites.where('groupId').equals(groupId).delete();
            // 2. 删除立绘组本身
            await db.datingSpriteGroups.delete(groupId);
            // 3. 【关键】找到所有引用了这个立绘组的约会预设，并将它们的引用清空
            const presetsToUpdate = await db.datingPresets.where('settings.spriteGroupId').equals(groupId).toArray();
            for (const preset of presetsToUpdate) {
                preset.settings.spriteGroupId = null;
                await db.datingPresets.put(preset);
            }
        });
        await renderSpriteGroupManagerList();
        await renderDatingSpriteGroupSelector();
        alert('立绘组已删除。');
    }
}
/* ▲▲▲ 约会立绘功能核心函数结束 ▲▲▲ */


// ▼▼▼ 用这块【新代码】完整替换旧的 showDatingSummaryCard 函数 ▼▼▼
/**
 * 【全新V2】当约会结束时，显示结算卡片，并自动保存到历史记录
 * @param {string} [finalStory=""] - 约会的最后一段剧情文本
 */
async function showDatingSummaryCard(finalStory = "") { // <--- 关键：将函数声明为 async
    const overlay = document.getElementById('dating-summary-overlay');
    const card = document.querySelector('.dating-summary-card');
    const cardInner = document.querySelector('.dating-summary-card-inner');
    const cardFront = document.querySelector('.card-front');
    const avatarEl = document.getElementById('summary-card-avatar');
    const ratingEl = document.getElementById('summary-card-rating');
    const historyEl = document.getElementById('summary-card-history');

    document.getElementById('summary-share-btn').style.display = 'block';

    card.classList.remove('is-flipped');
    cardFront.classList.remove('romantic', 'passionate', 'perfect');
    cardFront.style.background = 'linear-gradient(135deg, #a8b2c5, #8e9eab)';

    const romance = datingGameState.romance;
    const lust = datingGameState.lust;
    const completion = datingGameState.completion;
    let ratingText = '';
    let cardClass = '';
    let finalRatingType = 'anticipation';

    if (romance >= 100 && lust >= 100 && completion >= 100) {
        ratingText = '完美之夜';
        cardClass = 'perfect';
        finalRatingType = 'perfect';
    } else if (romance >= 100) {
        ratingText = '浪漫之夜';
        cardClass = 'romantic';
        finalRatingType = 'romantic';
    } else if (lust >= 100) {
        ratingText = '激情之夜';
        cardClass = 'passionate';
        finalRatingType = 'passionate';
    } else {
        ratingText = '期待之夜';
    }
    
    const character = state.chats[datingGameState.characterId];
    avatarEl.src = character.settings.aiAvatar || defaultAvatar;
    ratingEl.textContent = ratingText;
    if(cardClass) {
        cardFront.classList.add(cardClass);
    }

    const fullHistory = [...datingGameState.storyHistory, `【旁白】: ${finalStory}`].join('\n\n').replace(/\n/g, '<br>');
    historyEl.innerHTML = `<p>${fullHistory}</p>`;
    
    // 暂存数据，以便分享
    currentDatingSummary = {
        rating: ratingText,
        ratingType: finalRatingType,
        characterId: datingGameState.characterId,
        avatarUrl: avatarEl.src,
        storyHistory: datingGameState.storyHistory,
        finalStory: finalStory,
        sceneName: datingGameState.scene.name
    };

    // ★★★★★ 这就是我们新增的、最核心的保存逻辑！ ★★★★★
    try {
        const historyRecord = {
            ...currentDatingSummary, // 将卡片的所有信息都复制过来
            timestamp: Date.now()   // 加上一个保存时的时间戳
        };
        // 使用 await 异步地将这条记录添加到我们的新数据库表中
        await db.datingHistory.add(historyRecord);
        console.log('约会结算卡片已保存到历史库:', historyRecord);
    } catch (error) {
        console.error('保存约会结算卡片失败:', error);
    }
    // ▲▲▲▲▲ 新增逻辑结束 ▲▲▲▲▲

    overlay.classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 【V2 | 编辑内容增强版】用这块新代码替换旧的 shareDatingSummary 函数 ▼▼▼
/**
 * 【全新V2】将结算卡片分享到与角色的聊天中 (包含完整记录用于编辑)
 */
async function shareDatingSummary() {
    if (!currentDatingSummary) return;

    const chat = state.chats[currentDatingSummary.characterId];
    if (!chat) return;

    // --- ★★★ 这就是本次修改的核心！ ★★★ ---

    // 1. 构建一个包含所有详细信息的、用于编辑的文本内容
    const storyForEdit = [...currentDatingSummary.storyHistory, `【旁白】: ${currentDatingSummary.finalStory}`].join('\n');
    const contentForEditing = `
[约会记录]
约会场所: ${currentDatingSummary.sceneName}
约会评级: ${currentDatingSummary.rating}
--------------------
${storyForEdit}
    `.trim();

    // 2. 创建消息对象
    const summaryMessage = {
        role: 'user', // 用户发出的分享
        type: 'dating_summary_card',
        timestamp: Date.now(),
        // 【核心】将我们刚刚构建的详细文本，作为这条消息的 content
        content: contentForEditing, 
        // payload 依然保留，它负责渲染出漂亮的卡片UI
        payload: {
            rating: currentDatingSummary.rating,
            ratingType: currentDatingSummary.ratingType,
            avatarUrl: currentDatingSummary.avatarUrl,
            // 为了安全，payload里也存一份，确保数据完整
            storyHistory: currentDatingSummary.storyHistory,
            finalStory: currentDatingSummary.finalStory,
            sceneName: currentDatingSummary.sceneName
        }
    };
    // --- ★★★ 修改结束 ★★★ ---

    chat.history.push(summaryMessage);
    await db.chats.put(chat);
    
    await showCustomAlert('分享成功', '你们的约会记录已发送给Ta！');
    
    // 分享后，关闭结算卡片并结束约会
    document.getElementById('dating-summary-overlay').classList.remove('visible');
    finalizeAndExitDate();
    currentDatingSummary = null;
}
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【V2 | 评级样式修复版】用这块新代码替换旧的 reopenDatingSummary 函数 ▼▼▼
/**
 * 【全新V2】点击聊天记录里的卡片时，重新打开结算详情
 * @param {object} payload - 消息中保存的结算数据
 */
function reopenDatingSummary(payload) {
    const overlay = document.getElementById('dating-summary-overlay');
    const card = document.querySelector('.dating-summary-card');
    const cardFront = document.querySelector('.card-front');
    const avatarEl = document.getElementById('summary-card-avatar');
    const ratingEl = document.getElementById('summary-card-rating');
    const historyEl = document.getElementById('summary-card-history');

    card.classList.remove('is-flipped');
    cardFront.classList.remove('romantic', 'passionate', 'perfect');
    // 恢复默认背景，防止颜色残留
    cardFront.style.background = 'linear-gradient(135deg, #a8b2c5, #8e9eab)';
    
    // 从 payload 中恢复数据
    avatarEl.src = payload.avatarUrl;
    ratingEl.textContent = payload.rating;
    if(payload.ratingType !== 'anticipation') {
        cardFront.classList.add(payload.ratingType);
    }
    
    const fullHistory = [...payload.storyHistory, `【旁白】: ${payload.finalStory}`].join('\n\n').replace(/\n/g, '<br>');
    historyEl.innerHTML = `<p>${fullHistory}</p>`;

    // 查看记录时，不应再提供“分享”功能
    document.getElementById('summary-share-btn').style.display = 'none';

    overlay.classList.add('visible');
    // 注意：这里不需要调用 endDate，因为只是查看记录
}
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 把这一整块全新的代码，粘贴到 init() 函数的上方 ▼▼▼

/* --- 【全新】约会历史记录功能核心函数 --- */

/**
 * 【总入口】打开历史约会界面
 */
async function openDatingHistory() {
    showScreen('dating-history-screen');
    await renderDatingHistory();
}

/**
 * 【渲染函数】渲染历史约会列表
 */
async function renderDatingHistory() {
    const listEl = document.getElementById('dating-history-list');
    listEl.innerHTML = '';

    // 从数据库读取所有记录，并按时间倒序排列
    const records = await db.datingHistory.orderBy('timestamp').reverse().toArray();

    if (records.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">还没有任何约会记录哦</p>';
        return;
    }

    // 遍历每一条记录，创建对应的卡片并添加到列表中
    records.forEach(record => {
        const card = createDatingHistoryCard(record);
        listEl.appendChild(card);
    });
}

/**
 * 【辅助函数】根据单条历史记录，创建一张可翻转的卡片
 * @param {object} record - 历史记录对象
 * @returns {HTMLElement} - 创建好的卡片DOM元素
 */
function createDatingHistoryCard(record) {
    const cardContainer = document.createElement('div');
    cardContainer.className = 'dating-summary-card'; // 复用结算卡片的样式，很方便！

    // 根据评级类型设置卡片正面的颜色
    let cardClass = '';
    if (record.ratingType === 'romantic') cardClass = 'romantic';
    else if (record.ratingType === 'passionate') cardClass = 'passionate';
    else if (record.ratingType === 'perfect') cardClass = 'perfect';

    // 拼接卡片背面的完整约会记录HTML
    const fullHistoryHtml = [...record.storyHistory, `【旁白】: ${record.finalStory}`]
        .join('\n\n')
        .replace(/\n/g, '<br>');

    // 获取角色名字，如果角色被删了，就显示“未知角色”
    const charName = state.chats[record.characterId]?.name || '未知角色';
    
    // 最终拼接成一个完整的、包含正反两面的卡片HTML
    cardContainer.innerHTML = `
        <div class="dating-summary-card-inner">
            <!-- 卡片正面 -->
            <div class="card-front ${cardClass}">
                <img src="${record.avatarUrl}" alt="角色头像">
                <h2>${record.rating}</h2>
                <p>${new Date(record.timestamp).toLocaleDateString()}</p>
                <p class="summary-card-tip">点击查看详情</p>
            </div>
            <!-- 卡片背面 -->
            <div class="card-back">
                <div class="card-back-header">
                    <span>${charName} - ${record.sceneName}</span>
                </div>
                <div class="card-back-content">
                    <p>${fullHistoryHtml}</p>
                </div>
            </div>
        </div>
    `;
    return cardContainer;
}

/* --- 【全新】约会历史记录功能函数结束 --- */

// ▼▼▼ 【全新 | V2 - 支持AI生成】用这整块代码，完整替换旧的 handleSaveCustomDatingScene 函数 ▼▼▼
/**
 * 【全新 | V2】处理用户保存自定义约会场景的逻辑
 * - 如果用户提供了URL，则直接使用。
 * - 如果用户未提供URL，则根据场景名称生成一个imagePrompt，交由后续流程处理。
 */
async function handleSaveCustomDatingScene() {
    const name = document.getElementById('scene-name-input').value.trim();
    const imageUrl = document.getElementById('scene-image-url-input').value.trim();
    const costStr = document.getElementById('scene-cost-input').value.trim();

    // 1. 【核心修改】验证逻辑调整，现在图片URL不再是必填项
    if (!name || !costStr) {
        alert("场景名称和花费为必填项！");
        return;
    }

    const cost = parseInt(costStr, 10);
    if (isNaN(cost) || cost < 0) {
        alert("请输入有效的花费金额！");
        return;
    }
    
    // 准备一个基础的场景对象
    const newScene = {
        name: name,
        cost: cost,
        uid: 'scene_user_' + Date.now() // 创建一个独特的ID
    };

    // 2. 【核心修改】根据用户是否输入了URL，来决定如何处理图片信息
    if (imageUrl) {
        // --- 用户提供了URL ---
        // 验证链接有效性
        if (!imageUrl.startsWith('http') && !imageUrl.startsWith('data:image')) {
            alert("请输入一个有效的网络图片URL！");
            return;
        }
        newScene.imageUrl = imageUrl;
        newScene.imagePrompt = 'User-provided image'; // 给一个占位符
    } else {
        // --- 用户没有提供URL，我们将为AI准备好“作画指令” ---
        newScene.imageUrl = ''; // 明确设置为空字符串
        // 根据场景名称，生成一个高质量的、用于文生图的英文Prompt
        newScene.imagePrompt = `${name}, vertical, phone wallpaper, cinematic lighting, masterpiece, best quality, beautiful anime style art, vibrant colors`;
    }

    try {
        // 3. 后续的保存和渲染逻辑完全不需要改变！
        await db.datingScenes.add(newScene);
        currentDatingScenes.push(newScene);
        
        document.getElementById('create-dating-scene-modal').classList.remove('visible');
        
        // 重新渲染列表。对于需要AI生成的卡片，它会自动显示加载动画。
        renderDatingScenes();

        alert('自定义约会场景已成功创建！');
    } catch (error) {
        console.error("保存自定义约会场景失败:", error);
        alert(`保存失败: ${error.message}`);
    }
}
// ▲▲▲ 替换结束 ▲▲▲


        // ===================================================================
        // 4. 初始化函数 init()
        // ===================================================================
        async function init() {
    // ▼▼▼ 在 init()    // ▼▼▼ 在这里粘贴下面这几行新代码 ▼▼▼
    // 更新小组件的月份显示
    const monthElement = document.getElementById('widget-month-display');
    if (monthElement) {
        const currentMonth = new Date().getMonth() + 1; // getMonth()返回0-11，所以要+1
        monthElement.textContent = currentMonth;
    }
    // ▲▲▲ 新代码粘贴结束 ▲▲▲ 函数的【最开头】，粘贴下面这两行代码 ▼▼▼
    const savedTheme = localStorage.getItem('ephone-theme') || 'light'; // 默认为日间模式
    applyTheme(savedTheme);
    // ▲▲▲ 粘贴结束 ▲▲▲

    // ▼▼▼ 新增代码 ▼▼▼
    const customBubbleStyleTag = document.createElement('style');
    customBubbleStyleTag.id = 'custom-bubble-style';
    document.head.appendChild(customBubbleStyleTag);
    // ▲▲▲ 新增结束 ▲▲▲

    // ▼▼▼ 新增代码 ▼▼▼
    const previewBubbleStyleTag = document.createElement('style');
    previewBubbleStyleTag.id = 'preview-bubble-style';
    document.head.appendChild(previewBubbleStyleTag);
    // ▲▲▲ 新增结束 ▲▲▲


    // ▼▼▼ 修改这两行 ▼▼▼
    applyScopedCss('', '#chat-messages', 'custom-bubble-style'); // 清除真实聊天界面的自定义样式
    applyScopedCss('', '#settings-preview-area', 'preview-bubble-style'); // 清除预览区的自定义样式
    // ▲▲▲ 修改结束 ▲▲▲

            window.showScreen = showScreen;
            window.openLoversSpaceFromCard = openLoversSpaceFromCard; // <-- 在这里添加这一行
            window.renderChatListProxy = renderChatList;
            window.renderApiSettingsProxy = renderApiSettings;
            window.renderWallpaperScreenProxy = renderWallpaperScreen;
            window.renderWorldBookScreenProxy = renderWorldBookScreen;

            await loadAllDataFromDB();
            // 在 loadAllDataFromDB 函数末尾，init(); 调用之前添加
if (typeof state.globalSettings.notificationSoundUrl === 'undefined') {
    state.globalSettings.notificationSoundUrl = 'https://files.catbox.moe/k369mf.mp3';
}
            // ▼▼▼ 把新代码粘贴到这里 ▼▼▼
            renderHomeScreenProfileFrame(); // 初始化时渲染主页头像框
            // ▲▲▲ 粘贴结束 ▲▲▲
            applyHomeIconWidgetTextColor(state.globalSettings.homeIconWidgetTextColor);
            await loadAllFontPresetsOnStartup(); // <---- 在这里添加这一行新代码
            await addDefaultDarkModeThemeIfNeeded();
            applyWidgetData();

if (state.globalSettings.homeIconWidgetTextColor) {
    applyHomeIconWidgetTextColor(state.globalSettings.homeIconWidgetTextColor);
}

// 2. 应用已保存的“去除阴影”设置
document.getElementById('phone-screen').classList.toggle('no-home-font-shadow', !!state.globalSettings.removeHomeFontShadow);

            // 初始化未读动态计数
            const storedCount = parseInt(localStorage.getItem('unreadPostsCount')) || 0;
            updateUnreadIndicator(storedCount);
            
            // ▲▲▲ 代码添加结束 ▲▲▲

            if (state.globalSettings && state.globalSettings.fontUrl) {
                applyCustomFont(state.globalSettings.fontUrl);
            }

    // ▼▼▼ 在这里粘贴新代码 ▼▼▼
    // 【核心修复】初始化时，自动加载并应用已保存的主题
    if (state.globalSettings.activeThemeId) {
        const activeTheme = await db.themes.get(state.globalSettings.activeThemeId);
        if (activeTheme) {
            console.log(`正在应用已保存的主题: "${activeTheme.name}"`);
            applyThemeCss(activeTheme.css);
        }
    }
    // ▲▲▲ 新代码粘贴结束 ▲▲▲

            updateClock();
            setInterval(updateClock, 1000 * 30);
            applyGlobalWallpaper();
            initBatteryManager(); 

applyAppIcons();
applyAppLabels();
    // ▼▼▼ 在这里添加下面这行代码 ▼▼▼
    initDraggableLyricsBar(); // 初始化悬浮歌词栏的拖动功能
    // ▲▲▲ 添加结束 ▲▲▲

            // ==========================================================
            // --- 各种事件监听器 ---
            // ==========================================================
            // ▼▼▼ 在 init() 函数的事件监听器区域末尾，添加下面这行代码 ▼▼▼
// ▼▼▼ 用这块新代码，替换旧的 weibo-screen 事件监听器 ▼▼▼
            // ▼▼▼ 【全新】“查角色手机”功能事件监听器 (V2 - 单独生成版) ▼▼▼

            // 1. 绑定主屏幕上的“查手机”APP图标
            document.getElementById('check-phone-btn').addEventListener('click', openCharacterSelectionScreen);

            // 2. 角色选择列表的点击事件 (事件委托)
            document.getElementById('character-selection-list').addEventListener('click', (e) => {
                const item = e.target.closest('.character-select-item');
                if (item && item.dataset.chatId) {
                    openCharacterPhone(item.dataset.chatId);
                }
            });

            // 3. 【总生成/清空】角色手机顶部的“刷新”和“清空”按钮
            document.getElementById('generate-character-data-btn').addEventListener('click', generateCharacterPhoneData);
            document.getElementById('clear-character-data-btn').addEventListener('click', clearCharacterPhoneData);

// ▼▼▼ 请用这一整块【功能增强版】的代码，完整替换掉你旧的 character-phone-container 事件监听器 ▼▼▼
document.getElementById('character-phone-container').addEventListener('click', (e) => {
    const backBtn = e.target.closest('.back-btn');
    const actionBtn = e.target.closest('.action-btn');

    // 1. 处理返回按钮
    if (backBtn) {
        if (backBtn.dataset.targetPage) {
            showCharacterPhonePage(backBtn.dataset.targetPage);
        } else if (backBtn.dataset.targetScreen) {
            showScreen(backBtn.dataset.targetScreen);
        }
        return;
    }
    
    // 2. 处理所有操作按钮（生成 + 删除）
    if (actionBtn) {
        switch (actionBtn.id) {
            // --- 单独生成按钮 ---
            case 'generate-chat-message-btn': 
                generateCharacterPhoneDataSegment('chats'); break;
            case 'generate-cart-item-btn':
                generateCharacterPhoneDataSegment('shoppingCart'); break;
            case 'generate-memo-btn':
                generateCharacterPhoneDataSegment('memos'); break;
            case 'generate-browser-history-btn':
                generateCharacterPhoneDataSegment('browserHistory'); break;
            case 'generate-album-photo-btn':
                generateCharacterPhoneDataSegment('photoAlbum'); break;
            case 'generate-bank-transaction-btn':
                generateCharacterPhoneDataSegment('bank'); break;
            case 'generate-trajectory-btn':
                generateCharacterPhoneDataSegment('trajectory'); break;
            case 'generate-app-usage-btn':
                generateCharacterPhoneDataSegment('appUsage'); break;
            case 'generate-diary-entry-btn':
                generateCharacterPhoneDataSegment('diary'); break;

            // --- ★★★ 这就是我们新增的全部删除按钮的逻辑 ★★★ ---
            case 'clear-npc-chats-btn':
                handleClearCharacterDataSegment('chats'); break;
            case 'clear-cart-items-btn':
                handleClearCharacterDataSegment('shoppingCart'); break;
            case 'clear-memos-btn':
                handleClearCharacterDataSegment('memos'); break;
            case 'clear-browser-history-btn':
                handleClearCharacterDataSegment('browserHistory'); break;
            case 'clear-album-photos-btn':
                handleClearCharacterDataSegment('photoAlbum'); break;
            case 'clear-bank-transactions-btn':
                handleClearCharacterDataSegment('bank.transactions'); break;
            case 'clear-trajectory-btn':
                handleClearCharacterDataSegment('trajectory'); break;
            case 'clear-app-usage-btn':
                handleClearCharacterDataSegment('appUsage'); break;
            case 'clear-diary-entries-btn':
                handleClearCharacterDataSegment('diary'); break;
        }
    }
});
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 【V3最终美化版】主屏幕预设功能事件绑定 ▼▼▼
document.getElementById('home-preset-selector').addEventListener('change', handleHomePresetSelection);
document.getElementById('apply-home-preset-btn').addEventListener('click', applySelectedHomeScreenPreset);
// 【核心修改】这里按钮的ID变了
document.getElementById('save-home-preset-btn').addEventListener('click', saveCurrentHomeScreenAsPreset); 
document.getElementById('update-home-preset-btn').addEventListener('click', updateSelectedHomeScreenPreset); // <-- 新增这一行
document.getElementById('rename-home-preset-btn').addEventListener('click', renameSelectedHomeScreenPreset);
document.getElementById('delete-home-preset-btn').addEventListener('click', deleteSelectedHomeScreenPreset);
document.getElementById('export-home-preset-btn').addEventListener('click', exportHomeScreenPreset);
document.getElementById('import-home-preset-btn').addEventListener('click', () => document.getElementById('import-home-preset-input').click());
document.getElementById('import-home-preset-input').addEventListener('change', (e) => {
    importHomeScreenPreset(e.target.files[0]);
    e.target.value = null;
});

            document.getElementById('theme-toggle-switch').addEventListener('change', toggleTheme);
// ▼▼▼ 【全新】聊天记录搜索功能事件绑定 ▼▼▼
document.getElementById('search-chat-btn').addEventListener('click', openChatSearchScreen);

document.getElementById('search-back-btn').addEventListener('click', () => {
    // 返回时，重新打开聊天设置弹窗
    showScreen('chat-interface-screen');
    document.getElementById('chat-settings-btn').click();
});

document.getElementById('perform-search-btn').addEventListener('click', performChatSearch);

// 使用事件委托来处理所有搜索结果的点击
document.getElementById('chat-search-results-list').addEventListener('click', (e) => {
    const item = e.target.closest('.search-result-item');
    if (item && item.dataset.timestamp) {
        jumpToMessage(parseInt(item.dataset.timestamp));
    }
});
// ▲▲▲ 新事件绑定结束 ▲▲▲
// ▼▼▼ 在 init() 函数的事件监听器区域，粘贴这行新代码 ▼▼▼

document.getElementById('create-weibo-post-btn').addEventListener('click', openWeiboPublisherClean);

// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 在 init() 函数的事件监听器区域末尾，粘贴下面这行新代码 ▼▼▼
document.getElementById('delete-expired-songs-btn').addEventListener('click', deleteExpiredSearchedSongs);
// ▼▼▼ 【修改】用这块【功能增强版】的代码，完整替换掉你旧的 weibo-following-list-container 事件监听器 ▼▼▼
document.getElementById('weibo-following-list-container').addEventListener('click', (e) => {
    const item = e.target.closest('.weibo-following-item');
    if (!item) return;

    // 1. 检查点击的是否是“操作”按钮
    const triggerBtn = e.target.closest('.weibo-action-trigger-btn');
    if (triggerBtn) {
        const targetInfo = {
            id: triggerBtn.dataset.targetId,
            name: triggerBtn.dataset.targetName,
            isNpc: triggerBtn.dataset.isNpc === 'true',
            ownerId: triggerBtn.dataset.ownerId || null
        };
        openWeiboActionModal(targetInfo);
    } 
    // 2. 如果点击的不是操作按钮，就视为点击了整行，触发“查看私信”
    else {
        // 先隐藏当前的关注列表弹窗
        document.getElementById('weibo-following-modal').classList.remove('visible');
        
        // 从整行item上获取角色信息
        const actionBtn = item.querySelector('.weibo-action-trigger-btn'); // 找到这一行的按钮以获取数据
        if (actionBtn) {
            const targetInfo = {
                id: actionBtn.dataset.targetId,
                name: actionBtn.dataset.targetName,
                isNpc: actionBtn.dataset.isNpc === 'true',
                ownerId: actionBtn.dataset.ownerId || null
            };
            // ★★★ 核心修改：调用我们新写的总入口函数 ★★★
            openWeiboDms(targetInfo);
        }
    }
});
// ▲▲▲ 替换结束 ▲▲▲

// ▲▲▲ 替换结束 ▲▲▲
document.getElementById('cancel-weibo-action-btn').addEventListener('click', () => {
    document.getElementById('weibo-action-modal').classList.remove('visible');
});

document.getElementById('confirm-weibo-action-btn').addEventListener('click', handleWeiboAiAction);

// ▲▲▲ 新代码粘贴结束 ▲▲▲

// 【已修改】为“生成热搜”和“生成广场”按钮绑定新的带角色选择的事件
document.getElementById('generate-hot-search-btn').addEventListener('click', async () => {
    const targets = await showMultiCharacterSelectorForWeibo(); // 调用新的多选函数
    if (targets) { 
        await generateHotSearch(targets); 
    }
});
document.getElementById('generate-plaza-feed-btn').addEventListener('click', async () => {
    const targets = await showMultiCharacterSelectorForWeibo();
    if (targets) {
        await generatePlazaFeed(null, targets); 
    }
});


// ▼▼▼ 在 init() 的事件监听器区域末尾，粘贴这整块新代码 ▼▼▼

// --- 微博热搜与广场功能事件绑定 ---

// 1. 绑定热搜详情页的“返回”按钮
document.getElementById('back-from-hottopic-btn').addEventListener('click', () => {
    switchToWeiboView('weibo-hot-search-view');
});

// 2. 绑定热搜详情页的“换一批”按钮
document.getElementById('refresh-hottopic-feed-btn').addEventListener('click', () => {
    if (currentHotTopic) {
        generateHotSearchFeed(currentHotTopic);
    }
});

// ▲▲▲ 新代码粘贴结束 ▲▲▲

    // ▼▼▼ 第2步 第5处修改（新增事件监听器） ▼▼▼
    // 【全新】角色表情包管理功能事件绑定
    document.getElementById('chat-settings-modal').addEventListener('click', (e) => {
        if (e.target.id === 'manage-char-stickers-btn') {
            document.getElementById('chat-settings-modal').classList.remove('visible');
            openCharStickerManager();
        }
    });

    document.getElementById('back-from-sticker-manager').addEventListener('click', () => {
        showScreen('chat-interface-screen');
        document.getElementById('chat-settings-btn').click();
    });

// ▼▼▼ 用这块新代码替换旧的页签切换事件 ▼▼▼
const stickerTabExclusive = document.getElementById('sticker-tab-exclusive');
const stickerTabCommon = document.getElementById('sticker-tab-common');
const stickerContentExclusive = document.getElementById('sticker-content-exclusive');
const stickerContentCommon = document.getElementById('sticker-content-common');

stickerTabExclusive.addEventListener('click', () => {
    stickerTabExclusive.classList.add('active');
    stickerTabCommon.classList.remove('active');
    stickerContentExclusive.classList.add('active');
    stickerContentCommon.classList.remove('active');
    // 切换时如果处于选择模式，需要重新渲染
    if (isCharStickerSelectionMode) renderCharStickers('exclusive');
});

stickerTabCommon.addEventListener('click', () => {
    stickerTabCommon.classList.add('active');
    stickerTabExclusive.classList.remove('active');
    stickerContentCommon.classList.add('active');
    stickerContentExclusive.classList.remove('active');
    // 切换时如果处于选择模式，需要重新渲染
    if (isCharStickerSelectionMode) renderCharStickers('common');
});
// ▲▲▲ 替换结束 ▲▲▲

    // 绑定各种添加/上传按钮
    document.getElementById('add-exclusive-sticker-btn').addEventListener('click', () => bulkAddCharStickers('exclusive'));
    document.getElementById('upload-exclusive-sticker-btn').addEventListener('click', () => uploadCharStickersLocal('exclusive'));
    document.getElementById('add-common-sticker-btn').addEventListener('click', () => bulkAddCharStickers('common'));
    document.getElementById('upload-common-sticker-btn').addEventListener('click', () => uploadCharStickersLocal('common'));

    // ▲▲▲ 新增事件监听器结束 ▲▲▲

// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 【全新】心声历史记录删除功能事件绑定 ▼▼▼
document.getElementById('clear-all-history-btn').addEventListener('click', clearAllInnerVoiceHistory);

// 使用事件委托处理单条删除
document.getElementById('inner-voice-history-list').addEventListener('click', (e) => {
    if (e.target.classList.contains('history-item-delete-btn')) {
        const timestamp = parseInt(e.target.dataset.timestamp);
        if (!isNaN(timestamp)) {
            deleteSingleInnerVoice(timestamp);
        }
    }
});
// ▲▲▲ 心声历史删除事件绑定结束 ▲▲▲

// ▼▼▼ 这是我们新加的导入功能事件监听 (已添加弹窗确认) ▼▼▼
document.getElementById('import-character-card-btn').addEventListener('click', async () => {
    // 1. 弹出确认弹窗，并等待用户选择
    const confirmed = await showCustomConfirm(
        '导入角色卡须知', // 这是弹窗的标题
        '🐱不玩酒馆的请不要导入酒馆角色卡，经过写卡老师同意才能导入角色卡，不要随意辱骂侮辱角色🐇' // 这是弹窗的主要内容
    );

    // 2. 如果用户点击了“确定”
    if (confirmed) {
        // 就去触发那个隐藏的文件选择框
        document.getElementById('character-card-input').click();
    }
    // 如果用户点击“取消”，则什么也不会发生
});


        document.getElementById('character-card-input').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                // 当用户选择了文件后，调用我们的总处理函数
                handleCharacterImport(file);
            }
            // 清空选择，这样用户下次还能选择同一个文件
            event.target.value = null; 
        });
        // ▲▲▲ 新事件监听结束 ▲▲▲
// ▼▼▼ 在 init() 的事件监听器区域，粘贴这行新代码 ▼▼▼
document.getElementById('phone-screen').addEventListener('click', unlockAudioContext, { once: true });
// ▲▲▲ 新代码粘贴结束 ▲▲▲
            document.getElementById('custom-modal-cancel').addEventListener('click', hideCustomModal);
            document.getElementById('custom-modal-overlay').addEventListener('click', (e) => { if (e.target === modalOverlay) hideCustomModal(); });
            document.getElementById('clear-orphaned-data-btn').addEventListener('click', clearOrphanedData);
            document.getElementById('export-data-btn').addEventListener('click', exportBackup);
            document.getElementById('import-btn').addEventListener('click', () => document.getElementById('import-data-input').click());
            document.getElementById('import-data-input').addEventListener('change', e => importBackup(e.target.files[0]));
            document.getElementById('back-to-list-btn').addEventListener('click', () => { 
 stopPetDecayTimer();
    // ▼▼▼ 修改这两行 ▼▼▼
    applyScopedCss('', '#chat-messages', 'custom-bubble-style'); // 清除真实聊天界面的自定义样式
    applyScopedCss('', '#settings-preview-area', 'preview-bubble-style'); // 清除预览区的自定义样式
    // ▲▲▲ 修改结束 ▲▲▲

exitSelectionMode(); state.activeChatId = null;
// 【心声功能】返回列表时，隐藏心形按钮
document.getElementById('char-heart-btn').style.display = 'none';
 showScreen('chat-list-screen'); });
            // ▼▼▼ 在 init() 的事件监听器区域末尾，粘贴这段新代码 ▼▼▼
            // 为歌曲封面/歌词区域绑定点击切换事件
            document.getElementById('music-display-area').addEventListener('click', () => {
                const displayArea = document.getElementById('music-display-area');
                // 直接切换 .show-lyrics 这个类，CSS会自动处理显示/隐藏
                displayArea.classList.toggle('show-lyrics');
            });
            // ▲▲▲ 新代码粘贴结束 ▲▲▲

                        document.getElementById('add-chat-btn').addEventListener('click', async () => { 
                const name = await showCustomPrompt('创建新聊天', '请输入Ta的名字'); 
                if (name && name.trim()) { 
                    const newChatId = 'chat_' + Date.now(); 
                    
                    // ▼▼▼ 从这里开始替换 ▼▼▼
                const newChat = {
                    id: newChatId,
                    name: name.trim(),
                    isGroup: false,
                    isPinned: false,
                    npcLibrary: [], // 角色专属NPC库
                    relationship: { status: 'friend', blockedTimestamp: null, applicationReason: '' },
                    status: { text: '在线', lastUpdate: Date.now(), isBusy: false },
                    settings: {
                        aiPersona: '你是谁呀。',
                        myPersona: '我是谁呀。',
                        maxMemory: 10,
                        aiAvatar: defaultAvatar,
                        myAvatar: defaultAvatar,
                        background: '',
                        theme: 'default',
                        fontSize: 13,
                        customCss: '',
                        linkedWorldBookIds: [],
                        aiAvatarLibrary: [],
                        stickerLibrary: [], // 专属表情库
                        // === 以下是本次修复新增的初始化属性 ===
                        linkedMemories: [], // 【修复核心】初始化记忆互通数组
                        offlineMode: { enabled: false, prompt: '', style: '', wordCount: 300, presets: [] }, // 初始化线下模式
                        timePerceptionEnabled: true, // 初始化时间感知
                        customTime: '', // 初始化自定义时间
                        isCoupleAvatar: false, // 初始化情侣头像开关
                        coupleAvatarDescription: '', // 初始化情侣头像描述
                        weiboProfession: '', // 初始化微博职业
                        weiboInstruction: '' // 初始化微博指令
                    },
                    history: [],
                    musicData: { totalTime: 0 },
                    // 手机数据也保持完整
                    characterPhoneData: {
                        lastGenerated: null, chats: {}, shoppingCart: [], memos: [],
                        browserHistory: [], photoAlbum: [], bank: { balance: 0, transactions: [] },
                        trajectory: [], appUsage: [], diary: []
                    }
                };
// ▲▲▲ 替换到这里结束 ▲▲▲


                    state.chats[newChatId] = newChat; 
                    await db.chats.put(newChat); 
                    renderChatList(); 
                } 
            });

            // ▼▼▼ 【修正】创建群聊按钮现在打开联系人选择器 ▼▼▼
document.getElementById('add-group-chat-btn').addEventListener('click', openContactPickerForGroupCreate);
// ▲▲▲ 替换结束 ▲▲▲                      
            document.getElementById('transfer-cancel-btn').addEventListener('click', () => document.getElementById('transfer-modal').classList.remove('visible'));
            document.getElementById('transfer-confirm-btn').addEventListener('click', sendUserTransfer);
            document.getElementById('listen-together-btn').addEventListener('click', handleListenTogetherClick);
            document.getElementById('music-exit-btn').addEventListener('click', () => endListenTogetherSession(true));
            document.getElementById('music-return-btn').addEventListener('click', returnToChat);
            document.getElementById('music-play-pause-btn').addEventListener('click', togglePlayPause);
            document.getElementById('music-next-btn').addEventListener('click', playNext);
            document.getElementById('music-prev-btn').addEventListener('click', playPrev);
            document.getElementById('music-mode-btn').addEventListener('click', changePlayMode);
            document.getElementById('music-playlist-btn').addEventListener('click', () => { updatePlaylistUI(); document.getElementById('music-playlist-panel').classList.add('visible'); });
            document.getElementById('close-playlist-btn').addEventListener('click', () => document.getElementById('music-playlist-panel').classList.remove('visible'));
            document.getElementById('add-song-url-btn').addEventListener('click', addSongFromURL);
            document.getElementById('add-song-local-btn').addEventListener('click', () => document.getElementById('local-song-upload-input').click());
            document.getElementById('local-song-upload-input').addEventListener('change', addSongFromLocal);
            // ▼▼▼ 【全新】BGM搜索功能事件绑定 ▼▼▼
document.getElementById('add-song-search-btn').addEventListener('click', addSongFromSearch);

document.getElementById('cancel-music-search-btn').addEventListener('click', () => {
    document.getElementById('music-search-results-modal').classList.remove('visible');
});

document.getElementById('search-results-list').addEventListener('click', (e) => {
    const item = e.target.closest('.search-result-item');
    if (item && item.dataset.songJson) {
        const songData = JSON.parse(item.dataset.songJson);
        handleSearchResultClick(songData);
    }
});
// ▲▲▲ 新增事件绑定结束 ▲▲▲

            audioPlayer.addEventListener('ended', playNext);

            const chatInput = document.getElementById('chat-input');
            // ▼▼▼ 找到 id="send-btn" 的 click 事件监听器 ▼▼▼
document.getElementById('send-btn').addEventListener('click', async () => { 
    const content = chatInput.value.trim(); 
    if (!content || !state.activeChatId) return; 
        // --- ▼▼▼【核心修复代码】▼▼▼ ---
    try {
        const command = JSON.parse(content);
        // 检查：这是否是一个让角色发微博的指令？
        if (command && command.type === 'weibo_post') {
            const chat = state.chats[state.activeChatId];
            if (chat.isGroup) {
                alert("不能在群聊中为单个角色发布微博。");
                return;
            }

            // 创建一个新的微博帖子对象
            const newPost = {
                authorId: chat.id, // 关键！作者ID是当前角色的ID，而不是'user'
                authorType: 'char',
                authorNickname: chat.name,
                authorAvatar: chat.settings.aiAvatar || defaultAvatar,
                content: command.content || '',
                timestamp: Date.now(),
                likes: [],
                comments: [],
                baseLikesCount: command.baseLikesCount || 0,
                baseCommentsCount: command.baseCommentsCount || 0
            };

            // 如果JSON里有路人评论，就解析并添加
            if (command.comments && typeof command.comments === 'string') {
                newPost.comments = command.comments.split('\n').map(c => {
                    const parts = c.split(/[:：]/);
                    const commenter = parts.shift() || '路人';
                    const commentText = parts.join(':').trim();
                    return { commentId: 'comment_' + Date.now() + Math.random(), authorNickname: commenter, commentText: commentText };
                }).filter(c => c.commentText);
            }

            await db.weiboPosts.add(newPost);
            
            // 刷新“关注的人”列表，新微博就会出现了！
            await renderFollowingWeiboFeed();

            await showCustomAlert('操作成功', `已为 “${chat.name}” 发布了一条新微博！`);
            
            chatInput.value = ''; // 清空输入框
            return; // 结束函数，不再执行后面的代码
        }
    } catch (e) {
        // 如果解析JSON失败，说明它不是指令，只是普通文本，就让代码继续往下走
    }
    // --- ▲▲▲【修复代码结束】▲▲▲ ---
    const chat = state.chats[state.activeChatId]; 
        // 1. 如果是群聊，并且你被禁言了
    if (chat && chat.isGroup && chat.settings.isUserMuted) {
        alert('你已被禁言，无法发言！');
        return; // 阻止发送
    }
    // ▲▲▲ 新代码粘贴结束 ▲▲▲
    // --- 【核心修改】在这里添加 ---
    const msg = { 
        role: 'user', 
        content, 
        timestamp: Date.now() 
    };

    // 检查当前是否处于引用回复模式
    if (currentReplyContext) {
        msg.quote = currentReplyContext; // 将引用信息附加到消息对象上
    }
    // --- 【修改结束】 ---
    
    chat.history.push(msg); 
    await db.chats.put(chat); 
    appendMessage(msg, chat); 
    renderChatList(); 
    chatInput.value = ''; 
    chatInput.style.height = 'auto'; 
    chatInput.focus(); 
    
    // --- 【核心修改】发送后，取消引用模式 ---
    cancelReplyMode(); 
});
            document.getElementById('wait-reply-btn').addEventListener('click', triggerAiResponse);
            chatInput.addEventListener('keypress', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); document.getElementById('send-btn').click(); } });
            chatInput.addEventListener('input', () => { chatInput.style.height = 'auto'; chatInput.style.height = (chatInput.scrollHeight) + 'px'; });

            document.getElementById('wallpaper-upload-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if(file) { const dataUrl = await new Promise((res, rej) => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.onerror = () => rej(reader.error); reader.readAsDataURL(file); }); newWallpaperBase64 = dataUrl; renderWallpaperScreen(); } });
// ▼▼▼ 用这整块【修复版】代码，替换你旧的 save-wallpaper-btn 事件监听器 ▼▼▼
document.getElementById('save-wallpaper-btn').addEventListener('click', async () => {
    let changesMade = false;

    // 保存壁纸
    if (newWallpaperBase64) {
        state.globalSettings.wallpaper = newWallpaperBase64;
        changesMade = true;
    }

    // 保存锁屏壁纸
    if (newLockscreenWallpaperBase64) {
        state.globalSettings.lockscreenWallpaper = newLockscreenWallpaperBase64;
        changesMade = true;
    }

    // 保存全局聊天背景
    if (newGlobalBgBase64 === 'REMOVED') { 
        state.globalSettings.globalChatBackground = '';
        changesMade = true;
    } else if (newGlobalBgBase64) { 
        state.globalSettings.globalChatBackground = newGlobalBgBase64;
        changesMade = true;
    }

    // 保存密码
    const newPassword = document.getElementById('password-set-input').value;
    state.globalSettings.password = newPassword;

    // 保存铃声
    state.globalSettings.ringtoneUrl = document.getElementById('ringtone-url-input').value.trim();

    // ★★★★★ 这就是我们本次修复的核心！ ★★★★★
    // 在这里，我们新增了下面这一行，用来保存消息提示音的URL
    state.globalSettings.notificationSoundUrl = document.getElementById('notification-sound-url-input').value.trim();
    // ★★★★★ 修复结束 ★★★★★

    const activeThemeSelector = document.getElementById('theme-selector');
    if (activeThemeSelector.value) {
        state.globalSettings.activeThemeId = parseInt(activeThemeSelector.value);
    } else {
        state.globalSettings.activeThemeId = null;
    }
    
    const isLockEnabled = document.getElementById('enable-lock-screen-toggle').checked;
    state.globalSettings.enableLockScreen = isLockEnabled;
    localStorage.setItem('lockScreenEnabled', isLockEnabled);

    state.globalSettings.homeIconWidgetTextColor = document.getElementById('home-icon-widget-text-color-picker').value;
    state.globalSettings.removeHomeFontShadow = document.getElementById('remove-home-font-shadow-toggle').checked;
    saveAppLabels();

    await db.globalSettings.put(state.globalSettings);

    // 应用所有更改
    if (changesMade) {
        applyGlobalWallpaper();        
        applyLockscreenWallpaper(); 
        newWallpaperBase64 = null;        
        newLockscreenWallpaperBase64 = null; 
        newGlobalBgBase64 = null; 
    }
    applyAppIcons(); 
    applyAppLabels();
    
    alert('外观设置已保存并应用！');
    showScreen('home-screen');
});
// ▲▲▲ 替换结束 ▲▲▲


            document.getElementById('save-api-settings-btn').addEventListener('click', async () => { 

    const proxyUrl = document.getElementById('proxy-url').value.trim();
    const apiKey = document.getElementById('api-key').value.trim();
    const isBlocked = BLOCKED_API_SITES.some(blockedDomain => proxyUrl.includes(blockedDomain));

if (isBlocked) {
    alert('错误：该 API 站点已被禁用，无法使用。');
    return; // 阻止保存
}
// ▲▲▲ 新代码粘贴结束 ▲▲▲

state.apiConfig.proxyUrl = document.getElementById('proxy-url').value.trim(); 
state.apiConfig.apiKey = document.getElementById('api-key').value.trim(); 
state.apiConfig.model = document.getElementById('model-select').value; 
state.apiConfig.temperature = parseFloat(document.getElementById('temperature-slider').value);
    // 【核心新增】保存 Minimax 设置
    state.apiConfig.minimaxGroupId = document.getElementById('minimax-group-id').value.trim();
    state.apiConfig.minimaxApiKey = document.getElementById('minimax-api-key').value.trim();
    state.apiConfig.minimaxSpeechModel = document.getElementById('minimax-speech-model-select').value;
await db.apiConfig.put(state.apiConfig); 

// 在 'save-api-settings-btn' 的 click 事件监听器内部
// await db.apiConfig.put(state.apiConfig); 这行之后

// ▼▼▼ 将之前那段保存后台活动设置的逻辑，替换为下面这个增强版 ▼▼▼

const backgroundSwitch = document.getElementById('background-activity-switch');
const intervalInput = document.getElementById('background-interval-input');
const newEnableState = backgroundSwitch.checked;
const oldEnableState = state.globalSettings.enableBackgroundActivity || false;

// 只有在用户“从关到开”时，才弹出警告
if (newEnableState && !oldEnableState) {
    const userConfirmed = confirm(
        "【高费用警告】\n\n" +
        "您正在启用“后台角色活动”功能。\n\n" +
        "这会使您的AI角色们在您不和他们聊天时，也能“独立思考”并主动给您发消息或进行社交互动，极大地增强沉浸感。\n\n" +
        "但请注意：\n" +
        "这会【在后台自动、定期地调用API】，即使您不进行任何操作。根据您的角色数量和检测间隔，这可能会导致您的API费用显著增加。\n\n" +
        "您确定要开启吗？"
    );

    if (!userConfirmed) {
        backgroundSwitch.checked = false; // 用户取消，把开关拨回去
        return; // 阻止后续逻辑
    }
}

state.globalSettings.enableBackgroundActivity = newEnableState;
state.globalSettings.backgroundActivityInterval = parseInt(intervalInput.value) || 60;
state.globalSettings.blockCooldownHours = parseFloat(document.getElementById('block-cooldown-input').value) || 1;
await db.globalSettings.put(state.globalSettings);

// 动态启动或停止模拟器
stopBackgroundSimulation();
if (state.globalSettings.enableBackgroundActivity) {
    startBackgroundSimulation();
    console.log(`后台活动模拟已启动，间隔: ${state.globalSettings.backgroundActivityInterval}秒`);
} else {
    console.log("后台活动模拟已停止。");
}
// ▲▲▲ 替换结束 ▲▲▲

alert('API设置已保存!'); });

                    // gemini 密钥聚焦的时候显示明文
        const ApiKeyInput = document.getElementById('api-key')
        ApiKeyInput.addEventListener('focus', (e) => {
            e.target.setAttribute('type', 'text')
        })
        ApiKeyInput.addEventListener('blur', (e) => {
            e.target.setAttribute('type', 'password')
        })


        document.getElementById('fetch-models-btn').addEventListener('click', async () => {
            const url = document.getElementById('proxy-url').value.trim();
            const key = document.getElementById('api-key').value.trim();
            if (!url || !key) return alert('请先填写反代地址和密钥');
            try {

                let  isGemini = url === GEMINI_API_URL;
                const response = await fetch(isGemini ? `${GEMINI_API_URL}?key=${getRandomValue(key)}` : `${url}/v1/models`,isGemini ? undefined : {headers: {'Authorization': `Bearer ${key}`}});
                if (!response.ok) throw new Error('无法获取模型列表');
                const data = await response.json();
                let models = isGemini ? data.models : data.data;
                if(isGemini){
                    models = models.map((model)=>{
                        const parts = model.name.split('/');
                        return {
                            id:parts.length > 1 ? parts[1] : model.name
                        }
                    })
                }
                const modelSelect = document.getElementById('model-select');
                modelSelect.innerHTML = '';
                models.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model.id;
                    option.textContent = model.id;
                    if (model.id === state.apiConfig.model) option.selected = true;
                    modelSelect.appendChild(option);
                });
                alert('模型列表已更新');
            } catch (error) {
                alert(`拉取模型失败: ${error.message}`);
            }
        });
        document.getElementById('fetch-minimax-speech-models-btn').addEventListener('click', fetchMinimaxSpeechModels);
        // ▼▼▼ 【全新】世界书导入功能事件绑定 ▼▼▼
document.getElementById('import-world-book-btn').addEventListener('click', () => {
    // 点击“导入”按钮时，触发隐藏的文件选择框
    document.getElementById('world-book-import-input').click();
});

document.getElementById('world-book-import-input').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
        // 当用户选择了文件后，调用我们的核心处理函数
        handleImportSillyTavernWorldBook(file);
    }
    // 每次用完后清空，这样用户下次还能选择同一个文件
    e.target.value = null; 
});
// ▲▲▲ 新增事件绑定结束 ▲▲▲

            document.getElementById('add-world-book-btn').addEventListener('click', async () => { const name = await showCustomPrompt('创建世界书', '请输入书名'); if (name && name.trim()) { const newBook = { id: 'wb_' + Date.now(), name: name.trim(), content: '' }; await db.worldBooks.add(newBook); state.worldBooks.push(newBook); renderWorldBookScreen(); openWorldBookEditor(newBook.id); } });
            document.getElementById('save-world-book-btn').addEventListener('click', async () => { if (!editingWorldBookId) return; const book = state.worldBooks.find(wb => wb.id === editingWorldBookId); if (book) { const newName = document.getElementById('world-book-name-input').value.trim(); if (!newName) { alert('书名不能为空！'); return; } book.name = newName; book.content = document.getElementById('world-book-content-input').value; 

        // ▼▼▼ 【核心修改】在这里保存分类ID ▼▼▼
        const categoryId = document.getElementById('world-book-category-select').value;
        // 如果选择了“未分类”，存入 null；否则存入数字ID
        book.categoryId = categoryId ? parseInt(categoryId) : null; 
        // ▲▲▲ 修改结束 ▲▲▲

await db.worldBooks.put(book); document.getElementById('world-book-editor-title').textContent = newName; editingWorldBookId = null; renderWorldBookScreen(); showScreen('world-book-screen'); } });
// ▼▼▼ 第3步：用这整块【全新的】代码，完整替换旧的 'chat-messages' 点击事件监听器 ▼▼▼
document.getElementById('chat-messages').addEventListener('click', async (e) => {
    
    const voiceBody = e.target.closest('.voice-message-body');
    if (voiceBody) {
        const bubble = voiceBody.closest('.message-bubble');
        if (!bubble) return;

        // 如果是用户自己的语音，只切换文字显示，不播放
        if (bubble.classList.contains('user')) {
            toggleVoiceTranscript(bubble);
            return;
        }

// ▼▼▼ 请用下面这段【已修复点击收起功能】的代码，完整替换你旧的AI语音点击处理逻辑 ▼▼▼
        // 如果是AI的语音消息
        const chat = state.chats[state.activeChatId];
        if (!chat) return;

        // --- 核心逻辑开始 ---

        // 1. 检查是否点击了正在播放的语音条
        if (isTtsPlaying && currentTtsAudioBubble === bubble) {
            // 如果是，则停止播放并收起所有关联的文字
            stopMinimaxAudio(); 
        } 
        // 2. 检查点击的是否是已经展开了文字但没有播放的语音条
        else if (bubble.dataset.state === 'expanded') {
            // 如果是，则只收起文字，不影响其他
            toggleVoiceTranscript(bubble);
        }
        // 3. 如果以上都不是，说明是想开始播放或只展开文字
        else {
            const clickedTimestamp = parseInt(bubble.dataset.timestamp);
            const startIndex = chat.history.findIndex(m => m.timestamp === clickedTimestamp);
            if (startIndex === -1) return;

            // 查找连续的语音消息
            const messagesToPlay = findConsecutiveAiVoiceMessages(chat.history, startIndex);
            if (messagesToPlay.length > 0) {
                const bubblesToAnimate = messagesToPlay.map(m => document.querySelector(`.message-bubble[data-timestamp="${m.timestamp}"]`)).filter(Boolean);
                
                // 检查配置，决定是播放还是只显示文字
                const groupId = state.apiConfig.minimaxGroupId;
                const apiKey = state.apiConfig.minimaxApiKey;
                const voiceId = chat.settings.minimaxVoiceId;

                if (groupId && apiKey && voiceId) {
                    // 【播放分支】
                    // 先展开所有文字
                    bubblesToAnimate.forEach(b => {
                        if (b.dataset.state !== 'expanded') {
                            toggleVoiceTranscript(b);
                        }
                    });
                    // 然后调用播放器
                    const combinedText = messagesToPlay.map(m => m.content.trim()).join('，');
                    playMinimaxAudio(combinedText, voiceId, bubblesToAnimate);
                } else {
                    // 【只显示文字分支】
                    // 只展开当前点击的这一个语音条的文字
                    toggleVoiceTranscript(bubble);
                }
            }
        }
        
        return; // 处理完语音后退出
    }
// ▲▲▲ 替换结束 ▲▲▲




    // --- 你原来的其他点击事件逻辑 ---
    const aiImage = e.target.closest('.ai-generated-image');
    if (aiImage) {
        const description = aiImage.dataset.description;
        if (description) showCustomAlert('照片描述', description);
        return;
    }
    const linkCard = e.target.closest('.link-share-card');
    if (linkCard && linkCard.closest('.message-bubble.is-link-share')) {
        const timestamp = parseInt(linkCard.dataset.timestamp);
        if (!isNaN(timestamp)) {
            openBrowser(timestamp);
        }
    }
    const packetCard = e.target.closest('.red-packet-card');
    if (packetCard) {
        const messageBubble = packetCard.closest('.message-bubble');
        if (messageBubble && messageBubble.dataset.timestamp) {
            const timestamp = parseInt(messageBubble.dataset.timestamp);
            handlePacketClick(timestamp);
        }
    }
    const pollCard = e.target.closest('.poll-card');
    if (pollCard) {
        const timestamp = parseInt(pollCard.dataset.pollTimestamp);
        if (isNaN(timestamp)) return;
        const optionItem = e.target.closest('.poll-option-item');
        if (optionItem && !pollCard.classList.contains('closed')) {
            handleUserVote(timestamp, optionItem.dataset.option);
            return;
        }
        const actionBtn = e.target.closest('.poll-action-btn');
        if (actionBtn) {
            if (pollCard.classList.contains('closed')) {
                showPollResults(timestamp);
            } else {
                endPoll(timestamp);
            }
            return;
        }
        if (pollCard.classList.contains('closed')) {
            showPollResults(timestamp);
        }
    }
    const card = e.target.closest('.waimai-card');
    if (card) {
        const messageBubble = card.closest('.message-bubble');
        const invitationMsg = state.chats[state.activeChatId].history.find(m => m.timestamp === parseInt(messageBubble.dataset.timestamp));
        if (invitationMsg && invitationMsg.type === 'lovers_space_invitation' && invitationMsg.status === 'pending') {
            const choice = e.target.dataset.choice;
            if (choice) {
                handleLoversSpaceResponse(invitationMsg.timestamp, choice);
            }
        }
    }
    const repostCard = e.target.closest('.link-share-card[data-post-id]');
    if (repostCard) {
        const postId = parseInt(repostCard.dataset.postId);
        if (!isNaN(postId)) {
            openPost(postId);
        }
    }
    
    // 【新增】处理分享卡片的点击
    const shareCard = e.target.closest('.link-share-card[data-timestamp]');
    if (shareCard && shareCard.closest('.message-bubble.is-link-share')) {
        const timestamp = parseInt(shareCard.dataset.timestamp);
        if(!isNaN(timestamp)) {
            const msg = state.chats[state.activeChatId].history.find(m=>m.timestamp===timestamp);
            if(msg && msg.type === 'share_card') openSharedHistoryViewer(timestamp);
            else if(msg && msg.type === 'share_link') openBrowser(timestamp);
        }
    }
    
    // 【新增】处理已撤回消息的点击
    const placeholder = e.target.closest('.recalled-message-placeholder');
    if (placeholder) {
        const wrapper = placeholder.closest('.message-wrapper');
        const chat = state.chats[state.activeChatId];
        if (chat && wrapper) {
            const timestamp = parseInt(wrapper.dataset.timestamp);
            const recalledMsg = chat.history.find(m => m.timestamp === timestamp);
            if (recalledMsg && recalledMsg.recalledData) {
                let originalContentText = '';
                const recalled = recalledMsg.recalledData;
                if (recalled.originalType === 'text') {
                    originalContentText = `原文: "${recalled.originalContent}"`;
                } else {
                    originalContentText = `撤回了一条[${recalled.originalType}]类型的消息`;
                }
                showCustomAlert('已撤回的消息', originalContentText);
            }
        }
    }
});
// ▲▲▲ 替换结束 ▲▲▲
            const chatSettingsModal = document.getElementById('chat-settings-modal');
            const worldBookSelectBox = document.querySelector('.custom-multiselect .select-box');
            const worldBookCheckboxesContainer = document.getElementById('world-book-checkboxes-container');

function updateWorldBookSelectionDisplay() { const checkedBoxes = worldBookCheckboxesContainer.querySelectorAll('input:checked'); const displayText = document.querySelector('.selected-options-text'); if (checkedBoxes.length === 0) { displayText.textContent = '-- 点击选择 --'; } else if (checkedBoxes.length > 2) { displayText.textContent = `已选择 ${checkedBoxes.length} 项`; } else { displayText.textContent = Array.from(checkedBoxes).map(cb => cb.parentElement.textContent.trim()).join(', '); } }        
            
            worldBookSelectBox.addEventListener('click', (e) => { e.stopPropagation(); worldBookCheckboxesContainer.classList.toggle('visible'); worldBookSelectBox.classList.toggle('expanded'); });
            document.getElementById('world-book-checkboxes-container').addEventListener('change', updateWorldBookSelectionDisplay);
            window.addEventListener('click', (e) => { if (!document.querySelector('.custom-multiselect').contains(e.target)) { worldBookCheckboxesContainer.classList.remove('visible'); worldBookSelectBox.classList.remove('expanded'); } });

// ▼▼▼ 请用这段【完整、全新的代码】替换旧的 chat-settings-btn 点击事件 ▼▼▼
document.getElementById('chat-settings-btn').addEventListener('click', async () => {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    const isGroup = chat.isGroup;
    document.getElementById('offline-mode-section').style.display = isGroup ? 'none' : 'block';
document.getElementById('couple-avatar-group').style.display = isGroup ? 'none' : 'block';
document.getElementById('streak-settings-section').style.display = isGroup ? 'none' : 'block';
// ▼▼▼ 在 const chat = ... 的下一行，粘贴这段新代码 ▼▼▼
// 计算总消息条数并更新显示
const totalMessages = chat.history.length;
const countDisplay = document.getElementById('total-message-count-display');
if (countDisplay) {
    countDisplay.textContent = `${totalMessages} 条`;
}
// ▲▲▲ 新代码粘贴结束 ▲▲▲
    // 计算并显示上下文Token数
    const contextTextForToken = await getContextForTokenCalculation(state.activeChatId);
    const tokenCount = calculateTokenCount(contextTextForToken);
    const tokenDisplay = document.getElementById('context-token-count-display');
    if (tokenDisplay) {
        tokenDisplay.textContent = tokenCount.toLocaleString(); // toLocaleString() 会给数字加上千位分隔符，例如 "1,234"
    }
    // ▲▲▲ 新代码粘贴结束 ▲▲▲
    // --- 统一显示/隐藏控件 ---
    // ▼▼▼ 在 chat-settings-btn 的 click 事件中，粘贴这段代码 ▼▼▼
const videoCallSettingsGroup = document.getElementById('video-call-settings-group');
const visualCallSwitch = document.getElementById('visual-video-call-switch');
const imageUploadsDiv = document.getElementById('video-call-image-uploads');
// --- 加载聊天总结设置 ---
const summarySettings = chat.settings.summary || {};
const summaryToggle = document.getElementById('summary-toggle');
const summaryDetails = document.getElementById('summary-details-container');

summaryToggle.checked = summarySettings.enabled || false;
summaryDetails.style.display = summaryToggle.checked ? 'block' : 'none';

document.querySelector(`input[name="summary-mode"][value="${summarySettings.mode || 'auto'}"]`).checked = true;
document.getElementById('summary-count-input').value = summarySettings.count || 20;
document.getElementById('summary-prompt-input').value = summarySettings.prompt || '请你以第三人称的视角，客观、冷静、不带任何感情色彩地总结以下对话的核心事件和信息。禁止进行任何角色扮演或添加主观评论。';

// 为开关添加实时交互
summaryToggle.onchange = () => {
    summaryDetails.style.display = summaryToggle.checked ? 'block' : 'none';
};
// ▲▲▲ 新代码粘贴结束 ▲▲▲
if (isGroup) {
    videoCallSettingsGroup.style.display = 'none'; // 群聊不支持，隐藏整个设置区
} else {
    videoCallSettingsGroup.style.display = 'block'; // 单聊显示
    
    // 加载当前设置
    visualCallSwitch.checked = chat.settings.visualVideoCallEnabled || false;
    imageUploadsDiv.style.display = visualCallSwitch.checked ? 'block' : 'none';
    document.getElementById('char-video-image-preview').src = chat.settings.charVideoImage || 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png';
    document.getElementById('user-video-image-preview').src = chat.settings.userVideoImage || 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png';

    // 为开关添加实时交互
    visualCallSwitch.onchange = () => {
        imageUploadsDiv.style.display = visualCallSwitch.checked ? 'block' : 'none';
    };
}
// ▲▲▲ 粘贴结束 ▲▲▲
    
    // --- 线下模式UI渲染 ---
    const offlineModeSettings = chat.settings.offlineMode || { enabled: false, presets: [] }; // 安全获取
    const offlineToggle = document.getElementById('offline-mode-toggle');
    const offlineDetails = document.getElementById('offline-mode-details');

    // 1. 设置开关状态并绑定事件
    offlineToggle.checked = offlineModeSettings.enabled;
    offlineDetails.style.display = offlineToggle.checked ? 'block' : 'none';
    offlineToggle.onchange = () => {
        offlineDetails.style.display = offlineToggle.checked ? 'block' : 'none';
    };

    // 2. 填充输入框
    document.getElementById('offline-prompt-input').value = offlineModeSettings.prompt || '';
    document.getElementById('offline-style-input').value = offlineModeSettings.style || '';
    document.getElementById('offline-word-count-input').value = offlineModeSettings.wordCount || 300;

    // 3. 渲染预设下拉框
    renderOfflinePresetsSelector();

    // ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 【全新】为气泡导入/导出按钮绑定事件 ▼▼▼
document.getElementById('export-bubble-preset-btn').addEventListener('click', exportSelectedBubblePreset);

document.getElementById('import-bubble-preset-btn').addEventListener('click', () => {
    // 点击“导入”按钮时，触发隐藏的文件选择框
    document.getElementById('import-bubble-preset-input').click();
});

document.getElementById('import-bubble-preset-input').addEventListener('change', (e) => {
    // 当用户选择了文件后，调用导入函数处理
    importBubblePreset(e.target.files[0]);
    e.target.value = null; // 每次用完后清空，方便下次选择同一个文件
});
// ▲▲▲ 新事件绑定结束 ▲▲▲

// --- 全新视频通话功能事件绑定 (V2 修正版) ---

// 绑定新界面的挂断按钮
document.getElementById('hang-up-btn-visual').addEventListener('click', endVideoCall);

// 【新增】绑定新界面的发言按钮
document.getElementById('user-speak-btn-visual').addEventListener('click', async () => {
    if (!videoCallState.isActive) return;
    const userInput = await showCustomPrompt('你说', '请输入你想说的话...');
    if (userInput && userInput.trim()) {
        triggerAiInCallAction(userInput.trim());
    }
});

// 绑定切换镜头按钮 (也是小窗本身)
document.getElementById('switch-camera-btn').addEventListener('click', switchVideoViews);
document.getElementById('video-pip-view').addEventListener('click', switchVideoViews);

// 【修正】绑定两个界面的重roll按钮
document.getElementById('reroll-call-btn').addEventListener('click', handleVideoCallReroll);
document.getElementById('reroll-call-btn-text').addEventListener('click', handleVideoCallReroll);

// ▲▲▲ 替换结束 ▲▲▲



    document.getElementById('chat-name-group').style.display = 'block';
    document.getElementById('minimax-voice-id-group').style.display = isGroup ? 'none' : 'block';
    document.getElementById('my-persona-group').style.display = 'block';
    document.getElementById('my-avatar-group').style.display = 'block';
    document.getElementById('my-group-nickname-group').style.display = isGroup ? 'block' : 'none';
    document.getElementById('group-avatar-group').style.display = isGroup ? 'block' : 'none';
    document.getElementById('group-members-group').style.display = isGroup ? 'block' : 'none';
    document.getElementById('ai-persona-group').style.display = isGroup ? 'none' : 'block';
    document.getElementById('ai-avatar-group').style.display = isGroup ? 'none' : 'block';
        // ▼▼▼ 在这里粘贴新代码 ▼▼▼
    document.getElementById('npc-library-group').style.display = isGroup ? 'none' : 'block';
    // ▲▲▲ 粘贴结束 ▲▲▲
            // ▼▼▼ 第2步 第1处修改（新增代码） ▼▼▼
        // 【修改】根据是否为单聊或群聊，显示表情管理按钮
        const charStickerGroup = document.getElementById('char-sticker-group');
        if (charStickerGroup) {
            // 现在无论是单聊还是群聊，这个按钮都会显示
            charStickerGroup.style.display = 'block';
        }

// 【核心新增】根据是否为群聊，显示或隐藏微博设置
document.getElementById('weibo-profession-group').style.display = isGroup ? 'none' : 'block';
document.getElementById('weibo-instruction-group').style.display = isGroup ? 'none' : 'block';
    // 【核心修改1】根据是否为群聊，显示或隐藏“好友分组”区域
    document.getElementById('assign-group-section').style.display = isGroup ? 'none' : 'block';
    
    // --- 加载表单数据 ---
    document.getElementById('chat-name-input').value = chat.name;
    document.getElementById('my-persona').value = chat.settings.myPersona;
    document.getElementById('my-avatar-preview').src = chat.settings.myAvatar || (isGroup ? defaultMyGroupAvatar : defaultAvatar);
    document.getElementById('max-memory').value = chat.settings.maxMemory;
// ▼▼▼ 【全新】记忆互通功能 - UI渲染逻辑 (V2 - 带头像版) ▼▼▼
const memoryLinkSelectBox = document.querySelector('#memory-link-multiselect .select-box');
const memoryLinkCheckboxesContainer = document.getElementById('memory-link-checkboxes-container');
memoryLinkCheckboxesContainer.innerHTML = ''; // 清空旧选项

// 1. 获取除了当前聊天以外的所有聊天
const otherChats = Object.values(state.chats).filter(c => c.id !== chat.id);

// 2. 动态创建带头像的复选框
otherChats.forEach(otherChat => {
    const existingLink = chat.settings.linkedMemories.find(link => link.chatId === otherChat.id);
    const isChecked = existingLink ? 'checked' : '';
    
    // 【核心修改1】根据是群聊还是单聊，获取正确的头像URL
    const avatarUrl = otherChat.isGroup 
        ? (otherChat.settings.groupAvatar || defaultGroupAvatar) 
        : (otherChat.settings.aiAvatar || defaultAvatar);

    const label = document.createElement('label');
    
    // 【核心修改2】构建包含 <img> 标签的新HTML结构
    label.innerHTML = `
        <input type="checkbox" value="${otherChat.id}" ${isChecked}>
        <img src="${avatarUrl}" class="avatar-preview">
        <span>${otherChat.name} ${otherChat.isGroup ? '(群聊)' : ''}</span>
    `;
    memoryLinkCheckboxesContainer.appendChild(label);
});


// 3. 更新已选数量的显示和记忆条数
function updateMemoryLinkDisplay() {
    const checkedBoxes = memoryLinkCheckboxesContainer.querySelectorAll('input:checked');
    const displayText = memoryLinkSelectBox.querySelector('.selected-options-text');
    if (checkedBoxes.length === 0) {
        displayText.textContent = '-- 点击选择 --';
    } else {
        displayText.textContent = `已链接 ${checkedBoxes.length} 个聊天`;
    }
}

    // 4. 加载记忆条数设置
    // 我们现在从一个独立的设置项加载，确保它总能被正确读取
    document.getElementById('link-memory-depth-input').value = chat.settings.linkMemoryDepth || 5;


// 5. 绑定事件
updateMemoryLinkDisplay(); // 初始化显示
memoryLinkCheckboxesContainer.addEventListener('change', updateMemoryLinkDisplay);
// 使用克隆节点技巧来防止事件重复绑定
const newSelectBox = memoryLinkSelectBox.cloneNode(true);
memoryLinkSelectBox.parentNode.replaceChild(newSelectBox, memoryLinkSelectBox);
newSelectBox.addEventListener('click', (e) => {
    e.stopPropagation();
    memoryLinkCheckboxesContainer.classList.toggle('visible');
    newSelectBox.classList.toggle('expanded');
});
// ▲▲▲ 记忆互通UI逻辑结束 ▲▲▲

    // ▼▼▼ 在 max-memory 赋值的下一行，粘贴这一整块代码 ▼▼▼
const timeToggle = document.getElementById('time-perception-toggle');
const customTimeContainer = document.getElementById('custom-time-container');
const customTimeInput = document.getElementById('custom-time-input');

// 如果是旧聊天，给一个默认值 true（开启）
const isTimeEnabled = chat.settings.timePerceptionEnabled ?? true; 
timeToggle.checked = isTimeEnabled;
customTimeInput.value = chat.settings.customTime || '';

// 根据开关状态，决定是否显示自定义时间输入框
customTimeContainer.style.display = isTimeEnabled ? 'none' : 'block';
// ▲▲▲ 粘贴结束 ▲▲▲

    const bgPreview = document.getElementById('bg-preview');
    const removeBgBtn = document.getElementById('remove-bg-btn');
    if (chat.settings.background) {
        bgPreview.src = chat.settings.background;
        bgPreview.style.display = 'block';
        removeBgBtn.style.display = 'inline-block';
    } else {
        bgPreview.style.display = 'none';
        removeBgBtn.style.display = 'none';
    }

    if (isGroup) {
        document.getElementById('my-group-nickname-input').value = chat.settings.myNickname || '';
        document.getElementById('group-avatar-preview').src = chat.settings.groupAvatar || defaultGroupAvatar;
        renderGroupMemberSettings(chat.members);
        // 加载群聊后台活动设置
const groupActivityGroup = document.getElementById('group-background-activity-group');
const groupActivitySwitch = document.getElementById('group-background-activity-switch');
const groupIntervalSettings = document.getElementById('group-background-interval-settings');
const groupIntervalInput = document.getElementById('group-background-interval-input');

groupActivityGroup.style.display = 'block'; // 显示设置区域
const bgSettings = chat.settings.backgroundActivity || { enabled: false, interval: 120 };
groupActivitySwitch.checked = bgSettings.enabled;
groupIntervalInput.value = bgSettings.interval;
groupIntervalSettings.style.display = bgSettings.enabled ? 'block' : 'none';

// 为开关添加实时交互
groupActivitySwitch.onchange = () => {
    groupIntervalSettings.style.display = groupActivitySwitch.checked ? 'block' : 'none';
};
    } else {
        document.getElementById('ai-persona').value = chat.settings.aiPersona;
        // 【核心修复】加载当前角色的微博职业和指令
document.getElementById('weibo-profession-input').value = chat.settings.weiboProfession || '';
document.getElementById('weibo-instruction-input').value = chat.settings.weiboInstruction || '';
        document.getElementById('ai-avatar-preview').src = chat.settings.aiAvatar || defaultAvatar;
        document.getElementById('minimax-voice-id-input').value = chat.settings.minimaxVoiceId || '';
        // ▼▼▼ Part C.1: 在这里粘贴【加载】情侣头像设置的代码 ▼▼▼
const coupleAvatarToggle = document.getElementById('couple-avatar-toggle');
const coupleAvatarDescContainer = document.getElementById('couple-avatar-desc-container');
const coupleAvatarDescInput = document.getElementById('couple-avatar-description');

coupleAvatarToggle.checked = chat.settings.isCoupleAvatar || false;
coupleAvatarDescInput.value = chat.settings.coupleAvatarDescription || '';

coupleAvatarDescContainer.style.display = coupleAvatarToggle.checked ? 'block' : 'none';

coupleAvatarToggle.onchange = () => {
    coupleAvatarDescContainer.style.display = coupleAvatarToggle.checked ? 'block' : 'none';
};
// ▲▲▲ 加载逻辑结束 ▲▲▲
        document.getElementById('group-background-activity-group').style.display = 'none';
        // 【核心修改2】如果是单聊，就加载分组列表到下拉框
        const select = document.getElementById('assign-group-select');
        select.innerHTML = '<option value="">未分组</option>'; // 清空并设置默认选项
        const groups = await db.qzoneGroups.toArray();
        groups.forEach(group => {
            const option = document.createElement('option');
            option.value = group.id;
            option.textContent = group.name;
            // 如果当前好友已经有分组，就默认选中它
            if (chat.groupId === group.id) {
                option.selected = true;
            }
            select.appendChild(option);
        }); 
    }
    
// ▼▼▼ 用下面这段【全新逻辑】替换掉原来简单的 forEach 循环 ▼▼▼

const worldBookCheckboxesContainer = document.getElementById('world-book-checkboxes-container');
worldBookCheckboxesContainer.innerHTML = '';
const linkedIds = new Set(chat.settings.linkedWorldBookIds || []);

// 1. 获取所有分类和世界书
const categories = await db.worldBookCategories.toArray();
const books = state.worldBooks;

// 【核心改造】如果存在未分类的书籍，就创建一个“虚拟分类”
const hasUncategorized = books.some(book => !book.categoryId);
if (hasUncategorized) {
    categories.push({ id: 'uncategorized', name: '未分类' });
}

// 2. 将书籍按分类ID进行分组
const booksByCategoryId = books.reduce((acc, book) => {
    const categoryId = book.categoryId || 'uncategorized';
    if (!acc[categoryId]) {
        acc[categoryId] = [];
    }
    acc[categoryId].push(book);
    return acc;
}, {});

// 3. 遍历分类，创建带折叠功能的列表
categories.forEach(category => {
    const booksInCategory = booksByCategoryId[category.id] || [];
    if (booksInCategory.length > 0) {
        const allInCategoryChecked = booksInCategory.every(book => linkedIds.has(book.id));
        
        const header = document.createElement('div');
        header.className = 'wb-category-header';
        header.innerHTML = `
            <span class="arrow">▼</span>
            <input type="checkbox" class="wb-category-checkbox" data-category-id="${category.id}" ${allInCategoryChecked ? 'checked' : ''}>
            <span>${category.name}</span>
        `;
        
        const bookContainer = document.createElement('div');
        bookContainer.className = 'wb-book-container';
        bookContainer.dataset.containerFor = category.id;

        booksInCategory.forEach(book => {
            const isChecked = linkedIds.has(book.id);
            const label = document.createElement('label');
            // 【核心修复】给书名包一个span，方便CSS做省略号处理
            label.innerHTML = `<input type="checkbox" class="wb-book-checkbox" value="${book.id}" data-parent-category="${category.id}" ${isChecked ? 'checked' : ''}> <span class="wb-book-name">${book.name}</span>`;
            bookContainer.appendChild(label);
        });

        // 默认将所有文件夹设置为折叠状态，保持界面整洁
        header.classList.add('collapsed');
        bookContainer.classList.add('collapsed');

        worldBookCheckboxesContainer.appendChild(header);
        worldBookCheckboxesContainer.appendChild(bookContainer);
    }
});

updateWorldBookSelectionDisplay(); // 更新顶部的已选数量显示

// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 在 updateWorldBookSelectionDisplay(); 的下一行，粘贴这整块新代码 ▼▼▼


    // 加载并更新所有预览相关控件
    const themeRadio = document.querySelector(`input[name="theme-select"][value="${chat.settings.theme || 'default'}"]`);
    if (themeRadio) themeRadio.checked = true;
    const fontSizeSlider = document.getElementById('font-size-slider');
    fontSizeSlider.value = chat.settings.fontSize || 13;
    document.getElementById('font-size-value').textContent = `${fontSizeSlider.value}px`;
    const customCssInput = document.getElementById('custom-css-input');
    // ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼
// ▼▼▼ 用这块【新代码】替换旧的火花加载逻辑 ▼▼▼
// --- 加载火花设置 ---
const streakSettings = chat.settings.streak || { enabled: false, initialDays: 0, extinguishThreshold: 1 };
// ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼
// --- 【全新】加载自定义火花图标和颜色设置 ---
document.getElementById('streak-lit-icon-url').value = streakSettings.litIconUrl || '';
document.getElementById('streak-extinguished-icon-url').value = streakSettings.extinguishedIconUrl || '';
document.getElementById('streak-font-color-picker').value = streakSettings.fontColor || '#ff6f00'; // 默认橙色
// ▲▲▲ 新代码粘贴结束 ▲▲▲
const streakToggle = document.getElementById('streak-enabled-toggle');
const streakDetails = document.getElementById('streak-details-container');
const initialDaysInput = document.getElementById('streak-initial-days-input');
const thresholdSelect = document.getElementById('streak-extinguish-threshold-select');

streakToggle.checked = streakSettings.enabled;
streakDetails.style.display = streakSettings.enabled ? 'block' : 'none';
initialDaysInput.value = streakSettings.initialDays || 0;
thresholdSelect.value = streakSettings.extinguishThreshold || 1;

// 为开关添加实时交互
streakToggle.onchange = () => {
    streakDetails.style.display = streakToggle.checked ? 'block' : 'none';
};
// ▲▲▲ 替换结束 ▲▲▲

    customCssInput.value = chat.settings.customCss || '';
    
    updateSettingsPreview(); 

// 【这三行就是我们新加的，现在已经放在正确的位置了】
renderBubblePresetSelector();
document.getElementById('bubble-style-preset-select').addEventListener('change', handlePresetSelectChange);
document.getElementById('manage-bubble-presets-btn').addEventListener('click', openBubblePresetManager);
    document.getElementById('chat-settings-modal').classList.add('visible');
});
// ▲▲▲ 替换结束 ▲▲▲
            
function renderGroupMemberSettings(members) { 
    const container = document.getElementById('group-members-settings'); 
    container.innerHTML = ''; 
    members.forEach(member => { 
        const div = document.createElement('div'); 
        div.className = 'member-editor'; 
        div.dataset.memberId = member.id; 
        // ★★★【核心重构】★★★
        // 显示的是 groupNickname
        div.innerHTML = `<img src="${member.avatar}" alt="${member.groupNickname}"><div class="member-name">${member.groupNickname}</div>`; 
        div.addEventListener('click', () => openMemberEditor(member.id)); 
        container.appendChild(div); 
    }); 
}

// ▼▼▼ 用这整块代码，替换你旧的 openMemberEditor 函数 ▼▼▼
function openMemberEditor(memberId) { 
    editingMemberId = memberId; 
    const chat = state.chats[state.activeChatId]; 
    const member = chat.members.find(m => m.id === memberId); 
    if (!member) return;

    if (typeof member.isMuted === 'undefined') {
        member.isMuted = false; // 为旧数据兼容
    }
    
    document.getElementById('member-name-input').value = member.groupNickname; 
    document.getElementById('member-persona-input').value = member.persona; 
    document.getElementById('member-avatar-preview').src = member.avatar; 

    // ★★★ 我们在这里为新按钮绑定了点击事件 ★★★
    const changeFrameBtn = document.getElementById('member-editor-change-frame-btn');
    const newChangeFrameBtn = changeFrameBtn.cloneNode(true);
    changeFrameBtn.parentNode.replaceChild(newChangeFrameBtn, changeFrameBtn);
    
    newChangeFrameBtn.addEventListener('click', () => {
        // 调用头像框选择器，并告诉它我们正在为'member'类型的成员（也就是NPC）设置头像框
        openFrameSelectorModal('member', memberId);
    });
    // ★★★ 添加结束 ★★★

    document.getElementById('member-settings-modal').classList.add('visible'); 
}
// ▲▲▲ 替换结束 ▲▲▲

            document.getElementById('cancel-member-settings-btn').addEventListener('click', () => { document.getElementById('member-settings-modal').classList.remove('visible'); editingMemberId = null; });
            document.getElementById('save-member-settings-btn').addEventListener('click', () => { 
    if (!editingMemberId) return; 
    const chat = state.chats[state.activeChatId]; 
    const member = chat.members.find(m => m.id === editingMemberId); 
    
    // ★★★【核心重构】★★★
    const newNickname = document.getElementById('member-name-input').value.trim();
    if (!newNickname) {
        alert("群昵称不能为空！");
        return;
    }
    member.groupNickname = newNickname; // 只修改群昵称
    member.persona = document.getElementById('member-persona-input').value; 
    member.avatar = document.getElementById('member-avatar-preview').src; 
    
    renderGroupMemberSettings(chat.members); 
    document.getElementById('member-settings-modal').classList.remove('visible'); 
});
            document.getElementById('reset-theme-btn').addEventListener('click', () => { document.getElementById('theme-default').checked = true; });
            document.getElementById('cancel-chat-settings-btn').addEventListener('click', () => { chatSettingsModal.classList.remove('visible'); });

document.getElementById('save-chat-settings-btn').addEventListener('click', async () => {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    const newName = document.getElementById('chat-name-input').value.trim();
    if (!newName) return alert('备注名/群名不能为空！');
    chat.name = newName;
    // ▼▼▼ 【全新】记忆互通功能 - 保存逻辑 ▼▼▼
    const linkedMemoryCheckboxes = document.querySelectorAll('#memory-link-checkboxes-container input:checked');
    const memoryDepth = parseInt(document.getElementById('link-memory-depth-input').value) || 5;

    // ▼▼▼ 在这里新增下面这一行 ▼▼▼
    chat.settings.linkMemoryDepth = memoryDepth; // 独立保存记忆条数设置
    // ▲▲▲ 新增结束 ▲▲▲

    chat.settings.linkedMemories = Array.from(linkedMemoryCheckboxes).map(checkbox => ({
        chatId: checkbox.value,
        depth: memoryDepth // 对所有选中的链接应用相同的深度
    }));
    // ▲▲▲ 保存逻辑结束 ▲▲▲


    const selectedThemeRadio = document.querySelector('input[name="theme-select"]:checked');
    chat.settings.theme = selectedThemeRadio ? selectedThemeRadio.value : 'default';

    chat.settings.fontSize = parseInt(document.getElementById('font-size-slider').value);
    chat.settings.customCss = document.getElementById('custom-css-input').value.trim();

    chat.settings.myPersona = document.getElementById('my-persona').value;
    chat.settings.myAvatar = document.getElementById('my-avatar-preview').src;
const checkedBooks = document.querySelectorAll('#world-book-checkboxes-container input.wb-book-checkbox:checked');
    chat.settings.linkedWorldBookIds = Array.from(checkedBooks).map(cb => cb.value);

    if (chat.isGroup) {
        chat.settings.myNickname = document.getElementById('my-group-nickname-input').value.trim();
        chat.settings.groupAvatar = document.getElementById('group-avatar-preview').src;
        // 保存群聊后台活动设置
const groupActivityEnabled = document.getElementById('group-background-activity-switch').checked;
const groupActivityInterval = parseInt(document.getElementById('group-background-interval-input').value) || 120;

// 确保 lastActivityTimestamp 字段存在
const lastTimestamp = chat.settings.backgroundActivity ? chat.settings.backgroundActivity.lastActivityTimestamp : 0;

chat.settings.backgroundActivity = {
    enabled: groupActivityEnabled,
    interval: groupActivityInterval,
    lastActivityTimestamp: lastTimestamp // 保留上次的时间戳
};

    } else {
        chat.settings.aiPersona = document.getElementById('ai-persona').value;
        chat.settings.aiAvatar = document.getElementById('ai-avatar-preview').src;
        chat.settings.minimaxVoiceId = document.getElementById('minimax-voice-id-input').value.trim();
        // ▼▼▼ Part C.2: 在这里粘贴【保存】情侣头像设置的代码 ▼▼▼
chat.settings.isCoupleAvatar = document.getElementById('couple-avatar-toggle').checked;
chat.settings.coupleAvatarDescription = document.getElementById('couple-avatar-description').value.trim();
// ▲▲▲ 保存逻辑结束 ▲▲▲
        // ▼▼▼ 在 save-chat-settings-btn 的 click 事件的 else 块内，粘贴这段代码 ▼▼▼
        // 【核心新增】从输入框读取值并保存
    chat.settings.weiboProfession = document.getElementById('weibo-profession-input').value.trim();
    chat.settings.weiboInstruction = document.getElementById('weibo-instruction-input').value.trim();
// 保存视频通话设置
chat.settings.visualVideoCallEnabled = document.getElementById('visual-video-call-switch').checked;
chat.settings.charVideoImage = document.getElementById('char-video-image-preview').src;
chat.settings.userVideoImage = document.getElementById('user-video-image-preview').src;
// ▲▲▲ 粘贴结束 ▲▲▲
        const selectedGroupId = document.getElementById('assign-group-select').value;
        chat.groupId = selectedGroupId ? parseInt(selectedGroupId) : null;
    }

    chat.settings.maxMemory = parseInt(document.getElementById('max-memory').value) || 10;
    // ▼▼▼ 在 chat.settings.maxMemory = ... 的下一行添加 ▼▼▼
chat.settings.timePerceptionEnabled = document.getElementById('time-perception-toggle').checked;
chat.settings.customTime = document.getElementById('custom-time-input').value;
// ▲▲▲ 添加结束 ▲▲▲
    // --- 保存线下模式设置 ---
    if (!chat.settings.offlineMode) chat.settings.offlineMode = {}; // 初始化
    chat.settings.offlineMode.enabled = document.getElementById('offline-mode-toggle').checked;
    chat.settings.offlineMode.prompt = document.getElementById('offline-prompt-input').value.trim();
    chat.settings.offlineMode.style = document.getElementById('offline-style-input').value.trim();
    chat.settings.offlineMode.wordCount = parseInt(document.getElementById('offline-word-count-input').value) || 300;
    // presets 的数据在管理函数中直接操作，这里无需保存
// ▼▼▼ 在这里粘贴下面的新代码 ▼▼▼
// --- 保存聊天总结设置 ---
if (!chat.settings.summary) chat.settings.summary = {}; // 初始化
chat.settings.summary.enabled = document.getElementById('summary-toggle').checked;
chat.settings.summary.mode = document.querySelector('input[name="summary-mode"]:checked').value;
chat.settings.summary.count = parseInt(document.getElementById('summary-count-input').value) || 20;
chat.settings.summary.prompt = document.getElementById('summary-prompt-input').value.trim();
// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 用这块【新代码】替换旧的火花保存逻辑 ▼▼▼
// --- 保存火花设置 ---
const isStreakEnabled = document.getElementById('streak-enabled-toggle').checked;
const newInitialDays = parseInt(document.getElementById('streak-initial-days-input').value) || 0;
const newThreshold = parseInt(document.getElementById('streak-extinguish-threshold-select').value);

const oldStreak = chat.settings.streak || {};

// ▼▼▼ 用这块【已添加新功能】的代码替换 ▼▼▼
if (isStreakEnabled) {
    // 检查是否是首次开启，或者初始天数被修改了
    if (!oldStreak.enabled || oldStreak.initialDays !== newInitialDays) {
        // 如果是，就重置当前天数为新的初始天数
        chat.settings.streak = {
            enabled: true,
            initialDays: newInitialDays,
            currentDays: newInitialDays,
            extinguishThreshold: newThreshold,
            lastInteractionDate: null,
            // ★★★ 核心新增：在这里保存我们的新设置 ★★★
            litIconUrl: document.getElementById('streak-lit-icon-url').value.trim(),
            extinguishedIconUrl: document.getElementById('streak-extinguished-icon-url').value.trim(),
            fontColor: document.getElementById('streak-font-color-picker').value
        };
    } else {
        // 如果只是普通保存，只更新开关状态和熄灭规则以及新设置
        chat.settings.streak.enabled = true;
        chat.settings.streak.extinguishThreshold = newThreshold;
        // ★★★ 核心新增：在这里保存我们的新设置 ★★★
        chat.settings.streak.litIconUrl = document.getElementById('streak-lit-icon-url').value.trim();
        chat.settings.streak.extinguishedIconUrl = document.getElementById('streak-extinguished-icon-url').value.trim();
        chat.settings.streak.fontColor = document.getElementById('streak-font-color-picker').value;
        // 保持 currentDays 和 lastInteractionDate 不变
    }
} else {
    // 如果用户关闭了功能，就重置所有设置
    chat.settings.streak = {
        enabled: false, initialDays: 0, currentDays: 0, extinguishThreshold: 1, lastInteractionDate: null,
        litIconUrl: '', extinguishedIconUrl: '', fontColor: '#ff6f00' // 同时重置新设置
    };
}
// ▲▲▲ 替换结束 ▲▲▲


    await db.chats.put(chat);

    applyScopedCss(chat.settings.customCss, '#chat-messages', 'custom-bubble-style');
    
    chatSettingsModal.classList.remove('visible');
    renderChatInterface(state.activeChatId);
    renderChatList();
});
            document.getElementById('clear-chat-btn').addEventListener('click', async () => { if (!state.activeChatId) return; const chat = state.chats[state.activeChatId]; const confirmed = await showCustomConfirm('清空聊天记录', '此操作将永久删除此聊天的所有消息，无法恢复。确定要清空吗？', { confirmButtonClass: 'btn-danger' }); if (confirmed) { chat.history = []; await db.chats.put(chat); renderChatInterface(state.activeChatId); renderChatList(); chatSettingsModal.classList.remove('visible'); } });
            // ▼▼▼ 在 init() 的事件监听器区域末尾，粘贴这段新代码 ▼▼▼

// 导出聊天记录按钮
document.getElementById('export-chat-history-btn').addEventListener('click', exportChatHistory);

// “导入聊天记录”这个可见的按钮
document.getElementById('import-chat-history-btn').addEventListener('click', () => {
    // 点击它时，我们去触发那个隐藏的文件选择框
    document.getElementById('import-chat-history-input').click();
});

// 隐藏的文件选择框
document.getElementById('import-chat-history-input').addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (file) {
        importChatHistory(file);
    }
    // 每次选择后清空，这样下次还能选择同一个文件
    event.target.value = null; 
});

// ▲▲▲ 新代码粘贴结束 ▲▲▲

            const setupFileUpload = (inputId, callback) => { document.getElementById(inputId).addEventListener('change', async (event) => { const file = event.target.files[0]; if (file) { const dataUrl = await new Promise((res, rej) => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.onerror = () => rej(reader.error); reader.readAsDataURL(file); }); callback(dataUrl); event.target.value = null; } }); };
            setupFileUpload('ai-avatar-input', (base64) => document.getElementById('ai-avatar-preview').src = base64);
            setupFileUpload('my-avatar-input', (base64) => document.getElementById('my-avatar-preview').src = base64);
            setupFileUpload('group-avatar-input', (base64) => document.getElementById('group-avatar-preview').src = base64);
            setupFileUpload('member-avatar-input', (base64) => document.getElementById('member-avatar-preview').src = base64);
            setupFileUpload('bg-input', (base64) => { if(state.activeChatId) { state.chats[state.activeChatId].settings.background = base64; const bgPreview = document.getElementById('bg-preview'); bgPreview.src = base64; bgPreview.style.display = 'block'; document.getElementById('remove-bg-btn').style.display = 'inline-block'; } });
            setupFileUpload('preset-avatar-input', (base64) => document.getElementById('preset-avatar-preview').src = base64);
            // ▼▼▼ 在 init() 函数的事件监听器区域，添加这两行 ▼▼▼
setupFileUpload('char-video-image-input', (base64) => document.getElementById('char-video-image-preview').src = base64);
setupFileUpload('user-video-image-input', (base64) => document.getElementById('user-video-image-preview').src = base64);
// ▲▲▲ 添加结束 ▲▲▲
            document.getElementById('remove-bg-btn').addEventListener('click', () => { if (state.activeChatId) { state.chats[state.activeChatId].settings.background = ''; const bgPreview = document.getElementById('bg-preview'); bgPreview.src = ''; bgPreview.style.display = 'none'; document.getElementById('remove-bg-btn').style.display = 'none'; } });

            const stickerPanel = document.getElementById('sticker-panel');
            document.getElementById('open-sticker-panel-btn').addEventListener('click', () => { renderStickerPanel(); stickerPanel.classList.add('visible'); });
            document.getElementById('close-sticker-panel-btn').addEventListener('click', () => stickerPanel.classList.remove('visible'));
            // ▼▼▼ 将原来的 add-sticker-btn 事件监听器替换为下面这行 ▼▼▼
document.getElementById('add-sticker-btn').addEventListener('click', openBulkAddStickersModal);
// ▲▲▲ 替换结束 ▲▲▲
            document.getElementById('upload-sticker-btn').addEventListener('click', () => document.getElementById('sticker-upload-input').click());

            // ▼▼▼ 用下面这段【支持多选】的代码，替换旧的 sticker-upload-input 事件监听器 ▼▼▼
document.getElementById('sticker-upload-input').addEventListener('change', async (event) => {
    const files = event.target.files;
    if (!files.length) return;

    const newStickers = [];
    let canceled = false;

    // 使用 for...of 循环来逐个处理选中的文件
    for (const file of files) {
        if (canceled) break; // 如果用户中途取消了，就跳出循环

        // 为每个文件生成一个临时的本地预览URL
        const previewUrl = URL.createObjectURL(file);
        
        // 弹出带图片预览的命名框
        const name = await showCustomPrompt(
            `为表情命名 (${newStickers.length + 1}/${files.length})`,
            "请输入表情名称",
            file.name.replace(/\.[^/.]+$/, ""), // 默认使用文件名作为名字
            'text',
            // 这是 showCustomPrompt 的一个隐藏功能，可以插入额外的HTML
            `<img src="${previewUrl}" style="max-width: 100px; max-height: 100px; margin-bottom: 10px; border-radius: 8px;">`
        );
        
        // 释放临时的预览URL，避免内存泄漏
        URL.revokeObjectURL(previewUrl);
        
        if (name && name.trim()) {
            // 用户确认命名，读取文件内容并准备保存
            const base64Url = await new Promise(resolve => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.readAsDataURL(file);
            });
            
            newStickers.push({
                id: 'sticker_' + (Date.now() + newStickers.length),
                url: base64Url,
                name: name.trim()
            });
        } else if (name === null) {
            // 如果用户点击了“取消”
            const confirmCancel = await showCustomConfirm("确认取消", "确定要取消剩余表情的上传吗？");
            if (confirmCancel) {
                canceled = true;
            }
        } else {
            alert("表情名不能为空！");
        }
    }
    
    // 循环结束后，如果收集到了新表情，就批量添加到数据库
    if (newStickers.length > 0) {
        await db.userStickers.bulkAdd(newStickers);
        state.userStickers.push(...newStickers);
        renderStickerPanel();
        await showCustomAlert("上传成功", `已成功添加 ${newStickers.length} 个新表情！`);
    }

    // 清空文件选择器的值，以便下次能选择相同的文件
    event.target.value = null;
});
// ▲▲▲ 替换结束 ▲▲▲

            document.getElementById('upload-image-btn').addEventListener('click', () => document.getElementById('image-upload-input').click());
            document.getElementById('image-upload-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (!file || !state.activeChatId) return; const reader = new FileReader(); reader.onload = async (e) => { const base64Url = e.target.result; const chat = state.chats[state.activeChatId]; const msg = { role: 'user', content: [{ type: 'image_url', image_url: { url: base64Url } }], timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); }; reader.readAsDataURL(file); event.target.value = null; });
            document.getElementById('voice-message-btn').addEventListener('click', async () => { if (!state.activeChatId) return; const text = await showCustomPrompt("发送语音", "请输入你想说的内容："); if (text && text.trim()) { const chat = state.chats[state.activeChatId]; const msg = { role: 'user', type: 'voice_message', content: text.trim(), timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); } });
            document.getElementById('send-photo-btn').addEventListener('click', async () => { if (!state.activeChatId) return; const description = await showCustomPrompt("发送照片", "请用文字描述您要发送的照片："); if (description && description.trim()) { const chat = state.chats[state.activeChatId]; const msg = { role: 'user', type: 'user_photo', content: description.trim(), timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); } });

// ▼▼▼ 【全新】外卖请求功能事件绑定 ▼▼▼
const waimaiModal = document.getElementById('waimai-request-modal');
document.getElementById('send-waimai-request-btn').addEventListener('click', () => {
    waimaiModal.classList.add('visible');
});

document.getElementById('waimai-cancel-btn').addEventListener('click', () => {
    waimaiModal.classList.remove('visible');
});

document.getElementById('waimai-confirm-btn').addEventListener('click', async () => {
    if (!state.activeChatId) return;
    
    const productInfoInput = document.getElementById('waimai-product-info');
    const amountInput = document.getElementById('waimai-amount');
    
    const productInfo = productInfoInput.value.trim();
    const amount = parseFloat(amountInput.value);

    if (!productInfo) {
        alert('请输入商品信息！');
        return;
    }
    if (isNaN(amount) || amount <= 0) {
        alert('请输入有效的代付金额！');
        return;
    }

    const chat = state.chats[state.activeChatId];
    const now = Date.now();

    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    
    const msg = {
        role: 'user',
        senderName: myNickname, 
        type: 'waimai_request',
        productInfo: productInfo,
        amount: amount,
        status: 'pending',
        countdownEndTime: now + 15 * 60 * 1000,
        timestamp: now
    };

    chat.history.push(msg);
    
    // 那一大段代码已经被删除了
    
    await db.chats.put(chat);
    appendMessage(msg, chat);
    renderChatList();

    productInfoInput.value = '';
    amountInput.value = '';
    waimaiModal.classList.remove('visible');
});         
            document.getElementById('open-persona-library-btn').addEventListener('click', openPersonaLibrary);
            document.getElementById('close-persona-library-btn').addEventListener('click', closePersonaLibrary);
            document.getElementById('add-persona-preset-btn').addEventListener('click', openPersonaEditorForCreate);
            document.getElementById('cancel-persona-editor-btn').addEventListener('click', closePersonaEditor);


// ▲▲▲ 替换到这里结束 ▲▲▲


            document.getElementById('preset-action-edit').addEventListener('click', openPersonaEditorForEdit);
            document.getElementById('preset-action-delete').addEventListener('click', deletePersonaPreset);
            document.getElementById('preset-action-cancel').addEventListener('click', hidePresetActions);
            
            document.getElementById('selection-cancel-btn').addEventListener('click', exitSelectionMode);

// ▼▼▼ 【最终加强版】用这块代码替换旧的 selection-delete-btn 事件监听器 ▼▼▼
document.getElementById('selection-delete-btn').addEventListener('click', async () => {
    if (selectedMessages.size === 0) return;
    const confirmed = await showCustomConfirm('删除消息', `确定要删除选中的 ${selectedMessages.size} 条消息吗？这将改变AI的记忆。`, { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        const chat = state.chats[state.activeChatId];
        
        // 1. 【核心加强】在删除前，检查被删除的消息中是否包含投票
        let deletedPollsInfo = [];
        for (const timestamp of selectedMessages) {
            const msg = chat.history.find(m => m.timestamp === timestamp);
            if (msg && msg.type === 'poll') {
                deletedPollsInfo.push(`关于“${msg.question}”的投票(时间戳: ${msg.timestamp})`);
            }
        }
        
        // 2. 更新后端的历史记录
        chat.history = chat.history.filter(msg => !selectedMessages.has(msg.timestamp));
        
        // 3. 【核心加强】构建更具体的“遗忘指令”
        let forgetReason = "一些之前的消息已被用户删除。";
        if (deletedPollsInfo.length > 0) {
            forgetReason += ` 其中包括以下投票：${deletedPollsInfo.join('；')}。`;
        }
        forgetReason += " 你应该像它们从未存在过一样继续对话，并相应地调整你的记忆和行为，不要再提及这些被删除的内容。";

        const forgetInstruction = {
            role: 'system',
            content: `[系统提示：${forgetReason}]`,
            timestamp: Date.now(),
            isHidden: true 
        };
        chat.history.push(forgetInstruction);
        
        // 4. 将包含“遗忘指令”的、更新后的chat对象存回数据库
        await db.chats.put(chat);
        
        // 5. 最后才更新UI
        renderChatInterface(state.activeChatId);
        renderChatList();
    }
});
// ▲▲▲ 替换结束 ▲▲▲

            document.getElementById('reset-font-btn').addEventListener('click', resetToDefaultFont);

            document.querySelectorAll('#chat-list-bottom-nav .nav-item').forEach(item => { item.addEventListener('click', () => switchToChatListView(item.dataset.view)); });
            document.getElementById('qzone-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));
            document.getElementById('qzone-nickname').addEventListener('click', async () => { const newNickname = await showCustomPrompt("修改昵称", "请输入新的昵称", state.qzoneSettings.nickname); if (newNickname && newNickname.trim()) { state.qzoneSettings.nickname = newNickname.trim(); await saveQzoneSettings(); renderQzoneScreen(); } });
            document.getElementById('qzone-avatar-container').addEventListener('click', () => document.getElementById('qzone-avatar-input').click());
            document.getElementById('qzone-banner-container').addEventListener('click', () => document.getElementById('qzone-banner-input').click());
            document.getElementById('qzone-avatar-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (file) { const dataUrl = await new Promise(res => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.readAsDataURL(file); }); state.qzoneSettings.avatar = dataUrl; await saveQzoneSettings(); renderQzoneScreen(); } event.target.value = null; });
            document.getElementById('qzone-banner-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (file) { const dataUrl = await new Promise(res => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.readAsDataURL(file); }); state.qzoneSettings.banner = dataUrl; await saveQzoneSettings(); renderQzoneScreen(); } event.target.value = null; });

// ▼▼▼ 用下面这两行，替换掉旧的事件绑定 ▼▼▼

document.getElementById('create-shuoshuo-btn').addEventListener('click', () => openQZonePublisher('shuoshuo'));
document.getElementById('create-post-btn').addEventListener('click', () => openQZonePublisher('complex'));

// ▲▲▲ 替换结束 ▲▲▲

            document.getElementById('open-album-btn').addEventListener('click', async () => { await renderAlbumList(); showScreen('album-screen'); });
            document.getElementById('album-back-btn').addEventListener('click', () => { showScreen('chat-list-screen'); switchToChatListView('qzone-screen'); });

// --- ↓↓↓ 从这里开始复制 ↓↓↓ ---

document.getElementById('album-photos-back-btn').addEventListener('click', () => {
    state.activeAlbumId = null;
    showScreen('album-screen');
});

document.getElementById('album-upload-photo-btn').addEventListener('click', () => document.getElementById('album-photo-input').click());

document.getElementById('album-photo-input').addEventListener('change', async (event) => {
    if (!state.activeAlbumId) return;
    const files = event.target.files;
    if (!files.length) return;

    const album = await db.qzoneAlbums.get(state.activeAlbumId);
    
    for (const file of files) {
        const dataUrl = await new Promise(resolve => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.readAsDataURL(file);
        });
        await db.qzonePhotos.add({ albumId: state.activeAlbumId, url: dataUrl, createdAt: Date.now() });
    }

    const photoCount = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).count();
    const updateData = { photoCount };
    
    if (!album.photoCount || album.coverUrl.includes('placeholder')) {
        const firstPhoto = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).first();
        if(firstPhoto) updateData.coverUrl = firstPhoto.url;
    }

    await db.qzoneAlbums.update(state.activeAlbumId, updateData);
    await renderAlbumPhotosScreen();
    await renderAlbumList();
    
    event.target.value = null;
    alert('照片上传成功！');
});

// --- ↑↑↑ 复制到这里结束 ↑↑↑ ---

// --- ↓↓↓ 从这里开始复制，完整替换掉旧的 photos-grid-page 监听器 ↓↓↓ ---

document.getElementById('photos-grid-page').addEventListener('click', async (e) => {
    const deleteBtn = e.target.closest('.photo-delete-btn');
    const photoThumb = e.target.closest('.photo-thumb');

    if (deleteBtn) {
        e.stopPropagation(); // 阻止事件冒泡到图片上
        const photoId = parseInt(deleteBtn.dataset.photoId);
        const confirmed = await showCustomConfirm(
            '删除照片',
            '确定要删除这张照片吗？此操作不可恢复。',
            { confirmButtonClass: 'btn-danger' }
        );

        if (confirmed) {
            const deletedPhoto = await db.qzonePhotos.get(photoId);
            if (!deletedPhoto) return;
            
            await db.qzonePhotos.delete(photoId);

            const album = await db.qzoneAlbums.get(state.activeAlbumId);
            const photoCount = (album.photoCount || 1) - 1;
            const updateData = { photoCount };
            
            if (album.coverUrl === deletedPhoto.url) {
                const nextPhoto = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).first();
                updateData.coverUrl = nextPhoto ? nextPhoto.url : 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png';
            }
            
            await db.qzoneAlbums.update(state.activeAlbumId, updateData);
            await renderAlbumPhotosScreen();
            await renderAlbumList();
            alert('照片已删除。');
        }
    } 
    else if (photoThumb) {
        // 这就是恢复的图片点击放大功能！
        openPhotoViewer(photoThumb.src);
    }
});

// 恢复图片查看器的控制事件
document.getElementById('photo-viewer-close-btn').addEventListener('click', closePhotoViewer);
document.getElementById('photo-viewer-next-btn').addEventListener('click', showNextPhoto);
document.getElementById('photo-viewer-prev-btn').addEventListener('click', showPrevPhoto);

// 恢复键盘左右箭头和ESC键的功能
document.addEventListener('keydown', (e) => {
    if (!photoViewerState.isOpen) return; 

    if (e.key === 'ArrowRight') {
        showNextPhoto();
    } else if (e.key === 'ArrowLeft') {
        showPrevPhoto();
    } else if (e.key === 'Escape') {
        closePhotoViewer();
    }
});

// --- ↑↑↑ 复制到这里结束 ↑↑↑ ---
         
document.getElementById('create-album-btn-page').addEventListener('click', async () => { const albumName = await showCustomPrompt("创建新相册", "请输入相册名称"); if (albumName && albumName.trim()) { const newAlbum = { name: albumName.trim(), coverUrl: 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png', photoCount: 0, createdAt: Date.now() }; await db.qzoneAlbums.add(newAlbum); await renderAlbumList(); alert(`相册 "${albumName}" 创建成功！`); } else if (albumName !== null) { alert("相册名称不能为空！"); } });

            document.getElementById('cancel-create-post-btn').addEventListener('click', () => document.getElementById('create-post-modal').classList.remove('visible'));
            document.getElementById('post-upload-local-btn').addEventListener('click', () => document.getElementById('post-local-image-input').click());
            document.getElementById('post-local-image-input').addEventListener('change', (event) => { const file = event.target.files[0]; if (file) { const reader = new FileReader(); reader.onload = (e) => { document.getElementById('post-image-preview').src = e.target.result; document.getElementById('post-image-preview-container').classList.add('visible'); document.getElementById('post-image-desc-group').style.display = 'block'; }; reader.readAsDataURL(file); } });
            document.getElementById('post-use-url-btn').addEventListener('click', async () => { const url = await showCustomPrompt("输入图片URL", "请输入网络图片的链接", "", "url"); if (url) { document.getElementById('post-image-preview').src = url; document.getElementById('post-image-preview-container').classList.add('visible'); document.getElementById('post-image-desc-group').style.display = 'block'; } });
            document.getElementById('post-remove-image-btn').addEventListener('click', () => resetCreatePostModal());
            const imageModeBtn = document.getElementById('switch-to-image-mode');
            const textImageModeBtn = document.getElementById('switch-to-text-image-mode');
            const imageModeContent = document.getElementById('image-mode-content');
            const textImageModeContent = document.getElementById('text-image-mode-content');
            imageModeBtn.addEventListener('click', () => { imageModeBtn.classList.add('active'); textImageModeBtn.classList.remove('active'); imageModeContent.classList.add('active'); textImageModeContent.classList.remove('active'); });
            textImageModeBtn.addEventListener('click', () => { textImageModeBtn.classList.add('active'); imageModeBtn.classList.remove('active'); textImageModeContent.classList.add('active'); imageModeContent.classList.remove('active'); });

// ▼▼▼ 请用下面这一整块【修复后】的代码，替换掉刚才删除的旧代码 ▼▼▼

// ▼▼▼ 用这【一整块】代码，替换掉旧的 'confirm-create-post-btn' 事件监听器 ▼▼▼

// ▼▼▼ 用这块【新代码】替换旧的 'confirm-create-post-btn' 事件监听器 ▼▼▼
document.getElementById('confirm-create-post-btn').addEventListener('click', async () => {
    const modal = document.getElementById('create-post-modal');
    const mode = modal.dataset.mode;

    // 【核心改造】我们在这里加一个判断
    // 如果当前是 'forum' (小组发帖) 模式，就调用我们刚刚写的发帖函数
    if (mode === 'forum') {
        await handleCreateForumPost();
        return; // 执行完就结束，不往下走了
    }
    
    // 如果是 'weibo' 模式，就调用发微博的函数
    if (mode === 'weibo') {
        await handlePublishWeibo();
        return;
    }

    // --- 下面是你原来已有的发布“动态”的逻辑，我们保持不变 ---
    const editingId = parseInt(modal.dataset.editingPostId);
    const areCommentsVisible = document.getElementById('post-comments-toggle').checked;
    
    const visibility = document.querySelector('input[name="visibility"]:checked').value;
    let visibleGroupIds = null;
    if (visibility === 'groups') {
        visibleGroupIds = Array.from(document.querySelectorAll('#post-visibility-groups input:checked'))
                           .map(cb => parseInt(cb.value));
        if (visibleGroupIds.length === 0) {
            alert("请至少选择一个可见的分组！");
            return;
        }
    }

    let postData = {};

    if (mode === 'edit') {
        const existingPost = await db.qzonePosts.get(editingId);
        if (!existingPost) {
            alert('错误：找不到要编辑的动态！');
            return;
        }
        postData = { 
            ...existingPost, 
            areCommentsVisible: areCommentsVisible,
            visibleGroupIds: visibleGroupIds
        };
        
        if (postData.type === 'shuoshuo') {
            postData.content = document.getElementById('post-public-text').value.trim();
        } else {
            postData.publicText = document.getElementById('post-public-text').value.trim();
            if (postData.type === 'image_post') {
                postData.imageUrl = document.getElementById('post-image-preview').src;
                postData.imageDescription = document.getElementById('post-image-description').value.trim();
            } else if (postData.type === 'text_image') {
                postData.hiddenContent = document.getElementById('post-hidden-text').value.trim();
            }
        }
        await db.qzonePosts.put(postData);

    } else {
        const basePostData = {
            timestamp: Date.now(),
            authorId: 'user',
            areCommentsVisible: areCommentsVisible,
            visibleGroupIds: visibleGroupIds
        };
        
        if (mode === 'shuoshuo') {
            const content = document.getElementById('post-public-text').value.trim();
            if (!content) return alert('说说内容不能为空哦！');
            postData = { ...basePostData, type: 'shuoshuo', content: content };
        } else {
            const publicText = document.getElementById('post-public-text').value.trim();
            const isImageModeActive = document.getElementById('image-mode-content').classList.contains('active');
            if (isImageModeActive) {
                const imageUrl = document.getElementById('post-image-preview').src;
                const imageDescription = document.getElementById('post-image-description').value.trim();
                if (!imageUrl || !(imageUrl.startsWith('http') || imageUrl.startsWith('data:'))) return alert('请先添加一张图片再发布动态哦！');
                if (!imageDescription) return alert('请为你的图片添加一个简单的描述（必填，给AI看的）！');
                postData = { ...basePostData, type: 'image_post', publicText, imageUrl, imageDescription };
            } else {
                const hiddenText = document.getElementById('post-hidden-text').value.trim();
                if (!hiddenText) return alert('请输入文字图描述！');
                postData = { ...basePostData, type: 'text_image', publicText, hiddenContent: hiddenText };
            }
        }
        const newPostId = await db.qzonePosts.add(postData);
        postData.id = newPostId;
    }
    
    let postSummary = postData.content || postData.publicText || postData.imageDescription || postData.hiddenContent || "（无文字内容）";
    postSummary = postSummary.substring(0, 50) + (postSummary.length > 50 ? '...' : '');
    for (const chatId in state.chats) {
        const chat = state.chats[chatId];
        if (chat.isGroup) continue;
        const historyMessage = { role: 'system', content: `[系统提示：用户${editingId ? '编辑了' : '发布了'}一条动态(ID: ${editingId || postData.id})，内容摘要是：“${postSummary}”。]`, timestamp: Date.now(), isHidden: true };
        chat.history.push(historyMessage);
        await db.chats.put(chat);
    }
    
    await renderQzonePosts();
    modal.classList.remove('visible');
    delete modal.dataset.editingPostId;
    delete modal.dataset.mode;
    alert(`动态${editingId ? '编辑' : '发布'}成功！`);
});
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 在 init() 函数的事件监听器区域，粘贴下面这【一整块】新代码 ▼▼▼

// 【全新】为全局聊天背景的上传按钮绑定事件
document.getElementById('global-bg-upload-input').addEventListener('change', async (event) => {
    const file = event.target.files[0];
    if(file) {
        const dataUrl = await new Promise((res) => {
            const reader = new FileReader();
            reader.onload = () => res(reader.result);
            reader.readAsDataURL(file);
        });
        newGlobalBgBase64 = dataUrl; // 将新背景存入临时变量
        // 实时更新预览
        const preview = document.getElementById('global-bg-preview');
        preview.style.backgroundImage = `url(${dataUrl})`;
        preview.textContent = '';
    }
});

// 【全新】为全局聊天背景的移除按钮绑定事件
document.getElementById('remove-global-bg-btn').addEventListener('click', () => {
    newGlobalBgBase64 = 'REMOVED'; // 用一个特殊标记表示“移除”
    const preview = document.getElementById('global-bg-preview');
    preview.style.backgroundImage = 'none';
    preview.textContent = '已移除';
    alert('全局背景将在点击“保存”后被移除。');
});

// 【全新】为“一键清空单人背景”按钮绑定事件
document.getElementById('clear-all-single-bgs-btn').addEventListener('click', clearAllSingleChatBackgrounds);

// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 请用这【一整块】包含所有滑动和点击事件的完整代码，替换掉旧的 postsList 事件监听器 ▼▼▼

const postsList = document.getElementById('qzone-posts-list');
let swipeState = { isDragging: false, startX: 0, startY: 0, currentX: 0, activeContainer: null, swipeDirection: null, isClick: true };

function resetAllSwipes(exceptThisOne = null) {
    document.querySelectorAll('.qzone-post-container').forEach(container => {
        if (container !== exceptThisOne) {
            container.querySelector('.qzone-post-item').classList.remove('swiped');
        }
    });
}

const handleSwipeStart = (e) => {
    const targetContainer = e.target.closest('.qzone-post-container');
    if (!targetContainer) return;

    resetAllSwipes(targetContainer);
    swipeState.activeContainer = targetContainer;
    swipeState.isDragging = true;
    swipeState.isClick = true;
    swipeState.swipeDirection = null;
    swipeState.startX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
    swipeState.startY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
    swipeState.activeContainer.querySelector('.qzone-post-item').style.transition = 'none';
};

const handleSwipeMove = (e) => {
    if (!swipeState.isDragging || !swipeState.activeContainer) return;

    const currentX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
    const currentY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
    const diffX = currentX - swipeState.startX;
    const diffY = currentY - swipeState.startY;
    const absDiffX = Math.abs(diffX);
    const absDiffY = Math.abs(diffY);
    const clickThreshold = 5;

    if (absDiffX > clickThreshold || absDiffY > clickThreshold) {
        swipeState.isClick = false;
    }

    if (swipeState.swipeDirection === null) {
        if (absDiffX > clickThreshold || absDiffY > clickThreshold) {
            if (absDiffX > absDiffY) {
                swipeState.swipeDirection = 'horizontal';
            } else {
                swipeState.swipeDirection = 'vertical';
            }
        }
    }
    if (swipeState.swipeDirection === 'vertical') {
        handleSwipeEnd(e);
        return;
    }
    if (swipeState.swipeDirection === 'horizontal') {
        e.preventDefault();
        swipeState.currentX = currentX;
        let translation = diffX;
        if (translation > 0) translation = 0;
        if (translation < -90) translation = -90;
        swipeState.activeContainer.querySelector('.qzone-post-item').style.transform = `translateX(${translation}px)`;
    }
};

const handleSwipeEnd = (e) => {
    if (swipeState.isClick) {
        swipeState.isDragging = false;
        swipeState.activeContainer = null;
        return;
    }
    if (!swipeState.isDragging || !swipeState.activeContainer) return;

    const postItem = swipeState.activeContainer.querySelector('.qzone-post-item');
    postItem.style.transition = 'transform 0.3s ease';

    const finalX = e.type.includes('touchend') ? e.changedTouches[0].pageX : e.pageX;
    const diffX = finalX - swipeState.startX;
    const swipeThreshold = -40;

    if (swipeState.swipeDirection === 'horizontal' && diffX < swipeThreshold) {
        postItem.classList.add('swiped');
        postItem.style.transform = '';
    } else {
        postItem.classList.remove('swiped');
        postItem.style.transform = '';
    }

    swipeState.isDragging = false;
    swipeState.startX = 0;
    swipeState.startY = 0;
    swipeState.currentX = 0;
    swipeState.activeContainer = null;
    swipeState.swipeDirection = null;
    swipeState.isClick = true;
};

// --- 绑定所有滑动事件 ---
postsList.addEventListener('mousedown', handleSwipeStart);
document.addEventListener('mousemove', handleSwipeMove);
document.addEventListener('mouseup', handleSwipeEnd);
postsList.addEventListener('touchstart', handleSwipeStart, { passive: false });
postsList.addEventListener('touchmove', handleSwipeMove, { passive: false });
postsList.addEventListener('touchend', handleSwipeEnd);

// ▼▼▼ 步骤3.3：用这整块代码替换旧的 qzone-posts-list 的 click 事件监听器 ▼▼▼
postsList.addEventListener('click', async (e) => {
    e.stopPropagation();
    const target = e.target;
// ▼▼▼ 在这里粘贴新代码 ▼▼▼
const summonBtn = target.closest('.action-icon.summon-npc');
if (summonBtn) {
    const postId = parseInt(summonBtn.dataset.postId);
    const authorId = summonBtn.dataset.authorId;
    if (!isNaN(postId) && authorId) {
        handleNpcSummonClick(postId, authorId);
    }
    return; // 处理完召唤逻辑后，直接结束，不执行后续的点赞等判断
}
// ▲▲▲ 粘贴结束 ▲▲▲

    // ★★★★★【核心修改：处理点击评论本身（用于回复）】★★★★★
    const commentItem = target.closest('.comment-item');
    // 确保点击的不是删除按钮或评论里的名字链接
    if (commentItem && !target.classList.contains('comment-delete-btn') && !target.classList.contains('commenter-name') && !target.classList.contains('reply-target-name')) {
        const postContainer = commentItem.closest('.qzone-post-container');
        if (postContainer) {
            const commenterName = commentItem.dataset.commenterName;
            const myNickname = state.qzoneSettings.nickname;
            
            // 如果点击的是自己的评论，则不进入回复模式
            if (commenterName !== myNickname) {
                const commentInput = postContainer.querySelector('.comment-input');
                commentInput.placeholder = `回复 ${commenterName}:`;
                commentInput.dataset.replyTo = commenterName; // 把要回复的人的名字，临时存起来
                commentInput.focus(); // 自动聚焦到输入框
            }
        }
        return; // 处理完点击评论后，就不用往下执行了
    }

    if (target.classList.contains('comment-delete-btn')) {
        const postContainer = target.closest('.qzone-post-container');
        if (!postContainer) return;
        const postId = parseInt(postContainer.dataset.postId);
        const commentIndex = parseInt(target.dataset.commentIndex);
        if (isNaN(postId) || isNaN(commentIndex)) return;
        const post = await db.qzonePosts.get(postId);
        if (!post || !post.comments || !post.comments[commentIndex]) return;
        const commentText = post.comments[commentIndex].text;
        const confirmed = await showCustomConfirm('删除评论', `确定要删除这条评论吗？\n\n“${commentText.substring(0, 50)}...”`, { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            post.comments.splice(commentIndex, 1);
            await db.qzonePosts.update(postId, { comments: post.comments });
            await renderQzonePosts();
            alert('评论已删除。');
        }
        return;
    }

    if (target.classList.contains('post-actions-btn')) {
        const container = target.closest('.qzone-post-container');
        if (container && container.dataset.postId) showPostActions(parseInt(container.dataset.postId));
        return;
    }

    if (target.closest('.qzone-post-delete-action')) {
        const container = target.closest('.qzone-post-delete-action').parentElement;
        if (!container) return;
        const postIdToDelete = parseInt(container.dataset.postId);
        if (isNaN(postIdToDelete)) return;
        const confirmed = await showCustomConfirm('删除动态', '确定要永久删除这条动态吗？', { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            container.style.transition = 'all 0.3s ease';
            container.style.transform = 'scale(0.8)';
            container.style.opacity = '0';
            setTimeout(async () => {
                 await db.qzonePosts.delete(postIdToDelete);
                 const notificationIdentifier = `(ID: ${postIdToDelete})`;
                 for (const chatId in state.chats) {
                     const chat = state.chats[chatId];
                     const originalHistoryLength = chat.history.length;
                     chat.history = chat.history.filter(msg => !(msg.role === 'system' && msg.content.includes(notificationIdentifier)));
                     if (chat.history.length < originalHistoryLength) await db.chats.put(chat);
                 }
                 await renderQzonePosts();
                 alert('动态已删除。');
            }, 300);
        }
        return;
    }

    if (target.tagName === 'IMG' && target.dataset.hiddenText) {
        showCustomAlert("图片内容", target.dataset.hiddenText.replace(/<br>/g, '\n'));
        return;
    }
    const icon = target.closest('.action-icon');
    if (icon) {
        const postContainer = icon.closest('.qzone-post-container');
        if (!postContainer) return;
        const postId = parseInt(postContainer.dataset.postId);
        if (isNaN(postId)) return;
        if (icon.classList.contains('like')) {
            const post = await db.qzonePosts.get(postId);
            if (!post) return;
            if (!post.likes) post.likes = [];
            const userNickname = state.qzoneSettings.nickname;
            const userLikeIndex = post.likes.indexOf(userNickname);
            if (userLikeIndex > -1) {
                post.likes.splice(userLikeIndex, 1);
            } else {
                post.likes.push(userNickname);
                icon.classList.add('animate-like');
                icon.addEventListener('animationend', () => icon.classList.remove('animate-like'), { once: true });
            }
            await db.qzonePosts.update(postId, { likes: post.likes });
        }
        if (icon.classList.contains('favorite')) {
            const existingFavorite = await db.favorites.where({ type: 'qzone_post', 'content.id': postId }).first();
            if (existingFavorite) {
                await db.favorites.delete(existingFavorite.id);
                await showCustomAlert('提示', '已取消收藏');
            } else {
                const postToSave = await db.qzonePosts.get(postId);
                if (postToSave) {
                    await db.favorites.add({ type: 'qzone_post', content: postToSave, timestamp: Date.now() });
                    await showCustomAlert('提示', '收藏成功！');
                }
            }
        }
        await renderQzonePosts();
        return;
    }
    
    // ★★★★★【核心修改：处理评论发送逻辑】★★★★★
    const sendBtn = target.closest('.comment-send-btn');
    if (sendBtn) {
        const postContainer = sendBtn.closest('.qzone-post-container');
        if (!postContainer) return;
        const postId = parseInt(postContainer.dataset.postId);
        const commentInput = postContainer.querySelector('.comment-input');
        const commentText = commentInput.value.trim();
        if (!commentText) return alert('评论内容不能为空哦！');
        const post = await db.qzonePosts.get(postId);
        if (!post) return;
        if (!post.comments) post.comments = [];

        // 创建新的评论对象
        const newComment = { 
            commenterName: state.qzoneSettings.nickname, 
            text: commentText, 
            timestamp: Date.now() 
        };

        // 检查是不是在回复模式
        if (commentInput.dataset.replyTo) {
            newComment.replyTo = commentInput.dataset.replyTo; // 如果是，就把回复对象的名字加上
        }

        post.comments.push(newComment);
        await db.qzonePosts.update(postId, { comments: post.comments });
        for (const chatId in state.chats) {
            const chat = state.chats[chatId];
            if (!chat.isGroup) {
                let aiNotification = `[系统提示：'${state.qzoneSettings.nickname}' 在ID为${postId}的动态下发表了评论：“${commentText}”`;
                if(newComment.replyTo) {
                    aiNotification += ` (这是对'${newComment.replyTo}'的回复)`;
                }
                aiNotification += `]`;
                chat.history.push({ role: 'system', content: aiNotification, timestamp: Date.now(), isHidden: true });
                await db.chats.put(chat);
            }
        }
        
        // 发送后，重置输入框状态
        commentInput.value = '';
        commentInput.placeholder = '友善的评论是交流的起点';
        delete commentInput.dataset.replyTo; // 清除回复状态

        await renderQzonePosts();
        return;
    }
});
// ▲▲▲ 步骤3.3替换结束 ▲▲▲

            // ▼▼▼ 在 init() 函数的事件监听器区域，粘贴下面这两行 ▼▼▼

            // 绑定动态页和收藏页的返回按钮
            document.getElementById('qzone-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));
            document.getElementById('favorites-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));

            // ▲▲▲ 添加结束 ▲▲▲

            // ▼▼▼ 在 init() 函数的事件监听器区域，检查并确保你有这段完整的代码 ▼▼▼

            // 收藏页搜索功能
            const searchInput = document.getElementById('favorites-search-input');
            const searchClearBtn = document.getElementById('favorites-search-clear-btn');

            searchInput.addEventListener('input', () => {
                const searchTerm = searchInput.value.trim().toLowerCase();
                
                // 控制清除按钮的显示/隐藏
                searchClearBtn.style.display = searchTerm ? 'block' : 'none';

                if (!searchTerm) {
                    displayFilteredFavorites(allFavoriteItems); // 如果搜索框为空，显示所有
                    return;
                }

                // 筛选逻辑
                const filteredItems = allFavoriteItems.filter(item => {
                    let contentToSearch = '';
                    let authorToSearch = '';

                    if (item.type === 'qzone_post') {
                        const post = item.content;
                        contentToSearch += (post.publicText || '') + ' ' + (post.content || '');
                        if (post.authorId === 'user') {
                            authorToSearch = state.qzoneSettings.nickname;
                        } else if (state.chats[post.authorId]) {
                            authorToSearch = state.chats[post.authorId].name;
                        }
                    } else if (item.type === 'chat_message') {
                        const msg = item.content;
                        if (typeof msg.content === 'string') {
                            contentToSearch = msg.content;
                        }
                        const chat = state.chats[item.chatId];
                        if (chat) {
                           if (msg.role === 'user') {
                                authorToSearch = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
                           } else {
                                authorToSearch = chat.isGroup ? msg.senderName : chat.name;
                           }
                        }
                    }
                    
                    // 同时搜索内容和作者，并且不区分大小写
                    return contentToSearch.toLowerCase().includes(searchTerm) || 
                           authorToSearch.toLowerCase().includes(searchTerm);
                });

                displayFilteredFavorites(filteredItems);
            });

            // 清除按钮的点击事件
            searchClearBtn.addEventListener('click', () => {
                searchInput.value = '';
                searchClearBtn.style.display = 'none';
                displayFilteredFavorites(allFavoriteItems);
                searchInput.focus();
            });

            // ▲▲▲ 代码检查结束 ▲▲▲

            // ▼▼▼ 新增/修改的事件监听器 ▼▼▼
            
            // 为聊天界面的批量收藏按钮绑定事件
                        // 为聊天界面的批量收藏按钮绑定事件 (已修正)
            document.getElementById('selection-favorite-btn').addEventListener('click', async () => {
                if (selectedMessages.size === 0) return;
                const chat = state.chats[state.activeChatId];
                if (!chat) return;

                const favoritesToAdd = [];
                const timestampsToFavorite = [...selectedMessages];

                for (const timestamp of timestampsToFavorite) {
                    // 【核心修正1】使用新的、高效的索引进行查询
                    const existing = await db.favorites.where('originalTimestamp').equals(timestamp).first();
                    
                    if (!existing) {
                        const messageToSave = chat.history.find(msg => msg.timestamp === timestamp);
                        if (messageToSave) {
                            favoritesToAdd.push({
                                type: 'chat_message',
                                content: messageToSave,
                                chatId: state.activeChatId,
                                timestamp: Date.now(), // 这是收藏操作发生的时间
                                originalTimestamp: messageToSave.timestamp // 【核心修正2】保存原始消息的时间戳到新字段
                            });
                        }
                    }
                }

                if (favoritesToAdd.length > 0) {
                    await db.favorites.bulkAdd(favoritesToAdd);
                    allFavoriteItems = await db.favorites.orderBy('timestamp').reverse().toArray(); // 更新全局收藏缓存
                    await showCustomAlert('收藏成功', `已成功收藏 ${favoritesToAdd.length} 条消息。`);
                } else {
                    await showCustomAlert('提示', '选中的消息均已收藏过。');
                }
                
                exitSelectionMode();
            });

            // 收藏页面的"编辑"按钮事件 (已修正)
            const favoritesEditBtn = document.getElementById('favorites-edit-btn');
            const favoritesView = document.getElementById('favorites-view');
            const favoritesActionBar = document.getElementById('favorites-action-bar');
            const mainBottomNav = document.getElementById('chat-list-bottom-nav'); // 获取主导航栏
            const favoritesList = document.getElementById('favorites-list'); // 获取收藏列表
            
            favoritesEditBtn.addEventListener('click', () => {
                isFavoritesSelectionMode = !isFavoritesSelectionMode;
                favoritesView.classList.toggle('selection-mode', isFavoritesSelectionMode);

                if (isFavoritesSelectionMode) {
                    // --- 进入编辑模式 ---
                    favoritesEditBtn.textContent = '完成';
                    favoritesActionBar.style.display = 'block'; // 显示删除操作栏
                    mainBottomNav.style.display = 'none'; // ▼ 新增：隐藏主导航栏
                    favoritesList.style.paddingBottom = '80px'; // ▼ 新增：给列表底部增加空间
                } else {
                    // --- 退出编辑模式 ---
                    favoritesEditBtn.textContent = '编辑';
                    favoritesActionBar.style.display = 'none'; // 隐藏删除操作栏
                    mainBottomNav.style.display = 'flex';  // ▼ 新增：恢复主导航栏
                    favoritesList.style.paddingBottom = ''; // ▼ 新增：恢复列表默认padding

                    // 退出时清空所有选择
                    selectedFavorites.clear();
                    document.querySelectorAll('.favorite-item-card.selected').forEach(card => card.classList.remove('selected'));
                    document.getElementById('favorites-delete-selected-btn').textContent = `删除 (0)`;
                }
            });

// ▼▼▼ 将它【完整替换】为下面这段修正后的代码 ▼▼▼
// 收藏列表的点击选择事件 (事件委托)
document.getElementById('favorites-list').addEventListener('click', (e) => {
    const target = e.target;
    const card = target.closest('.favorite-item-card');

    // 【新增】处理文字图点击，这段逻辑要放在最前面，保证任何模式下都生效
    if (target.tagName === 'IMG' && target.dataset.hiddenText) {
        const hiddenText = target.dataset.hiddenText;
        showCustomAlert("图片内容", hiddenText.replace(/<br>/g, '\n'));
        return; // 处理完就退出，不继续执行选择逻辑
    }
    
    // 如果不在选择模式，则不执行后续的选择操作
    if (!isFavoritesSelectionMode) return;

    // --- 以下是原有的选择逻辑，保持不变 ---
    if (!card) return;

    const favId = parseInt(card.dataset.favid);
    if (isNaN(favId)) return;

    // 切换选择状态
    if (selectedFavorites.has(favId)) {
        selectedFavorites.delete(favId);
        card.classList.remove('selected');
    } else {
        selectedFavorites.add(favId);
        card.classList.add('selected');
    }
    
    // 更新底部删除按钮的计数
    document.getElementById('favorites-delete-selected-btn').textContent = `删除 (${selectedFavorites.size})`;
});

// ▼▼▼ 将它【完整替换】为下面这段修正后的代码 ▼▼▼
// 收藏页面批量删除按钮事件
document.getElementById('favorites-delete-selected-btn').addEventListener('click', async () => {
    if (selectedFavorites.size === 0) return;

    const confirmed = await showCustomConfirm(
        '确认删除', 
        `确定要从收藏夹中移除这 ${selectedFavorites.size} 条内容吗？`, 
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        const idsToDelete = [...selectedFavorites];
        await db.favorites.bulkDelete(idsToDelete);
        await showCustomAlert('删除成功', '选中的收藏已被移除。');
        
        // 【核心修正1】从前端缓存中也移除被删除的项
        allFavoriteItems = allFavoriteItems.filter(item => !idsToDelete.includes(item.id));
        
        // 【核心修正2】使用更新后的缓存，立即重新渲染列表
        displayFilteredFavorites(allFavoriteItems);
        
        // 最后，再退出编辑模式
        favoritesEditBtn.click(); // 模拟点击"完成"按钮来退出编辑模式
    }
});

// ▼▼▼ 在 init() 函数末尾添加 ▼▼▼
if (state.globalSettings.enableBackgroundActivity) {
    startBackgroundSimulation();
    console.log("后台活动模拟已自动启动。");
}
// ▲▲▲ 添加结束 ▲▲▲

// ▼▼▼ 【这是最终的正确代码】请粘贴这段代码到 init() 的事件监听器区域末尾 ▼▼▼

// --- 统一处理所有影响预览的控件的事件 ---

// 1. 监听主题选择
document.querySelectorAll('input[name="theme-select"]').forEach(radio => {
    radio.addEventListener('change', updateSettingsPreview);
});

// 2. 监听字体大小滑块
const fontSizeSlider = document.getElementById('font-size-slider');
fontSizeSlider.addEventListener('input', () => {
    // a. 实时更新数值显示
    document.getElementById('font-size-value').textContent = `${fontSizeSlider.value}px`;
    // b. 更新预览
    updateSettingsPreview();
});

// 3. 监听自定义CSS输入框
const customCssInputForPreview = document.getElementById('custom-css-input');
customCssInputForPreview.addEventListener('input', updateSettingsPreview);

// 4. 监听重置按钮
document.getElementById('reset-theme-btn').addEventListener('click', () => {
    document.getElementById('theme-default').checked = true;
    updateSettingsPreview();
});

document.getElementById('reset-custom-css-btn').addEventListener('click', () => {
    document.getElementById('custom-css-input').value = '';
    updateSettingsPreview();
});

// ▲▲▲ 粘贴结束 ▲▲▲

// ▼▼▼ 请将这段【新代码】粘贴到 init() 的事件监听器区域末尾 ▼▼▼
document.querySelectorAll('input[name="visibility"]').forEach(radio => {
    radio.addEventListener('change', function() {
        const groupsContainer = document.getElementById('post-visibility-groups');
        if (this.value === 'include' || this.value === 'exclude') {
            groupsContainer.style.display = 'block';
        } else {
            groupsContainer.style.display = 'none';
        }
    });
});
// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 请将这段【新代码】粘贴到 init() 的事件监听器区域末尾 ▼▼▼
document.getElementById('manage-groups-btn').addEventListener('click', openGroupManager);
document.getElementById('close-group-manager-btn').addEventListener('click', () => {
    document.getElementById('group-management-modal').classList.remove('visible');
    // 刷新聊天设置里的分组列表
    const chatSettingsBtn = document.getElementById('chat-settings-btn');
    if (document.getElementById('chat-settings-modal').classList.contains('visible')) {
       chatSettingsBtn.click(); // 再次点击以重新打开
    }
});

document.getElementById('add-new-group-btn').addEventListener('click', addNewGroup);
document.getElementById('existing-groups-list').addEventListener('click', (e) => {
    if (e.target.classList.contains('delete-group-btn')) {
        const groupId = parseInt(e.target.dataset.id);
        deleteGroup(groupId);
    }
});
// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 请将这段【新代码】粘贴到 init() 的事件监听器区域末尾 ▼▼▼
// 消息操作菜单的按钮事件
document.getElementById('cancel-message-action-btn').addEventListener('click', hideMessageActions);
// ▼▼▼ 【修正】使用新的编辑器入口 ▼▼▼
document.getElementById('edit-message-btn').addEventListener('click', openAdvancedMessageEditor);
// ▲▲▲ 替换结束 ▲▲▲
document.getElementById('copy-message-btn').addEventListener('click', copyMessageContent);

// ▼▼▼ 在这里添加新代码 ▼▼▼
document.getElementById('recall-message-btn').addEventListener('click', handleRecallClick);
// ▲▲▲ 添加结束 ▲▲▲

// ▼▼▼ 请用这段【修正后】的代码替换旧的 select-message-btn 事件监听器 ▼▼▼
document.getElementById('select-message-btn').addEventListener('click', () => {
    // 【核心修复】在关闭菜单前，先捕获时间戳
    const timestampToSelect = activeMessageTimestamp; 
    hideMessageActions();
    // 使用捕获到的值
    if (timestampToSelect) {
        enterSelectionMode(timestampToSelect);
    }
});
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 在 init() 函数的事件监听器区域末尾添加 ▼▼▼

// 动态操作菜单的按钮事件
document.getElementById('edit-post-btn').addEventListener('click', openPostEditor);
document.getElementById('copy-post-btn').addEventListener('click', copyPostContent);
document.getElementById('cancel-post-action-btn').addEventListener('click', hidePostActions);

// ▲▲▲ 添加结束 ▲▲▲

// ▼▼▼ 【新增】联系人选择器事件绑定 ▼▼▼
document.getElementById('cancel-contact-picker-btn').addEventListener('click', () => {
    showScreen('chat-list-screen');
});

document.getElementById('contact-picker-list').addEventListener('click', (e) => {
    const item = e.target.closest('.contact-picker-item');
    if (!item) return;

    const contactId = item.dataset.contactId;
    item.classList.toggle('selected');
    
    if (selectedContacts.has(contactId)) {
        selectedContacts.delete(contactId);
    } else {
        selectedContacts.add(contactId);
    }
    updateContactPickerConfirmButton();
});

// ▼▼▼ 【新增】绑定“管理群成员”按钮事件 ▼▼▼
document.getElementById('manage-members-btn').addEventListener('click', () => {
    // 在切换屏幕前，先隐藏当前的聊天设置弹窗
    document.getElementById('chat-settings-modal').classList.remove('visible');
    // 然后再打开成员管理屏幕
    openMemberManagementScreen();
});
// ▲▲▲ 新增代码结束 ▲▲▲

// ▼▼▼ 【最终完整版】群成员管理功能事件绑定 ▼▼▼
document.getElementById('back-from-member-management').addEventListener('click', () => {

    showScreen('chat-interface-screen');    
    document.getElementById('chat-settings-btn').click();
});
// ▲▲▲ 替换结束 ▲▲▲

document.getElementById('add-existing-contact-btn').addEventListener('click', async () => {
    // 【已恢复】从好友列表添加的事件
    // 【关键】为“完成”按钮绑定“拉人入群”的逻辑
    const confirmBtn = document.getElementById('confirm-contact-picker-btn');
    // 使用克隆节点方法清除旧的事件监听器，防止重复绑定
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    newConfirmBtn.addEventListener('click', handleAddMembersToGroup);
    
    await openContactPickerForAddMember();
});

document.getElementById('create-new-member-btn').addEventListener('click', createNewMemberInGroup);
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【全新】视频通话功能事件监听器 ▼▼▼

// 绑定单聊和群聊的发起按钮
document.getElementById('video-call-btn').addEventListener('click', handleInitiateCall);
document.getElementById('group-video-call-btn').addEventListener('click', handleInitiateCall);

// 绑定“挂断”按钮
document.getElementById('hang-up-btn').addEventListener('click', endVideoCall);

// 绑定“取消呼叫”按钮
document.getElementById('cancel-call-btn').addEventListener('click', () => {
    videoCallState.isAwaitingResponse = false;
    showScreen('chat-interface-screen');
});

// 【全新】绑定“加入通话”按钮
document.getElementById('join-call-btn').addEventListener('click', handleUserJoinCall);

// ▼▼▼ 用这个【已修复并激活旁观模式】的版本替换旧的 decline-call-btn 事件监听器 ▼▼▼
// 绑定来电请求的“拒绝”按钮
document.getElementById('decline-call-btn').addEventListener('click', async () => {
    stopRingtone(); 
    hideIncomingCallModal();
    const callerChatId = videoCallState.activeChatId; // 【核心修正1】从专用信道获取来电者ID
    if (!callerChatId) return;

    const chat = state.chats[callerChatId];
    if (!chat) return;
    
    // 【核心修正2】根据是否群聊，执行不同的拒绝逻辑
    if (videoCallState.isGroupCall) {
        // 对于群聊，拒绝=旁观，这个逻辑不变
        videoCallState.isUserParticipating = false;
        const systemNote = {
            role: 'system',
            content: `[系统提示：用户拒绝了通话邀请，但你们可以自己开始。请你们各自决策是否加入。]`,
            timestamp: Date.now(),
            isHidden: true
        };
        chat.history.push(systemNote);
        await db.chats.put(chat);
        await triggerAiResponse(); 
    } else { 
        // 对于单聊，我们不再打扰用户当前界面，而是静默处理
        const declineMessage = { role: 'user', content: '我拒绝了你的视频通话请求。', timestamp: Date.now(), isHidden: true };
        chat.history.push(declineMessage);
        await db.chats.put(chat);
        
        // 【核心修正3】只通知，不切换屏幕
        showNotification(callerChatId, "你已拒绝通话邀请。");
        // 【重要】在后台为对方触发一个响应，让它知道自己被拒绝了
        // 我们需要临时切换activeChatId来触发，然后再换回来
        const originalActiveChatId = state.activeChatId;
        state.activeChatId = callerChatId;
        await triggerAiResponse();
        state.activeChatId = originalActiveChatId;
    }
    
    // 清理状态
    videoCallState.isAwaitingResponse = false;
    videoCallState.activeChatId = null;
});
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 用这个【已修复重复头像BUG】的版本替换旧的 accept-call-btn 事件监听器 ▼▼▼
// 绑定来电请求的“接听”按钮
document.getElementById('accept-call-btn').addEventListener('click', async () => {
    stopRingtone();
    hideIncomingCallModal();
    const callerChatId = videoCallState.activeChatId; // 【核心修正1】从专用信道获取ID
    if (!callerChatId) return;
    
    // 【核心修正2】在接听时，我们才真正改变全局状态，并打开通话界面
    state.activeChatId = callerChatId; // <-- 在这里，我们才授权修改全局状态！
    
    videoCallState.initiator = 'ai';
    videoCallState.isUserParticipating = true;
    
    if (videoCallState.isGroupCall) {
        const chat = state.chats[videoCallState.activeChatId];
        const requester = chat.members.find(m => m.name === videoCallState.callRequester);
        if (requester) {
            videoCallState.participants = [requester];
        } else {
            videoCallState.participants = [];
        }
    }
    
    startVideoCall(); // 启动通话界面
});
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 请用这个【已增加用户高亮】的全新版本，完整替换旧的 user-speak-btn 事件监听器 ▼▼▼
// 绑定用户在通话中发言的按钮
document.getElementById('user-speak-btn').addEventListener('click', async () => {
    if (!videoCallState.isActive) return;

    // ★★★★★ 核心新增：在弹出输入框前，先找到并高亮用户头像 ★★★★★
    const userAvatar = document.querySelector('.participant-avatar-wrapper[data-participant-id="user"] .participant-avatar');
    if (userAvatar) {
        userAvatar.classList.add('speaking');
    }

    const userInput = await showCustomPrompt('你说', '请输入你想说的话...');
    
    // ★★★★★ 核心新增：无论用户是否输入，只要关闭输入框就移除高亮 ★★★★★
    if (userAvatar) {
        userAvatar.classList.remove('speaking');
    }

    if (userInput && userInput.trim()) {
        triggerAiInCallAction(userInput.trim());
    }
});
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 【新增】回忆录相关事件绑定 ▼▼▼
// 1. 将“回忆”页签和它的视图连接起来
document.querySelector('.nav-item[data-view="memories-view"]').addEventListener('click', () => {
    // 在切换前，确保"收藏"页面的编辑模式已关闭
    if (isFavoritesSelectionMode) {
        document.getElementById('favorites-edit-btn').click(); 
    }
    switchToChatListView('memories-view');
    renderMemoriesScreen(); // 点击时渲染
});

// 2. 绑定回忆录界面的返回按钮
document.getElementById('memories-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));

// ▲▲▲ 新增结束 ▲▲▲

// 【全新】约定/倒计时功能事件绑定
document.getElementById('add-countdown-btn').addEventListener('click', () => {
    document.getElementById('create-countdown-modal').classList.add('visible');
});
document.getElementById('cancel-create-countdown-btn').addEventListener('click', () => {
    document.getElementById('create-countdown-modal').classList.remove('visible');
});
document.getElementById('confirm-create-countdown-btn').addEventListener('click', async () => {
    const title = document.getElementById('countdown-title-input').value.trim();
    const dateValue = document.getElementById('countdown-date-input').value;
    
    if (!title || !dateValue) {
        alert('请填写完整的约定标题和日期！');
        return;
    }

    const targetDate = new Date(dateValue);
    if (isNaN(targetDate) || targetDate <= new Date()) {
        alert('请输入一个有效的、未来的日期！');
        return;
    }

    const newCountdown = {
        chatId: null, // 用户创建的，不属于任何特定AI
        authorName: '我',
        description: title,
        timestamp: Date.now(),
        type: 'countdown',
        targetDate: targetDate.getTime()
    };
    
    await db.memories.add(newCountdown);
    document.getElementById('create-countdown-modal').classList.remove('visible');
    renderMemoriesScreen();
});

// 【全新】拉黑功能事件绑定
document.getElementById('block-chat-btn').addEventListener('click', async () => {
    if (!state.activeChatId || state.chats[state.activeChatId].isGroup) return;

    const chat = state.chats[state.activeChatId];
    const confirmed = await showCustomConfirm(
        '确认拉黑', 
        `确定要拉黑“${chat.name}”吗？拉黑后您将无法向其发送消息，直到您将Ta移出黑名单，或等待Ta重新申请好友。`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        chat.relationship.status = 'blocked_by_user';
        chat.relationship.blockedTimestamp = Date.now();

        // ▼▼▼ 在这里添加下面的代码 ▼▼▼
        const hiddenMessage = {
            role: 'system',
            content: `[系统提示：你刚刚被用户拉黑了。在对方解除拉黑之前，你无法再主动发起对话，也无法回应。]`,
            timestamp: Date.now() + 1,
            isHidden: true
        };
        chat.history.push(hiddenMessage);
        // ▲▲▲ 添加结束 ▲▲▲

        await db.chats.put(chat);
        
        // 关闭设置弹窗，并刷新聊天界面
        document.getElementById('chat-settings-modal').classList.remove('visible');
        renderChatInterface(state.activeChatId);
        // 刷新聊天列表，可能会有UI变化
        renderChatList();
    }
});

document.getElementById('chat-lock-overlay').addEventListener('click', async (e) => {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    if (e.target.id === 'force-apply-check-btn') {
        alert("正在手动触发好友申请流程，请稍后...\n如果API调用成功，将弹出提示。如果失败，也会有错误提示。如果长时间无反应，说明AI可能决定暂时不申请。");
        await triggerAiFriendApplication(chat.id);
        renderChatInterface(chat.id); 
        return;
    }

    if (e.target.id === 'unblock-btn') {
        chat.relationship.status = 'friend';
        chat.relationship.blockedTimestamp = null;

        // ▼▼▼ 在这里添加下面的代码 ▼▼▼
        const hiddenMessage = {
            role: 'system',
            content: `[系统提示：用户刚刚解除了对你的拉黑。现在你们可以重新开始对话了。]`,
            timestamp: Date.now(),
            isHidden: true
        };
        chat.history.push(hiddenMessage);
        // ▲▲▲ 添加结束 ▲▲▲

        await db.chats.put(chat);
        renderChatInterface(chat.id);
        renderChatList();
        triggerAiResponse(); // 【可选但推荐】解除后让AI主动说点什么
    }
    else if (e.target.id === 'accept-friend-btn') {
        chat.relationship.status = 'friend';
        chat.relationship.applicationReason = '';

        // ▼▼▼ 在这里添加下面的代码 ▼▼▼
        const hiddenMessage = {
            role: 'system',
            content: `[系统提示：用户刚刚通过了你的好友申请。你们现在又可以正常聊天了。]`,
            timestamp: Date.now(),
            isHidden: true
        };
        chat.history.push(hiddenMessage);
        // ▲▲▲ 添加结束 ▲▲▲

        await db.chats.put(chat);
        renderChatInterface(chat.id);
        renderChatList();
        const msg = { role: 'user', content: '我通过了你的好友请求', timestamp: Date.now() };
        chat.history.push(msg);
        await db.chats.put(chat);
        appendMessage(msg, chat);
        triggerAiResponse();
    }
    else if (e.target.id === 'reject-friend-btn') {
        chat.relationship.status = 'blocked_by_user';
        chat.relationship.blockedTimestamp = Date.now();
        chat.relationship.applicationReason = '';
        await db.chats.put(chat);
        renderChatInterface(chat.id);
    }
    // 【新增】处理申请好友按钮的点击事件
    else if (e.target.id === 'apply-friend-btn') {
        const reason = await showCustomPrompt(
            '发送好友申请', 
            `请输入你想对“${chat.name}”说的申请理由：`,
            "我们和好吧！"
        );
        // 只有当用户输入了内容并点击“确定”后才继续
        if (reason !== null) {
            // 更新关系状态为“等待AI批准”
            chat.relationship.status = 'pending_ai_approval';
            chat.relationship.applicationReason = reason;
            await db.chats.put(chat);

            // 刷新UI，显示“等待通过”的界面
            renderChatInterface(chat.id);
            renderChatList();
            
            // 【关键】触发AI响应，让它去处理这个好友申请
            triggerAiResponse();
        }
    }
});

// ▼▼▼ 【全新】红包功能事件绑定 ▼▼▼

// 1. 将原有的转账按钮(￥)的点击事件，重定向到新的总入口函数
document.getElementById('transfer-btn').addEventListener('click', handlePaymentButtonClick);

// 2. 红包模态框内部的控制按钮
document.getElementById('cancel-red-packet-btn').addEventListener('click', () => {
    document.getElementById('red-packet-modal').classList.remove('visible');
});
document.getElementById('send-group-packet-btn').addEventListener('click', sendGroupRedPacket);
document.getElementById('send-direct-packet-btn').addEventListener('click', sendDirectRedPacket);

// 3. 红包模态框的页签切换逻辑
const rpTabGroup = document.getElementById('rp-tab-group');
const rpTabDirect = document.getElementById('rp-tab-direct');
const rpContentGroup = document.getElementById('rp-content-group');
const rpContentDirect = document.getElementById('rp-content-direct');

rpTabGroup.addEventListener('click', () => {
    rpTabGroup.classList.add('active');
    rpTabDirect.classList.remove('active');
    rpContentGroup.style.display = 'block';
    rpContentDirect.style.display = 'none';
});
rpTabDirect.addEventListener('click', () => {
    rpTabDirect.classList.add('active');
    rpTabGroup.classList.remove('active');
    rpContentDirect.style.display = 'block';
    rpContentGroup.style.display = 'none';
});

// 4. 实时更新红包金额显示
document.getElementById('rp-group-amount').addEventListener('input', (e) => {
    const amount = parseFloat(e.target.value) || 0;
    document.getElementById('rp-group-total').textContent = `¥ ${amount.toFixed(2)}`;
});
document.getElementById('rp-direct-amount').addEventListener('input', (e) => {
    const amount = parseFloat(e.target.value) || 0;
    document.getElementById('rp-direct-total').textContent = `¥ ${amount.toFixed(2)}`;
});

// ▲▲▲ 新事件绑定结束 ▲▲▲

// ▼▼▼ 【全新添加】使用事件委托处理红包点击，修复失效问题 ▼▼▼
document.getElementById('chat-messages').addEventListener('click', (e) => {
    // 1. 找到被点击的红包卡片
    const packetCard = e.target.closest('.red-packet-card');
    if (!packetCard) return; // 如果点击的不是红包，就什么也不做

    // 2. 从红包卡片的父级.message-bubble获取时间戳
    const messageBubble = packetCard.closest('.message-bubble');
    if (!messageBubble || !messageBubble.dataset.timestamp) return;

    // 3. 调用我们现有的处理函数
    const timestamp = parseInt(messageBubble.dataset.timestamp);
    handlePacketClick(timestamp);
});
// ▲▲▲ 新增代码结束 ▲▲▲

// ▼▼▼ 【全新】投票功能事件监听器 ▼▼▼
// 在输入框工具栏添加按钮
document.getElementById('send-poll-btn').addEventListener('click', openCreatePollModal);

// 投票创建模态框的按钮
document.getElementById('add-poll-option-btn').addEventListener('click', addPollOptionInput);
document.getElementById('cancel-create-poll-btn').addEventListener('click', () => {
    document.getElementById('create-poll-modal').classList.remove('visible');
});
document.getElementById('confirm-create-poll-btn').addEventListener('click', sendPoll);

// 使用事件委托处理投票卡片内的所有点击事件
document.getElementById('chat-messages').addEventListener('click', (e) => {
    const pollCard = e.target.closest('.poll-card');
    if (!pollCard) return;

    const timestamp = parseInt(pollCard.dataset.pollTimestamp);
    if (isNaN(timestamp)) return;
    
    // 点击了选项
    const optionItem = e.target.closest('.poll-option-item');
    if (optionItem && !pollCard.classList.contains('closed')) {
        handleUserVote(timestamp, optionItem.dataset.option);
        return;
    }
    
    // 点击了动作按钮（结束投票/查看结果）
    const actionBtn = e.target.closest('.poll-action-btn');
    if (actionBtn) {
        if (pollCard.classList.contains('closed')) {
            showPollResults(timestamp);
        } else {
            endPoll(timestamp);
        }
        return;
    }

    // 如果是已结束的投票，点击卡片任何地方都可以查看结果
    if (pollCard.classList.contains('closed')) {
        showPollResults(timestamp);
    }
});
// ▲▲▲ 新事件监听器粘贴结束 ▲▲▲

  // ▼▼▼ 【全新】AI头像库功能事件绑定 ▼▼▼
document.getElementById('manage-ai-avatar-library-btn').addEventListener('click', openAiAvatarLibraryModal);
document.getElementById('add-ai-avatar-btn').addEventListener('click', addAvatarToLibrary);
document.getElementById('close-ai-avatar-library-btn').addEventListener('click', closeAiAvatarLibraryModal);
// ▲▲▲ 新增结束 ▲▲▲

// ▼▼▼ 在 init() 的事件监听区域，粘贴这段【新代码】▼▼▼
            // ▼▼▼ 【请求4】App图标上传功能升级 (请用这整块代码替换旧的icon-settings-grid监听器) ▼▼▼
            document.getElementById('icon-settings-grid').addEventListener('click', async (e) => {
                if (e.target.classList.contains('change-icon-btn')) {
                    const item = e.target.closest('.icon-setting-item');
                    const iconId = item.dataset.iconId;
                    if (!iconId) return;

                    // 1. 弹出选择模态框
                    const choice = await showChoiceModal("更换图标", [
                        { text: '📁 从本地上传', value: 'local' },
                        { text: '🌐 使用网络URL', value: 'url' }
                    ]);

                    let newUrl = null;

                    // 2. 根据用户的选择执行不同操作
                    if (choice === 'local') {
                        newUrl = await uploadImageLocally(); // 调用我们之前写好的本地上传辅助函数
                    } else if (choice === 'url') {
                        const currentUrl = state.globalSettings.appIcons[iconId];
                        newUrl = await showCustomPrompt(`更换“${item.querySelector('.icon-preview').alt}”图标`, '请输入新的图片URL', currentUrl, 'url');
                    }

                    // 3. 处理最终结果
                    if (newUrl && newUrl.trim()) {
                        const trimmedUrl = newUrl.trim();
                        // 仅在内存中更新，等待用户点击“保存”
                        state.globalSettings.appIcons[iconId] = trimmedUrl;
                        // 实时更新设置页面的预览图
                        item.querySelector('.icon-preview').src = trimmedUrl;
                    } else if (newUrl !== null) {
                        alert("请输入一个有效的URL或选择一个文件！");
                    }
                }
            });
            // ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 在 init() 函数的末尾，粘贴这段【全新的事件监听器】 ▼▼▼

    document.getElementById('chat-messages').addEventListener('click', (e) => {
        // 使用 .closest() 向上查找被点击的卡片
        const linkCard = e.target.closest('.link-share-card');
        if (linkCard) {
            const timestamp = parseInt(linkCard.dataset.timestamp);
            if (!isNaN(timestamp)) {
                openBrowser(timestamp); // 调用我们的函数
            }
        }
    });

    // 浏览器返回按钮的事件监听，确保它只绑定一次
    document.getElementById('browser-back-btn').addEventListener('click', () => {
        showScreen('chat-interface-screen');
    });

// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 在 init() 函数的末尾，粘贴这段【全新的事件监听器】 ▼▼▼

    // 1. 绑定输入框上方“分享链接”按钮的点击事件
    document.getElementById('share-link-btn').addEventListener('click', openShareLinkModal);

    // 2. 绑定模态框中“取消”按钮的点击事件
    document.getElementById('cancel-share-link-btn').addEventListener('click', () => {
        document.getElementById('share-link-modal').classList.remove('visible');
    });

    // 3. 绑定模态框中“分享”按钮的点击事件
    document.getElementById('confirm-share-link-btn').addEventListener('click', sendUserLinkShare);

// ▲▲▲ 新代码粘贴结束 ▲▲▲

document.getElementById('theme-toggle-switch').addEventListener('change', toggleTheme);

// ▼▼▼ 在 init() 的事件监听器区域，粘贴下面这几行 ▼▼▼
// 绑定消息操作菜单中的“引用”按钮
document.getElementById('quote-message-btn').addEventListener('click', startReplyToMessage);

// 绑定回复预览栏中的“取消”按钮
document.getElementById('cancel-reply-btn').addEventListener('click', cancelReplyMode);
// ▲▲▲ 粘贴结束 ▲▲▲

// 在你的 init() 函数的事件监听器区域...

// ▼▼▼ 用这段代码替换旧的转账卡片点击事件 ▼▼▼
document.getElementById('chat-messages').addEventListener('click', (e) => {
    // 1. 向上查找被点击的元素是否在一个消息气泡内
    const bubble = e.target.closest('.message-bubble');
    if (!bubble) return; // 如果不在，就退出

    // 2. 【核心修正】在这里添加严格的筛选条件
    // 必须是 AI 的消息 (.ai)
    // 必须是转账类型 (.is-transfer)
    // 必须是我们标记为“待处理”的 (data-status="pending")
    if (bubble.classList.contains('ai') && 
        bubble.classList.contains('is-transfer') && 
        bubble.dataset.status === 'pending') {
        
        // 3. 只有满足所有条件，才执行后续逻辑
        const timestamp = parseInt(bubble.dataset.timestamp);
        if (!isNaN(timestamp)) {
            showTransferActionModal(timestamp);
        }
    }
});
// ▲▲▲ 替换结束 ▲▲▲

// 在 init() 的事件监听区域添加
document.getElementById('transfer-action-accept').addEventListener('click', () => handleUserTransferResponse('accepted'));
document.getElementById('transfer-action-decline').addEventListener('click', () => handleUserTransferResponse('declined'));
document.getElementById('transfer-action-cancel').addEventListener('click', hideTransferActionModal);

// ▼▼▼ 用这段【新代码】替换旧的通话记录事件绑定 ▼▼▼

document.getElementById('chat-list-title').addEventListener('click', renderCallHistoryScreen);

// 2. 绑定通话记录页面的“返回”按钮
document.getElementById('call-history-back-btn').addEventListener('click', () => {
    // 【核心修改】返回到聊天列表页面，而不是聊天界面
    showScreen('chat-list-screen');
});

// 3. 监听卡片点击的逻辑保持不变
document.getElementById('call-history-list').addEventListener('click', (e) => {
    const card = e.target.closest('.call-record-card');
    if (card && card.dataset.recordId) {
        showCallTranscript(parseInt(card.dataset.recordId));
    }
});

// 4. 关闭详情弹窗的逻辑保持不变
document.getElementById('close-transcript-modal-btn').addEventListener('click', () => {
    document.getElementById('call-transcript-modal').classList.remove('visible');
});

// ▲▲▲ 替换结束 ▲▲▲

document.getElementById('chat-messages').addEventListener('click', (e) => {
    // 1. 检查点击的是否是语音条
    const voiceBody = e.target.closest('.voice-message-body');
    if (!voiceBody) return;

    // 2. 找到相关的DOM元素
    const bubble = voiceBody.closest('.message-bubble');
    if (!bubble) return;
    
    const spinner = voiceBody.querySelector('.loading-spinner');
    const transcriptEl = bubble.querySelector('.voice-transcript');

    // 如果正在加载中，则不响应点击
    if (bubble.dataset.state === 'loading') {
        return;
    }

    // 3. 如果文字已经展开，则收起
    if (bubble.dataset.state === 'expanded') {
        transcriptEl.style.display = 'none';
        bubble.dataset.state = 'collapsed';
    } 
    // 4. 如果是收起状态，则开始“转录”流程
    else {
        bubble.dataset.state = 'loading'; // 进入加载状态
        spinner.style.display = 'block';   // 显示加载动画

        // 模拟1.5秒的语音识别过程
        setTimeout(() => {
            // 检查此时元素是否还存在（可能用户已经切换了聊天）
            if (document.body.contains(bubble)) {
                const voiceText = bubble.dataset.voiceText || '(无法识别)';
                transcriptEl.textContent = voiceText; // 填充文字
                
                spinner.style.display = 'none';      // 隐藏加载动画
                transcriptEl.style.display = 'block';// 显示文字
                bubble.dataset.state = 'expanded';     // 进入展开状态
            }
        }, 500);
    }
});

document.getElementById('chat-header-status').addEventListener('click', handleEditStatusClick);

// 在 init() 的事件监听器区域添加
document.getElementById('selection-share-btn').addEventListener('click', () => {
    if (selectedMessages.size > 0) {
        openShareTargetPicker(); // 打开我们即将创建的目标选择器
    }
});

// 在 init() 的事件监听器区域添加
document.getElementById('confirm-share-target-btn').addEventListener('click', async () => {
    const sourceChat = state.chats[state.activeChatId];
    const selectedTargetIds = Array.from(document.querySelectorAll('.share-target-checkbox:checked'))
                                   .map(cb => cb.dataset.chatId);

    if (selectedTargetIds.length === 0) {
        alert("请至少选择一个要分享的聊天。");
        return;
    }

    // 1. 打包聊天记录
    const sharedHistory = [];
    const sortedTimestamps = [...selectedMessages].sort((a, b) => a - b);
    for (const timestamp of sortedTimestamps) {
        const msg = sourceChat.history.find(m => m.timestamp === timestamp);
        if (msg) {
            sharedHistory.push(msg);
        }
    }
    
    // 2. 创建分享卡片消息对象
    const shareCardMessage = {
        role: 'user',
        senderName: sourceChat.isGroup ? (sourceChat.settings.myNickname || '我') : '我',
        type: 'share_card',
        timestamp: Date.now(),
        payload: {
            sourceChatName: sourceChat.name,
            title: `来自“${sourceChat.name}”的聊天记录`,
            sharedHistory: sharedHistory
        }
    };

    // 3. 循环发送到所有目标聊天
    for (const targetId of selectedTargetIds) {
        const targetChat = state.chats[targetId];
        if (targetChat) {
            targetChat.history.push(shareCardMessage);
            await db.chats.put(targetChat);
        }
    }
    
    // 4. 收尾工作
    document.getElementById('share-target-modal').classList.remove('visible');
    exitSelectionMode(); // 退出多选模式
    await showCustomAlert("分享成功", `聊天记录已成功分享到 ${selectedTargetIds.length} 个会话中。`);
    renderChatList(); // 刷新列表，可能会有新消息提示
});

// 绑定取消按钮
document.getElementById('cancel-share-target-btn').addEventListener('click', () => {
    document.getElementById('share-target-modal').classList.remove('visible');
});

// 在 init() 的事件监听器区域添加
document.getElementById('chat-messages').addEventListener('click', (e) => {
    // ...你已有的其他点击事件逻辑...

    // 新增逻辑：处理分享卡片的点击
    const shareCard = e.target.closest('.link-share-card[data-timestamp]');
    if (shareCard && shareCard.closest('.message-bubble.is-link-share')) {
        const timestamp = parseInt(shareCard.dataset.timestamp);
        openSharedHistoryViewer(timestamp);
    }
});

// 绑定查看器的关闭按钮
document.getElementById('close-shared-history-viewer-btn').addEventListener('click', () => {
    document.getElementById('shared-history-viewer-modal').classList.remove('visible');
});

// 创建新函数来处理渲染逻辑
function openSharedHistoryViewer(timestamp) {
    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === timestamp);
    if (!message || message.type !== 'share_card') return;

    const viewerModal = document.getElementById('shared-history-viewer-modal');
    const viewerTitle = document.getElementById('shared-history-viewer-title');
    const viewerContent = document.getElementById('shared-history-viewer-content');

    viewerTitle.textContent = message.payload.title;
    viewerContent.innerHTML = ''; // 清空旧内容

    // 【核心】复用 createMessageElement 来渲染每一条被分享的消息
    message.payload.sharedHistory.forEach(sharedMsg => {
        // 注意：这里我们传入的是 sourceChat 对象，以确保头像、昵称等正确
        const sourceChat = Object.values(state.chats).find(c => c.name === message.payload.sourceChatName) || chat;
        const bubbleEl = createMessageElement(sharedMsg, sourceChat);
        if (bubbleEl) {
            viewerContent.appendChild(bubbleEl);
        }
    });

    viewerModal.classList.add('visible');
}

audioPlayer.addEventListener('timeupdate', updateMusicProgressBar);

audioPlayer.addEventListener('pause', () => { 
    if(musicState.isActive) { 
        musicState.isPlaying = false; 
        updatePlayerUI(); 
    } 
});
audioPlayer.addEventListener('play', () => { 
    if(musicState.isActive) { 
        musicState.isPlaying = true; 
        updatePlayerUI(); 
    } 
});

document.getElementById('playlist-body').addEventListener('click', async (e) => {
    const target = e.target;
    if (target.classList.contains('delete-track-btn')) {
        const index = parseInt(target.dataset.index);
        const track = musicState.playlist[index];
        const confirmed = await showCustomConfirm('删除歌曲', `确定要从播放列表中删除《${track.name}》吗？`);
        if (confirmed) {
            deleteTrack(index);
        }
        return;
    }
    // ▼▼▼ 在 lyrics-btn 的判断逻辑【上方】，添加这段新代码 ▼▼▼
            if (target.classList.contains('cover-btn')) {
                const index = parseInt(target.dataset.index);
                if (!isNaN(index)) {
                    handleCoverUpload(index);
                }
                return; // 处理完就退出，避免触发其他逻辑
            }
// ▲▲▲ 添加结束 ▲▲▲

            // ▼▼▼ 请用这【一整块新代码】替换旧的 lyrics-btn 点击逻辑 ▼▼▼
            if (target.classList.contains('lyrics-btn')) {
                const index = parseInt(target.dataset.index);
                if (isNaN(index)) return;

                // 1. 弹窗询问用户选择（已移除图标）
                const choice = await showChoiceModal("选择歌词来源", [
                    { text: '使用网络URL', value: 'url' },
                    { text: '从本地上传', value: 'local' }
                ]);

                let lrcContent = null;

                // 2. 根据选择执行不同操作
                if (choice === 'url') {
                    const url = await showCustomPrompt("歌词URL", "请输入.lrc歌词文件的网络链接");
                    if (url && url.trim()) {
                        try {
                            const response = await fetch(url.trim());
                            if (response.ok) {
                                lrcContent = await response.text();
                            } else {
                                alert('无法获取歌词文件，请检查URL是否正确。');
                            }
                        } catch (error) {
                            alert('获取歌词失败: ' + error.message);
                        }
                    }
                } else if (choice === 'local') {
                    lrcContent = await new Promise(resolve => {
                        const lrcInput = document.getElementById('lrc-upload-input');
                        const handler = (event) => {
                            const file = event.target.files[0];
                            if (file) {
                                const reader = new FileReader();
                                reader.onload = (re) => resolve(re.target.result);
                                reader.readAsText(file);
                            } else {
                                resolve(null);
                            }
                            lrcInput.removeEventListener('change', handler);
                            lrcInput.value = '';
                        };
                        lrcInput.addEventListener('change', handler);
                        lrcInput.click();
                    });
                }

                // 3. 如果成功获取到歌词，就保存并更新
                if (lrcContent !== null) {
                    musicState.playlist[index].lrcContent = lrcContent;
                    await saveGlobalPlaylist();
                    alert('歌词导入成功！');
                    if (musicState.currentIndex === index) {
                        musicState.parsedLyrics = parseLRC(lrcContent);
                        renderLyrics();
                    }
                }
            }
            // ▲▲▲ 替换结束 ▲▲▲
});

document.querySelector('.progress-bar').addEventListener('click', (e) => {
    if (!audioPlayer.duration) return;
    const progressBar = e.currentTarget;
    const barWidth = progressBar.clientWidth;
    const clickX = e.offsetX;
    audioPlayer.currentTime = (clickX / barWidth) * audioPlayer.duration;
});

// ▼▼▼ 在 init() 函数的事件监听器区域，粘贴这段新代码 ▼▼▼

// 使用事件委托来处理所有“已撤回消息”的点击事件
document.getElementById('chat-messages').addEventListener('click', (e) => {
    // 检查被点击的元素或其父元素是否是“已撤回”提示
    const placeholder = e.target.closest('.recalled-message-placeholder');
    if (!placeholder) return; // 如果不是，就退出

    // 如果是，就从聊天记录中找到对应的数据并显示
    const chat = state.chats[state.activeChatId];
    const wrapper = placeholder.closest('.message-wrapper'); // 找到它的父容器
    if (chat && wrapper) {
        // 从父容器上找到时间戳
        const timestamp = parseInt(wrapper.dataset.timestamp);
        const recalledMsg = chat.history.find(m => m.timestamp === timestamp);
        
        if (recalledMsg && recalledMsg.recalledData) {
            let originalContentText = '';
            const recalled = recalledMsg.recalledData;
            
            if (recalled.originalType === 'text') {
                originalContentText = `原文: "${recalled.originalContent}"`;
            } else {
                originalContentText = `撤回了一条[${recalled.originalType}]类型的消息`;
            }
            showCustomAlert('已撤回的消息', originalContentText);
        }
    }
});

// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 在 init() 的事件监听器区域，粘贴这段新代码 ▼▼▼
document.getElementById('manage-world-book-categories-btn').addEventListener('click', openCategoryManager);
document.getElementById('close-category-manager-btn').addEventListener('click', () => {
    document.getElementById('world-book-category-manager-modal').classList.remove('visible');
    renderWorldBookScreen(); // 关闭后刷新主列表
});
document.getElementById('add-new-category-btn').addEventListener('click', addNewCategory);
document.getElementById('existing-categories-list').addEventListener('click', (e) => {
    if (e.target.classList.contains('delete-group-btn')) {
        const categoryId = parseInt(e.target.dataset.id);
        deleteCategory(categoryId);
    }
});
// ▲▲▲ 新代码粘贴结束 ▲▲▲

// --- ▼▼▼ 【全新】自定义头像框功能事件绑定 ▼▼▼ ---

// 打开“选择”弹窗的按钮
document.getElementById('chat-settings-modal').addEventListener('click', (e) => {
    if (e.target.classList.contains('change-frame-btn')) {
        openFrameSelectorModal(e.target.dataset.type);
    }
});
document.getElementById('member-settings-modal').addEventListener('click', (e) => {
    if (e.target.classList.contains('change-frame-btn')) {
        openFrameSelectorModal('member', editingMemberId);
    }
});

// “选择”弹窗内的按钮
// “选择”弹窗内的按钮（已修正）
document.getElementById('manage-custom-frames-btn').addEventListener('click', () => {
    // 1. 先关闭当前的选择弹窗
    document.getElementById('avatar-frame-modal').classList.remove('visible');
    
    // 2. 然后再打开管理弹窗
    openFrameManager();
});
document.getElementById('cancel-frame-settings-btn').addEventListener('click', () => document.getElementById('avatar-frame-modal').classList.remove('visible'));
document.getElementById('save-frame-settings-btn').addEventListener('click', saveSelectedFrames);

// “管理”弹窗内的按钮
document.getElementById('upload-custom-frame-btn').addEventListener('click', handleUploadCustomFrame);
document.getElementById('close-frame-manager-btn').addEventListener('click', () => {
    document.getElementById('custom-frame-manager-modal').classList.remove('visible');
    // 关闭管理后，刷新选择界面，因为列表可能变了
    openFrameSelectorModal(currentFrameSelection.type, currentFrameSelection.target);
});

// ▲▲▲ 新事件绑定结束 ▲▲▲

// ▼▼▼ 【全新】聊天列表左滑功能JS逻辑 ▼▼▼
const chatListEl = document.getElementById('chat-list');
let chatSwipeState = { isDragging: false, startX: 0, activeContent: null };

// 关闭所有已滑开的项
function resetAllChatSwipes(exceptThisOne = null) {
    document.querySelectorAll('.chat-list-item-content.swiped').forEach(content => {
        if (content !== exceptThisOne) {
            content.classList.remove('swiped');
        }
    });
}

chatListEl.addEventListener('mousedown', (e) => {
    const content = e.target.closest('.chat-list-item-content');
    if (content) {
        resetAllChatSwipes(content);
        chatSwipeState.isDragging = true;
        chatSwipeState.startX = e.pageX;
        chatSwipeState.activeContent = content;
        // 阻止拖动时选中文本
        e.preventDefault();
    }
});

document.addEventListener('mousemove', (e) => {
    if (!chatSwipeState.isDragging || !chatSwipeState.activeContent) return;
    const diffX = e.pageX - chatSwipeState.startX;
    if (diffX < 0 && diffX > -170) { // 只允许向左滑, 限制最大距离
        chatSwipeState.activeContent.style.transition = 'none'; // 滑动时禁用动画
        chatSwipeState.activeContent.style.transform = `translateX(${diffX}px)`;
    }
});

document.addEventListener('mouseup', (e) => {
    if (!chatSwipeState.isDragging || !chatSwipeState.activeContent) return;
    
    chatSwipeState.activeContent.style.transition = 'transform 0.3s ease';
    const transformStyle = window.getComputedStyle(chatSwipeState.activeContent).transform;
    const currentTranslateX = new DOMMatrix(transformStyle).m41;

    if (currentTranslateX < -60) { // 滑动超过阈值
        chatSwipeState.activeContent.classList.add('swiped');
    } else {
        chatSwipeState.activeContent.classList.remove('swiped');
    }
    chatSwipeState.activeContent.style.transform = ''; // 清除内联样式，交由CSS class控制

    // 重置状态
    chatSwipeState.isDragging = false;
    chatSwipeState.activeContent = null;
});

// 移动端触摸事件的兼容
chatListEl.addEventListener('touchstart', (e) => {
     const content = e.target.closest('.chat-list-item-content');
    if (content) {
        resetAllChatSwipes(content);
        chatSwipeState.isDragging = true;
        chatSwipeState.startX = e.touches[0].pageX;
        chatSwipeState.activeContent = content;
    }
}, { passive: true });

chatListEl.addEventListener('touchmove', (e) => {
    if (!chatSwipeState.isDragging || !chatSwipeState.activeContent) return;
    const diffX = e.touches[0].pageX - chatSwipeState.startX;
     if (diffX < 0 && diffX > -170) {
        chatSwipeState.activeContent.style.transition = 'none';
        chatSwipeState.activeContent.style.transform = `translateX(${diffX}px)`;
    }
}, { passive: true });

chatListEl.addEventListener('touchend', (e) => {
    if (!chatSwipeState.isDragging || !chatSwipeState.activeContent) return;
    
    chatSwipeState.activeContent.style.transition = 'transform 0.3s ease';
    const transformStyle = window.getComputedStyle(chatSwipeState.activeContent).transform;
    const currentTranslateX = new DOMMatrix(transformStyle).m41;

    if (currentTranslateX < -60) {
        chatSwipeState.activeContent.classList.add('swiped');
    } else {
        chatSwipeState.activeContent.classList.remove('swiped');
    }
    chatSwipeState.activeContent.style.transform = '';

    chatSwipeState.isDragging = false;
    chatSwipeState.activeContent = null;
});
// ▲▲▲ 新JS逻辑粘贴结束 ▲▲▲

// ▼▼▼ 【全新】聊天列表操作按钮点击事件 ▼▼▼
chatListEl.addEventListener('click', async (e) => {
    const target = e.target;
    if (target.classList.contains('swipe-action-btn')) {
        const container = target.closest('.chat-list-item-swipe-container');
        if (!container) return;

        const chatId = container.dataset.chatId;
        const chat = state.chats[chatId];
        if (!chat) return;

        if (target.classList.contains('pin') || target.classList.contains('unpin')) {
            // 置顶或取消置顶
            chat.isPinned = !chat.isPinned;
            await db.chats.put(chat);
            await renderChatList(); // 重新渲染列表以更新排序
        } else if (target.classList.contains('delete')) {
            // 删除
            const confirmed = await showCustomConfirm('删除对话', `确定要删除与 "${chat.name}" 的整个对话吗？此操作不可撤销。`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                if (musicState.isActive && musicState.activeChatId === chat.id) await endListenTogetherSession(false);
                delete state.chats[chat.id];
                if (state.activeChatId === chat.id) state.activeChatId = null;
                await db.chats.delete(chat.id);
                await renderChatList();
            } else {
                // 如果取消删除，则把滑块收回去
                const content = container.querySelector('.chat-list-item-content');
                if (content) content.classList.remove('swiped');
            }
        }
    }
});
// ▲▲▲ 新事件监听粘贴结束 ▲▲▲
// ▼▼▼ 从这里开始，把下面这两块完整的 eventListener 代码【剪切】掉 ▼▼▼

// 使用事件委托来处理所有点击和勾选事件，效率更高
worldBookCheckboxesContainer.addEventListener('click', (e) => {
    const header = e.target.closest('.wb-category-header');
    // 如果点击的是文件夹头部，并且不是点在复选框上
    if (header && !e.target.matches('input[type="checkbox"]')) {
        const categoryId = header.querySelector('.wb-category-checkbox')?.dataset.categoryId;
        if (categoryId) {
            const bookContainer = worldBookCheckboxesContainer.querySelector(`.wb-book-container[data-container-for="${categoryId}"]`);
            if (bookContainer) {
                header.classList.toggle('collapsed');
                bookContainer.classList.toggle('collapsed');
            }
        }
    }
});

worldBookCheckboxesContainer.addEventListener('change', (e) => {
    const target = e.target;
    
    // 如果点击的是分类的“全选”复选框
    if (target.classList.contains('wb-category-checkbox')) {
        const categoryId = target.dataset.categoryId;
        const isChecked = target.checked;
        // 找到这个分类下的所有书籍复选框，并将它们的状态设置为与分类复选框一致
        const bookCheckboxes = worldBookCheckboxesContainer.querySelectorAll(`input.wb-book-checkbox[data-parent-category="${categoryId}"]`);
        bookCheckboxes.forEach(cb => cb.checked = isChecked);
    }
    
    // 如果点击的是单个书籍的复选框
    if (target.classList.contains('wb-book-checkbox')) {
        const categoryId = target.dataset.parentCategory;
        if (categoryId) { // 检查它是否属于一个分类
            const categoryCheckbox = worldBookCheckboxesContainer.querySelector(`input.wb-category-checkbox[data-category-id="${categoryId}"]`);
            const allBookCheckboxes = worldBookCheckboxesContainer.querySelectorAll(`input.wb-book-checkbox[data-parent-category="${categoryId}"]`);
            // 检查该分类下是否所有书籍都被选中了
            const allChecked = Array.from(allBookCheckboxes).every(cb => cb.checked);
            // 同步分类“全选”复选框的状态
            if(categoryCheckbox) categoryCheckbox.checked = allChecked;
        }
    }
    
    // 每次变更后都更新顶部的已选数量显示
    updateWorldBookSelectionDisplay();
});

// ▲▲▲ 把上面这两块完整的 eventListener 代码【剪切】掉 ▲▲▲


    // ▼▼▼ 在 init() 的事件监听器区域末尾，粘贴下面这一整块新代码 ▼▼▼

    // --- 美化功能事件绑定 ---
    const themeEditor = document.getElementById('theme-css-editor');
    
    // 页面加载时，加载主题列表并显示模板
    await loadThemesToDropdown();
    themeEditor.value = THEME_CSS_TEMPLATE;

    // 绑定下拉框选择事件
    document.getElementById('theme-selector').addEventListener('change', handleThemeSelection);
    
    // 绑定所有操作按钮
    document.getElementById('apply-theme-btn').addEventListener('click', () => applyThemeCss(themeEditor.value));
    document.getElementById('save-theme-btn').addEventListener('click', saveCurrentTheme);
    document.getElementById('save-as-new-theme-btn').addEventListener('click', saveAsNewTheme);
    document.getElementById('rename-theme-btn').addEventListener('click', renameSelectedTheme);
    document.getElementById('delete-theme-btn').addEventListener('click', deleteSelectedTheme);
    document.getElementById('export-theme-btn').addEventListener('click', exportTheme);
    
    // 绑定导入按钮和隐藏的文件选择器
    document.getElementById('import-theme-btn').addEventListener('click', () => {
        document.getElementById('import-theme-input').click();
    });
    document.getElementById('import-theme-input').addEventListener('change', (e) => {
        importTheme(e.target.files[0]);
        e.target.value = null; // 清空，以便下次能选择同一个文件
    });
    
    // ▲▲▲ 新事件绑定结束 ▲▲▲

document.getElementById('api-preset-select').addEventListener('change', handleApiPresetSelectChange);
document.getElementById('manage-api-presets-btn').addEventListener('click', openApiPresetManager);

            // ▼▼▼ 【全新】锁屏功能事件监听器 ▼▼▼

            // 1. 锁屏壁纸上传
            document.getElementById('lockscreen-wallpaper-upload-input').addEventListener('change', async (event) => {
                const file = event.target.files[0];
                if(file) {
                    const dataUrl = await new Promise((res, rej) => {
                        const reader = new FileReader();
                        reader.onload = () => res(reader.result);
                        reader.onerror = () => rej(reader.error);
                        reader.readAsDataURL(file);
                    });
                    newLockscreenWallpaperBase64 = dataUrl;
                    renderWallpaperScreen(); // 上传后实时预览
                }
            });

            // 2. 密码输入框按钮
            document.getElementById('password-confirm-btn').addEventListener('click', checkPassword);
            document.getElementById('password-cancel-btn').addEventListener('click', hidePasswordModal);
            // 允许在输入框内按回车键确认
            document.getElementById('password-input-field').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    checkPassword();
                }
            });

            // 3. 【全新】带有动画效果的上滑解锁手势
            const lockScreen = document.getElementById('lock-screen');
            const unlockHint = document.getElementById('unlock-hint');
            let touchStartY = 0;
            let isSwiping = false;

// 统一的开始处理函数
const handleUnlockStart = (e) => {
    if (document.getElementById('password-modal-overlay').classList.contains('visible')) return;
    
    // (你原来的其他逻辑保持不变)
    const blurBg = document.getElementById('lock-screen-background-blur');
    if (state.globalSettings.password) {
        blurBg.style.backgroundImage = lockScreen.style.backgroundImage;
        blurBg.style.display = 'block';
    } else {
        document.getElementById('home-screen').classList.add('active');
    }
    
    touchStartY = getEventCoords(e).y; // 使用辅助函数获取Y坐标
    isSwiping = true;
    lockScreen.style.transition = 'none';
    unlockHint.style.transition = 'none';
};

// 统一的移动处理函数
const handleUnlockMove = (e) => {
    if (!isSwiping) return;
    const currentY = getEventCoords(e).y; // 使用辅助函数
    let diffY = currentY - touchStartY;
    // (你原来的其他逻辑保持不变)
    if (diffY > 0) diffY = 0;
    lockScreen.style.transform = `translateY(${diffY}px)`;
    unlockHint.style.opacity = Math.max(0, 1 - Math.abs(diffY) / 100);
    if (state.globalSettings.password) {
        const blurBg = document.getElementById('lock-screen-background-blur');
        blurBg.style.opacity = Math.min(1, Math.abs(diffY) / 80);
    }
};

// 统一的结束处理函数
const handleUnlockEnd = (e) => {
    if (!isSwiping) return;
    isSwiping = false;

    // (你原来的其他逻辑保持不变)
    lockScreen.style.transition = 'transform 0.3s ease-out';
    unlockHint.style.transition = 'opacity 0.3s ease-out';
    const blurBg = document.getElementById('lock-screen-background-blur');
    
    // 注意：touchend事件的坐标在 e.changedTouches[0]
    const touchEndY = e.changedTouches ? e.changedTouches[0].clientY : e.pageY;
    const swipeDistance = touchStartY - touchEndY;
    
    if (swipeDistance > 80) {
        lockScreen.style.transform = 'translateY(-100%)';
        setTimeout(() => {
            if (state.globalSettings.password) {
                showPasswordModal();
            } else {
                unlockPhone();
            }
        }, 300);
    } else {
        lockScreen.style.transform = 'translateY(0)';
        unlockHint.style.opacity = '1';
        if (state.globalSettings.password) {
            blurBg.style.opacity = '0';
            setTimeout(() => { blurBg.style.display = 'none'; }, 300);
        } else {
            document.getElementById('home-screen').classList.remove('active');
        }
    }
};

// 2. 绑定两种事件到同一套处理逻辑上
lockScreen.addEventListener('touchstart', handleUnlockStart, { passive: true });
lockScreen.addEventListener('touchmove', handleUnlockMove, { passive: true });
lockScreen.addEventListener('touchend', handleUnlockEnd, { passive: true });

lockScreen.addEventListener('mousedown', handleUnlockStart);
// 注意：mousemove和mouseup最好绑定在document上，防止鼠标拖出范围后失效
document.addEventListener('mousemove', handleUnlockMove);
document.addEventListener('mouseup', handleUnlockEnd);
            
            // ▲▲▲ 新事件监听器粘贴结束 ▲▲▲

// 【全新】为聊天底部工具栏添加鼠标拖动滚动功能
const actionsTopBar = document.getElementById('chat-input-actions-top');
let isDown = false;
let startX;
let scrollLeft;

actionsTopBar.addEventListener('mousedown', (e) => {
    isDown = true;
    actionsTopBar.classList.add('grabbing'); // 添加一个class来改变鼠标样式
    startX = e.pageX - actionsTopBar.offsetLeft;
    scrollLeft = actionsTopBar.scrollLeft;
});

actionsTopBar.addEventListener('mouseleave', () => {
    isDown = false;
    actionsTopBar.classList.remove('grabbing');
});

actionsTopBar.addEventListener('mouseup', () => {
    isDown = false;
    actionsTopBar.classList.remove('grabbing');
});

actionsTopBar.addEventListener('mousemove', (e) => {
    if (!isDown) return;
    e.preventDefault();
    const x = e.pageX - actionsTopBar.offsetLeft;
    const walk = (x - startX) * 2; // 乘以2可以增加拖动速度，感觉更灵敏
    actionsTopBar.scrollLeft = scrollLeft - walk;
});

// ▼▼▼ 在 init() 的事件监听器区域末尾，粘贴这段新代码 ▼▼▼
document.getElementById('location-cancel-btn').addEventListener('click', () => {
    document.getElementById('send-location-modal').classList.remove('visible');
});
document.getElementById('location-confirm-btn').addEventListener('click', sendUserLocation);
// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 在 init() 的事件监听器区域末尾，粘贴这段新代码 ▼▼▼

// 【全新】为定位模态框的“添加途经点”按钮绑定事件
document.getElementById('add-trajectory-point-btn').addEventListener('click', () => {
    // 限制最多添加3个途经点，防止UI过于拥挤
    if (document.querySelectorAll('.trajectory-point-input').length < 3) {
        addTrajectoryPointInput();
    } else {
        alert("最多只能添加3个途经点哦！");
    }
});

// 【新增】打开定位模态框时，清空旧的途经点
document.getElementById('send-location-btn').addEventListener('click', () => {
    document.getElementById('trajectory-points-container').innerHTML = '';
    document.getElementById('send-location-modal').classList.add('visible');
});

// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 在这里粘贴下面这行新代码 ▼▼▼
document.getElementById('reroll-btn').addEventListener('click', handleRerollClick);
// ▲▲▲ 粘贴结束 ▲▲▲

// ▼▼▼ 【全新】粘贴这整块事件监听代码到 init() 末尾 ▼▼▼

// --- 悬浮歌词栏设置功能 ---
document.getElementById('lyrics-settings-btn').addEventListener('click', (e) => {
    e.stopPropagation(); // 阻止事件冒泡触发拖动或打开播放器
    document.getElementById('lyrics-settings-modal').classList.add('visible');
});

document.getElementById('close-lyrics-settings-btn').addEventListener('click', async () => {
    // 保存设置到全局状态并写入数据库
    state.globalSettings.lyricsBarSettings = lyricsBarSettings;
    await db.globalSettings.put(state.globalSettings);
    document.getElementById('lyrics-settings-modal').classList.remove('visible');
    alert('设置已保存！');
});

document.getElementById('reset-lyrics-settings-btn').addEventListener('click', () => {
    // 恢复到默认值
    lyricsBarSettings = { fontSize: 14, bgOpacity: 0, fontColor: '#FFFFFF', showOnClose: true };
    applyLyricsSettings(); // 应用默认设置
});

// 实时更新样式
document.getElementById('lyrics-font-size-slider').addEventListener('input', (e) => {
    lyricsBarSettings.fontSize = e.target.value;
    applyLyricsSettings();
});
document.getElementById('lyrics-bg-opacity-slider').addEventListener('input', (e) => {
    lyricsBarSettings.bgOpacity = e.target.value;
    applyLyricsSettings();
});
document.getElementById('lyrics-font-color-picker').addEventListener('input', (e) => {
    lyricsBarSettings.fontColor = e.target.value;
    applyLyricsSettings();
});

// 歌词栏上的关闭按钮
document.querySelector('#floating-lyrics-bar .close-btn').addEventListener('click', (e) => {
    e.stopPropagation();
    document.getElementById('floating-lyrics-bar').style.display = 'none';
});

// 播放器里的“悬浮/隐藏”开关
document.getElementById('toggle-lyrics-bar-btn').addEventListener('click', async (e) => {
    lyricsBarSettings.showOnClose = !lyricsBarSettings.showOnClose;
    e.target.textContent = lyricsBarSettings.showOnClose ? '悬浮' : '隐藏';
    e.target.style.opacity = lyricsBarSettings.showOnClose ? '1' : '0.5';
    // 立即保存这个设置
    state.globalSettings.lyricsBarSettings = lyricsBarSettings;
    await db.globalSettings.put(state.globalSettings);
});

// 【重要】在页面加载时，就应用一次已保存的设置
applyLyricsSettings();

// ▲▲▲ 新代码粘贴结束 ▲▲▲

            // ▼▼▼ 【全新】“查角色手机”功能事件监听器 ▼▼▼

            // 1. 绑定主屏幕上的“查手机”APP图标
            const checkPhoneAppIcon = document.querySelector('.app-icon[data-app-id="check-phone"]');
            if (checkPhoneAppIcon) {
                checkPhoneAppIcon.onclick = openCharacterSelectionScreen; // 修改onclick事件
            }

            // 2. 角色选择列表的点击事件 (事件委托)
            document.getElementById('character-selection-list').addEventListener('click', (e) => {
                const item = e.target.closest('.character-select-item');
                if (item && item.dataset.chatId) {
                    openCharacterPhone(item.dataset.chatId);
                }
            });
// ▼▼▼ 请用这整块代码替换 ▼▼▼
// 【V3版】角色手机聊天列表的点击事件 (事件委托)
document.getElementById('character-chat-list').addEventListener('click', (e) => {
    const item = e.target.closest('.chat-list-item');
    if (item && item.dataset.contactName) {
        // ▼▼▼ 在这里粘贴探针 #2 ▼▼▼
        const isUserChat = item.dataset.isUserChat === 'true';
        console.log("【诊断日志 2】: 点击了聊天列表项", {
            contactName: item.dataset.contactName,
            isUserChat: isUserChat
        });
        // ▲▲▲ 探针结束 ▲▲▲
        
        // 将联系人名字和“身份证”一起传递给渲染函数
        renderCharacterChatHistory(item.dataset.contactName, isUserChat);
        showCharacterPhonePage('character-chat-history-screen');
    }
});
// ▲▲▲ 替换结束 ▲▲▲



            // 3. 角色手机顶部的“刷新”和“清空”按钮
            document.getElementById('generate-character-data-btn').addEventListener('click', generateCharacterPhoneData);
            document.getElementById('clear-character-data-btn').addEventListener('click', clearCharacterPhoneData);

            // ▲▲▲ 事件监听器添加结束 ▲▲▲

            // ▼▼▼ 【全新】角色手机内部统一返回事件监听器 ▼▼▼
            document.getElementById('character-phone-container').addEventListener('click', (e) => {
                const backBtn = e.target.closest('.back-btn');
                if (!backBtn) return;

                // 检查是返回到角色手机内部页面，还是返回到主屏幕
                if (backBtn.dataset.targetPage) {
                    showCharacterPhonePage(backBtn.dataset.targetPage);
                } else if (backBtn.dataset.targetScreen) {
                    showScreen(backBtn.dataset.targetScreen);
                }
            });
            // ▲▲▲ 新代码粘贴结束 ▲▲▲

            // ▼▼▼ 【全新】角色手机日记APP事件监听器 ▼▼▼
            document.getElementById('character-app-grid').addEventListener('click', (e) => {
                const icon = e.target.closest('.app-icon');
                if (icon && icon.querySelector('.label').textContent === '日记') {
                    renderCharacterDiary();
                }
            });
            document.getElementById('generate-diary-entry-btn').addEventListener('click', generateNewDiaryEntry);
            // ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 【全新】“查手机”内容单条删除功能事件绑定 ▼▼▼
document.getElementById('character-phone-container').addEventListener('click', (e) => {
    const deleteBtn = e.target.closest('.item-delete-btn');
    if (deleteBtn) {
        // 【新增】处理微信消息删除
        if (deleteBtn.classList.contains('message-delete-btn')) {
            const contactName = deleteBtn.dataset.contactName;
            const index = parseInt(deleteBtn.dataset.index);
            if (contactName && !isNaN(index)) {
                handleCharacterChatMessageDeletion(contactName, index);
            }
        } 
        // 处理其他列表删除
        else {
            const dataType = deleteBtn.dataset.type;
            const index = parseInt(deleteBtn.dataset.index);
            if (dataType && !isNaN(index)) {
                handleCharacterDataDeletion(dataType, index);
            }
        }
    }
});
// ▲▲▲ 删除功能事件绑定结束 ▲▲▲

// ▼▼▼ 【全新】NPC库管理功能事件绑定 ▼▼▼

// 聊天设置里的“管理NPC库”按钮
document.getElementById('chat-settings-modal').addEventListener('click', (e) => {
    if (e.target.id === 'manage-npcs-btn') {
        // 先关闭聊天设置，再打开NPC管理
        document.getElementById('chat-settings-modal').classList.remove('visible');
        openNpcManager();
    }
});

// NPC管理界面的返回按钮
document.getElementById('back-from-npc-management').addEventListener('click', () => {
    // 返回时，重新打开聊天设置
    showScreen('chat-interface-screen');
    document.getElementById('chat-settings-btn').click();
});

// NPC管理界面的“+”按钮
document.getElementById('add-new-npc-btn').addEventListener('click', () => openNpcEditor(null));



// ▼▼▼ 【全新】粘贴这整块事件监听器代码 ▼▼▼
// --- 后台活动设置界面的事件绑定 ---

// 1. 总开关的事件
document.getElementById('background-activity-switch').addEventListener('change', () => {
    // 每次点击总开关，都重新渲染一次详细设置区（它会根据开关状态自动显示或隐藏）
    renderBackgroundFrequencySelector();
});

// 2. 全选按钮
document.getElementById('bg-select-all-chars').addEventListener('click', () => {
    document.querySelectorAll('.bg-char-checkbox').forEach(checkbox => {
        checkbox.checked = true;
    });
});

// 3. 全不选按钮
document.getElementById('bg-deselect-all-chars').addEventListener('click', () => {
    document.querySelectorAll('.bg-char-checkbox').forEach(checkbox => {
        checkbox.checked = false;
    });
});

// 这是修复后的新代码块，用它替换掉旧的
document.querySelector('#background-activity-details').addEventListener('click', async (e) => { // 注意这里加了 async
    if (e.target.classList.contains('bg-freq-btn')) {
        const freq = e.target.dataset.freq;
        const selectedCheckboxes = document.querySelectorAll('.bg-char-checkbox:checked');
        
        if (selectedCheckboxes.length === 0) {
            alert('请先选择至少一个角色！');
            return;
        }

        const config = state.globalSettings.backgroundActivityConfig || {};
        selectedCheckboxes.forEach(checkbox => {
            const chatId = checkbox.dataset.chatId;
            if (freq === 'none') {
                delete config[chatId];
            } else {
                config[chatId] = freq;
            }
        });
        
        state.globalSettings.backgroundActivityConfig = config;
        
        // ★★★★★ 这就是我们新加的关键代码！★★★
        await db.globalSettings.put(state.globalSettings);
        // ★★★★★ 添加结束 ★★★★★
        
        renderBackgroundFrequencySelector();

        const freqTextMap = {low:'低', medium:'中', high:'高', none: '关闭'};
        const freqText = freqTextMap[freq];
        alert(`已为 ${selectedCheckboxes.length} 个角色将后台活动频率设为 "${freqText}"`);
    }
});
// 使用事件委托，为所有可编辑元素统一绑定点击事件
// ▼▼▼ 用这块【功能增强版】的代码替换旧的 ▼▼▼
// 使用事件委托，为所有可编辑元素统一绑定点击事件
document.getElementById('home-screen').addEventListener('click', async (e) => { // <-- 把这行也改成 async
    // 【核心修正】使用 .closest() 来确保即使点击到子元素也能正确触发
    const editableText = e.target.closest('.editable-text');
    if (editableText) {
        handleEditText(editableText);
        return; // 处理完就退出，避免重复触发
    }

    const editableImage = e.target.closest('.editable-image');
    if (editableImage) {
        // --- ▼▼▼ 这就是我们本次修改的核心代码 ▼▼▼ ---
        // 1. 判断被点击的图片是不是主屏幕的那个大头像
        if (editableImage.id === 'profile-avatar-img') {
            // 2. 如果是，就弹出一个选择菜单
            const choice = await showChoiceModal("编辑头像", [
                { text: '更换头像图片', value: 'avatar' },
                { text: '更换头像框', value: 'frame' }
            ]);
            
            // 3. 根据用户的选择，执行不同的操作
            if (choice === 'avatar') {
                handleEditImage(editableImage); // 调用原来的更换图片函数
            } else if (choice === 'frame') {
                openFrameSelectorModal('home_profile'); // 调用我们新增的更换头像框函数
            }
        } else {
            // 4. 如果点击的不是主头像（比如是其他小组件的图片），就还执行原来的逻辑
            handleEditImage(editableImage);
        }
        // --- ▲▲▲ 核心代码修改结束 ▲▲▲ ---
        return;
    }
});
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 【全新】“查手机”内容单条删除功能 ▼▼▼
/**
 * 处理角色手机内数据删除的通用函数
 * @param {string} dataType - 要删除的数据类型, 比如 'memos', 'shoppingCart'
 * @param {number} index - 要删除的数据在数组中的索引
 */
async function handleCharacterDataDeletion(dataType, index) {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    
    let dataArray;
    // 【核心修改】处理像 bank.transactions 这样的嵌套数据
    if (dataType.includes('.')) {
        const keys = dataType.split('.');
        dataArray = chat.characterPhoneData[keys[0]][keys[1]];
    } else {
        dataArray = chat.characterPhoneData[dataType];
    }

    if (!chat || !dataArray) return;

    const itemToDelete = dataArray[index];
    if (!itemToDelete) return;

    const confirmed = await showCustomConfirm(
        '确认删除',
        '确定要删除这条记录吗？',
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        dataArray.splice(index, 1);
        await db.chats.put(chat);
        
        // 根据删除的类型，重新渲染对应的APP界面
        switch(dataType) {
            case 'memos': renderCharacterMemos(); break;
            case 'shoppingCart': renderCharacterShoppingCart(); break;
            case 'browserHistory': renderCharacterBrowser(); break;
            case 'diary': renderCharacterDiary(); break;
            case 'bank.transactions': renderCharacterBank(); break; // 新增
            case 'trajectory': renderCharacterTrajectory(); break;   // 新增
            case 'appUsage': renderCharacterAppUsage(); break;       // 新增
            case 'photoAlbum': renderCharacterPhotoAlbum(); break;   // 新增
        }
        alert('记录已删除。');
    }
}
// 使用事件委托来处理所有删除按钮的点击
document.getElementById('character-phone-container').addEventListener('click', (e) => {
    if (e.target.classList.contains('item-delete-btn')) {
        const dataType = e.target.dataset.type;
        const index = parseInt(e.target.dataset.index);
        if (dataType && !isNaN(index)) {
            handleCharacterDataDeletion(dataType, index);
        }
    }
});
// ▲▲▲ 删除功能结束 ▲▲▲
// ▼▼▼ 【全新】“查手机”内容单条删除功能 ▼▼▼
/**
 * 处理角色手机内数据删除的通用函数
 * @param {string} dataType - 要删除的数据类型, 比如 'memos', 'shoppingCart'
 * @param {number} index - 要删除的数据在数组中的索引
 */
async function handleCharacterDataDeletion(dataType, index) {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    
    let dataArray;
    // 处理像 bank.transactions 这样的嵌套数据
    if (dataType.includes('.')) {
        const keys = dataType.split('.');
        dataArray = chat.characterPhoneData[keys[0]][keys[1]];
    } else {
        dataArray = chat.characterPhoneData[dataType];
    }

    if (!chat || !dataArray) return;

    const itemToDelete = dataArray[index];
    if (!itemToDelete) return;

    const confirmed = await showCustomConfirm(
        '确认删除',
        '确定要删除这条记录吗？',
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        dataArray.splice(index, 1);
        await db.chats.put(chat);
        
        // 根据删除的类型，重新渲染对应的APP界面
        switch(dataType) {
            case 'memos': renderCharacterMemos(); break;
            case 'shoppingCart': renderCharacterShoppingCart(); break;
            case 'browserHistory': renderCharacterBrowser(); break;
            case 'diary': renderCharacterDiary(); break;
            case 'bank.transactions': renderCharacterBank(); break;
            case 'trajectory': renderCharacterTrajectory(); break;
            case 'appUsage': renderCharacterAppUsage(); break;
            case 'photoAlbum': renderCharacterPhotoAlbum(); break;
        }
        alert('记录已删除。');
    }
}
// ▲▲▲ 删除功能结束 ▲▲▲
startGroupSimulation(); // 启动群聊专属的后台时钟
// ▲▲▲ 新事件绑定结束 ▲▲▲
    // ▼▼▼ 步骤3.3：在 init() 的前面粘贴这段新代码 ▼▼▼
    // 使用事件委托，监听整个动态列表的“焦点移出”事件
    document.getElementById('qzone-posts-list').addEventListener('focusout', (e) => {
        // 如果是评论输入框失去了焦点
        if (e.target.classList.contains('comment-input')) {
            const commentInput = e.target;
            // 并且输入框是空的
            if (commentInput.value.trim() === '') {
                // 就重置它的状态，取消回复
                commentInput.placeholder = '友善的评论是交流的起点';
                delete commentInput.dataset.replyTo;
            }
        }
    });
    // ▲▲▲ 步骤3.3粘贴结束 ▲▲▲
// ▼▼▼ 把这一整块代码，粘贴到 init(); 的正上方 ▼▼▼
// 【全新】为时间感知开关添加实时交互事件
document.getElementById('time-perception-toggle').addEventListener('change', (e) => {
    const customTimeContainer = document.getElementById('custom-time-container');
    customTimeContainer.style.display = e.target.checked ? 'none' : 'block';
});
// ▲▲▲ 粘贴结束 ▲▲▲
// 请用这段新代码替换上面的错误代码
document.getElementById('char-heart-btn').addEventListener('click', openInnerVoiceModal);

document.getElementById('close-inner-voice-modal').addEventListener('click', () => {
    document.getElementById('inner-voice-modal').classList.remove('visible');
});
document.getElementById('inner-voice-history-btn').addEventListener('click', toggleInnerVoiceHistory);
document.getElementById('back-from-history-btn').addEventListener('click', toggleInnerVoiceHistory);
// ▲▲▲ 心声功能事件监听器结束 ▲▲▲
// ▼▼▼ 把下面这一整块新函数，粘贴到你的JS功能函数定义区 ▼▼▼

/**
 * 【全新】导出当前角色的聊天记录
 */
async function exportChatHistory() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    // 1. 创建一个只包含聊天记录和角色名的对象
    const exportData = {
        characterName: chat.name,
        exportedAt: new Date().toISOString(),
        history: chat.history
    };

    // 2. 将这个对象转换为格式化的JSON字符串
    const jsonString = JSON.stringify(exportData, null, 2);
    
    // 3. 创建一个Blob对象
    const blob = new Blob([jsonString], { type: 'application/json' });
    
    // 4. 创建一个临时的下载链接
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    
    // 5. 设置下载链接的属性，包括文件名
    const dateStr = new Date().toISOString().split('T')[0];
    link.href = url;
    link.download = `[${chat.name}]-聊天记录-${dateStr}.json`;
    
    // 6. 模拟点击链接来触发下载
    document.body.appendChild(link);
    link.click();
    
    // 7. 清理临时创建的元素和URL
    document.body.removeChild(link);
    URL.revokeObjectURL(url);

    await showCustomAlert('导出成功', `与“${chat.name}”的聊天记录已开始下载！`);
}

/**
 * 【全新】导入聊天记录到当前角色
 */
async function importChatHistory(file) {
    if (!file) return;
    if (!state.activeChatId) return;
    
    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const data = JSON.parse(e.target.result);

            // 关键验证：检查导入的文件是否包含一个名为 'history' 的数组
            if (!data.history || !Array.isArray(data.history)) {
                throw new Error("文件格式不正确，缺少有效的'history'数据。");
            }

            const chat = state.chats[state.activeChatId];
            
            // 安全警告：提醒用户这将覆盖现有记录
            const confirmed = await showCustomConfirm(
                '确认导入',
                `这将会【覆盖】你与“${chat.name}”的当前所有聊天记录。此操作无法撤销，确定要继续吗？`,
                { confirmButtonClass: 'btn-danger' }
            );

            if (confirmed) {
                // 替换历史记录
                chat.history = data.history;
                // 保存到数据库
                await db.chats.put(chat);
                // 刷新界面
                renderChatInterface(state.activeChatId);
                renderChatList(); // 刷新列表以更新最后一条消息
                await showCustomAlert('导入成功', '聊天记录已成功导入并覆盖！');
            }
        } catch (error) {
            console.error("导入聊天记录失败:", error);
            await showCustomAlert('导入失败', `无法导入文件，请检查文件是否为正确的聊天记录备份文件。\n\n错误: ${error.message}`);
        }
    };
    reader.readAsText(file, 'UTF-8');
}

// ▲▲▲ 新函数粘贴结束 ▲▲▲
// ▼▼▼ 【全新】气泡样式预设导入/导出功能 ▼▼▼

/**
 * 导出当前选中的气泡样式预设
 */
async function exportSelectedBubblePreset() {
    const selectEl = document.getElementById('bubble-style-preset-select');
    const selectedId = parseInt(selectEl.value);

    if (!selectedId) {
        alert("请先从下拉框中选择一个要导出的预设。");
        return;
    }

    const preset = await db.bubbleStylePresets.get(selectedId);
    if (!preset) {
        alert("找不到选中的预设。");
        return;
    }

    // 准备要导出的数据
    const exportData = {
        presetName: preset.name,
        presetCss: preset.css
    };

    // 创建并触发下载
    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `[EPhone气泡]${preset.name}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

/**
 * 处理导入的气泡样式预设文件
 * @param {File} file - 用户选择的.json文件
 */
function importBubblePreset(file) {
    if (!file) return;
    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const data = JSON.parse(e.target.result);
            // 验证文件内容是否正确
            if (data.presetName && typeof data.presetCss !== 'undefined') {
                const newPreset = {
                    name: `${data.presetName} (导入)`,
                    css: data.presetCss
                };
                const newId = await db.bubbleStylePresets.add(newPreset);

                if (!state.bubbleStylePresets) state.bubbleStylePresets = [];
                state.bubbleStylePresets.push({ id: newId, ...newPreset });

                // 刷新下拉框并自动选中新导入的预设
                renderBubblePresetSelector();
                document.getElementById('bubble-style-preset-select').value = newId;
                handlePresetSelectChange();
                await showCustomAlert('导入成功', `气泡预设 "${newPreset.name}" 已成功导入！`);
            } else {
                alert("导入失败：文件格式不正确。");
            }
        } catch (error) {
            alert(`导入失败：文件解析错误。 ${error.message}`);
        }
    };
    reader.readAsText(file);
}

// ▲▲▲ 新增功能函数结束 ▲▲▲

// ▼▼▼ 用这【一整块】代码，替换掉所有旧的、和微博相关的事件监听器 ▼▼▼

// ▼▼▼ 请用下面这【一整块】代码，完整替换掉上面那段旧代码 ▼▼▼
document.getElementById('weibo-app-icon').addEventListener('click', () => {
    renderWeiboProfile(); // 渲染个人资料
    renderMyWeiboFeed(); // <-- 就是新增了这一行！主动渲染“我的微博”列表
    switchToWeiboView('weibo-my-profile-view'); // 默认显示“我的微博”
    showScreen('weibo-screen');
});
// ▲▲▲ 替换结束 ▲▲▲


// 2. 绑定微博页面内的各种点击事件 (使用事件委托)
document.getElementById('weibo-screen').addEventListener('click', async (e) => {
    // --- 【全新】处理微博帖子中头像点击的逻辑 ---
    const avatarWrapper = e.target.closest('.weibo-post-avatar-clickable');
    if (avatarWrapper) {
        const charId = avatarWrapper.dataset.charId;
        // 如果点击的不是用户自己，就打开TA的主页
        if (charId && charId !== 'user') {
            openWeiboCharProfile(charId);
        }
        return; // 处理完就结束，不再执行后面的逻辑
    }
    
    // ▲▲▲ 新代码粘贴结束 ▲▲▲
    const target = e.target;
// ▼▼▼ 在这里粘贴新代码 ▼▼▼
            // ▼▼▼ 在 'const target = e.target;' 的下一行，粘贴下面这整块新代码 ▼▼▼

            // --- 【全新】处理热搜和广场帖子的删除按钮 ---
            const deleteBtn = target.closest('.weibo-post-delete-btn');
            if (deleteBtn) {
                const postItem = deleteBtn.closest('.weibo-post-item');
                if (postItem) {
                    // 先给用户一个确认的机会，防止误删
                    const confirmed = await showCustomConfirm(
                        '删除动态',
                        '确定要删除这条动态吗？（此操作仅在本页面生效）',
                        { confirmButtonClass: 'btn-danger' }
                    );
                    
                    if (confirmed) {
                        // 如果用户确认，就播放一个好看的消失动画，然后移除帖子
                        postItem.style.transition = 'opacity 0.3s, transform 0.3s';
                        postItem.style.opacity = '0';
                        postItem.style.transform = 'scale(0.95)';
                        setTimeout(() => {
                            postItem.remove();
                        }, 300); // 等动画播放完再彻底删除
                    }
                }
                return; // ★★★ 关键！处理完删除后，必须立刻结束，防止触发下面的其他点击事件
            }
            
            // ▲▲▲ 新代码粘贴结束 ▲▲▲
// 【核心修复】处理微博中的“文字图”点击事件
if (target.classList.contains('weibo-post-image') && target.dataset.hiddenText) {
    showCustomAlert("图片内容", target.dataset.hiddenText.replace(/<br>/g, '\n'));
    return; // 处理完后，立刻退出，避免触发其他逻辑
}
// ▲▲▲ 新代码粘贴结束 ▲▲▲

    const postItem = target.closest('.weibo-post-item');
    const postId = postItem ? parseInt(postItem.dataset.postId) : null;

    // --- 处理“删除评论”按钮 ---
    const deleteCommentBtn = target.closest('.comment-delete-btn');
    if (deleteCommentBtn) {
        const commentItem = deleteCommentBtn.closest('.weibo-comment-item');
        if (postId && commentItem && commentItem.dataset.commentId) {
            deleteWeiboComment(postId, commentItem.dataset.commentId);
        }
        return;
    }

    // --- 处理“生成评论”按钮 ---
    const generateBtn = target.closest('.generate-comments-btn');
    if (generateBtn) {
        if (postId) {
            generateWeiboComments(postId);
        }
        return; 
    }

    // --- 处理底部导航栏切换 ---
    const navItem = target.closest('.weibo-nav-item');
    if (navItem && navItem.dataset.view) {
        switchToWeiboView(navItem.dataset.view);
        return;
    }

// ▼▼▼ 用这块新代码替换 ▼▼▼

            const actionsBtn = target.closest('.post-actions-btn');
            if (actionsBtn) {
                // 核心修正1：从按钮本身获取正确的 postId
                const postId = parseInt(actionsBtn.dataset.postId);

                const confirmed = await showCustomConfirm('删除微博', '确定要永久删除这条微博吗？此操作不可恢复。', { confirmButtonClass: 'btn-danger' });
                
                // 核心修正2：检查 postId 是否是一个有效的数字
                if (confirmed && !isNaN(postId)) { 
                    await db.weiboPosts.delete(postId);
                    // 删除后，刷新所有相关的微博列表和个人资料
                    await renderMyWeiboFeed(); 
                    await renderFollowingWeiboFeed();
                    await renderWeiboProfile();
                    alert('微博已删除。');
                }
                return;
            }

// ▲▲▲ 替换结束 ▲▲▲

    
    // --- 处理点赞、评论、回复 ---
    if (target.closest('.like-btn')) { if (postId) handleWeiboLike(postId); return; }
    if (target.closest('.weibo-comment-send-btn')) { const input = postItem.querySelector('.weibo-comment-input'); if (postId && input) handleWeiboComment(postId, input); return; }
    
    const commentItem = target.closest('.weibo-comment-item');
    if (commentItem) {
        const commenterName = commentItem.dataset.commenterName;
        const commentId = commentItem.dataset.commentId;
        const input = postItem.querySelector('.weibo-comment-input');
        if (input.dataset.replyToId === commentId) {
            input.placeholder = '留下你的精彩评论吧...';
            delete input.dataset.replyToId; delete input.dataset.replyToNickname;
        } else {
            input.placeholder = `回复 @${commenterName}:`;
            input.dataset.replyToId = commentId; input.dataset.replyToNickname = commenterName;
            input.focus();
        }
        return;
    }
});

// 3. 【核心】为微博个人主页的所有可编辑元素，绑定专属的编辑函数
// ▼▼▼ 用这块【功能增强版】的代码，替换旧的 weibo-profile-page 事件监听器 ▼▼▼
document.getElementById('weibo-profile-page').addEventListener('click', async (e) => {
    const target = e.target;
    
    // --- ▼▼▼ 核心修改在这里 ▼▼▼ ---
    if (target.id === 'weibo-avatar-img' || target.closest('.weibo-avatar-container')) {
        // 1. 弹出一个选择菜单，让用户决定是换头像还是换框
        const choice = await showChoiceModal("编辑头像", [
            { text: '更换头像图片', value: 'avatar' },
            { text: '更换头像框', value: 'frame' }
        ]);
        
        // 2. 根据用户的选择，执行不同的操作
        if (choice === 'avatar') {
            editWeiboAvatar(); // 调用原来的更换头像函数
        } else if (choice === 'frame') {
            openFrameSelectorModal('weibo_profile'); // 调用我们新增的更换头像框函数
        }
        return; // 处理完后直接退出
    } 
    // --- ▲▲▲ 修改结束 ▲▲▲

    else if (target.id === 'weibo-nickname') {
        editWeiboNickname();
    } 
    else if (target.id === 'weibo-user-profession-display') {
        openWeiboUserSettingsModal();
    } 
    else if (target.id === 'weibo-background-img') {
        editWeiboBackground();
    } else if (target.closest('#weibo-fans-item')) {
        editWeiboFansCount();
    }
});
// ▲▲▲ 替换结束 ▲▲▲

// 4. 【核心】为“关注”数字和“发布微博”按钮绑定事件
document.getElementById('weibo-following-btn').addEventListener('click', showFollowingList);
document.getElementById('create-weibo-post-btn').addEventListener('click', openWeiboPublisherClean);
document.getElementById('close-following-list-btn').addEventListener('click', () => {
    document.getElementById('weibo-following-modal').classList.remove('visible');
});
document.getElementById('clear-following-feed-btn').addEventListener('click', clearFollowingFeed);

// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 用这块【已隐藏可见范围】的代码，替换旧的 openWeiboPublisherClean 函数 ▼▼▼
function openWeiboPublisherClean() {
    // 1. 重置并获取模态框
    resetCreatePostModal(); 
    const modal = document.getElementById('create-post-modal');
    
    // 2. 设置为“微博”模式，并修改标题和提示语
    modal.dataset.mode = 'weibo';
    document.getElementById('create-post-modal-title').textContent = '发微博';
    document.getElementById('post-public-text').placeholder = '有什么新鲜事想分享给大家？';

    // 3. 确保所有“动态”专属的HTML元素都被隐藏
    const imageDescGroup = document.getElementById('post-image-desc-group');
    if (imageDescGroup) imageDescGroup.style.display = 'none';
    
    const commentsToggleGroup = document.getElementById('post-comments-toggle-group');
    if (commentsToggleGroup) commentsToggleGroup.style.display = 'none';

    // ▼▼▼ 就是在这里新增了一行代码！▼▼▼
    const visibilityGroup = document.getElementById('post-visibility-group');
    if (visibilityGroup) visibilityGroup.style.display = 'none';
    // ▲▲▲ 新增结束 ▲▲▲

    // 4. 显示微博需要的控件
    const modeSwitcher = document.getElementById('post-mode-switcher');
    if (modeSwitcher) modeSwitcher.style.display = 'flex';
    
    // 5. 显示弹窗
    modal.classList.add('visible');
}
// ▲▲▲ 替换结束 ▲▲▲


document.getElementById('close-following-list-btn').addEventListener('click', () => {
    document.getElementById('weibo-following-modal').classList.remove('visible');
});
document.getElementById('clear-following-feed-btn').addEventListener('click', clearFollowingFeed);

// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 用这块【已修复】的代码，完整替换掉你旧的 `editWeiboProfileBtn` 事件监听器 ▼▼▼
    // 【全新】微博用户人设设置功能事件绑定
    document.getElementById('edit-weibo-profile-btn').addEventListener('click', openWeiboUserSettingsModal);
    document.getElementById('cancel-weibo-user-settings-btn').addEventListener('click', () => {
        document.getElementById('weibo-user-settings-modal').classList.remove('visible');
    });
    document.getElementById('save-weibo-user-settings-btn').addEventListener('click', saveWeiboUserSettings);
    document.getElementById('weibo-user-preset-select').addEventListener('change', handleWeiboUserPresetSelection);
    document.getElementById('manage-weibo-user-presets-btn').addEventListener('click', openWeiboUserPresetManager);
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 【全新】论坛功能事件监听器 ▼▼▼

// 1. 初始化时创建默认小组
await initializeDefaultGroups();

// 2. 当用户点击“圈子”App图标时，渲染小组列表
document.querySelector('.desktop-app-icon[onclick="showScreen(\'forum-screen\')"]').addEventListener('click', renderForumScreen);

// 3. 绑定小组页和帖子页的返回按钮
document.getElementById('back-to-forum-list').addEventListener('click', () => showScreen('forum-screen'));
document.getElementById('back-to-group-screen').addEventListener('click', () => openGroup(activeGroupId, document.getElementById('group-screen-title').textContent));

// 4. 绑定帖子评论区的发送按钮
document.getElementById('send-post-comment-btn').addEventListener('click', handleAddComment);

// 这是【修复后】的代码
document.getElementById('trigger-fanfic-generation-btn').addEventListener('click', () => {
    // 核心修改：使用箭头函数，在点击时获取并传入当前的 activeGroupId
    generateFanfic(activeGroupId);
});


// 绑定所有小组头部通用的“生成”按钮
document.getElementById('generate-group-content-btn').addEventListener('click', handleGenerateGroupContent);
// ▲▲▲ 替换结束 ▲▲▲


// 6. 绑定帖子详情页的“转载”按钮
document.getElementById('repost-to-chat-btn').addEventListener('click', repostToChat);

// ▼▼▼ 在 init() 函数中，用【这一行】替换旧的 create-group-btn 监听器 ▼▼▼
document.getElementById('create-group-btn').addEventListener('click', openGroupCreator);
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 用这块新代码替换 ▼▼▼
document.getElementById('create-forum-post-btn').addEventListener('click', () => {
    // 【核心修改】我们不再弹窗提示，而是调用一个新函数来打开真正的发帖窗口
    openCreateForumPostModal(); 
});
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 在 init() 的事件监听器区域，粘贴下面这块【新代码】 ▼▼▼

// 使用事件委托，为帖子详情页的“生成评论”按钮绑定事件
document.getElementById('post-detail-content').addEventListener('click', (e) => {
    if (e.target.id === 'generate-forum-comments-btn') {
        generateForumComments();
    }
});

// 在用户手动输入评论后，如果输入框为空就失去焦点时，自动取消回复状态
document.getElementById('post-comment-input').addEventListener('blur', (e) => {
    const input = e.target;
    if (input.value.trim() === '') {
        input.placeholder = '发布你的评论...';
        delete input.dataset.replyTo;
    }
});
// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 在 init() 函数的事件监听器区域末尾，粘贴下面这整块新代码 ▼▼▼

// 使用事件委托，为所有转载的帖子卡片添加点击事件
document.getElementById('chat-messages').addEventListener('click', (e) => {
    const repostCard = e.target.closest('.link-share-card[data-post-id]');
    if (repostCard) {
        const postId = parseInt(repostCard.dataset.postId);
        if (!isNaN(postId)) {
            // 调用你已经写好的“打开帖子”函数
            openPost(postId);
        }
    }
});

// ▲▲▲ 新增代码结束 ▲▲▲
// ▼▼▼ 【全新】论坛帖子列表事件委托 ▼▼▼
document.getElementById('group-post-list').addEventListener('click', async (e) => {
    const postItem = e.target.closest('.forum-post-item');
    if (!postItem) return;

    // 检查点击的是否是删除按钮
    if (e.target.classList.contains('forum-post-delete-btn')) {
        const postId = postItem.dataset.postId;
        if (!postId) return;
        
        const post = await db.forumPosts.get(parseInt(postId));
        if (!post) return;

        const confirmed = await showCustomConfirm(
            '删除帖子', 
            `确定要删除帖子《${post.title}》吗？此操作将同时删除帖子下的所有评论，且无法恢复。`, 
            { confirmButtonClass: 'btn-danger' }
        );

        if (confirmed) {
            try {
                // 使用数据库事务来确保帖子和评论被同时删除
                await db.transaction('rw', db.forumPosts, db.forumComments, async () => {
                    // 1. 删除所有与该帖子关联的评论
                    await db.forumComments.where('postId').equals(parseInt(postId)).delete();
                    // 2. 删除帖子本身
                    await db.forumPosts.delete(parseInt(postId));
                });

                await showCustomAlert('删除成功', '帖子及其所有评论已被删除。');
                // 刷新帖子列表
                await renderGroupPosts(activeGroupId);
            } catch (error) {
                console.error('删除帖子失败:', error);
                await showCustomAlert('删除失败', `操作失败: ${error.message}`);
            }
        }
    } else {
        // 如果点击的不是删除按钮，那就是点击了帖子本身，执行跳转逻辑
        const postId = postItem.dataset.postId;
        if (postId) {
            openPost(parseInt(postId));
        }
    }
});
// ▲▲▲ 新事件监听器结束 ▲▲▲
// ▼▼▼ 【全新】圈子/小组高级功能事件监听 ▼▼▼

// 1. 为“圈子”主页右上角的“+”按钮，绑定创建小组的事件
document.getElementById('create-group-btn').addEventListener('click', openGroupCreator);

// 2. 为小组编辑器弹窗的“保存”和“取消”按钮绑定事件
document.getElementById('save-group-editor-btn').addEventListener('click', saveGroupSettings);
document.getElementById('cancel-group-editor-btn').addEventListener('click', () => {
    document.getElementById('forum-group-editor-modal').classList.remove('visible');
});

// 3. 为分类管理弹窗的按钮绑定事件
document.getElementById('add-new-forum-category-btn').addEventListener('click', addNewForumCategory);
document.getElementById('close-forum-category-manager-btn').addEventListener('click', () => {
    document.getElementById('forum-category-manager-modal').classList.remove('visible');
});

// 4. 使用事件委托，为分类列表中的“删除”按钮绑定事件
document.getElementById('existing-forum-categories-list').addEventListener('click', (e) => {
    if (e.target.classList.contains('delete-group-btn')) { // 复用样式
        const categoryId = parseInt(e.target.dataset.id);
        deleteForumCategory(categoryId);
    }
});
// ▲▲▲ 新增事件监听结束 ▲▲▲


// ▲▲▲ 论坛事件监听器结束 ▲▲▲
// ▼▼▼ 把这一整块全新的事件监听器代码，粘贴到 init() 函数的末尾，就在 init(); 的正上方 ▼▼▼

// --- 塔罗牌占卜功能事件绑定 ---
document.getElementById('open-tarot-btn').addEventListener('click', openTarotModal);
document.getElementById('close-tarot-modal-btn').addEventListener('click', () => {
    document.getElementById('tarot-divination-modal').classList.remove('visible');
});
document.getElementById('draw-tarot-cards-btn').addEventListener('click', handleDrawCards);
document.getElementById('back-to-tarot-setup-btn').addEventListener('click', () => {
    document.getElementById('tarot-result-view').style.display = 'none';
    document.getElementById('tarot-setup-view').style.display = 'block';
});
document.getElementById('send-tarot-result-btn').addEventListener('click', sendTarotReadingToChat);
document.getElementById('tarot-history-btn').addEventListener('click', openTarotHistory);
document.getElementById('back-to-tarot-main-btn').addEventListener('click', () => {
    document.getElementById('tarot-history-view').style.display = 'none';
    document.getElementById('tarot-setup-view').style.display = 'block';
});
// 使用事件委托处理历史记录的删除按钮
document.getElementById('tarot-history-list').addEventListener('click', (e) => {
    if (e.target.classList.contains('tarot-history-delete-btn')) {
        const readingId = parseInt(e.target.dataset.id);
        if (!isNaN(readingId)) {
            deleteTarotReading(readingId);
        }
    }
});

// --- 塔罗牌占卜功能事件绑定结束 ---

// ▲▲▲ 粘贴结束 ▲▲▲
// ▼▼▼ 【全新】情侣空间功能事件监听器 ▼▼▼
// ▼▼▼ 第3步.3：在这里粘贴新代码 ▼▼▼
document.getElementById('ls-change-bg-btn').addEventListener('click', handleChangeLoversSpaceBackground);
// ▲▲▲ 新代码粘贴结束 ▲▲▲

// 绑定主屏幕App图标的点击事件
document.getElementById('lovers-space-app-icon').addEventListener('click', openLoversSpaceEntry);

// ▼▼▼ 用这块代码替换 ▼▼▼
document.getElementById('ls-char-selector-list').addEventListener('click', async (e) => {
    const item = e.target.closest('.chat-list-item');
    if (item && item.dataset.chatId) {
        const chatId = item.dataset.chatId;
        const chat = state.chats[chatId];
        
        // 关闭选择弹窗
        document.getElementById('ls-char-selector-modal').classList.remove('visible');
        
        // 【核心逻辑】判断情侣空间状态
        if (chat.loversSpaceData) {
            // 如果已开通，直接进入
            openLoversSpace(chatId);
        } else {
            // 如果未开通，弹窗确认是否发送邀请
            const confirmed = await showCustomConfirm(
                '邀请开启情侣空间',
                `你和“${chat.name}”的情侣空间还未开启，要现在邀请Ta吗？`
            );
            if (confirmed) {
                // 如果用户确认，发送邀请并跳转到聊天界面
                await sendLoversSpaceInvitation(chatId);
                openChat(chatId);
            }
        }
    }
});
// ▲▲▲ 替换结束 ▲▲▲

document.getElementById('ls-cancel-switch-char-btn').addEventListener('click', () => {
    document.getElementById('ls-char-selector-modal').classList.remove('visible');
});
document.getElementById('ls-switch-char-btn').addEventListener('click', openCharSelectorForLoversSpace);

// ▼▼▼ 用这块【修复后】的代码，完整替换旧的 'ls-tab-bar' 事件监听器 ▼▼▼
// 绑定页签切换事件
document.getElementById('ls-tab-bar').addEventListener('click', (e) => {
    const tab = e.target.closest('.ls-tab-item');
    if (tab && tab.dataset.view) {
        const viewId = tab.dataset.view;
        // 1. 切换高亮和视图
        document.querySelectorAll('.ls-tab-item').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        switchLoversSpaceTab(viewId);

        // 2. 【核心修复】根据点击的页签，渲染对应的内容
        const chat = state.chats[activeLoversSpaceCharId];
        if (!chat) return;

        if (viewId === 'ls-moments-view') {
            renderLSMoments(chat.loversSpaceData.moments, chat);
        } else if (viewId === 'ls-album-view') {
            renderLSPhotos(chat.loversSpaceData.photos, chat);
        } else if (viewId === 'ls-letters-view') {
            renderLSLetters(chat.loversSpaceData.loveLetters, chat);
        } else if (viewId === 'ls-questions-view') {
            // 这就是我们新增的逻辑！
            renderLSQuestions(chat.loversSpaceData.questions, chat);    
        }
        else if (viewId === 'ls-diary-view') {
    const now = new Date();
    renderLSDiaryView(now.getFullYear(), now.getMonth() + 1);
}
    else if (viewId === 'ls-shares-view') {
        renderLSShares(chat.loversSpaceData.shares, chat);
    }
    // ▼▼▼ 在这里添加下面这3行新代码 ▼▼▼
    else if (viewId === 'ls-pomodoro-view') {
        openPomodoroScreen();
    }
    }
});
// ▲▲▲ 替换结束 ▲▲▲


// 绑定“说说”功能的按钮
document.getElementById('ls-add-moment-btn').addEventListener('click', openMomentCreator);
document.getElementById('ls-cancel-moment-btn').addEventListener('click', () => {
    document.getElementById('ls-create-moment-modal').classList.remove('visible');
});
document.getElementById('ls-confirm-moment-btn').addEventListener('click', handlePostMoment);

// 绑定“相册”功能的按钮
document.getElementById('ls-add-album-btn').addEventListener('click', openAlbumCreator);
document.getElementById('ls-select-photos-btn').addEventListener('click', () => {
    document.getElementById('ls-photo-input').click();
});
document.getElementById('ls-photo-input').addEventListener('change', (e) => {
    handlePhotoSelection(e.target.files);
});
// 绑定新弹窗里的模式切换按钮
const lsImageModeBtn = document.getElementById('ls-switch-to-image-mode');
const lsTextImageModeBtn = document.getElementById('ls-switch-to-text-image-mode');
const lsImageModeContent = document.getElementById('ls-image-mode-content');
const lsTextImageModeContent = document.getElementById('ls-text-image-mode-content');
// ▼▼▼ 用这块【已修复】的代码，替换掉上面那段错误的代码 ▼▼▼
lsImageModeBtn.addEventListener('click', () => {
    lsImageModeBtn.classList.add('active');
    lsTextImageModeBtn.classList.remove('active');
    // 新增下面这两行，这才是关键！
    lsImageModeContent.classList.add('active');
    lsTextImageModeContent.classList.remove('active');
    // 旧的样式控制也保留，确保万无一失
    lsImageModeContent.style.display = 'block';
    lsTextImageModeContent.style.display = 'none';
});

lsTextImageModeBtn.addEventListener('click', () => {
    lsTextImageModeBtn.classList.add('active');
    lsImageModeBtn.classList.remove('active');
    // 新增下面这两行，这才是关键！
    lsTextImageModeContent.classList.add('active');
    lsImageModeContent.classList.remove('active');
    // 旧的样式控制也保留，确保万无一失
    lsTextImageModeContent.style.display = 'block';
    lsImageModeContent.style.display = 'none';
});
// ▲▲▲ 替换结束 ▲▲▲

 document.getElementById('ls-cancel-album-btn').addEventListener('click', () => {
    document.getElementById('ls-create-album-modal').classList.remove('visible');
});
 document.getElementById('ls-confirm-album-btn').addEventListener('click', handleConfirmAlbum);
// ▼▼▼ 【全新】情侣空间设置功能事件监听 ▼▼▼
document.getElementById('ls-settings-btn').addEventListener('click', () => {
    const chat = state.chats[activeLoversSpaceCharId];
    if (chat && chat.loversSpaceData) {
        // 将已保存的日期加载到输入框中
        document.getElementById('ls-start-date-input').value = chat.loversSpaceData.relationshipStartDate || '';
    }
    document.getElementById('ls-settings-modal').classList.add('visible');
});

document.getElementById('ls-settings-cancel-btn').addEventListener('click', () => {
    document.getElementById('ls-settings-modal').classList.remove('visible');
});

document.getElementById('ls-settings-save-btn').addEventListener('click', async () => {
    const chat = state.chats[activeLoversSpaceCharId];
    if (!chat) return;

    const newDate = document.getElementById('ls-start-date-input').value;
    chat.loversSpaceData.relationshipStartDate = newDate;
    
    await db.chats.put(chat); // 保存到数据库
    
    // 重新渲染整个空间以显示更新
    await renderLoversSpace(chat);

    document.getElementById('ls-settings-modal').classList.remove('visible');
    alert('纪念日已保存！');
});
// ▲▲▲ 事件监听结束 ▲▲▲
// ▼▼▼ 把这段新代码粘贴到 init() 的事件监听器区域 ▼▼▼

// 【情侣空间相册】事件监听
document.getElementById('ls-album-list').addEventListener('click', (e) => {
    const item = e.target.closest('.ls-album-item');
    if (!item) return;

    const timestamp = parseInt(item.dataset.timestamp);
    if (isNaN(timestamp)) return;
    
    // 检查点击的是否是删除按钮
    if (e.target.classList.contains('ls-photo-delete-btn')) {
        handleDeleteLSPhoto(timestamp);
    } else {
        // 否则，就是点击了图片本身，执行查看描述的逻辑
        const chat = state.chats[activeLoversSpaceCharId];
        if (chat && chat.loversSpaceData && chat.loversSpaceData.photos) {
            const photo = chat.loversSpaceData.photos.find(p => p.timestamp === timestamp);
            if (photo) {
                showCustomAlert(`照片描述 (${formatPostTimestamp(photo.timestamp)})`, photo.description);
            }
        }
    }
});
// ▲▲▲ 事件监听结束 ▲▲▲
// ▼▼▼ 【全新】情侣空间说说互动功能事件监听 ▼▼▼
document.getElementById('ls-moments-list').addEventListener('click', async (e) => {
    const target = e.target;
    const momentCard = target.closest('.ls-moment-card');
    if (!momentCard) return;

    // 1. 【核心】从被点击的卡片上获取正确的索引
    const momentIndex = parseInt(momentCard.dataset.momentIndex);
    const chat = state.chats[activeLoversSpaceCharId];
    // 安全检查，确保能找到对应的数据
    if (!chat || !chat.loversSpaceData || !chat.loversSpaceData.moments[momentIndex]) return;
    
    const moment = chat.loversSpaceData.moments[momentIndex];

    // --- 处理“发送评论”按钮 ---
    if (target.classList.contains('ls-comment-send-btn')) {
        const input = momentCard.querySelector('.ls-comment-input-area input');
        const commentText = input.value.trim();
        if (!commentText) {
            alert("评论内容不能为空！");
            return;
        }

        const newComment = {
            author: chat.settings.myNickname || '我',
            text: commentText
        };
        
        if (!moment.comments) {
            moment.comments = [];
        }
        moment.comments.push(newComment);
        
        await db.chats.put(chat); // 保存到数据库
        renderLSMoments(chat.loversSpaceData.moments, chat); // 刷新界面
    }

    // --- 2. 【核心】处理“删除说说”按钮 ---
    if (target.classList.contains('ls-moment-delete-btn')) {
        const confirmed = await showCustomConfirm('删除说说', '确定要删除这条说说吗？', { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            // 2. 【核心】使用我们刚刚获取的、绝对正确的 momentIndex 来删除数组中的元素
            chat.loversSpaceData.moments.splice(momentIndex, 1);
            await db.chats.put(chat);
            renderLSMoments(chat.loversSpaceData.moments, chat);
        }
    }

    // --- 3. 处理“删除评论”按钮 ---
    if (target.classList.contains('ls-comment-delete-btn')) {
        const commentIndex = parseInt(target.dataset.commentIndex);
        const confirmed = await showCustomConfirm('删除评论', '确定要删除这条评论吗？', { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            moment.comments.splice(commentIndex, 1);
            await db.chats.put(chat);
            renderLSMoments(chat.loversSpaceData.moments, chat);
        }
    }
});

/* ▼▼▼ 把这一整块全新的事件监听器代码，粘贴到 // ▲▲▲ 情侣空间事件监听结束 ▲▲▲ 的正上方 ▼▼▼ */

// --- 【全新】情侣空间情书功能事件监听 ---

// 1. 绑定“写情书”的浮动按钮
document.getElementById('ls-add-letter-btn').addEventListener('click', () => openLoveLetterEditor());

// 2. 绑定写信弹窗的“取消”和“寄出”按钮
document.getElementById('ls-cancel-letter-btn').addEventListener('click', () => {
    document.getElementById('ls-create-letter-modal').classList.remove('visible');
});
document.getElementById('ls-confirm-letter-btn').addEventListener('click', handlePostLoveLetter);

// ▼▼▼ 用这块【功能更强大的】代码，完整替换旧的 ls-letters-list 事件监听器 ▼▼▼
// 使用事件委托，为情书列表中的所有卡片和按钮绑定点击事件
document.getElementById('ls-letters-list').addEventListener('click', async (e) => {
    const letterItem = e.target.closest('.ls-love-letter-item');
    if (!letterItem) return;

    // 检查点击的是否是删除按钮
    if (e.target.classList.contains('ls-letter-delete-btn')) {
        const letterId = letterItem.dataset.letterId;
        const chat = state.chats[activeLoversSpaceCharId];
        const letter = chat.loversSpaceData.loveLetters.find(l => l.id === letterId);
        
        const confirmed = await showCustomConfirm(
            '删除情书',
            `确定要删除这封写给“${letter.recipientName}”的情书吗？`,
            { confirmButtonClass: 'btn-danger' }
        );

        if (confirmed) {
            chat.loversSpaceData.loveLetters = chat.loversSpaceData.loveLetters.filter(l => l.id !== letterId);
            await db.chats.put(chat);
            renderLSLetters(chat.loversSpaceData.loveLetters, chat);
            alert('情书已删除。');
        }
    } 
    // 否则，就是点击了卡片本身，执行查看详情的逻辑
    else if (letterItem.dataset.letterId) {
        showLoveLetterDetail(letterItem.dataset.letterId);
    }
});
// ▲▲▲ 替换结束 ▲▲▲


/* ▲▲▲ 新增事件监听结束 ▲▲▲ */
/* ▼▼▼ 把这段新代码粘贴到 // ▲▲▲ 情侣空间事件监听结束 ▲▲▲ 的正上方 ▼▼▼ */

// --- 【全新】情书查看器按钮事件监听 ---
document.getElementById('ls-close-letter-viewer-btn').addEventListener('click', () => {
    document.getElementById('ls-letter-viewer-modal').classList.remove('visible');
    activeLoveLetter = null; // 关闭时清理暂存的数据
});

document.getElementById('ls-reply-letter-btn').addEventListener('click', () => {
    // 先关闭查看器
    document.getElementById('ls-letter-viewer-modal').classList.remove('visible');
    // 然后打开回复编辑器
    if (activeLoveLetter) {
        openLoveLetterEditor(activeLoveLetter);
    }
    activeLoveLetter = null; // 清理
});

/* ▲▲▲ 新增代码粘贴结束 ▲▲▲ */
// ▼▼▼ 把这一整块全新的事件监听器代码，粘贴到 // ▲▲▲ 情侣空间事件监听结束 ▲▲▲ 的正上方 ▼▼▼

/* --- 【全新】情侣空间-情侣提问功能事件监听 --- */

// 1. 绑定“提问”的浮动按钮
document.getElementById('ls-add-question-btn').addEventListener('click', openQuestionAsker);

// 2. 绑定提问弹窗的按钮
document.getElementById('ls-cancel-ask-btn').addEventListener('click', () => {
    document.getElementById('ls-ask-question-modal').classList.remove('visible');
});
document.getElementById('ls-confirm-ask-btn').addEventListener('click', handlePostQuestion);

// 3. 绑定回答弹窗的按钮
document.getElementById('ls-cancel-answer-btn').addEventListener('click', () => {
    document.getElementById('ls-answer-question-modal').classList.remove('visible');
});
document.getElementById('ls-confirm-answer-btn').addEventListener('click', handlePostAnswer);

// 4. 使用事件委托，为所有“回答”和“删除”按钮绑定点击事件
document.getElementById('ls-questions-list').addEventListener('click', (e) => {
    // 这是你已有的处理“回答”按钮的逻辑
    if (e.target.classList.contains('ls-answer-btn')) {
        const questionId = e.target.dataset.questionId;
        if (questionId) {
            openAnswerEditor(questionId);
        }
    }

    // ▼▼▼ 这是我们新加的处理“删除”按钮的逻辑 ▼▼▼
    if (e.target.classList.contains('ls-question-delete-btn')) {
        const questionId = e.target.dataset.questionId;
        if (questionId) {
            handleDeleteLSQuestion(questionId);
        }
    }
    // ▲▲▲ 新增逻辑结束 ▲▲▲
});


/* --- 情侣提问事件监听结束 --- */

// ▼▼▼ 【全新】情侣空间专属播放器事件监听器 ▼▼▼

// 1. 监听主播放器内的所有按钮
document.getElementById('ls-close-player-btn').addEventListener('click', () => {
    document.getElementById('ls-music-player-overlay').classList.remove('visible');
});
document.getElementById('ls-playlist-btn').addEventListener('click', () => {
    renderLSMusicPlaylist();
    document.getElementById('ls-music-playlist-panel').classList.add('visible');
});
document.getElementById('ls-play-pause-btn').addEventListener('click', toggleLSMusicPlayPause);
document.getElementById('ls-next-btn').addEventListener('click', playNextLSSong);
document.getElementById('ls-prev-btn').addEventListener('click', playPrevLSSong);

// 2. 监听播放列表面板内的所有按钮
document.getElementById('ls-close-playlist-btn').addEventListener('click', () => {
    document.getElementById('ls-music-playlist-panel').classList.remove('visible');
});
document.getElementById('ls-clear-playlist-btn').addEventListener('click', async () => {
    const confirmed = await showCustomConfirm('清空列表', '确定要清空情侣空间的播放列表吗？', { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        clearLSMusicPlaylist();
    }
});
document.getElementById('ls-playlist-body').addEventListener('click', (e) => {
    if (e.target.classList.contains('delete-track-btn')) {
        const index = parseInt(e.target.dataset.index);
        lsMusicState.playlist.splice(index, 1);
        
        // 如果删除的是正在播放的歌曲
        if (index === lsMusicState.currentIndex) {
            playNextLSSong();
        } else if (index < lsMusicState.currentIndex) {
            lsMusicState.currentIndex--; // 修正索引
        }
        renderLSMusicPlaylist();
    }
});

// 3. 监听音频播放器的状态
const lsAudioPlayer = document.getElementById('ls-audio-player');
lsAudioPlayer.addEventListener('timeupdate', updateLSProgressBar);
lsAudioPlayer.addEventListener('ended', playNextLSSong);
lsAudioPlayer.addEventListener('play', () => {
    lsMusicState.isPlaying = true;
    renderLSMusicPlayerUI();
});
lsAudioPlayer.addEventListener('pause', () => {
    lsMusicState.isPlaying = false;
    renderLSMusicPlayerUI();
});

// 4. 监听进度条的点击
document.getElementById('ls-progress-bar').addEventListener('click', (e) => {
    if (!lsAudioPlayer.duration) return;
    const progressBar = e.currentTarget;
    const barWidth = progressBar.clientWidth;
    const clickX = e.offsetX;
    lsAudioPlayer.currentTime = (clickX / barWidth) * lsAudioPlayer.duration;
});

// 5. 【核心】拦截情侣空间分享列表的点击事件，不再触发“一起听”
document.getElementById('ls-shares-list').addEventListener('click', async (e) => {
    const item = e.target.closest('.ls-share-item');
    if (!item || !item.dataset.shareData) return;

    const shareData = JSON.parse(item.dataset.shareData);

    // 如果是歌曲，就调用我们新的播放器函数！
    if (shareData.shareType === 'song') {
        openLoversSpaceMusicPlayer(shareData);
    } 
    // 其他类型的分享，保持原来的逻辑
    else if (shareData.shareType === 'movie' || shareData.shareType === 'book') {
        await showCustomAlert(`分享详情 - ${shareData.title}`, shareData.thoughts || shareData.summary || '暂无简介');
    }
    // ▼▼▼ 在这里粘贴下面这块【全新】的代码 ▼▼▼
else if (shareData.shareType === 'game') {
    // 为游戏分享卡片构建一个更详细的弹窗内容
    const gameInfo = `游戏名：${shareData.title}\n\n简介：${shareData.summary || '暂无简介'}\n\nTa说：“${shareData.thoughts || '一起玩吧！'}”`;
    await showCustomAlert(`分享的游戏`, gameInfo);
}
});

// ▲▲▲ 新增事件监听结束 ▲▲▲
// ▼▼▼ 在 init() 的事件监听器区域末尾，粘贴这段新代码 ▼▼▼

// 【全新】情侣空间播放器封面/歌词切换事件
document.getElementById('ls-display-area').addEventListener('click', () => {
    document.getElementById('ls-display-area').classList.toggle('show-lyrics');
});

// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 在 init() 函数的末尾，粘贴这整块新代码 ▼▼▼

// ▼▼▼ 把这一整块全新的代码，粘贴到 init(); 的正上方 ▼▼▼

/* --- 【全新】情侣番茄钟事件监听器 --- */

// 1. 绑定“开启新的专注时光”按钮
document.getElementById('ls-pomodoro-start-btn-container').addEventListener('click', openPomodoroSetup);

// 2. 绑定设置弹窗的按钮
document.getElementById('pomodoro-cancel-setup-btn').addEventListener('click', () => {
    document.getElementById('ls-pomodoro-setup-modal').classList.remove('visible');
});
document.getElementById('pomodoro-confirm-setup-btn').addEventListener('click', startPomodoroSession);

// 3. 【核心】为我们新增的“本地上传”按钮绑定事件
document.getElementById('pomodoro-bg-local-upload-btn').addEventListener('click', () => {
    document.getElementById('pomodoro-bg-file-input').click();
});
document.getElementById('pomodoro-bg-file-input').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = (event) => {
            pomodoroState.tempBgDataUrl = event.target.result; // 将本地图片转为DataURL暂存起来
            document.getElementById('pomodoro-bg-url-input').value = `[本地图片: ${file.name}]`; // 在输入框里给个提示
        };
        reader.readAsDataURL(file);
    }
});

// 4. 绑定计时器界面上的元素
document.getElementById('pomodoro-char-avatar').addEventListener('click', () => {
    // 【核心修改】现在它会调用API来生成话语
    triggerPomodoroAIResponse('user_click');
});
document.getElementById('pomodoro-end-btn').addEventListener('click', () => {
    endPomodoroSession(false); // false表示是用户手动中断
});

// 5. 绑定历史详情弹窗的关闭按钮
document.getElementById('pomodoro-close-history-viewer-btn').addEventListener('click', () => {
    document.getElementById('ls-pomodoro-history-viewer-modal').classList.remove('visible');
});
// ▼▼▼ 【全新】这是为番茄钟计时模式新增的交互代码 ▼▼▼
document.querySelector('#ls-pomodoro-setup-modal').addEventListener('change', (e) => {
    if (e.target.name === 'pomodoro-mode') {
        const durationGroup = document.getElementById('pomodoro-duration-input').parentElement;
        if (e.target.value === 'countup') {
            // 如果选择正计时，就隐藏时长输入框
            durationGroup.style.display = 'none';
        } else {
            // 否则（选择倒计时），就显示它
            durationGroup.style.display = 'block';
        }
    }
});
// ▲▲▲ 新增代码结束 ▲▲▲

/* --- 番茄钟事件监听结束 --- */
// ▼▼▼ 在 init() 的事件监听器区域，粘贴这块新代码 ▼▼▼
// 【全新】处理情侣空间邀请卡片的点击事件
document.getElementById('chat-messages').addEventListener('click', async (e) => {
    const card = e.target.closest('.waimai-card');
    if (!card) return;
    const messageBubble = card.closest('.message-bubble');
    const invitationMsg = state.chats[state.activeChatId].history.find(m => m.timestamp === parseInt(messageBubble.dataset.timestamp));

    if (invitationMsg && invitationMsg.type === 'lovers_space_invitation' && invitationMsg.status === 'pending') {
        const choice = e.target.dataset.choice; // 'accepted' or 'rejected'
// ▼▼▼ 用这块【最终通知版】的代码，替换掉你旧的 if (choice) { ... } 代码块 ▼▼▼
if (choice) {
    // 1. 更新邀请卡片的状态
    invitationMsg.status = choice;
    const chat = state.chats[state.activeChatId];
    
    // 2. 判断用户的选择
    if (choice === 'accepted') {
        // 如果同意，创建情侣空间数据
        chat.loversSpaceData = {
            background: 'https://i.postimg.cc/k495F4W5/profile-banner.jpg',
            relationshipStartDate: null,
            moments: [], albums: [], photos: [], loveLetters: [], shares: [], questions: [],
        };
        
        // 创建对【用户可见】的系统通知
        const visibleNotice = {
            role: 'system',
            type: 'pat_message',
            content: `[系统：你和“${chat.name}”的情侣空间已成功开启！]`,
            timestamp: Date.now()
        };
        chat.history.push(visibleNotice);

        // 创建给【AI看】的隐藏指令
        const hiddenMessage = {
            role: 'system',
            content: `[系统指令：用户同意了你开启情侣空间的邀请。]`,
            timestamp: Date.now() + 1,
            isHidden: true
        };
        chat.history.push(hiddenMessage);
        
        await db.chats.put(chat);
        renderChatInterface(state.activeChatId);
        // (这里没有 triggerAiResponse()，AI不会回应)

    } else { // 如果拒绝 (choice === 'rejected')
        
        // --- ▼▼▼ 这就是我们为你新增的核心代码 ▼▼▼ ---

        // a. 创建一条对【用户可见】的系统通知
        const visibleNotice = {
            role: 'system',
            type: 'pat_message', // 复用灰色居中气泡样式
            content: `[系统：你拒绝了“${chat.name}”的情侣空间邀请。]`,
            timestamp: Date.now()
        };
        chat.history.push(visibleNotice);

        // b. 创建一条给【AI看】的隐藏指令，告诉它被拒绝了
        const hiddenMessage = {
            role: 'system',
            content: `[系统指令：用户拒绝了你开启情侣空间的邀请。]`,
            timestamp: Date.now() + 1,
            isHidden: true
        };
        chat.history.push(hiddenMessage);

        // c. 保存所有更改到数据库
        await db.chats.put(chat);

        // d. 刷新聊天界面，让卡片状态和新的系统通知都显示出来
        renderChatInterface(state.activeChatId);
        
        // (这里也没有 triggerAiResponse()，AI不会回应)
        
        // --- ▲▲▲ 新增代码结束 ▲▲▲ ---
    }
}
// ▲▲▲ 替换结束 ▲▲▲


    }
});
// ▲▲▲ 粘贴结束 ▲▲▲

// ▼▼▼ 在 init() 的事件监听器区域末尾，粘贴这段新代码 ▼▼▼
// 【全新】处理情侣空间邀请卡片的点击事件
document.getElementById('chat-messages').addEventListener('click', async (e) => {
    // 寻找被点击的元素是否在邀请卡片内
    const card = e.target.closest('.waimai-card');
    if (!card) return;
    const messageBubble = card.closest('.message-bubble');
    // 通过时间戳找到对应的消息数据
    const invitationMsg = state.chats[state.activeChatId].history.find(m => m.timestamp === parseInt(messageBubble.dataset.timestamp));

    // 确保这是一条待处理的情侣空间邀请
    if (invitationMsg && invitationMsg.type === 'lovers_space_invitation' && invitationMsg.status === 'pending') {
        const choice = e.target.dataset.choice; // 获取点击的是 'accepted' 还是 'rejected'
        if (choice) {
            // 调用我们刚刚创建的处理器函数
            handleLoversSpaceResponse(invitationMsg.timestamp, choice);
        }
    }
});
// ▲▲▲ 粘贴结束 ▲▲▲

// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▲▲▲ 情侣空间事件监听结束 ▲▲▲
// ▼▼▼ 【全新】这是主屏幕滑动分页的JS逻辑 ▼▼▼
function initHomeScreenSlider() {
    const slider = document.querySelector('.home-screen-slider');
    const dots = document.querySelectorAll('.pagination-dots .dot');

    if (!slider || dots.length === 0) return;

    // 监听滑动事件
    slider.addEventListener('scroll', () => {
        // 计算当前滑到了第几页
        const pageIndex = Math.round(slider.scrollLeft / slider.clientWidth);
        
        // 更新小圆点的状态
        dots.forEach((dot, index) => {
            dot.classList.toggle('active', index === pageIndex);
        });
    });
}
// ▲▲▲ 新增JS逻辑结束 ▲▲▲
initHomeScreenSlider(); // 初始化主屏幕滑动功能

// ▼▼▼ 在这里粘贴新代码 ▼▼▼
// 监听主屏幕图标和小组件颜色选择器的实时变化
document.getElementById('home-icon-widget-text-color-picker').addEventListener('input', (e) => {
    applyHomeIconWidgetTextColor(e.target.value);
});
// ▲▲▲ 新代码粘贴结束 ▲▲▲
// 【全新】主屏幕字体阴影开关的实时预览事件
document.getElementById('remove-home-font-shadow-toggle').addEventListener('change', (e) => {
    document.getElementById('phone-screen').classList.toggle('no-home-font-shadow', e.target.checked);
});
// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 【全新】圈子/小组分类筛选功能事件监听 ▼▼▼
// 1. 绑定主页和小组页的筛选按钮
document.getElementById('forum-filter-btn').addEventListener('click', () => openForumFilterModal('global'));
document.getElementById('group-filter-btn').addEventListener('click', () => openForumFilterModal('group', activeGroupId));

// 2. 绑定筛选弹窗内的按钮
document.getElementById('apply-forum-filter-btn').addEventListener('click', applyForumFilter);
document.getElementById('cancel-forum-filter-btn').addEventListener('click', () => {
    document.getElementById('forum-filter-modal').classList.remove('visible');
});
document.getElementById('reset-forum-filter-btn').addEventListener('click', async () => {
    // 清空复选框并应用
    document.querySelectorAll('#forum-filter-category-list input:checked').forEach(cb => cb.checked = false);
    await applyForumFilter();
});
// ▲▲▲ 新增事件监听结束 ▲▲▲



// ▲▲▲ 新增事件监听结束 ▲▲▲

// ▼▼▼ 【全新】宠物功能事件监听器 ▼▼▼

// 1. 绑定输入框上方的宠物图标按钮
document.getElementById('pet-action-btn').addEventListener('click', openPetModal);

// 2. 绑定宠物弹窗内的各种按钮
document.getElementById('pet-modal-cancel-btn').addEventListener('click', () => {
    document.getElementById('pet-modal').classList.remove('visible');
    currentPetData = null; // 取消时也要清理
});
document.getElementById('pet-modal-save-btn').addEventListener('click', savePetSettings);

// 3. 实时更新预览
document.getElementById('pet-type-input').addEventListener('input', updatePetPreview);
document.getElementById('pet-name-input').addEventListener('input', updatePetPreview);
document.getElementById('pet-image-input').addEventListener('input', updatePetPreview);

// 4. “在聊天界面显示”开关的交互
document.getElementById('pet-display-toggle').addEventListener('change', (e) => {
    document.getElementById('pet-position-controls').style.display = e.target.checked ? 'block' : 'none';
});

// 5. 尺寸滑块的交互
const sizeSlider = document.getElementById('pet-size-slider');
sizeSlider.addEventListener('input', () => {
    document.getElementById('pet-size-value').textContent = `${sizeSlider.value}px`;
});

// 6. 绑定更换自定义图片的点击事件
document.getElementById('pet-preview-display').addEventListener('click', () => {
    document.getElementById('pet-custom-image-input').click();
});
document.getElementById('pet-custom-image-input').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = (event) => {
            // 将图片的Base64链接直接填入输入框
            document.getElementById('pet-image-input').value = event.target.result;
            updatePetPreview(); // 并更新预览
        };
        reader.readAsDataURL(file);
    }
});

// 7. 绑定互动按钮 (使用事件委托)
document.getElementById('pet-interaction-area').addEventListener('click', (e) => {
    if (e.target.tagName === 'BUTTON' && e.target.dataset.action) {
        handlePetInteraction(e.target.dataset.action);
    }
});

// 8. 初始化宠物的拖动功能
initPetDragging();
// ▼▼▼ 【全新】宠物聊天功能事件绑定 ▼▼▼
document.getElementById('send-to-pet-btn').addEventListener('click', handleSendToPet);
document.getElementById('pet-chat-input').addEventListener('keypress', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        document.getElementById('send-to-pet-btn').click();
    }
});

// 为宠物聊天窗口的“外部”点击添加关闭功能
const petChatModal = document.getElementById('pet-chat-modal');
petChatModal.addEventListener('click', (e) => {
    if (e.target === petChatModal) { // 只有点击灰色遮罩层才关闭
        petChatModal.classList.remove('visible');
    }
});
// ▲▲▲ 新事件绑定结束 ▲▲▲
// ▼▼▼ 在 init() 的事件监听器区域末尾，粘贴这段新代码 ▼▼▼
// 【全新】为“放生宠物”按钮绑定事件
document.getElementById('pet-abandon-btn').addEventListener('click', async () => {
    if (!state.activeChatId) return;

    const confirmed = await showCustomConfirm(
        '确认放生',
        '确定要关闭宠物系统吗？这将会重置所有宠物数据（数值、聊天记录等），但不会删除你的设置。你可以随时重新领养。',
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        const chat = state.chats[state.activeChatId];
        chat.settings.petAdopted = false; // 关闭领养状态
        delete chat.settings.pet; // 删除宠物数据对象
        
        await db.chats.put(chat);
        
        renderChatPet(); // 从聊天界面移除宠物
        document.getElementById('pet-modal').classList.remove('visible'); // 关闭弹窗
        alert('宠物已放生，江湖再见！');
    }
});
// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▲▲▲ 宠物功能事件监听器结束 ▲▲▲
// ▼▼▼ 在 init() 的事件监听器区域末尾，粘贴下面这整块新代码 ▼▼▼

/* --- 【全新】情侣空间-情绪日记事件监听 --- */
document.getElementById('lovers-space-screen').addEventListener('click', (e) => {
    const chat = state.chats[activeLoversSpaceCharId];
    if (!chat) return;

    // 日历月份切换
    if (e.target.id === 'ls-prev-month-btn' || e.target.id === 'ls-next-month-btn') {
        const currentDisplay = document.getElementById('ls-current-month-display').textContent;
        const [year, month] = currentDisplay.match(/\d+/g).map(Number);
        let newDate = new Date(year, month - 1, 1);
        
        if (e.target.id === 'ls-prev-month-btn') {
            newDate.setMonth(newDate.getMonth() - 1);
        } else {
            newDate.setMonth(newDate.getMonth() + 1);
        }
        renderLSDiaryView(newDate.getFullYear(), newDate.getMonth() + 1);
        return;
    }
    
    // 点击日历格子
    const dayCell = e.target.closest('.ls-calendar-day:not(.empty)');
    if (dayCell) {
        openDiaryModal(dayCell.dataset.date);
    }
});

// 日记编辑弹窗事件
document.getElementById('ls-emoji-selector').addEventListener('click', (e) => {
    if (e.target.classList.contains('emoji-option')) {
        document.querySelectorAll('#ls-emoji-selector .emoji-option').forEach(el => el.classList.remove('selected'));
        e.target.classList.add('selected');
    }
});
document.getElementById('ls-cancel-diary-btn').addEventListener('click', () => {
    document.getElementById('ls-diary-editor-modal').classList.remove('visible');
});
document.getElementById('ls-save-diary-btn').addEventListener('click', handleSaveUserDiary);

// 日记查看弹窗关闭按钮
document.getElementById('ls-close-diary-viewer-btn').addEventListener('click', () => {
    document.getElementById('ls-diary-viewer-modal').classList.remove('visible');
});

/* --- 情绪日记事件监听结束 --- */

// ▲▲▲ 新增代码粘贴结束 ▲▲▲
// 在 init() 函数的事件监听器区域末尾...

// ▼▼▼ 在这里粘贴下面这几行新代码 ▼▼▼

// 绑定线下模式预设的下拉框和管理按钮
document.getElementById('offline-preset-select').addEventListener('change', handleOfflinePresetSelection);
document.getElementById('manage-offline-presets-btn').addEventListener('click', openOfflinePresetManager);

// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 【已修复】用这段新代码替换旧的 ▼▼▼
document.getElementById('back-from-dm-list').addEventListener('click', () => {
    // 从私信列表返回时，直接显示微博主屏幕
    showScreen('weibo-screen');
    // 并且确保默认显示的是“我的微博”那个页签
    switchToWeiboView('weibo-my-profile-view');
});
// ▲▲▲ 替换结束 ▲▲▲


document.getElementById('back-from-dm-detail').addEventListener('click', () => {
    // 从私信详情返回私信列表
    showScreen('weibo-dm-list-screen');
});

// 绑定“继续生成”按钮
document.getElementById('generate-more-dms-btn').addEventListener('click', handleGenerateMoreDms);

// 使用事件委托处理私信列表的点击
document.getElementById('weibo-dm-list').addEventListener('click', (e) => {
    const item = e.target.closest('.dm-list-item');
    if (item && item.dataset.fanIndex) {
        openDmDetail(parseInt(item.dataset.fanIndex));
    }
});

// 使用事件委托处理私信详情页的删除按钮点击
document.getElementById('weibo-dm-messages').addEventListener('click', (e) => {
    const deleteBtn = e.target.closest('.dm-message-delete-btn');
    if (deleteBtn) {
        const fanIndex = parseInt(document.querySelector('.dm-list-item.active')?.dataset.fanIndex ?? document.getElementById('weibo-dm-detail-screen').dataset.currentFanIndex);
        const messageIndex = parseInt(deleteBtn.dataset.messageIndex);
        
        const conversation = state.chats[currentViewingDmsFor.isNpc ? currentViewingDmsFor.ownerId : currentViewingDmsFor.id].weiboDms.find(convo => convo.fanName === document.getElementById('weibo-dm-detail-title').textContent);
        const fanIdx = state.chats[currentViewingDmsFor.isNpc ? currentViewingDmsFor.ownerId : currentViewingDmsFor.id].weiboDms.indexOf(conversation);

        if (!isNaN(fanIdx) && !isNaN(messageIndex)) {
            handleDeleteWeiboDm(fanIdx, messageIndex);
        }
    }
});
// ▲▲▲ 新事件监听器粘贴结束 ▲▲▲
document.getElementById('clear-all-dms-btn').addEventListener('click', handleClearAllDms);
// 在 init() 的事件监听器区域
// ▼▼▼ 【全新】聊天总结功能事件绑定 ▼▼▼
document.getElementById('view-summaries-btn').addEventListener('click', openSummaryViewer);
document.getElementById('close-summary-viewer-btn').addEventListener('click', () => {
    document.getElementById('summary-viewer-modal').classList.remove('visible');
    // 关闭后重新打开设置弹窗，回到上一级
    document.getElementById('chat-settings-btn').click();
});

// ▼▼▼ 用这块【功能更全】的代码，替换旧的 summary-list 事件监听器 ▼▼▼
// 使用事件委托处理总结列表中的所有按钮
document.getElementById('summary-list').addEventListener('click', (e) => {
    const editBtn = e.target.closest('.edit-summary-btn');
    if (editBtn) {
        const timestamp = parseInt(editBtn.dataset.timestamp);
        editSummary(timestamp);
        return;
    }
    
    const deleteBtn = e.target.closest('.delete-summary-btn');
    if (deleteBtn) {
        const timestamp = parseInt(deleteBtn.dataset.timestamp);
        deleteSummary(timestamp);
        return;
    }

    // 【核心新增】处理单条精简按钮的点击
    const conciseBtn = e.target.closest('.concise-summary-btn');
    if (conciseBtn) {
        const timestamp = parseInt(conciseBtn.dataset.timestamp);
        handleConciseSummary(timestamp);
        return;
    }
});

// 【全新】为“全部精简”按钮绑定事件
document.getElementById('concise-all-summaries-btn').addEventListener('click', handleConciseAllSummaries);
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 第3步：用这块【新代码】替换旧的 manual-summary-btn 事件监听器 ▼▼▼
document.getElementById('chat-settings-modal').addEventListener('click', (e) => {
    if (e.target.id === 'manual-summary-btn') {
        // 点击后先关闭设置弹窗
        document.getElementById('chat-settings-modal').classList.remove('visible');
        // 【核心修改】调用我们新创建的选择函数，而不是直接总结
        openManualSummaryOptions();
    }
});
// ▲▲▲ 替换结束 ▲▲▲

// ▼▼▼ 把这一整块全新的事件监听器代码，粘贴到 init() 的事件监听器区域末尾 ▼▼▼

/* --- 【全新】“桃宝”App 事件监听器 --- */

// 1. 绑定主屏幕的App图标
document.getElementById('taobao-app-icon').addEventListener('click', openTaobaoApp);
// 绑定新加的“清空”按钮
document.getElementById('clear-taobao-products-btn').addEventListener('click', clearTaobaoProducts);
// ▼▼▼ 在 init() 的事件监听区域末尾，粘贴下面这整块新代码 ▼▼▼

/* --- 【全新】桃宝购物车功能事件监听器 --- */

// 1. 绑定App内部的页签切换
document.querySelector('.taobao-tabs').addEventListener('click', (e) => {
    if (e.target.classList.contains('taobao-tab')) {
        switchTaobaoView(e.target.dataset.view);
    }
});

// 2. 使用事件委托，处理商品列表和购物车列表中的所有点击
document.getElementById('taobao-screen').addEventListener('click', async (e) => {
    const target = e.target;
    
    // 点击“加入购物车”按钮
    if (target.classList.contains('add-cart-btn')) {
        const productId = parseInt(target.dataset.productId);
        if (!isNaN(productId)) {
            await handleAddToCart(productId);
        }
        return;
    }
    
    // 点击商品卡片（图片或信息区），打开详情页
    const productCard = target.closest('.product-card');
    if (productCard && !target.classList.contains('add-cart-btn')) {
        const productId = parseInt(productCard.dataset.productId);
        if (!isNaN(productId)) {
            await openProductDetail(productId);
        }
        return;
    }
    
    // 点击购物车里的商品（图片或信息区），打开详情页
    const cartItem = target.closest('.cart-item');
    if (cartItem && (target.classList.contains('product-image') || target.closest('.cart-item-info'))) {
         const productId = parseInt(target.dataset.productId);
         if (!isNaN(productId)) {
            await openProductDetail(productId);
        }
        return;
    }

    // 点击购物车数量控制按钮
    if (target.classList.contains('quantity-increase')) {
        const cartId = parseInt(target.dataset.cartId);
        if (!isNaN(cartId)) await handleChangeCartItemQuantity(cartId, 1);
        return;
    }
    if (target.classList.contains('quantity-decrease')) {
        const cartId = parseInt(target.dataset.cartId);
        if (!isNaN(cartId)) await handleChangeCartItemQuantity(cartId, -1);
        return;
    }

    // 点击购物车删除按钮
    if (target.classList.contains('delete-cart-item-btn')) {
        const cartId = parseInt(target.dataset.cartId);
        if (!isNaN(cartId)) {
            const confirmed = await showCustomConfirm('移出购物车', '确定要删除这个宝贝吗？');
            if (confirmed) await handleRemoveFromCart(cartId);
        }
        return;
    }

    // 点击分类页签
    const categoryTab = target.closest('.category-tab-btn');
    if (categoryTab) {
        const category = categoryTab.dataset.category === 'all' ? null : categoryTab.dataset.category;
        await renderTaobaoProducts(category);
        return;
    }
});

// 3. 绑定商品详情弹窗的关闭按钮
document.getElementById('close-product-detail-btn').addEventListener('click', () => {
    document.getElementById('product-detail-modal').classList.remove('visible');
});

// 4. 绑定结算按钮
document.getElementById('checkout-btn').addEventListener('click', handleCheckout);


// ▲▲▲ 新增事件监听结束 ▲▲▲


// ▼▼▼ 用这块新代码替换旧的 'top-up-btn' 事件监听器 ▼▼▼
document.getElementById('top-up-btn').addEventListener('click', async () => {
    const amountStr = await showCustomPrompt("充值", "请输入要充值的金额 (元):", "", "number");
    if (amountStr !== null) {
        const amount = parseFloat(amountStr);
        if (!isNaN(amount) && amount > 0) {
            // 【核心修改】调用我们的新函数来处理充值和记录
            await updateUserBalanceAndLogTransaction(amount, '充值');
            await renderBalanceDetails(); // 刷新余额和明细
            alert(`成功充值 ¥${amount.toFixed(2)}！`);
        } else {
            alert("请输入有效的金额！");
        }
    }
});
// ▲▲▲ 替换结束 ▲▲▲


// 4. 绑定首页右上角的“+”按钮
document.getElementById('add-product-btn').addEventListener('click', openAddProductChoiceModal);

// 5. 绑定添加方式选择弹窗的按钮
document.getElementById('add-product-manual-btn').addEventListener('click', () => {
    document.getElementById('add-product-choice-modal').classList.remove('visible');
    openProductEditor();
});
document.getElementById('add-product-link-btn').addEventListener('click', () => {
    document.getElementById('add-product-choice-modal').classList.remove('visible');
    openAddFromLinkModal();
});
document.getElementById('add-product-ai-btn').addEventListener('click', () => {
    document.getElementById('add-product-choice-modal').classList.remove('visible');
    handleGenerateProductsAI();
});
document.getElementById('cancel-add-choice-btn').addEventListener('click', () => {
    document.getElementById('add-product-choice-modal').classList.remove('visible');
});

// 6. 绑定手动添加/编辑弹窗的按钮
document.getElementById('cancel-product-editor-btn').addEventListener('click', () => {
    document.getElementById('product-editor-modal').classList.remove('visible');
});
document.getElementById('save-product-btn').addEventListener('click', saveProduct);

// 7. 绑定识别链接弹窗的按钮
document.getElementById('cancel-link-paste-btn').addEventListener('click', () => {
    document.getElementById('add-from-link-modal').classList.remove('visible');
});
document.getElementById('confirm-link-paste-btn').addEventListener('click', handleAddFromLink);

// ▼▼▼ 在 init() 的事件监听器区域，用这块【新代码】替换旧的 'products-view' 点击事件 ▼▼▼
document.getElementById('products-view').addEventListener('click', async (e) => {
    const target = e.target;
    
    // 【核心修改】我们把原来的购买逻辑，改成了打开详情页的逻辑
    const productCard = target.closest('.product-card');
    if (productCard && !target.classList.contains('add-cart-btn')) {
        const productId = parseInt(productCard.dataset.productId);
        if (!isNaN(productId)) {
            await openProductDetail(productId); // <--- 就是修改了这里！
        }
        return;
    }
    
    // 下面这两部分逻辑保持不变
    if (target.classList.contains('add-cart-btn')) {
        const productId = parseInt(target.dataset.productId);
        if (!isNaN(productId)) {
            await handleAddToCart(productId);
        }
        return;
    }
    const categoryTab = target.closest('.category-tab-btn');
    if (categoryTab) {
        const category = categoryTab.dataset.category === 'all' ? null : categoryTab.dataset.category;
        renderTaobaoProducts(category);
        return;
    }
});
// ▲▲▲ 替换结束 ▲▲▲


// ▼▼▼ 把这一整块全新的事件监听器代码，粘贴到 init() 的事件监听器区域末尾 ▼▼▼

/* --- 【全新】“桃宝”App 搜索与AI结果弹窗事件监听器 --- */

// 1. 绑定搜索按钮
productSearchBtn.addEventListener('click', handleSearchProductsAI);
productSearchInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
        handleSearchProductsAI();
    }
});

// 2. 绑定AI结果弹窗的关闭按钮
document.getElementById('close-ai-products-modal-btn').addEventListener('click', async () => {
    aiGeneratedProductsModal.classList.remove('visible');
    // 关闭后刷新主页，显示新添加的商品
    await renderTaobaoProducts(); 
});

// 3. 使用事件委托，处理结果弹窗内所有“添加”按钮的点击
document.getElementById('ai-product-results-grid').addEventListener('click', async (e) => {
    if (e.target.classList.contains('add-to-my-page-btn')) {
        const button = e.target;
        const productData = JSON.parse(button.dataset.product);
        // ▼▼▼ 在这里粘贴下面这段新代码 ▼▼▼
        // 【核心修改】如果AI返回的商品数据里没有图片URL
        if (!productData.imageUrl) {
            // 就调用我们的辅助函数，给它一张随机默认图
            productData.imageUrl = getRandomDefaultProductImage();
            console.log(`AI生成的商品 "${productData.name}" 缺少图片，已自动补充默认图。`);
        }
        // ▲▲▲ 新增代码粘贴结束 ▲▲▲
        // 检查商品是否已存在
        const existingProduct = await db.taobaoProducts.where('name').equals(productData.name).first();
        if (existingProduct) {
            alert('这个商品已经存在于你的桃宝主页啦！');
            button.textContent = '已添加';
            button.disabled = true;
            return;
        }

        // 添加到数据库
        await db.taobaoProducts.add(productData);
        
        // 禁用按钮并更新文本，给用户反馈
        button.textContent = '✓ 已添加';
        button.disabled = true;
        
        // （可选）给个小提示
        // await showCustomAlert('添加成功', `“${productData.name}”已添加到你的桃宝！`);
    }
});

// ▼▼▼ 在 init() 的事件监听器区域末尾，粘贴下面这整块新代码 ▼▼▼

/* --- 【全新】桃宝订单物流功能事件监听器 --- */

// 1. 使用事件委托，为“我的订单”列表中的所有订单项绑定点击事件
document.getElementById('orders-view').addEventListener('click', (e) => {
    const item = e.target.closest('.order-item');
    if (item && item.dataset.orderId) {
        const orderId = parseInt(item.dataset.orderId);
        if (!isNaN(orderId)) {
            openLogisticsView(orderId);
        }
    }
});

// 2. 绑定物流页面的返回按钮
document.getElementById('logistics-back-btn').addEventListener('click', () => {
    // 返回时，直接显示“桃宝”主界面，并自动切换到“我的订单”页签
    showScreen('taobao-screen');
    switchTaobaoView('orders-view'); 
});

/* --- 事件监听结束 --- */

// ▲▲▲ 新增代码粘贴结束 ▲▲▲
document.getElementById('share-cart-to-char-btn').addEventListener('click', handleShareCartRequest);
// ▼▼▼ 在 init() 的事件监听器区域粘贴 ▼▼▼
document.getElementById('buy-for-char-btn').addEventListener('click', handleBuyForChar);
// ▲▲▲ 粘贴结束 ▲▲▲
/* --- “桃宝”App 事件监听器结束 --- */
// ▼▼▼ 【全新】这是角色手机外观设置的事件监听器 ▼▼▼
document.getElementById('character-phone-container').addEventListener('click', (e) => {
    // 使用事件委托，判断点击的是哪个按钮
    if (e.target.id === 'upload-char-phone-wallpaper-btn') {
        document.getElementById('char-phone-wallpaper-upload-input').click();
    } 
    else if (e.target.id === 'remove-char-phone-wallpaper-btn') {
        handleCharPhoneWallpaperChange(''); // 传入空字符串来移除壁纸
    }
    else {
        const changeIconButton = e.target.closest('.change-icon-btn');
        if (changeIconButton) {
            const iconId = changeIconButton.dataset.iconId;
            handleChangeCharPhoneIcon(iconId);
        }
    }
});

// 监听壁纸文件选择
document.getElementById('char-phone-wallpaper-upload-input').addEventListener('change', async (event) => {
    const file = event.target.files[0];
    if(file) {
        const dataUrl = await new Promise(res => {
            const reader = new FileReader();
            reader.onload = () => res(reader.result);
            reader.readAsDataURL(file);
        });
        handleCharPhoneWallpaperChange(dataUrl);
    }
    event.target.value = null; // 清空，以便下次能选择同一个文件
});
// ▲▲▲ 事件监听结束 ▲▲▲
// ▼▼▼ 在 init() 的事件监听器区域末尾，粘贴下面这整块新代码 ▼▼▼

/* --- 【全新】角色微博主页事件监听器 --- */
// ▼▼▼ 在 init() 的事件监听器区域粘贴这段新代码 ▼▼▼

// 为角色微博主页的“关注”和“粉丝”添加点击编辑功能
document.getElementById('weibo-char-profile-page').addEventListener('click', async (e) => {
    if (!currentViewingWeiboProfileId) return;
    const chat = state.chats[currentViewingWeiboProfileId];
    if (!chat) return;

    // 判断点击的是否是“关注”区域
    if (e.target.closest('#weibo-char-following-item')) {
        const newFollowing = await showCustomPrompt("编辑关注数", "请输入新的关注数:", chat.settings.weiboFollowingCount);
        if (newFollowing !== null) {
            chat.settings.weiboFollowingCount = newFollowing.trim() || '0';
            await db.chats.put(chat);
            await renderWeiboCharProfile(currentViewingWeiboProfileId);
        }
    }
    // 判断点击的是否是“粉丝”区域
    else if (e.target.closest('#weibo-char-fans-item')) {
        const newFans = await showCustomPrompt("编辑粉丝数", "请输入新的粉丝数 (支持'万'/'亿'):", chat.settings.weiboFansCount);
        if (newFans !== null) {
            chat.settings.weiboFansCount = newFans.trim() || '0';
            await db.chats.put(chat);
            await renderWeiboCharProfile(currentViewingWeiboProfileId);
        }
    }
});

// ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▼▼▼ 请用下面这块【已修复】的代码，完整替换掉上面那段旧代码 ▼▼▼
document.getElementById('back-from-char-profile').addEventListener('click', () => {
    // 【核心修改】我们不再显示关注列表弹窗，而是直接返回到微博主屏幕
    showScreen('weibo-screen'); 
});
// ▲▲▲ 替换结束 ▲▲▲


// 2. 绑定新页面右上角的编辑按钮
document.getElementById('edit-char-weibo-profile-btn').addEventListener('click', openCharWeiboEditor);

// 3. 绑定角色资料编辑弹窗的按钮
document.getElementById('cancel-char-weibo-editor-btn').addEventListener('click', () => {
    document.getElementById('char-weibo-editor-modal').classList.remove('visible');
});
document.getElementById('save-char-weibo-editor-btn').addEventListener('click', saveCharWeiboProfile);

// 4. 为角色资料编辑弹窗的图片上传绑定事件
setupFileUpload('char-weibo-editor-avatar-input', (base64) => {
    document.getElementById('char-weibo-editor-avatar-preview').src = base64;
});
setupFileUpload('char-weibo-editor-bg-input', (base64) => {
    document.getElementById('char-weibo-editor-bg-preview').src = base64;
});

// 5. 绑定关注列表的点击事件（事件委托）
document.getElementById('weibo-following-list-container').addEventListener('click', (e) => {
    const viewProfileBtn = e.target.closest('.view-profile-btn');
    if (viewProfileBtn && viewProfileBtn.dataset.charId) {
        openWeiboCharProfile(viewProfileBtn.dataset.charId);
    }
});

/* --- 新事件监听结束 --- */
// ▲▲▲ 新增代码粘贴结束 ▲▲▲
// ▼▼▼ 在 init() 函数的事件监听器区域末尾，粘贴下面这整块新代码 ▼▼▼

/* --- 【全新】角色微博资料编辑器事件绑定 --- */

// 1. 使用事件委托，为角色微博编辑弹窗内的所有按钮绑定事件
document.getElementById('char-weibo-editor-modal').addEventListener('click', (e) => {
    // a. 如果点击的是“更换头像框”按钮
    if (e.target.classList.contains('change-frame-btn')) {
        const type = e.target.dataset.type; // 获取按钮类型 'char-weibo'
        const targetId = currentViewingWeiboProfileId; // 获取当前正在查看的角色ID
        
        // 调用头像框选择函数，并传入正确的参数
        openFrameSelectorModal(type, targetId);
    }
    // b. 如果点击的是“取消”按钮
    else if (e.target.id === 'cancel-char-weibo-editor-btn') {
        document.getElementById('char-weibo-editor-modal').classList.remove('visible');
    }
    // c. 如果点击的是“保存”按钮
    else if (e.target.id === 'save-char-weibo-editor-btn') {
        saveCharWeiboProfile();
    }
});

// 2. 为角色手机的图片上传输入框绑定事件（这是之前就有的，确保它在正确的位置）
setupFileUpload('char-weibo-editor-avatar-input', (base64) => {
    document.getElementById('char-weibo-editor-avatar-preview').src = base64;
});
setupFileUpload('char-weibo-editor-bg-input', (base64) => {
    document.getElementById('char-weibo-editor-bg-preview').src = base64;
});

// ▲▲▲ 新代码粘贴结束 ▲▲▲
        // ▼▼▼ 在 init() 的事件监听器区域末尾，粘贴这整块新代码 ▼▼▼

        /* --- 【全新】角色手机小组件上传功能事件绑定 --- */

        // 辅助函数：处理图片上传的通用逻辑
        const handleWidgetUpload = async (widgetKey, inputFileId) => {
            const fileInput = document.getElementById(inputFileId);
            const file = fileInput.files[0];
            if (!file) return;

            const dataUrl = await new Promise(res => {
                const reader = new FileReader();
                reader.onload = () => res(reader.result);
                reader.readAsDataURL(file);
            });
            
            const chat = state.chats[activeCharacterPhoneId];
            if (!chat.characterPhoneData.widgets) {
                chat.characterPhoneData.widgets = {};
            }
            chat.characterPhoneData.widgets[widgetKey] = dataUrl;
            
            await db.chats.put(chat);
            renderCharPhoneAppearanceScreen(); // 刷新设置页预览
            openCharacterPhone(activeCharacterPhoneId); // 刷新手机主屏幕
            alert('小组件图片已更新！');
            fileInput.value = null; // 清空以便下次选择
        };

        // 辅助函数：处理图片移除的通用逻辑
        const handleWidgetRemove = async (widgetKey) => {
             const chat = state.chats[activeCharacterPhoneId];
             if (chat.characterPhoneData.widgets && chat.characterPhoneData.widgets[widgetKey]) {
                delete chat.characterPhoneData.widgets[widgetKey];
                await db.chats.put(chat);
                renderCharPhoneAppearanceScreen();
                openCharacterPhone(activeCharacterPhoneId);
                alert('小组件图片已移除！');
             }
        };

        // 为四个新按钮绑定事件
        document.getElementById('upload-widget-1-btn').addEventListener('click', () => {
            document.getElementById('char-phone-widget-1-upload-input').click();
        });
        document.getElementById('remove-widget-1-btn').addEventListener('click', () => {
            handleWidgetRemove('widget1_url');
        });
        document.getElementById('char-phone-widget-1-upload-input').addEventListener('change', () => {
            handleWidgetUpload('widget1_url', 'char-phone-widget-1-upload-input');
        });

        document.getElementById('upload-widget-2-btn').addEventListener('click', () => {
            document.getElementById('char-phone-widget-2-upload-input').click();
        });
        document.getElementById('remove-widget-2-btn').addEventListener('click', () => {
            handleWidgetRemove('widget2_url');
        });
        document.getElementById('char-phone-widget-2-upload-input').addEventListener('change', () => {
            handleWidgetUpload('widget2_url', 'char-phone-widget-2-upload-input');
        });

        /* --- 小组件事件绑定结束 --- */
        // ▲▲▲ 新代码粘贴结束 ▲▲▲

// ▲▲▲ 新增事件监听结束 ▲▲▲
// ▼▼▼ 【全新】角色手机外观预设功能事件绑定 ▼▼▼
document.getElementById('char-phone-preset-selector').addEventListener('change', handleCharPhonePresetSelection);
document.getElementById('apply-char-phone-preset-btn').addEventListener('click', applySelectedCharPhonePreset);
document.getElementById('save-char-phone-preset-btn').addEventListener('click', saveCurrentCharPhonePreset);
document.getElementById('update-char-phone-preset-btn').addEventListener('click', updateSelectedCharPhonePreset);
document.getElementById('rename-char-phone-preset-btn').addEventListener('click', renameSelectedCharPhonePreset);
document.getElementById('delete-char-phone-preset-btn').addEventListener('click', deleteSelectedCharPhonePreset);
document.getElementById('export-char-phone-preset-btn').addEventListener('click', exportCharPhonePreset);
document.getElementById('import-char-phone-preset-btn').addEventListener('click', () => {
    document.getElementById('import-char-phone-preset-input').click();
});
document.getElementById('import-char-phone-preset-input').addEventListener('change', (e) => {
    importCharPhonePreset(e.target.files[0]);
    e.target.value = null; // 清空以便下次能选择同一个文件
});
// ▲▲▲ 事件绑定结束 ▲▲▲
// ▼▼▼ 【全新】角色手机App内壁纸功能事件绑定 ▼▼▼

// 监听“上传”按钮的点击，去触发隐藏的文件选择器
document.getElementById('upload-char-phone-app-wallpaper-btn').addEventListener('click', () => {
    document.getElementById('char-phone-app-wallpaper-upload-input').click();
});

// 监听文件选择器的变化
document.getElementById('char-phone-app-wallpaper-upload-input').addEventListener('change', async (event) => {
    const file = event.target.files[0];
    if(file) {
        const dataUrl = await new Promise((res) => {
            const reader = new FileReader();
            reader.onload = () => res(reader.result);
            reader.readAsDataURL(file);
        });
        // 文件读取成功后，立刻调用处理函数来保存和应用
        handleCharPhoneAppWallpaperChange(dataUrl);
    }
    event.target.value = null; // 清空，以便下次能选择同一个文件
});

// 监听“移除”按钮的点击
document.getElementById('remove-char-phone-app-wallpaper-btn').addEventListener('click', () => {
    // 调用处理函数，并传入空字符串表示移除
    handleCharPhoneAppWallpaperChange('');
});

// ▲▲▲ 新事件绑定结束 ▲▲▲

// ▲▲▲ 替换结束 ▲▲▲
    // 【全新】心声背景更换功能事件监听
    document.getElementById('change-inner-voice-bg-btn').addEventListener('click', handleInnerVoiceBgChange);

    document.getElementById('inner-voice-bg-input').addEventListener('change', async (event) => {
        const file = event.target.files[0];
        if (!file) return;

        // 将图片文件转换为Base64，以便保存和显示
        const dataUrl = await new Promise(resolve => {
            const reader = new FileReader();
            reader.onload = e => resolve(e.target.result);
            reader.readAsDataURL(file);
        });
        
        // 调用保存函数
        await saveInnerVoiceBackground(dataUrl);

        // 每次用完后清空，以便下次能选择同一个文件
        event.target.value = null; 
    });

// ▲▲▲ 新增代码结束 ▲▲▲

// 情侣空间取消和解除▼▼▼
document.getElementById('ls-cancel-space-btn').addEventListener('click', handleCancelLoversSpace);
document.getElementById('ls-disconnect-space-btn').addEventListener('click', handleDisconnectLoversSpace);
// ▲▲▲ 新代码粘贴结束 ▲▲▲
// 在 init() 函数的事件监听器区域粘贴

/* --- 【全新】User微博私信功能事件监听器 --- */

// 1. 微博主页右上角的“私信”按钮
// 我们需要找到这个按钮并给它一个ID
// (假设你在HTML里已经为它设置了id="weibo-my-dms-btn")
// 注意：这个按钮是你需要手动加到 .header-actions 里的
const userDmBtn = document.getElementById('weibo-my-dms-btn');
if (userDmBtn) {
    userDmBtn.addEventListener('click', openUserDmListScreen);
}

// 2. 私信列表页面的返回按钮
document.getElementById('back-from-user-dm-list').addEventListener('click', () => {
    // 返回到微博主页
    showScreen('weibo-screen');
    switchToWeiboView('weibo-my-profile-view');
});

// 3. 私信列表页面的“生成新私信”和“清空”按钮
document.getElementById('generate-new-user-dms-btn').addEventListener('click', () => generateUserDms(true));
document.getElementById('clear-all-user-dms-btn').addEventListener('click', handleClearAllUserDms);

// 4. 使用事件委托处理私信列表的点击，打开聊天详情
document.getElementById('user-dm-list-container').addEventListener('click', (e) => {
    const item = e.target.closest('.dm-list-item');
    if (item && item.dataset.fanIndex) {
        openUserDmDetail(parseInt(item.dataset.fanIndex));
    }
});

// 5. 私信详情页的返回按钮
document.getElementById('back-from-user-dm-detail').addEventListener('click', () => {
    showScreen('user-dm-list-screen'); // 返回到私信列表
});

// 6. 私信详情页的发送按钮和回车发送
document.getElementById('user-dm-send-btn').addEventListener('click', handleSendUserDm);
document.getElementById('user-dm-input').addEventListener('keypress', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        document.getElementById('user-dm-send-btn').click();
    }
});

/* --- User微博私信功能事件监听结束 --- */
// 在 init() 的事件监听区域粘贴

// 7. 【新增】绑定私信详情页输入框的两个新按钮
document.getElementById('user-dm-trigger-ai-btn').addEventListener('click', handleTriggerUserDmAiReply);
document.getElementById('user-dm-reroll-btn').addEventListener('click', handleUserDmReroll);
        // ▼▼▼ 【全新】User私信删除功能事件监听器 ▼▼▼
        
        // --- 1. 单条消息删除的事件委托 ---
        document.getElementById('user-dm-messages-container').addEventListener('click', (e) => {
            const deleteBtn = e.target.closest('.user-dm-message-delete-btn');
            if (deleteBtn) {
                // currentUserDmFanIndex 是你已有的全局变量，用于记录当前正在看的粉丝索引
                const messageIndex = parseInt(deleteBtn.dataset.messageIndex);
                if (currentUserDmFanIndex !== null && !isNaN(messageIndex)) {
                    handleDeleteUserDmMessage(currentUserDmFanIndex, messageIndex);
                }
            }
        });

        // --- 2. 整个对话左滑删除的事件 ---
        const userDmListEl = document.getElementById('user-dm-list-container');
        let userDmSwipeState = { isDragging: false, startX: 0, activeContent: null };

        // 关闭所有已滑开的项
        function resetAllUserDmSwipes(exceptThisOne = null) {
            document.querySelectorAll('.user-dm-list-item-content.swiped').forEach(content => {
                if (content !== exceptThisOne) {
                    content.classList.remove('swiped');
                }
            });
        }
        
        // 监听鼠标/触摸开始
        userDmListEl.addEventListener('mousedown', (e) => {
            const content = e.target.closest('.user-dm-list-item-content');
            if (content) {
                resetAllUserDmSwipes(content);
                userDmSwipeState = { isDragging: true, startX: e.pageX, activeContent: content };
                e.preventDefault();
            }
        });
        userDmListEl.addEventListener('touchstart', (e) => {
            const content = e.target.closest('.user-dm-list-item-content');
            if (content) {
                resetAllUserDmSwipes(content);
                userDmSwipeState = { isDragging: true, startX: e.touches[0].pageX, activeContent: content };
            }
        }, { passive: true });

        // 监听鼠标/触摸移动
        document.addEventListener('mousemove', (e) => {
            if (!userDmSwipeState.isDragging || !userDmSwipeState.activeContent) return;
            const diffX = e.pageX - userDmSwipeState.startX;
            if (diffX < 0 && diffX > -90) { // 限制最大滑动距离
                userDmSwipeState.activeContent.style.transition = 'none';
                userDmSwipeState.activeContent.style.transform = `translateX(${diffX}px)`;
            }
        });
        document.addEventListener('touchmove', (e) => {
             if (!userDmSwipeState.isDragging || !userDmSwipeState.activeContent) return;
             const diffX = e.touches[0].pageX - userDmSwipeState.startX;
             if (diffX < 0 && diffX > -90) {
                 userDmSwipeState.activeContent.style.transition = 'none';
                 userDmSwipeState.activeContent.style.transform = `translateX(${diffX}px)`;
             }
        }, { passive: true });

        // 监听鼠标/触摸结束
        const handleUserDmSwipeEnd = (e) => {
            if (!userDmSwipeState.isDragging || !userDmSwipeState.activeContent) return;
            
            const content = userDmSwipeState.activeContent;
            content.style.transition = 'transform 0.3s ease';
            const transformStyle = window.getComputedStyle(content).transform;
            const currentTranslateX = new DOMMatrix(transformStyle).m41;

            if (currentTranslateX < -40) { // 滑动超过一半就自动滑开
                content.classList.add('swiped');
            } else {
                content.classList.remove('swiped');
            }
            content.style.transform = ''; // 清除内联样式

            userDmSwipeState = { isDragging: false, activeContent: null }; // 重置状态
        };
        document.addEventListener('mouseup', handleUserDmSwipeEnd);
        document.addEventListener('touchend', handleUserDmSwipeEnd);
        
        // --- 3. 监听删除按钮的点击 ---
        userDmListEl.addEventListener('click', (e) => {
            if (e.target.classList.contains('swipe-action-btn') && e.target.classList.contains('delete')) {
                const fanIndex = parseInt(e.target.dataset.fanIndex);
                if (!isNaN(fanIndex)) {
                    handleDeleteUserDmConversation(fanIndex);
                }
            }
        });

        // ▲▲▲ User私信删除功能事件监听结束 ▲▲▲
// ▼▼▼ 在 init() 函数的事件监听器区域末尾，粘贴下面这块新代码 ▼▼▼

// ▼▼▼ 请用这块【功能增强版】的代码，完整替换你旧的 'member-management-list' 事件监听器 ▼▼▼
document.getElementById('member-management-list').addEventListener('click', (e) => {
    const button = e.target.closest('.action-btn');
    if (!button) return;

    const action = button.dataset.action;
    const memberId = button.dataset.memberId;

    if (!action || !memberId) return;

    // --- 处理用户自己的按钮 ---
    if (memberId === 'user') {
        if (action === 'set-nickname') handleSetUserNickname();
        if (action === 'set-title') handleSetUserTitle();
        // ★★★ 【核心新增】用户点击自己的“解禁”按钮 ★★★
        if (action === 'unmute-self') { 
            handleUserUnmute();
        }
        return;
    }

    // --- 处理其他成员的按钮 ---
    switch (action) {
        case 'toggle-admin':
            handleToggleAdmin(memberId);
            break;
        case 'set-title':
            handleSetMemberTitle(memberId);
            break;
        case 'transfer-owner':
            handleTransferOwnership(memberId);
            break;
        case 'remove-member':
            removeMemberFromGroup(memberId);
            break;
        case 'mute-member': // ★★★ 禁言/解禁统一走这里 ★★★
            handleMuteMember(memberId);
            break;
    }
});
// ▲▲▲ 替换结束 ▲▲▲
// ▼▼▼ 【全新】群公告功能事件绑定 ▼▼▼
document.getElementById('group-announcement-btn').addEventListener('click', openGroupAnnouncementModal);
// ▲▲▲ 事件绑定结束 ▲▲▲
// ▼▼▼ 在 init() 函数的事件监听区域添加 ▼▼▼
// 绑定用户表情面板的批量删除按钮
document.getElementById('edit-user-stickers-btn').addEventListener('click', toggleUserStickerSelectionMode);
document.getElementById('done-user-stickers-btn').addEventListener('click', toggleUserStickerSelectionMode);
document.getElementById('delete-selected-user-stickers-btn').addEventListener('click', handleBulkDeleteUserStickers);

// 【重要】关闭面板时，也要退出选择模式
document.getElementById('close-sticker-panel-btn').addEventListener('click', () => {
    exitUserStickerSelectionMode();
    stickerPanel.classList.remove('visible');
});
// ▲▲▲ 添加结束 ▲▲▲
// ▼▼▼ 在 init() 函数的事件监听区域添加 ▼▼▼
// 绑定角色表情管理页的批量删除按钮
document.getElementById('edit-char-stickers-btn').addEventListener('click', toggleCharStickerSelectionMode);
document.getElementById('done-char-stickers-btn').addEventListener('click', toggleCharStickerSelectionMode);
document.getElementById('delete-selected-char-stickers-btn').addEventListener('click', handleBulkDeleteCharStickers);

// 【重要】返回聊天设置时，也要退出选择模式
document.getElementById('back-from-sticker-manager').addEventListener('click', () => {
    exitCharStickerSelectionMode();
    showScreen('chat-interface-screen');
    document.getElementById('chat-settings-btn').click();
});
// ▲▲▲ 添加结束 ▲▲▲
        // ▼▼▼ 【全新】这是为心声面板编辑按钮新增的事件监听 ▼▼▼
        document.getElementById('inner-voice-modal').addEventListener('click', (e) => {
            if (e.target.closest('#inner-voice-edit-btn')) {
                showInnerVoiceEditOptions();
            }
        });
        // ▲▲▲ 新增结束 ▲▲▲
        // ▼▼▼ 【全新】心声样式编辑器事件绑定 ▼▼▼
const ivEditorModal = document.getElementById('inner-voice-editor-modal');
const ivPanel = document.getElementById('inner-voice-main-panel');

// 实时预览功能
ivEditorModal.addEventListener('input', (e) => {
    const targetId = e.target.id;
    const value = e.target.value;

    switch (targetId) {
        case 'iv-color-clothing':
            ivPanel.style.setProperty('--iv-color-clothing', value);
            break;
        case 'iv-color-behavior':
            ivPanel.style.setProperty('--iv-color-behavior', value);
            break;
        case 'iv-color-thoughts':
            ivPanel.style.setProperty('--iv-color-thoughts', value);
            break;
        case 'iv-color-naughty':
            ivPanel.style.setProperty('--iv-color-naughty', value);
            break;
        case 'iv-card-bg-color':
            ivPanel.style.setProperty('--iv-card-bg-rgb', hexToRgb(value));
            break;
        case 'iv-opacity-slider':
            document.getElementById('iv-opacity-value').textContent = `${Math.round(value * 100)}%`;
            ivPanel.style.setProperty('--iv-card-opacity', value);
            break;
                // ★★★ 在这里添加下面的新 case ★★★
        case 'iv-icon-color':
            ivPanel.style.setProperty('--iv-icon-color', value);
            break;
    }
});

// 保存按钮
document.getElementById('iv-editor-save-btn').addEventListener('click', saveInnerVoiceStyles);

// 取消按钮
document.getElementById('iv-editor-cancel-btn').addEventListener('click', () => {
    ivEditorModal.classList.remove('visible');
    // 取消时，重新应用一下保存好的样式，以撤销预览改动
    applySavedInnerVoiceStyles();
});

// ▲▲▲ 新增事件监听器结束 ▲▲▲
// ▼▼▼ 在 init() 的事件监听器区域粘贴这段新代码 ▼▼▼

// 【全新】AI生成群成员功能事件绑定
document.getElementById('ai-generate-members-btn').addEventListener('click', openAiGenerateMembersModal);
document.getElementById('cancel-ai-generate-members-btn').addEventListener('click', () => {
    document.getElementById('ai-generate-members-modal').classList.remove('visible');
});
document.getElementById('confirm-ai-generate-members-btn').addEventListener('click', handleGenerateMembers);
// ▼▼▼ 在 init() 的事件监听器区域末尾，粘贴下面这整块新代码 ▼▼▼

// ▼▼▼ 在 init() 的事件监听器区域末尾，用这整块新代码替换旧的 ▼▼▼

// ▼▼▼ 在 init() 的事件监听器区域末尾，粘贴下面这整块新代码 ▼▼▼

/* --- 【全新】约会大作战功能事件监听器 --- */
document.getElementById('date-a-live-app-icon').addEventListener('click', openDatingApp);
document.getElementById('refresh-dating-scene-btn').addEventListener('click', refreshDatingScenes);
document.getElementById('end-date-btn').addEventListener('click', endDate); // 绑定结束约会按钮

// ▼▼▼ 在 init() 的事件监听器区域，用这块【新代码】替换旧的 'dating-scene-content' 事件监听器 ▼▼▼

// 使用事件委托处理删除和点击
document.getElementById('dating-scene-content').addEventListener('click', (e) => {
    const card = e.target.closest('.dating-scene-card');
    if (!card) return;

    const sceneUid = card.dataset.uid;
    const scene = currentDatingScenes.find(s => s.uid === sceneUid);
    if (!scene) return;
    
    // 如果点击的是删除按钮
    if (e.target.classList.contains('dating-scene-delete-btn')) {
        deleteDatingScene(sceneUid);
    } else {
        // 否则，点击的是卡片本身，打开角色选择器
        openDatingCharacterSelector(scene);
    }
});
// ▲▲▲ 新增/修改事件绑定结束 ▲▲▲


// ▼▼▼ 在 init() 的事件监听器区域，用这块【新代码】替换旧的【文游文本框点击事件】 ▼▼▼

// ▼▼▼ 在 init() 函数中，用这段新代码替换旧的文本框点击事件 ▼▼▼

// 为文游文本框绑定“点击切换下一句”的事件 (已增加保护)
document.querySelector('.dating-game-textbox').addEventListener('click', () => {
    if (
        datingGameState.isActive && 
        !datingGameState.isSwitchingSentence && // 新增：检查是否正在切换中
        datingGameState.currentSentenceIndex < datingGameState.sentences.length - 1
    ) {
        showNextSentence();
    }
});

// ▲▲▲ 替换结束 ▲▲▲



// ▲▲▲ 替换结束 ▲▲▲

// ▲▲▲ 新增代码粘贴结束 ▲▲▲



/* --- 事件监听结束 --- */
// ▲▲▲ 替换结束 ▲▲▲


/* --- 事件监听结束 --- */
// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 在 init() 函数的事件监听器区域末尾，粘贴下面这整块新代码 ▼▼▼

/* --- 【全新】约会大作战-文游模式UI事件绑定 --- */

// 右上角图标
document.getElementById('dating-game-settings-btn').addEventListener('click', openDatingSettingsModal);
document.getElementById('dating-game-reroll-btn').addEventListener('click', handleDatingReroll);

// 设置弹窗内的按钮
document.getElementById('cancel-dating-settings-btn').addEventListener('click', () => {
    document.getElementById('dating-game-settings-modal').classList.remove('visible');
    // 取消时，要恢复到角色已保存的设置，而不是停在临时修改的状态
    const chat = state.chats[datingGameState.characterId];
    currentDatingUISettings = JSON.parse(JSON.stringify(chat.settings.datingUISettings || {}));
    applyDatingUISettings();
});
document.getElementById('save-dating-settings-btn').addEventListener('click', saveDatingSettings);

// 图片上传按钮
document.querySelector('#dating-game-settings-modal .bg-upload-container button').addEventListener('click', () => handleDatingImageUpload('bg'));
document.querySelector('#dating-game-settings-modal .form-group:nth-of-type(5) .bg-upload-container button').addEventListener('click', () => handleDatingImageUpload('sprite'));

// 图片URL输入实时更新
document.getElementById('dating-bg-url-input').addEventListener('input', (e) => {
    currentDatingUISettings.backgroundUrl = e.target.value.trim();
    applyDatingUISettings();
});
// ▼▼▼ 在 init() 的事件监听器区域，粘贴这整块新代码 ▼▼▼

/* --- 【全新】约会立绘功能事件监听器 --- */
document.getElementById('manage-sprite-groups-btn').addEventListener('click', openSpriteGroupManager);
document.getElementById('close-sprite-group-manager-btn').addEventListener('click', () => {
    document.getElementById('sprite-group-manager-modal').classList.remove('visible');
});

document.getElementById('sprite-group-list-container').addEventListener('click', (e) => {
    const target = e.target;
    if (target.tagName === 'BUTTON' && target.dataset.id) {
        const action = target.dataset.action;
        const groupId = parseInt(target.dataset.id);
        if (action === 'edit') {
            openSpriteEditor(groupId);
        } else if (action === 'delete') {
            deleteSpriteGroup(groupId);
        }
    }
});

document.getElementById('create-new-sprite-group-btn').addEventListener('click', () => openSpriteEditor());

document.getElementById('cancel-sprite-editor-btn').addEventListener('click', () => {
    document.getElementById('sprite-editor-modal').classList.remove('visible');
});

document.getElementById('save-sprite-editor-btn').addEventListener('click', saveSpriteGroup);

document.getElementById('add-new-sprite-btn').addEventListener('click', () => {
    document.getElementById('sprite-list-editor').appendChild(createSpriteEditCard());
});
/* --- 约会立绘事件监听器结束 --- */

// ▲▲▲ 新代码粘贴结束 ▲▲▲

// 预设功能按钮
document.getElementById('dating-preset-select').addEventListener('change', handleDatingPresetSelect);
document.getElementById('manage-dating-presets-btn').addEventListener('click', openDatingPresetManager);

// ▲▲▲ 新代码粘贴结束 ▲▲▲
// ▼▼▼ 【全新】约会结算卡片事件绑定 ▼▼▼

/* --- 约会结算卡片事件绑定 --- */
const summaryCard = document.querySelector('.dating-summary-card');
const summaryCardBackBtn = document.getElementById('summary-flip-back-btn');

// 1. 点击卡片正面或背面的返回按钮，都会触发翻转
summaryCard.addEventListener('click', (e) => {
    // 确保点击的不是分享或关闭按钮
    if (!e.target.closest('button')) {
        summaryCard.classList.toggle('is-flipped');
    }
});
summaryCardBackBtn.addEventListener('click', (e) => {
    e.stopPropagation(); // 阻止事件冒泡到父元素
    summaryCard.classList.remove('is-flipped');
});

// 2. 分享按钮
document.getElementById('summary-share-btn').addEventListener('click', shareDatingSummary);

// ▼▼▼ 【修复版】用这块新代码替换旧的 'summary-close-btn' 事件监听器 ▼▼▼
// 3. 关闭按钮
document.getElementById('summary-close-btn').addEventListener('click', async () => {
    const confirmed = await showCustomConfirm(
        '确认关闭',
        '确定要关闭结算卡片吗？关闭后约会即告结束。',
        { confirmButtonClass: 'btn-danger' } // 使用更醒目的红色按钮
    );
    if (confirmed) {
        // 调用我们新的、真正的结束函数
        finalizeAndExitDate();
    }
});
// ▲▲▲ 替换结束 ▲▲▲


// 4. 聊天记录中的卡片点击事件（事件委托）
document.getElementById('chat-messages').addEventListener('click', (e) => {
    const chatCard = e.target.closest('.dating-summary-chat-card');
    if (chatCard && chatCard.dataset.summaryPayload) {
        try {
            // 读取并解析存储的payload数据
            const payloadString = chatCard.dataset.summaryPayload.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
            const payload = JSON.parse(payloadString);
            reopenDatingSummary(payload);
        } catch (error) {
            console.error("解析分享的约会记录失败:", error);
            alert("无法打开这个约会记录。");
        }
    }
});
// 在 init() 函数的事件监听器区域末尾，粘贴下面这整块代码

// ▼▼▼ 【全新】约会历史记录功能事件绑定 ▼▼▼

// 1. 为“约会大作战”主界面的“历史”图标绑定打开事件
document.getElementById('dating-history-btn').addEventListener('click', openDatingHistory);

// 2. 为“历史约会”页面的返回按钮绑定返回事件
document.getElementById('dating-history-back-btn').addEventListener('click', () => showScreen('date-a-live-screen'));

// 3. 使用事件委托，为历史列表中的所有卡片绑定“翻转”事件
document.getElementById('dating-history-list').addEventListener('click', e => {
    // 找到被点击的卡片
    const card = e.target.closest('.dating-summary-card');
    if (card) {
        // 切换 is-flipped 类即可触发CSS动画
        card.classList.toggle('is-flipped');
    }
});

// ▲▲▲ 新增事件绑定结束 ▲▲▲
// 在 init() 函数的事件监听器区域粘贴

// ▼▼▼ 【全新】约会大作战-创建场景功能事件绑定 ▼▼▼
document.getElementById('create-dating-scene-btn').addEventListener('click', () => {
    // 打开创建弹窗，并清空输入框
    document.getElementById('scene-name-input').value = '';
    document.getElementById('scene-image-url-input').value = '';
    document.getElementById('scene-cost-input').value = '';
    document.getElementById('create-dating-scene-modal').classList.add('visible');
});

document.getElementById('cancel-create-scene-btn').addEventListener('click', () => {
    document.getElementById('create-dating-scene-modal').classList.remove('visible');
});

document.getElementById('save-custom-scene-btn').addEventListener('click', handleSaveCustomDatingScene);
// ▲▲▲ 新增事件绑定结束 ▲▲▲

/* --- 约会结算事件绑定结束 --- */

// ▲▲▲ 新增事件监听器结束 ▲▲▲



// ▲▲▲ 新增代码粘贴结束 ▲▲▲


// ===================================================================
// 5. 启动！

// 应用壁纸并更新所有时钟
applyLockscreenWallpaper();
updateLockClock();

// ▼▼▼ 【最终修复版】请用这整块代码，替换掉你 init() 函数中旧的锁屏和状态栏开关逻辑 ▼▼▼

// 1. 读取、应用并监听“启用锁屏”设置
const enableLockScreenToggle = document.getElementById('enable-lock-screen-toggle');
const lockScreenEnabled = localStorage.getItem('lockScreenEnabled') !== 'false';
enableLockScreenToggle.checked = lockScreenEnabled;

// 2. 读取、应用并监听“显示状态栏”设置
const showStatusBarToggle = document.getElementById('show-status-bar-toggle');
const statusBar = document.getElementById('status-bar');
// 读取保存的状态，如果没保存过，默认是 true (显示)
const showStatusBar = localStorage.getItem('showStatusBar') !== 'false'; 
// 让开关的状态和保存的状态同步
showStatusBarToggle.checked = showStatusBar; 
// 根据保存的状态，决定一加载进来时是否显示状态栏
if (showStatusBar) {
    statusBar.style.display = 'flex';
} else {
    statusBar.style.display = 'none';
}

// 3. 【关键】给开关添加“变化”监听器，这样你每次点击它都会保存状态
showStatusBarToggle.addEventListener('change', (e) => {
    const isEnabled = e.target.checked;
    // a. 将新的开关状态 (true 或 false) 保存到浏览器的 localStorage 里
    localStorage.setItem('showStatusBar', isEnabled);
    // b. 立刻根据新的状态来显示或隐藏状态栏
    statusBar.style.display = isEnabled ? 'flex' : 'none';
});

// 4. 根据最终的锁屏设置，决定应用启动时第一个显示的屏幕
if (lockScreenEnabled) {
    lockPhone(); // 如果设置是“启用”，就锁定手机
} else {
    showScreen('home-screen'); // 否则，直接进入主屏幕
}
// ▲▲▲ 替换结束 ▲▲▲

        }

        init();

// ▼▼▼ 在这里添加下面这个“全局接口”部分 ▼▼▼

/*
 * ===================================================================
 * === 全局接口 (Public API for other scripts) ===
 * ===================================================================
 * 将主应用的核心功能暴露给其他脚本文件（如 game-hall.js）使用
 */
window.openChat = openChat;
window.triggerAiResponse = triggerAiResponse;

// ▲▲▲ 添加结束 ▲▲▲
 // ▼▼▼ 把这【一整块】全新的代码，粘贴到 <script> 标签内的【变量定义区域】的末尾 ▼▼▼

const avatarFrames = [
    { id: 'none', url: '', name: '无' }, 
    { id: 'frame_cat_ear', url: 'https://i.postimg.cc/fLDnz5Pn/IMG-5574.gif', name: '1' }, 
    { id: 'frame_ribbon', url: 'https://i.postimg.cc/HxH3cNHz/IMG-6871.gif', name: '2' }, 
    { id: 'frame_flower', url: 'https://i.postimg.cc/jCVK0fGL/IMG-6890.gif', name: '3' }, 
    { id: 'frame_tech', url: 'https://i.postimg.cc/85Zsyjwn/IMG-6895.gif', name: '4' }, 
    { id: 'frame_5', url: 'https://i.postimg.cc/cJtpZCB3/IMG-6894.gif', name: '5' }, 
    { id: 'frame_6', url: 'https://i.postimg.cc/63sDQKMm/IMG-6893.gif', name: '6' }, 
    { id: 'frame_7', url: 'https://i.postimg.cc/cHQPgzj4/IMG-6888.gif', name: '7' }, 
    { id: 'frame_8', url: 'https://i.postimg.cc/dVLXm3Xf/IMG-6885.gif', name: '8' }, 
    { id: 'frame_9', url: 'https://i.postimg.cc/kGsZwbq0/IMG-6886.gif', name: '9' }, 
    { id: 'frame_10', url: 'https://i.postimg.cc/63NmX03s/IMG-4366.gif', name: '10' }, 
    { id: 'frame_11', url: 'https://i.postimg.cc/zvz2LGK0/IMG-4367.gif', name: '11' }, 
    { id: 'frame_12', url: 'https://i.postimg.cc/prsGKMBx/IMG-4370.gif', name: '12' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/gk0BmrY0/IMG-4371.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/fRt2SFSn/IMG-4368.gif', name: '14' }, 
    { id: 'frame_cat_ear', url: 'https://i.postimg.cc/kGgwJhPH/IMG-4374.gif', name: '1' }, 
    { id: 'frame_ribbon', url: 'https://i.postimg.cc/PrcKH436/IMG-4376.gif', name: '2' }, 
    { id: 'frame_flower', url: 'https://i.postimg.cc/fRV86FMq/IMG-4381.gif', name: '3' }, 
    { id: 'frame_tech', url: 'https://i.postimg.cc/HsyqMVyk/IMG-4385.gif', name: '4' }, 
    { id: 'frame_5', url: 'https://i.postimg.cc/qBbKK7dS/IMG-4386.gif', name: '5' }, 
    { id: 'frame_6', url: 'https://i.postimg.cc/05wnd389/IMG-4388.gif', name: '6' }, 
    { id: 'frame_7', url: 'https://i.postimg.cc/RZNLhbbr/IMG-4389.gif', name: '7' }, 
    { id: 'frame_8', url: 'https://i.postimg.cc/fLTc42dg/IMG-4391.gif', name: '8' }, 
    { id: 'frame_9', url: 'https://i.postimg.cc/FzbGNdRT/IMG-4392.gif', name: '9' }, 
    { id: 'frame_10', url: 'https://i.postimg.cc/XY63sTS3/IMG-4393.gif', name: '10' }, 
    { id: 'frame_11', url: 'https://i.postimg.cc/Cx9vCVWH/IMG-4395.gif', name: '11' }, 
    { id: 'frame_12', url: 'https://i.postimg.cc/kMfPQBwQ/IMG-4396.gif', name: '12' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/CLrZQMMD/IMG-4398.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/L4zwDhTC/IMG-4399.gif', name: '14' }, 
    { id: 'frame_cat_ear', url: 'https://i.postimg.cc/yN3s8szM/IMG-4400.gif', name: '1' }, 
    { id: 'frame_ribbon', url: 'https://i.postimg.cc/59Cn1tkB/IMG-4401.gif', name: '2' }, 
    { id: 'frame_flower', url: 'https://i.postimg.cc/g0s1V0PX/IMG-4402.gif', name: '3' }, 
    { id: 'frame_tech', url: 'https://i.postimg.cc/Jn1DFPgY/IMG-4403.gif', name: '4' }, 
    { id: 'frame_5', url: 'https://i.postimg.cc/q7cQnDy1/IMG-4404.gif', name: '5' }, 
    { id: 'frame_6', url: 'https://i.postimg.cc/RFK3q2t0/IMG-4407.gif', name: '6' }, 
    { id: 'frame_7', url: 'https://i.postimg.cc/gcV0VR2t/IMG-4408.gif', name: '7' }, 
    { id: 'frame_8', url: 'https://i.postimg.cc/W1CjLb4J/IMG-4409.gif', name: '8' }, 
    { id: 'frame_9', url: 'https://i.postimg.cc/Ss7pM6fW/IMG-4410.gif', name: '9' }, 
    { id: 'frame_10', url: 'https://i.postimg.cc/nrFfYX3N/IMG-4412.gif', name: '10' }, 
    { id: 'frame_11', url: 'https://i.postimg.cc/cHWp0KG6/IMG-4413.gif', name: '11' }, 
    { id: 'frame_12', url: 'https://i.postimg.cc/4yNjHrdg/IMG-4414.gif', name: '12' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/hPX5F8Qp/IMG-4415.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/vHCSG1WM/IMG-4416.gif', name: '14' }, 
    { id: 'frame_cat_ear', url: 'https://i.postimg.cc/x1Hp80Rm/IMG-4417.gif', name: '1' }, 
    { id: 'frame_ribbon', url: 'https://i.postimg.cc/FHRcCGfH/IMG-4418.gif', name: '2' }, 
    { id: 'frame_flower', url: 'https://i.postimg.cc/13hhJ77p/IMG-4419.gif', name: '3' }, 
    { id: 'frame_tech', url: 'https://i.postimg.cc/J4WCQd2j/IMG-4420.gif', name: '4' }, 
    { id: 'frame_5', url: 'https://i.postimg.cc/Dydkpd9H/IMG-4421.gif', name: '5' }, 
    { id: 'frame_6', url: 'https://i.postimg.cc/mrkvDxPW/IMG-4422.gif', name: '6' }, 
    { id: 'frame_7', url: 'https://i.postimg.cc/76Tj3g1B/IMG-4425.gif', name: '7' }, 
    { id: 'frame_8', url: 'https://i.postimg.cc/3N5Vndn3/IMG-4426.gif', name: '8' }, 
    { id: 'frame_9', url: 'https://i.postimg.cc/05DLr0yj/IMG-4427.gif', name: '9' }, 
    { id: 'frame_10', url: 'https://i.postimg.cc/GhR6DT4Q/IMG-4428.gif', name: '10' }, 
    { id: 'frame_11', url: 'https://i.postimg.cc/fRTF24jS/IMG-4430.gif', name: '11' }, 
    { id: 'frame_12', url: 'https://i.postimg.cc/R0WYmcYM/IMG-4431.gif', name: '12' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/nrJSqNhz/IMG-4432.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/tC9mJ0cv/IMG-4438.gif', name: '14' }, 
    { id: 'frame_cat_ear', url: 'https://i.postimg.cc/XNkQTHvf/IMG-5561.gif', name: '1' }, 
    { id: 'frame_ribbon', url: 'https://i.postimg.cc/Mpv5fzm5/IMG-4439.gif', name: '2' }, 
    { id: 'frame_flower', url: 'https://i.postimg.cc/T1tjhsyB/IMG-4720.gif', name: '3' }, 
    { id: 'frame_tech', url: 'https://i.postimg.cc/c4JMPd2W/IMG-4724.gif', name: '4' }, 
    { id: 'frame_5', url: 'https://i.postimg.cc/g2XykNGB/IMG-4727.gif', name: '5' }, 
    { id: 'frame_6', url: 'https://i.postimg.cc/y8MmJcd6/IMG-4728.gif', name: '6' }, 
    { id: 'frame_7', url: 'https://i.postimg.cc/Lsjzj5Yt/IMG-4729.gif', name: '7' }, 
    { id: 'frame_8', url: 'https://i.postimg.cc/bNdk33SN/IMG-4893.gif', name: '8' }, 
    { id: 'frame_9', url: 'https://i.postimg.cc/4x9tTy1D/IMG-5563.gif', name: '9' }, 
    { id: 'frame_10', url: 'https://i.postimg.cc/DZshzKv6/IMG-5576.gif', name: '10' }, 
    { id: 'frame_11', url: 'https://i.postimg.cc/Fsvr71JL/IMG-5573.gif', name: '11' }, 
    { id: 'frame_12', url: 'https://i.postimg.cc/Fz3HwLk9/IMG-5569.gif', name: '12' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/wjH180kn/IMG-5566.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/MG6qtLYK/IMG-5565.gif', name: '14' }, 
    { id: 'frame_cat_ear', url: 'https://i.postimg.cc/CKgDNYVb/IMG-5577.gif', name: '1' }, 
    { id: 'frame_ribbon', url: 'https://i.postimg.cc/hj4dkrvj/IMG-5578.gif', name: '2' }, 
    { id: 'frame_flower', url: 'https://i.postimg.cc/hj4dkrvj/IMG-5578.gif', name: '3' }, 
    { id: 'frame_tech', url: 'https://i.postimg.cc/C5XnfpNB/IMG-5579.gif', name: '4' }, 
    { id: 'frame_5', url: 'https://i.postimg.cc/4y7mGFgJ/IMG-5716.gif', name: '5' }, 
    { id: 'frame_6', url: 'https://i.postimg.cc/FzM1Hgr0/IMG-5717.gif', name: '6' }, 
    { id: 'frame_7', url: 'https://i.postimg.cc/rF4KYbjj/IMG-5720.gif', name: '7' }, 
    { id: 'frame_8', url: 'https://i.postimg.cc/6pLTBvDG/IMG-5721.gif', name: '8' }, 
    { id: 'frame_9', url: 'https://i.postimg.cc/VNK6Ccsf/IMG-5722.gif', name: '9' }, 
    { id: 'frame_10', url: 'https://i.postimg.cc/wx72fhr2/IMG-5968.gif', name: '10' }, 
    { id: 'frame_11', url: 'https://i.postimg.cc/QdrqdvdY/IMG-5969.gif', name: '11' }, 
    { id: 'frame_12', url: 'https://i.postimg.cc/0yd0MZ6k/IMG-5971.gif', name: '12' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/1zmcp66p/IMG-5973.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/wBw5Fvcn/IMG-5974.gif', name: '14' }, 
    { id: 'frame_cat_ear', url: 'https://i.postimg.cc/R0pfKYvB/IMG-5976.gif', name: '1' }, 
    { id: 'frame_ribbon', url: 'https://i.postimg.cc/9fQZ425b/IMG-5975.gif', name: '2' }, 
    { id: 'frame_flower', url: 'https://i.postimg.cc/v8V9xXjJ/IMG-6137.gif', name: '3' }, 
    { id: 'frame_tech', url: 'https://i.postimg.cc/WbmkXzsS/IMG-6138.gif', name: '4' }, 
    { id: 'frame_5', url: 'https://i.postimg.cc/Dw2bDhZh/IMG-6140.gif', name: '5' }, 
    { id: 'frame_6', url: 'https://i.postimg.cc/ZqQBCyLY/IMG-6144.gif', name: '6' }, 
    { id: 'frame_7', url: 'https://i.postimg.cc/qRCtnMms/IMG-6145.gif', name: '7' }, 
    { id: 'frame_8', url: 'https://i.postimg.cc/1Rwn3XVP/IMG-6146.gif', name: '8' }, 
    { id: 'frame_9', url: 'https://i.postimg.cc/Kv51tW5H/IMG-6147.gif', name: '9' }, 
    { id: 'frame_10', url: 'https://i.postimg.cc/nhcC21Rc/IMG-6148.gif', name: '10' }, 
    { id: 'frame_11', url: 'https://i.postimg.cc/fTWzQRx8/IMG-6149.gif', name: '11' }, 
    { id: 'frame_12', url: 'https://i.postimg.cc/LXyyqDbY/IMG-6294.gif', name: '12' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/7Zgm1wRy/IMG-6295.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/5tbpnDcQ/IMG-6296.gif', name: '14' }, 
    { id: 'frame_cat_ear', url: 'https://i.postimg.cc/YSRRV8kn/IMG-6297.gif', name: '1' }, 
    { id: 'frame_ribbon', url: 'https://i.postimg.cc/k45sd8gn/IMG-6375.gif', name: '2' }, 
    { id: 'frame_flower', url: 'https://i.postimg.cc/50k390X8/IMG-6376.gif', name: '3' }, 
    { id: 'frame_tech', url: 'https://i.postimg.cc/90RBDh9K/IMG-6377.gif', name: '4' }, 
    { id: 'frame_5', url: 'https://i.postimg.cc/cCpBYbMH/IMG-6552.gif', name: '5' }, 
    { id: 'frame_6', url: 'https://i.postimg.cc/Pf9g2fSL/IMG-6554.gif', name: '6' }, 
    { id: 'frame_7', url: 'https://i.postimg.cc/gkhf597g/IMG-6555.gif', name: '7' }, 
    { id: 'frame_8', url: 'https://i.postimg.cc/g2PfbSFm/IMG-6556.gif', name: '8' }, 
    { id: 'frame_9', url: 'https://i.postimg.cc/pLY3WfR8/IMG-6557.gif', name: '9' }, 
    { id: 'frame_10', url: 'https://i.postimg.cc/65Cmcr7S/IMG-6559.gif', name: '10' }, 
    { id: 'frame_11', url: 'https://i.postimg.cc/Y94XWYKd/IMG-6560.gif', name: '11' }, 
    { id: 'frame_12', url: 'https://i.postimg.cc/ydwLXx7s/IMG-6562.gif', name: '12' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/G3y73Fj2/IMG-6563.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/TYvkKKkc/IMG-6565.gif', name: '14' }, 
    { id: 'frame_cat_ear', url: 'https://i.postimg.cc/GmcqjZn8/IMG-6566.gif', name: '1' }, 
    { id: 'frame_ribbon', url: 'https://i.postimg.cc/k5Gs0K47/IMG-6567.gif', name: '2' }, 
    { id: 'frame_flower', url: 'https://i.postimg.cc/XJy8JWdh/IMG-6568.gif', name: '3' }, 
    { id: 'frame_tech', url: 'https://i.postimg.cc/fycfcvHf/IMG-6569.gif', name: '4' }, 
    { id: 'frame_5', url: 'https://i.postimg.cc/J7ZxC11H/IMG-6570.gif', name: '5' }, 
    { id: 'frame_6', url: 'https://i.postimg.cc/hPnrSHjy/IMG-4434.gif', name: '6' }, 
    { id: 'frame_7', url: 'https://i.postimg.cc/YqxxjbLp/IMG-6572.gif', name: '7' }, 
    { id: 'frame_8', url: 'https://i.postimg.cc/wjfcQMkZ/IMG-6573.gif', name: '8' }, 
    { id: 'frame_9', url: 'https://i.postimg.cc/Vv8jkCYr/IMG-6574.gif', name: '9' }, 
    { id: 'frame_10', url: 'https://i.postimg.cc/MZ77rdDy/IMG-6850.gif', name: '10' }, 
    { id: 'frame_11', url: 'https://i.postimg.cc/T3NvqJCZ/IMG-6851.gif', name: '11' }, 
    { id: 'frame_12', url: 'https://i.postimg.cc/28TsrxRV/IMG-6852.gif', name: '12' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/VkV2bLNw/IMG-6853.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/gJ95NSRB/IMG-6854.gif', name: '14' }, 
    { id: 'frame_cat_ear', url: 'https://i.postimg.cc/d1qsQsbQ/IMG-6855.gif', name: '1' }, 
    { id: 'frame_ribbon', url: 'https://i.postimg.cc/gJNYx9pV/IMG-6856.gif', name: '2' }, 
    { id: 'frame_flower', url: 'https://i.postimg.cc/fyPDvxJk/IMG-6860.gif', name: '3' }, 
    { id: 'frame_tech', url: 'https://i.postimg.cc/QMDsSNxg/IMG-6861.gif', name: '4' }, 
    { id: 'frame_5', url: 'https://i.postimg.cc/vBqsQW7X/IMG-6858.gif', name: '5' }, 
    { id: 'frame_6', url: 'https://i.postimg.cc/Y0vwjhb7/IMG-6857.gif', name: '6' }, 
    { id: 'frame_7', url: 'https://i.postimg.cc/90sH9Cn7/IMG-6868.gif', name: '7' }, 
    { id: 'frame_8', url: 'https://i.postimg.cc/Y2PHZzCC/IMG-6866.gif', name: '8' }, 
    { id: 'frame_9', url: 'https://i.postimg.cc/7Z8yYP7v/IMG-6889.gif', name: '9' }, 
    { id: 'frame_10', url: 'https://i.postimg.cc/nryNzTXK/IMG-6915.gif', name: '10' }, 
    { id: 'frame_11', url: 'https://i.postimg.cc/Qx5dqyJ3/IMG-6917.gif', name: '11' }, 
    { id: 'frame_12', url: 'https://i.postimg.cc/Wbr0JSDD/IMG-5316.gif', name: '12' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/tgR6wjBP/IMG-5570.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/d0WCKxff/IMG-6932.gif', name: '14' }, 
    { id: 'frame_11', url: 'https://i.postimg.cc/Ss3znzk7/IMG-6934.gif', name: '11' }, 
    { id: 'frame_12', url: 'https://i.postimg.cc/nrm9BcL8/IMG-6941.gif', name: '12' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/ZYvd1jxf/IMG-6937.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/sDFhySn3/IMG-6936.gif', name: '14' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/43PhvxRq/IMG-6922.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/3Rb46fRZ/IMG-6923.gif', name: '14' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/PJppkbvn/IMG-6918.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/XqRZNZ9G/IMG-6916.gif', name: '14' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/RVt6sRzc/IMG-6939.gif', name: '14' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/mgGc0HbK/IMG-6926.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/P5zLh5JJ/IMG-6942.gif', name: '14' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/xCqqKGRN/IMG-6929.gif', name: '14' },
    { id: 'frame_12', url: 'https://i.postimg.cc/7LSRp4hx/e7fa949b9pc84cff0dabe57defceb54c.gif', name: '12' },
    { id: 'frame_13', url: 'https://i.postimg.cc/DZgMwc1H/817178fdbpf2ff7740dc98e26ab78759.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/3NffgJSZ/e09c07034ld7e62266c0a5de6a36ae62.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/vHDNGfT2/35ac7f372v588bf48d4f659077196b85.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/KvVsjjgG/3c3aa5219s18b90187ef1f54b3db7ba8.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/k5P1NHcL/55f3e31d8qbc8a02d152b07b99d31567.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/FFCTCzpy/641bad3b3udc599fdb63ca75fde427e5.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/8k7YSLjK/1689aa46aqc4b9ffc0f970e668f56537.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/J0CZSwyW/IMG-6938.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/Df1qLzDf/IMG-6927.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/CLNkrQSW/IMG-6925.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/y8p9s3Jj/IMG-6919.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/Lsr1Zd3Z/IMG-6928.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/Ssgbv41n/IMG-6876.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/SNByPrf9/IMG-7005.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/Z5nrCyS5/IMG-7006.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/mDfMXXFP/IMG-7007.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/DZrGtrqB/IMG-7008.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/ZnJNZWHZ/IMG-7009.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/RhGH0vpt/IMG-7010.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/tRzPkzRg/IMG-7012.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/wTTNGs3Q/IMG-7013.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/3JSG5Jv5/IMG-7014.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/rwDr8X1d/IMG-7015.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/DzDy2vS7/IMG-7017.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/QMVdG9x6/IMG-7016.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/mZ9hgH3J/IMG-7019.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/t4ksHGdg/IMG-7020.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/hP9JpdfT/IMG-7023.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/wTKyXVT9/IMG-7024.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/ZqjKXPSv/IMG-7025.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/gj3Tmqz5/mmexport1751030241029.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/4yCXW52F/mmexport1751030908335.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/VkXngG72/mmexport1751031208329.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/LscBkxZb/mmexport1751017556565.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/1XqzGKwJ/mmexport1751018282681.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/8kHCQwbQ/mmexport1751020645824.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/HWynLK7f/mmexport1751021724230.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/JnwFp3Kx/mmexport1751031208329.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/HLZNWkQw/mmexport1751031767634.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/vH2X6N1y/mmexport1751032231179.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/NFS4ZyvM/mmexport1751032686953.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/3RpmWc8c/mmexport1751033102811.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/L5RLr3tg/mmexport1751035976943.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/4NCPsp5d/mmexport1751034427637.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/CMv02LHm/mmexport1751034842120.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/rFnSzWGx/mmexport1751035618517.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/7YRbzN51/mmexport1751036276038.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/cJpbtPWq/mmexport1751036607799.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/HxLV5v92/mmexport1751036977582.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/D01rYy86/mmexport1751037965259.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/J4fwkTLW/mmexport1751038167142.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/xjpN4swz/IMG-7240.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/ZnzbGdxX/IMG-7239.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/DyYDmKtw/IMG-7238.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/W40f9qtd/IMG-7098.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/8PsK20jQ/IMG-7236.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/cHsTXDVz/IMG-7235.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/sXwm8Yzg/IMG-7234.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/xTk5xN49/IMG-7233.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/k5yv6QBv/IMG-7232.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/yx2m4nbs/IMG-7231.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/vZt0fFKn/IMB-r-HMBXY.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/pddJj9zN/IMG-7094.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/rmB17Qbc/IMB-f-VDf-Fc.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/VkKjzYTK/IMB-f4kk-CT.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/B6KD52vz/IMG-7096.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/9XPwWmwy/IMB-Kf7um-P.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/mrFhKBGz/IMB-e-QWBpa.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/bw4wxW2z/IMB-16r-COL.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/3x0Kx1fz/IMB-K1u-Jp-P.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/CLz0cJ0d/IMG-7116.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/fyyGgW61/IMG-7115.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/gkk7s0vD/IMG-6984.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/0NpZPgYj/IMG-6985.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/tTWKKmTN/IMG-7073.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/jS8tc9wW/IMG-7083.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/rmRVKJpD/IMG-7087.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/zvWGPjms/IMG-7090.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/YSkqDg8V/IMG-7092.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/FzqHTBng/IMG-7093.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/tTpZ6wLs/IMG-7095.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/8P5vt8sW/IMG-7097.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/wMxmCZVC/IMG-7099.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/2jxd0FGp/IMG-7100.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/B6T59xGK/IMG-7101.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/kXfcgFRN/IMG-7106.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/htZppbS4/IMG-7107.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/hPgyjtyn/IMG-7108.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/HLKvs0Kv/IMG-7109.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/wjwbnYkp/IMG-7111.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/bJDMQVkj/IMG-7112.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/SNWBTP5S/IMG-7113.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/jCVMQsKH/IMG-7114.gif', name: '14' },
];

// ▲▲▲ 粘贴结束 ▲▲▲       
    });
</script>
<!-- ▼▼▼ 这是我们新加的隐藏文件选择器 ▼▼▼ -->
<input type="file" id="character-card-input" accept=".png, .json" style="display: none;">
<!-- ▲▲▲ 文件选择器结束 ▲▲▲ -->
<input type="file" id="world-book-import-input" accept=".json, .jsonl" style="display: none;">
<input type="file" id="ludo-qbank-import-input" accept=".json" hidden>
<input type="file" id="inner-voice-bg-input" accept="image/*" hidden>
</body>
</html>
